<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HslCommunication</name>
    </assembly>
    <members>
        <member name="T:HslCommunication.Algorithms.Fourier.FFTFilter">
            <summary>
            一个基于傅立叶变换的一个滤波算法
            </summary>
            <remarks>
            非常感谢来自北京的monk网友，提供了完整的解决方法。
            </remarks>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.FillDataArray``1(System.Collections.Generic.List{``0},System.Int32@)">
            <summary>
            对指定的数据进行填充，方便的进行傅立叶计算
            </summary>
            <typeparam name="T">数据的数据类型</typeparam>
            <param name="source">数据源</param>
            <param name="putLength">输出的长度</param>
            <returns>填充结果</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.FilterFFT(System.Double[],System.Double)">
            <summary>
            对指定的原始数据进行滤波，并返回成功的数据值
            </summary>
            <param name="source">数据源，数组的长度需要为2的n次方。</param>
            <param name="filter">滤波值：最大值为1，不能低于0，越接近1，滤波强度越强，也可能会导致失去真实信号，为0时没有滤波效果。</param>
            <returns>滤波后的数据值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.FilterFFT(System.Single[],System.Double)">
            <summary>
            对指定的原始数据进行滤波，并返回成功的数据值
            </summary>
            <param name="source">数据源，数组的长度需要为2的n次方。</param>
            <param name="filter">滤波值：最大值为1，不能低于0，越接近1，滤波强度越强，也可能会导致失去真实信号，为0时没有滤波效果。</param>
            <returns>滤波后的数据值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.Filter(System.Single[],System.Double)">
            <summary>
            对指定的原始数据进行滤波，并返回成功的数据值
            </summary>
            <param name="source">数据源，数组的长度需要为2的n次方。</param>
            <param name="filter">滤波值：最大值为1，不能低于0，越接近1，滤波强度越强，也可能会导致失去真实信号，为0时没有滤波效果。</param>
            <returns>滤波后的数据值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.Filter(System.Double[],System.Double)">
            <summary>
            对指定的原始数据进行滤波，并返回成功的数据值
            </summary>
            <param name="source">数据源，数组的长度需要为2的n次方。</param>
            <param name="filter">滤波值：最大值为1，不能低于0，越接近1，滤波强度越强，也可能会导致失去真实信号，为0时没有滤波效果。</param>
            <returns>滤波后的数据值</returns>
        </member>
        <member name="T:HslCommunication.Algorithms.Fourier.FFTHelper">
            <summary>
            离散傅氏变换的快速算法，处理的信号，适合单周期信号数为2的N次方个，支持变换及逆变换
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.bitrp(System.Double[],System.Double[],System.Int32)">
            <summary>
            
            </summary>
            <param name="xreal"></param>
            <param name="ximag"></param>
            <param name="n"></param>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.FFT(System.Double[])">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.GetFFTImage(System.Double[],System.Int32,System.Int32,System.Drawing.Color,System.Boolean)">
            <summary>
            获取FFT变换后的显示图形，需要指定图形的相关参数
            </summary>
            <param name="xreal">实数部分的值</param>
            <param name="width">图形的宽度</param>
            <param name="heigh">图形的高度</param>
            <param name="lineColor">线条颜色</param>
            <param name="isSqrtDouble">是否开两次根，显示的噪点信息会更新明显</param>
            <returns>等待呈现的图形</returns>
            <remarks>
            <note type="warning">.net standrard2.0 下不支持。</note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.FFTValue(System.Double[],System.Double[],System.Boolean)">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <param name="isSqrtDouble">是否开两次根，显示的噪点信息会更新明显</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.FFT(System.Double[],System.Double[])">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.FFT(System.Single[],System.Single[])">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.IFFT(System.Single[],System.Single[])">
            <summary>
            快速傅立叶变换的逆变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>2的多少次方</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.IFFT(System.Double[],System.Double[])">
            <summary>
            快速傅立叶变换的逆变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>2的多少次方</returns>
        </member>
        <member name="T:HslCommunication.Algorithms.PID.PIDHelper">
            <summary>
            一个PID的辅助类，可以设置 P,I,D 三者的值，用来模拟信号波动的时候，信号的收敛情况
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.PID.PIDHelper.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.PID.PIDHelper.PidInit">
            <summary>
            初始化PID的数据信息
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.Kp">
            <summary>
            -rando
            比例的参数信息
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.Ki">
            <summary>
            积分的参数信息
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.Kd">
            <summary>
            微分的参数信息
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.DeadBand">
            <summary>
            获取或设置死区的值
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.MaxLimit">
            <summary>
            获取或设置输出的上限，默认为没有设置
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.MinLimit">
            <summary>
            获取或设置输出的下限，默认为没有设置
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.SetValue">
            <summary>
            获取或设置当前设置的值
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.PID.PIDHelper.PidCalculate">
            <summary>
            计算Pid数据的值
            </summary>
            <returns>计算值</returns>
        </member>
        <member name="T:HslCommunication.Algorithms.PID.PidMode">
            <summary>
            Pid的模式选择
            </summary>
        </member>
        <member name="F:HslCommunication.Algorithms.PID.PidMode.Increment">
            <summary>
            增量模式
            </summary>
        </member>
        <member name="T:HslCommunication.Algorithms.ConnectPool.ConnectPool`1">
            <summary>
            一个连接池管理器，负责维护多个可用的连接，并且自动清理，扩容，用于快速读写服务器或是PLC时使用。<br />
            A connection pool manager is responsible for maintaining multiple available connections, 
            and automatically cleans up, expands, and is used to quickly read and write servers or PLCs.
            </summary>
            <typeparam name="TConnector">管理的连接类，需要支持IConnector接口</typeparam>
            <remarks>
            需要先实现 <see cref="T:HslCommunication.Algorithms.ConnectPool.IConnector"/> 接口的对象，然后就可以实现真正的连接池了，理论上可以实现任意的连接对象，包括modbus连接对象，各种PLC连接对象，数据库连接对象，redis连接对象，SimplifyNet连接对象等等。下面的示例就是modbus-tcp的实现
            <note type="warning">要想真正的支持连接池访问，还需要服务器支持一个端口的多连接操作，三菱PLC的端口就不支持，如果要测试示例代码的连接池对象，需要使用本组件的<see cref="T:HslCommunication.ModBus.ModbusTcpServer"/>来创建服务器对象</note>
            </remarks>
            <example>
            下面举例实现一个modbus的连接池对象，先实现接口化的操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="IConnector Example" title="IConnector示例" />
            然后就可以实现真正的连接池了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="ConnectPoolExample" title="ConnectPool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.#ctor(System.Func{`0})">
            <summary>
            实例化一个连接池对象，需要指定如果创建新实例的方法<br />
            To instantiate a connection pool object, you need to specify how to create a new instance
            </summary>
            <param name="createConnector">创建连接对象的委托</param>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.GetAvailableConnector">
            <summary>
            获取一个可用的连接对象，如果已经达到上限，就进行阻塞等待。当使用完连接对象的时候，需要调用<see cref="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.ReturnConnector(`0)"/>方法归还连接对象。<br />
            Get an available connection object, if the upper limit has been reached, block waiting. When the connection object is used up, 
            you need to call the <see cref="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.ReturnConnector(`0)"/> method to return the connection object.
            </summary>
            <returns>可用的连接对象</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.ReturnConnector(`0)">
            <summary>
            使用完之后需要通知连接池的管理器，本方法调用之前需要获取到连接对象信息。<br />
            After using it, you need to notify the manager of the connection pool, and you need to get the connection object information before calling this method.
            </summary>
            <param name="connector">连接对象</param>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.ResetAllConnector">
            <summary>
            将目前连接中的所有对象进行关闭，然后移除队列。<br />
            Close all objects in the current connection, and then remove the queue.
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.MaxConnector">
            <summary>
            获取或设置最大的连接数，当实际的连接数超过最大的连接数的时候，就会进行阻塞，直到有新的连接对象为止。<br />
            Get or set the maximum number of connections. When the actual number of connections exceeds the maximum number of connections, 
            it will block until there is a new connection object.
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.ConectionExpireTime">
            <summary>
            获取或设置当前连接过期的时间，单位秒，默认30秒，也就是说，当前的连接在设置的时间段内未被使用，就进行释放连接，减少内存消耗。<br />
            Get or set the expiration time of the current connection, in seconds, the default is 30 seconds, that is, 
            if the current connection is not used within the set time period, the connection will be released to reduce memory consumption.
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.UsedConnector">
            <summary>
            当前已经使用的连接数，会根据使用的频繁程度进行动态的变化。<br />
            The number of currently used connections will dynamically change according to the frequency of use.
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.UseConnectorMax">
            <summary>
            当前已经使用的连接数的峰值，可以用来衡量当前系统的适用的连接池上限。<br />
            The current peak value of the number of connections used can be used to measure the upper limit of the applicable connection pool of the current system.
            </summary>
        </member>
        <member name="T:HslCommunication.Algorithms.ConnectPool.IConnector">
            <summary>
            连接池的接口，连接池的管理对象必须实现此接口
            </summary>
            <remarks>为了使用完整的连接池功能，需要先实现本接口，然后配合<see cref="T:HslCommunication.Algorithms.ConnectPool.ConnectPool`1"/>来使用</remarks>
            <example>
            下面举例实现一个modbus的连接池对象
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="IConnector Example" title="IConnector示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.IConnector.IsConnectUsing">
            <summary>
            指示当前的连接是否在使用用
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.IConnector.GuidToken">
            <summary>
            唯一的GUID码
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.IConnector.LastUseTime">
            <summary>
            最新一次使用的时间
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.IConnector.Open">
            <summary>
            打开连接
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.IConnector.Close">
            <summary>
            关闭并释放
            </summary>
        </member>
        <member name="T:HslCommunication.Authorization">
            <summary>
            系统的基本授权类
            </summary>
        </member>
        <member name="M:HslCommunication.Authorization.nzugaydgwadawdibbas">
            <summary>
            普通VIP的授权的判定
            </summary>
            <returns>是否授权成功</returns>
        </member>
        <member name="M:HslCommunication.Authorization.asdniasnfaksndiqwhawfskhfaiw">
            <summary>
            商业授权则返回true，否则返回false
            </summary>
            <returns>是否成功进行商业授权</returns>
        </member>
        <member name="M:HslCommunication.Authorization.SetAuthorizationCode(System.String)">
            <summary>
            设置本组件系统的授权信息，如果激活失败，只能使用24小时，24小时后所有的网络通信不会成功<br />
            Set the authorization information of this component system. If the activation fails, it can only be used for 8 hours. All network communication will not succeed after 8 hours
            </summary>
            <param name="code">授权码</param>
        </member>
        <member name="T:HslCommunication.BasicFramework.SharpList`1">
            <summary>
            一个高效的数组管理类，用于高效控制固定长度的数组实现<br />
            An efficient array management class for efficient control of fixed-length array implementations
            </summary>
            <typeparam name="T">泛型类型</typeparam>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            实例化一个对象，需要指定数组的最大数据对象
            </summary>
            <param name="count">数据的个数</param>
            <param name="appendLast">是否从最后一个数添加</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SharpList`1.Count">
            <summary>
            获取数组的个数<br />
            Get the number of arrays
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.Add(`0)">
            <summary>
            新增一个数据值<br />
            Add a data value
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            批量的增加数据<br />
            Increase data in batches
            </summary>
            <param name="values">批量数据信息</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.ToArray">
            <summary>
            获取数据的数组值<br />
            Get array value of data
            </summary>
            <returns>数组值</returns>
        </member>
        <member name="P:HslCommunication.BasicFramework.SharpList`1.Item(System.Int32)">
            <summary>
            获取或设置指定索引的位置的数据<br />
            Gets or sets the data at the specified index
            </summary>
            <param name="index">索引位置</param>
            <returns>数据值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.FormAuthorize">
            <summary>
            用来测试版软件授权的窗口
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormAuthorize.#ctor(HslCommunication.BasicFramework.SoftAuthorize,System.String,System.Func{System.String,System.String})">
            <summary>
            实例化授权注册窗口
            </summary>
            <param name="authorize"></param>
            <param name="aboutCode">提示关于怎么获取注册码的信息</param>
            <param name="encrypt">加密的方法</param>
        </member>
        <member name="F:HslCommunication.BasicFramework.FormAuthorize.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormAuthorize.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormAuthorize.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.FormPopup">
            <summary>
            一个用于消息弹出显示的类
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.AddNewForm(HslCommunication.BasicFramework.FormPopup)">
            <summary>
            新增一个显示的弹出窗口
            </summary>
            <param name="form"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.ResetLocation">
            <summary>
            重置所有弹出窗口的位置
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.#ctor">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.#ctor(System.String)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.#ctor(System.String,System.Drawing.Color)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
            <param name="infocolor">文本的颜色</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.#ctor(System.String,System.Drawing.Color,System.Int32)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
            <param name="infocolor">文本的颜色</param>
            <param name="existTime">指定窗口多少时间后消失，单位毫秒</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.LocationUpMove">
            <summary>
            窗体的位置进行向上调整
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.LocationUpMove(System.Int32)">
            <summary>
            窗体的位置进行向上调整
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.FormPopup.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.FormPortraitSelect">
            <summary>
            一个正方形图形选择窗口，可以获取指定的分辨率
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.FormPortraitSelect.HasPicture">
            <summary>
            是否有图片存在
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.FormPortraitSelect.RectangleSelected">
            <summary>
            已选择的图形大小
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.FormPortraitSelect.RectangleImage">
            <summary>
            在控件显示的图片的大小，按照比例缩放以后
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.LoadPictureFile(System.String)">
            <summary>
            增加一张图片的路径
            </summary>
            <param name="picPath"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.GetSpecifiedSizeImage(System.Int32)">
            <summary>
            获取指定大小的图片，该图片将会按照比例压缩
            </summary>
            <param name="size">图片的横向分辨率</param>
            <returns>缩放后的图形</returns>
        </member>
        <member name="F:HslCommunication.BasicFramework.FormPortraitSelect.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.FormSupport">
            <summary>
            作者的技术支持的窗口界面
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormSupport.#ctor">
            <summary>
            实例化一个默认的界面
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.FormSupport.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormSupport.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormSupport.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftAnimation">
            <summary>
            系统框架支持的一些常用的动画特效
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAnimation.TimeFragment">
            <summary>
            最小的时间片段
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAnimation.BeginBackcolorAnimation(System.Windows.Forms.Control,System.Drawing.Color,System.Int32)">
            <summary>
            调整控件背景色，采用了线性的颜色插补方式，实现了控件的背景色渐变，需要指定控件，颜色，以及渐变的时间
            </summary>
            <param name="control">控件</param>
            <param name="color">设置的颜色</param>
            <param name="time">时间</param>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftAuthorize">
            <summary>
            软件授权类
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.#ctor(System.Boolean)">
            <summary>
            实例化一个软件授权类
            </summary>
            <param name="UseAdmin">是否使用管理员模式</param>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.TextCode">
            <summary>
            注册码描述文本
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAuthorize.FinalCode">
            <summary>
            最终的注册秘钥信息，注意是只读的。
            </summary>
            <remarks>
            时间：2018年9月1日 23:01:54，来自 洛阳-LYG 的建议，公开了本属性信息，只读。
            </remarks>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAuthorize.IsReleaseVersion">
            <summary>
            是否正式发行版，是的话就取消授权
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAuthorize.HasLoadByFile">
            <summary>
            指示是否加载过文件信息
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAuthorize.IsSoftTrial">
            <summary>
            指示系统是否处于试用运行
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.GetMachineCodeString">
            <summary>
            获取本机的机器码
            </summary>
            <returns>机器码字符串</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.ToSaveString">
            <summary>
            获取需要保存的数据内容
            </summary>
            <returns>实际保存的内容</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.LoadByString(System.String)">
            <summary>
            从字符串加载数据
            </summary>
            <param name="content">文件存储的数据</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.SaveToFile">
            <summary>
            使用特殊加密算法加密数据
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.LoadByFile">
            <summary>
            使用特殊解密算法解密数据
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.CheckAuthorize(System.String,System.Func{System.String,System.String})">
            <summary>
            检查该注册码是否是正确的注册码
            </summary>
            <param name="code">注册码信息</param>
            <param name="encrypt">数据加密的方法，必须用户指定</param>
            <returns>是否注册成功</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.IsAuthorizeSuccess(System.Func{System.String,System.String})">
            <summary>
            检测授权是否成功
            </summary>
            <param name="encrypt">数据加密的方法，必须用户指定</param>
            <returns>是否成功授权</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.GetInfo(System.Boolean)">
            <summary>
            获取本计算机唯一的机器码  
            </summary>
            <returns>字符串形式的机器码</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.GetHddInfo(System.Byte)">
            <summary>
            获得硬盘信息
            </summary>
            <param name="driveIndex">硬盘序号</param>
            <returns>硬盘信息</returns>
            <remarks>
            by sunmast for everyone
            thanks lu0 for his great works
            在Windows Array8/ME中，S.M.A.R.T并不缺省安装，请将SMARTVSD.VXD拷贝到%SYSTEM%＼IOSUBSYS目录下。
            在Windows 2000/2003下，需要Administrators组的权限。
            </remarks>
            <example>
            AtapiDevice.GetHddInfo()
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.CreateFile(System.String,System.IO.FileAccess,System.IO.FileShare,System.IntPtr,System.IO.FileMode,System.IO.FileAttributes,System.IntPtr)">
            <summary>
            执行打开/建立资源的功能。
            </summary>
            <param name="lpFileName">指定要打开的设备或文件的名称。</param>
            <param name="dwDesiredAccess">
            <para>Win32 常量，用于控制对设备的读访问、写访问或读/写访问的常数。内容如下表：
            <p><list type="table">
            <listheader>
            <term>名称</term>
            <description>说明</description>
            </listheader>
            <item>
            <term>GENERIC_READ</term><description>指定对设备进行读取访问。</description>
            </item>
            <item>
            <term>GENERIC_WRITE</term><description>指定对设备进行写访问。</description>
            </item>
            <item><term><b>0</b></term><description>如果值为零，则表示只允许获取与一个设备有关的信息。</description></item>
            </list></p>
            </para>
            </param>
            <param name="dwShareMode">指定打开设备时的文件共享模式</param>
            <param name="lpSecurityAttributes"></param>
            <param name="dwCreationDisposition">Win32 常量，指定操作系统打开文件的方式。内容如下表：
            <para><p>
            <list type="table">
            <listheader><term>名称</term><description>说明</description></listheader>
            <item>
            <term>CREATE_NEW</term>
            <description>指定操作系统应创建新文件。如果文件存在，则抛出 <see cref="T:System.IO.IOException"/> 异常。</description>
            </item>
            <item><term>CREATE_ALWAYS</term><description>指定操作系统应创建新文件。如果文件已存在，它将被改写。</description></item>
            </list>
            </p></para>
            </param>
            <param name="dwFlagsAndAttributes"></param>
            <param name="hTemplateFile"></param>
            <returns>使用函数打开的设备的句柄。</returns>
            <remarks>
            本函数可以执行打开或建立文件、文件流、目录/文件夹、物理磁盘、卷、系统控制的缓冲区、磁带设备、
            通信资源、邮件系统和命名管道。
            </remarks>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.CloseHandle(System.IntPtr)">
            <summary>
            关闭一个指定的指针对象指向的设备。。
            </summary>
            <param name="hObject">要关闭的句柄 <see cref="T:System.IntPtr"/> 对象。</param>
            <returns>成功返回 <b>0</b> ，不成功返回非零值。</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.DeviceIoControl(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,HslCommunication.BasicFramework.SoftAuthorize.GetVersionOutParams@,System.UInt32,System.UInt32@,System.IntPtr)">
            <summary>
            对设备执行指定的操作。
            </summary>
            <param name="hDevice">要执行操作的设备句柄。</param>
            <param name="dwIoControlCode">Win32 API 常数，输入的是以 <b>FSCTL_</b> 为前缀的常数，定义在
            <b>WinIoCtl.h</b> 文件内，执行此重载方法必须输入 <b>SMART_GET_VERSION</b> 。</param>
            <param name="lpInBuffer">当参数为指针时，默认的输入值是 <b>0</b> 。</param>
            <param name="nInBufferSize">输入缓冲区的字节数量。</param>
            <param name="lpOutBuffer">一个 <b>GetVersionOutParams</b> ，表示执行函数后输出的设备检查。</param>
            <param name="nOutBufferSize">输出缓冲区的字节数量。</param>
            <param name="lpBytesReturned">实际装载到输出缓冲区的字节数量。</param>
            <param name="lpOverlapped">同步操作控制，一般不使用，默认值为 <b>0</b> 。</param>
            <returns>非零表示成功，零表示失败。</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.DeviceIoControl(System.IntPtr,System.UInt32,HslCommunication.BasicFramework.SoftAuthorize.SendCmdInParams@,System.UInt32,HslCommunication.BasicFramework.SoftAuthorize.SendCmdOutParams@,System.UInt32,System.UInt32@,System.IntPtr)">
            <summary>
            对设备执行指定的操作。
            </summary>
            <param name="hDevice">要执行操作的设备句柄。</param>
            <param name="dwIoControlCode">Win32 API 常数，输入的是以 <b>FSCTL_</b> 为前缀的常数，定义在
            <b>WinIoCtl.h</b> 文件内，执行此重载方法必须输入 <b>SMART_SEND_DRIVE_COMMAND</b> 或 <b>SMART_RCV_DRIVE_DATA</b> 。</param>
            <param name="lpInBuffer">一个 <b>SendCmdInParams</b> 结构，它保存向系统发送的查询要求具体命令的数据结构。</param>
            <param name="nInBufferSize">输入缓冲区的字节数量。</param>
            <param name="lpOutBuffer">一个 <b>SendCmdOutParams</b> 结构，它保存系统根据命令返回的设备相信信息二进制数据。</param>
            <param name="nOutBufferSize">输出缓冲区的字节数量。</param>
            <param name="lpBytesReturned">实际装载到输出缓冲区的字节数量。</param>
            <param name="lpOverlapped">同步操作控制，一般不使用，默认值为 <b>0</b> 。</param>
            <returns>非零表示成功，零表示失败。</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo">
            <summary>
            硬盘信息
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo.ModuleNumber">
            <summary>
            型号
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo.Firmware">
            <summary>
            固件版本
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo.SerialNumber">
            <summary>
            序列号
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo.Capacity">
            <summary>
            容量，以M为单位
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.ISoftFileSaveBase">
            <summary>
            支持字符串信息加载存储的接口，定义了几个通用的方法
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISoftFileSaveBase.ToSaveString">
            <summary>
            获取需要保存的数据，需要重写实现
            </summary>
            <returns>需要存储的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISoftFileSaveBase.LoadByString(System.String)">
            <summary>
            从字符串加载数据，需要重写实现
            </summary>
            <param name="content">字符串数据</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISoftFileSaveBase.LoadByFile">
            <summary>
            不使用解密方法从文件读取数据
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISoftFileSaveBase.SaveToFile">
            <summary>
            不使用加密方法保存数据到文件
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.ISoftFileSaveBase.FileSavePath">
            <summary>
            文件路径的存储
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftFileSaveBase">
            <summary>
            文件存储功能的基类，包含了文件存储路径，存储方法等
            </summary>
            <remarks>
            需要继承才能实现你想存储的数据，比较经典的例子就是存储你的应用程序的配置信息，通常的格式就是xml文件或是json文件。具体请看例子：
            </remarks>
            <example>
            下面举例实现两个字段的普通数据存储
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="SoftFileSaveBase1" title="简单示例" />
            然后怎么调用呢？
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="Example" title="调用示例" />
            如果你想实现加密存储，这样就不用关心被用户看到了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="SoftFileSaveBase2" title="加密示例" />
            如果还是担心被反编译获取数据，那么这个密钥就要来自服务器的数据，本地不做存储。
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.#ctor">
            <summary>
            实例化一个文件存储的基类
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftFileSaveBase.LogHeaderText">
            <summary>
            在日志保存时的标记当前调用类的信息
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.ToSaveString">
            <inheritdoc cref="M:HslCommunication.BasicFramework.ISoftFileSaveBase.ToSaveString"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.LoadByString(System.String)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.ISoftFileSaveBase.LoadByString(System.String)"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.LoadByFile">
            <inheritdoc cref="M:HslCommunication.BasicFramework.ISoftFileSaveBase.LoadByFile"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.LoadByFile(System.Converter{System.String,System.String})">
            <summary>
            使用用户自定义的解密方法从文件读取数据
            </summary>
            <param name="decrypt">用户自定义的解密方法</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.SaveToFile">
            <inheritdoc cref="M:HslCommunication.BasicFramework.ISoftFileSaveBase.SaveToFile"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.SaveToFile(System.Converter{System.String,System.String})">
            <summary>
            使用用户自定义的加密方法保存数据到文件
            </summary>
            <param name="encrypt">用户自定义的加密方法</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftFileSaveBase.FileSavePath">
            <summary>
            文件存储的路径
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftFileSaveBase.ILogNet">
            <summary>
            日志记录类
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftBasic">
            <summary>
            一个软件基础类，提供常用的一些静态方法，比如字符串转换，字节转换的方法<br />
            A software-based class that provides some common static methods，Such as string conversion, byte conversion method
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateFileMD5(System.String)">
            <summary>
            获取文件的md5码<br />
            Get the MD5 code of the file
            </summary>
            <param name="filePath">文件的路径，既可以是完整的路径，也可以是相对的路径 -> The path to the file</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个文件的md5码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateFileMD5Example" title="CalculateFileMD5示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateStreamMD5(System.IO.Stream)">
            <summary>
            获取数据流的md5码<br />
            Get the MD5 code for the data stream
            </summary>
            <param name="stream">数据流，可以是内存流，也可以是文件流</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个流的md5码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateStreamMD5Example1" title="CalculateStreamMD5示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateStreamMD5(System.String)">
            <summary>
            获取文本字符串信息的Md5码，编码为UTF8<br />
            Get the Md5 code of the text string information, using the utf-8 encoding
            </summary>
            <param name="data">文本数据信息</param>
            <returns>Md5字符串</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateStreamMD5(System.String,System.Text.Encoding)">
            <summary>
            获取文本字符串信息的Md5码，使用指定的编码<br />
            Get the Md5 code of the text string information, using the specified encoding
            </summary>
            <param name="data">文本数据信息</param>
            <param name="encode">编码信息</param>
            <returns>Md5字符串</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateStreamMD5(System.Drawing.Bitmap)">
            <summary>
            获取内存图片的md5码<br />
            Get the MD5 code of the memory picture
            </summary>
            <param name="bitmap">内存图片</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个图像的md5码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateStreamMD5Example2" title="CalculateStreamMD5示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetSizeDescription(System.Int64)">
            <summary>
            从一个字节大小返回带单位的描述，主要是用于显示操作<br />
            Returns a description with units from a byte size, mainly for display operations
            </summary>
            <param name="size">实际的大小值</param>
            <returns>最终的字符串值</returns>
            <example>
            比如说我们获取了文件的长度，这个长度可以来自于本地，也可以来自于数据库查询
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetSizeDescriptionExample" title="GetSizeDescription示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetTimeSpanDescription(System.TimeSpan)">
            <summary>
            从一个时间差返回带单位的描述，主要是用于显示操作。<br />
            Returns a description with units from a time difference, mainly for display operations.
            </summary>
            <param name="ts">实际的时间差</param>
            <returns>最终的字符串值</returns>
            <example>
            比如说我们获取了一个时间差信息
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetTimeSpanDescriptionExample" title="GetTimeSpanDescription示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0[])">
            <summary>
            将数组格式化为显示的字符串的信息，支持所有的类型对象<br />
            Formats the array into the displayed string information, supporting all types of objects
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">数组信息</param>
            <returns>最终显示的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0[],System.String)">
            <summary>
            将数组格式化为显示的字符串的信息，支持所有的类型对象<br />
            Formats the array into the displayed string information, supporting all types of objects
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">数组信息</param>
            <param name="format">格式化的信息</param>
            <returns>最终显示的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0)">
            <summary>
            将数组格式化为显示的字符串的信息，支持所有的类型对象<br />
            Formats the array into the displayed string information, supporting all types of objects
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">数组信息</param>
            <returns>最终显示的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0,System.String)">
            <summary>
            将数组格式化为显示的字符串的信息，支持所有的类型对象<br />
            Formats the array into the displayed string information, supporting all types of objects
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">数组信息</param>
            <param name="format">格式化的信息</param>
            <returns>最终显示的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.AddArrayData``1(``0[]@,``0[],System.Int32)">
            <summary>
            一个通用的数组新增个数方法，会自动判断越界情况，越界的情况下，会自动的截断或是填充<br />
            A common array of new methods, will automatically determine the cross-border situation, in the case of cross-border, will be automatically truncated or filled
            </summary>
            <typeparam name="T">数据类型</typeparam>
            <param name="array">原数据</param>
            <param name="data">等待新增的数据</param>
            <param name="max">原数据的最大值</param>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="AddArrayDataExample" title="AddArrayData示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayExpandToLength``1(``0[],System.Int32)">
            <summary>
            将一个数组进行扩充到指定长度，或是缩短到指定长度<br />
            Extend an array to a specified length, or shorten to a specified length or fill
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="data">原先数据的数据</param>
            <param name="length">新数组的长度</param>
            <returns>新数组长度信息</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayExpandToLengthExample" title="ArrayExpandToLength示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayExpandToLengthEven``1(``0[])">
            <summary>
            将一个数组进行扩充到偶数长度<br />
            Extend an array to even lengths
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="data">原先数据的数据</param>
            <returns>新数组长度信息</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayExpandToLengthEvenExample" title="ArrayExpandToLengthEven示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArraySplitByLength``1(``0[],System.Int32)">
            <summary>
            将指定的数据按照指定长度进行分割，例如int[10]，指定长度4，就分割成int[4],int[4],int[2]，然后拼接list<br />
            Divide the specified data according to the specified length, such as int [10], and specify the length of 4 to divide into int [4], int [4], int [2], and then concatenate the list
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">等待分割的数组</param>
            <param name="length">指定的长度信息</param>
            <returns>分割后结果内容</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArraySplitByLengthExample" title="ArraySplitByLength示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SplitIntegerToArray(System.Int32,System.Int32)">
            <summary>
            将整数进行有效的拆分成数组，指定每个元素的最大值<br />
            Effectively split integers into arrays, specifying the maximum value for each element
            </summary>
            <param name="integer">整数信息</param>
            <param name="everyLength">单个的数组长度</param>
            <returns>拆分后的数组长度</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="SplitIntegerToArrayExample" title="SplitIntegerToArray示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.IsTwoBytesEquel(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            判断两个字节的指定部分是否相同<br />
            Determines whether the specified portion of a two-byte is the same
            </summary>
            <param name="b1">第一个字节</param>
            <param name="start1">第一个字节的起始位置</param>
            <param name="b2">第二个字节</param>
            <param name="start2">第二个字节的起始位置</param>
            <param name="length">校验的长度</param>
            <returns>返回是否相等</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoBytesEquelExample1" title="IsTwoBytesEquel示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.IsTwoBytesEquel(System.Byte[],System.Byte[])">
            <summary>
            判断两个字节的指定部分是否相同<br />
            Determines whether the specified portion of a two-byte is the same
            </summary>
            <param name="b1">第一个字节</param>
            <param name="b2">第二个字节</param>
            <returns>返回是否相等</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoBytesEquelExample2" title="IsTwoBytesEquel示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.IsByteTokenEquel(System.Byte[],System.Guid)">
            <summary>
            判断两个数据的令牌是否相等<br />
            Determines whether the tokens of two data are equal
            </summary>
            <param name="head">字节数据</param>
            <param name="token">GUID数据</param>
            <returns>返回是否相等</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoTokenEquelExample" title="IsByteTokenEquel示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.IsTwoTokenEquel(System.Guid,System.Guid)">
            <summary>
            判断两个数据的令牌是否相等<br />
            Determines whether the tokens of two data are equal
            </summary>
            <param name="token1">第一个令牌</param>
            <param name="token2">第二个令牌</param>
            <returns>返回是否相等</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetEnumValues``1">
            <summary>
            获取一个枚举类型的所有枚举值，可直接应用于组合框数据<br />
            Gets all the enumeration values of an enumeration type that can be applied directly to the combo box data
            </summary>
            <typeparam name="TEnum">枚举的类型值</typeparam>
            <returns>枚举值数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetEnumValuesExample" title="GetEnumValues示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetEnumFromString``1(System.String)">
            <summary>
            从字符串的枚举值数据转换成真实的枚举值数据<br />
            Convert enumeration value data from strings to real enumeration value data
            </summary>
            <typeparam name="TEnum">枚举的类型值</typeparam>
            <param name="value">枚举的字符串的数据值</param>
            <returns>真实的枚举值</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetEnumFromStringExample" title="GetEnumFromString示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetValueFromJsonObject``1(Newtonsoft.Json.Linq.JObject,System.String,``0)">
            <summary>
            一个泛型方法，提供json对象的数据读取<br />
            A generic method that provides data read for a JSON object
            </summary>
            <typeparam name="T">读取的泛型</typeparam>
            <param name="json">json对象</param>
            <param name="name">值名称</param>
            <param name="defaultValue">默认值</param>
            <returns>值对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetValueFromJsonObjectExample" title="GetValueFromJsonObject示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.JsonSetValue``1(Newtonsoft.Json.Linq.JObject,System.String,``0)">
            <summary>
            一个泛型方法，提供json对象的数据写入<br />
            A generic method that provides data writing to a JSON object
            </summary>
            <typeparam name="T">写入的泛型</typeparam>
            <param name="json">json对象</param>
            <param name="property">值名称</param>
            <param name="value">值数据</param>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="JsonSetValueExample" title="JsonSetValue示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ShowExceptionMessage(System.Exception)">
            <summary>
            显示一个完整的错误信息<br />
            Displays a complete error message
            </summary>
            <param name="ex">异常对象</param>
            <remarks>调用本方法可以显示一个异常的详细信息</remarks>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ShowExceptionMessage(System.String,System.Exception)">
            <summary>
            显示一个完整的错误信息，和额外的字符串描述信息<br />
            Displays a complete error message, and additional string description information
            </summary>
            <param name="extraMsg">额外的描述信息</param>
            <remarks>调用本方法可以显示一个异常的详细信息</remarks>
            <param name="ex">异常对象</param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetExceptionMessage(System.Exception)">
            <summary>
            获取一个异常的完整错误信息<br />
            Gets the complete error message for an exception
            </summary>
            <param name="ex">异常对象</param>
            <returns>完整的字符串数据</returns>
            <remarks>获取异常的完整信息</remarks>
            <exception cref="T:System.NullReferenceException">ex不能为空</exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetExceptionMessageExample1" title="GetExceptionMessage示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetExceptionMessage(System.String,System.Exception)">
            <summary>
            获取一个异常的完整错误信息，和额外的字符串描述信息<br />
            Gets the complete error message for an exception, and additional string description information
            </summary>
            <param name="extraMsg">额外的信息</param>
            <param name="ex">异常对象</param>
            <returns>完整的字符串数据</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetExceptionMessageExample2" title="GetExceptionMessage示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[])">
            <summary>
            字节数据转化成16进制表示的字符串<br />
            Byte data into a string of 16 binary representations
            </summary>
            <param name="InBytes">字节数组</param>
            <returns>返回的字符串</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToHexStringExample1" title="ByteToHexString示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char)">
            <summary>
            字节数据转化成16进制表示的字符串<br />
            Byte data into a string of 16 binary representations
            </summary>
            <param name="InBytes">字节数组</param>
            <param name="segment">分割符</param>
            <returns>返回的字符串</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToHexStringExample2" title="ByteToHexString示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char,System.Int32)">
            <summary>
            字节数据转化成16进制表示的字符串<br />
            Byte data into a string of 16 binary representations
            </summary>
            <param name="InBytes">字节数组</param>
            <param name="segment">分割符</param>
            <param name="newLineCount">每隔指定数量的时候进行换行</param>
            <returns>返回的字符串</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToHexStringExample2" title="ByteToHexString示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.String)">
            <summary>
            字符串数据转化成16进制表示的字符串<br />
            String data into a string of 16 binary representations
            </summary>
            <param name="InString">输入的字符串数据</param>
            <returns>返回的字符串</returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.HexStringToBytes(System.String)">
            <summary>
            将16进制的字符串转化成Byte数据，将检测每2个字符转化，也就是说，中间可以是任意字符<br />
            Converts a 16-character string into byte data, which will detect every 2 characters converted, that is, the middle can be any character
            </summary>
            <param name="hex">十六进制的字符串，中间可以是任意的分隔符</param>
            <returns>转换后的字节数组</returns>
            <remarks>参数举例：AA 01 34 A8</remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="HexStringToBytesExample" title="HexStringToBytes示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BytesReverseByWord(System.Byte[])">
            <summary>
            将byte数组按照双字节进行反转，如果为单数的情况，则自动补齐<br />
            Reverses the byte array by double byte, or if the singular is the case, automatically
            </summary>
            <param name="inBytes">输入的字节信息</param>
            <returns>反转后的数据</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BytesReverseByWord" title="BytesReverseByWord示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetAsciiStringRender(System.Byte[])">
            <summary>
            将字节数组显示为ASCII格式的字符串，当遇到0x20以下及0x7E以上的不可见字符时，使用十六进制的数据显示<br />
            Display the byte array as a string in ASCII format, when encountering invisible characters below 0x20 and above 0x7E, use hexadecimal data to display<br />
            </summary>
            <param name="content">字节数组信息</param>
            <returns>ASCII格式的字符串信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetFromAsciiStringRender(System.String)">
            <summary>
            从显示的ASCII格式的字符串，转为原始字节数组，如果遇到 \00 这种表示原始字节的内容，则直接进行转换操作，遇到 \r 直接转换 0x0D, \n 直接转换 0x0A<br />
            Convert from the displayed string in ASCII format to the original byte array. If you encounter \00, which represents the original byte content,
            the conversion operation is performed directly. When encountering \r, it is directly converted to 0x0D, and \n is directly converted to 0x0A.
            </summary>
            <param name="render">等待转换的字符串</param>
            <returns>原始字节数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BytesToAsciiBytes(System.Byte[])">
            <summary>
            将原始的byte数组转换成ascii格式的byte数组<br />
            Converts the original byte array to an ASCII-formatted byte array
            </summary>
            <param name="inBytes">等待转换的byte数组</param>
            <returns>转换后的数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.AsciiBytesToBytes(System.Byte[])">
            <summary>
            将ascii格式的byte数组转换成原始的byte数组<br />
            Converts an ASCII-formatted byte array to the original byte array
            </summary>
            <param name="inBytes">等待转换的byte数组</param>
            <returns>转换后的数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.Byte)">
            <summary>
            从字节构建一个ASCII格式的数据内容<br />
            Build an ASCII-formatted data content from bytes
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.Int16)">
            <summary>
            从short构建一个ASCII格式的数据内容<br />
            Constructing an ASCII-formatted data content from a short
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.UInt16)">
            <summary>
            从ushort构建一个ASCII格式的数据内容<br />
            Constructing an ASCII-formatted data content from ushort
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.UInt32)">
            <summary>
            从uint构建一个ASCII格式的数据内容<br />
            Constructing an ASCII-formatted data content from uint
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.Byte[])">
            <summary>
            从字节数组构建一个ASCII格式的数据内容<br />
            Byte array to construct an ASCII format data content
            </summary>
            <param name="value">字节信息</param>
            <returns>ASCII格式的地址</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BoolOnByteIndex(System.Byte,System.Int32)">
            <summary>
            获取byte数据类型的第offset位，是否为True<br />
            Gets the index bit of the byte data type, whether it is True
            </summary>
            <param name="value">byte数值</param>
            <param name="offset">索引位置</param>
            <returns>结果</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BoolOnByteIndex" title="BoolOnByteIndex示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SetBoolOnByteIndex(System.Byte,System.Int32,System.Boolean)">
            <summary>
            设置取byte数据类型的第offset位，是否为True<br />
            Set the offset bit of the byte data type, whether it is True
            </summary>
            <param name="byt">byte数值</param>
            <param name="offset">索引位置</param>
            <param name="value">写入的结果值</param>
            <returns>结果</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="SetBoolOnByteIndex" title="SetBoolOnByteIndex示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BoolArrayToByte(System.Boolean[])">
            <summary>
            将bool数组转换到byte数组<br />
            Converting a bool array to a byte array
            </summary>
            <param name="array">bool数组</param>
            <returns>转换后的字节数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BoolArrayToByte" title="BoolArrayToByte示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BoolArrayToString(System.Boolean[])">
            <summary>
            将bool数组转换为字符串进行显示，true被转为1，false转换为0<br />
            Convert the bool array to a string for display, true is converted to 1, false is converted to 0
            </summary>
            <param name="array">bool数组</param>
            <returns>转换后的字符串</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[],System.Int32)">
            <summary>
            从Byte数组中提取位数组，length代表位数<br />
            Extracts a bit array from a byte array, length represents the number of digits
            </summary>
            <param name="InBytes">原先的字节数组</param>
            <param name="length">想要转换的长度，如果超出自动会缩小到数组最大长度</param>
            <returns>转换后的bool数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToBoolArray" title="ByteToBoolArray示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[])">
            <summary>
            从Byte数组中提取所有的位数组<br />
            Extracts a bit array from a byte array, length represents the number of digits
            </summary>
            <param name="InBytes">原先的字节数组</param>
            <returns>转换后的bool数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToBoolArray" title="ByteToBoolArray示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveDouble``1(``0[],System.Int32,System.Int32)">
            <summary>
            将一个数组的前后移除指定位数，返回新的一个数组<br/>
            Removes a array before and after the specified number of bits, returning a new array
            </summary>
            <param name="value">数组</param>
            <param name="leftLength">前面的位数</param>
            <param name="rightLength">后面的位数</param>
            <returns>新的数组</returns>
            <exception cref="T:System.RankException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayRemoveDouble" title="ArrayRemoveDouble示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveBegin``1(``0[],System.Int32)">
            <summary>
            将一个数组的前面指定位数移除，返回新的一个数组<br />
            Removes the preceding specified number of bits in a array, returning a new array
            </summary>
            <param name="value">数组</param>
            <param name="length">等待移除的长度</param>
            <returns>新的数组</returns>
            <exception cref="T:System.RankException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayRemoveBegin" title="ArrayRemoveBegin示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveLast``1(``0[],System.Int32)">
            <summary>
            将一个数组的后面指定位数移除，返回新的一个数组<br />
            Removes the specified number of digits after a array, returning a new array
            </summary>
            <param name="value">数组</param>
            <param name="length">等待移除的长度</param>
            <returns>新的数组</returns>
            <exception cref="T:System.RankException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayRemoveLast" title="ArrayRemoveLast示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectMiddle``1(``0[],System.Int32,System.Int32)">
            <summary>
            获取到数组里面的中间指定长度的数组<br />
            Get an array of the specified length in the array
            </summary>
            <param name="value">数组</param>
            <param name="index">起始索引</param>
            <param name="length">数据的长度</param>
            <returns>新的数组值</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArraySelectMiddle" title="ArraySelectMiddle示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectBegin``1(``0[],System.Int32)">
            <summary>
            选择一个数组的前面的几个数据信息<br />
            Select the begin few items of data information of a array
            </summary>
            <param name="value">数组</param>
            <param name="length">数据的长度</param>
            <returns>新的数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArraySelectBegin" title="ArraySelectBegin示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectLast``1(``0[],System.Int32)">
            <summary>
            选择一个数组的后面的几个数据信息<br />
            Select the last few items of data information of a array
            </summary>
            <param name="value">数组</param>
            <param name="length">数据的长度</param>
            <returns>新的数组信息</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArraySelectLast" title="ArraySelectLast示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceArray``1(``0[][])">
            <summary>
            拼接任意个泛型数组为一个总的泛型数组对象，采用深度拷贝实现。<br />
            Splicing any number of generic arrays into a total generic array object is implemented using deep copy.
            </summary>
            <typeparam name="T">数组的类型信息</typeparam>
            <param name="arrays">任意个长度的数组</param>
            <returns>拼接之后的最终的结果对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="SpliceByteArray" title="SpliceByteArray示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceStringArray(System.String,System.String[])">
            <summary>
            将一个<see cref="T:System.String"/>的数组和多个<see cref="T:System.String"/> 类型的对象整合成一个数组<br />
            Combine an array of <see cref = "T:System.String" /> and multiple objects of type <see cref = "T:System.String" /> into an array
            </summary>
            <param name="first">第一个数组对象</param>
            <param name="array">字符串数组信息</param>
            <returns>总的数组对象</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceStringArray(System.String,System.String,System.String[])">
            <summary>
            将两个<see cref="T:System.String"/>的数组和多个<see cref="T:System.String"/> 类型的对象整合成一个数组<br />
            Combine two arrays of <see cref="T:System.String" /> and multiple objects of type <see cref="T:System.String"/> into one array
            </summary>
            <param name="first">第一个数据对象</param>
            <param name="second">第二个数据对象</param>
            <param name="array">字符串数组信息</param>
            <returns>总的数组对象</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceStringArray(System.String,System.String,System.String,System.String[])">
            <summary>
            将两个<see cref="T:System.String"/>的数组和多个<see cref="T:System.String"/> 类型的对象整合成一个数组<br />
            Combine two arrays of <see cref="T:System.String" /> and multiple objects of type <see cref="T:System.String"/> into one array
            </summary>
            <param name="first">第一个数据对象</param>
            <param name="second">第二个数据对象</param>
            <param name="third">第三个数据对象</param>
            <param name="array">字符串数组信息</param>
            <returns>总的数组对象</returns>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftBasic.FrameworkVersion">
            <summary>
            设置或获取系统框架的版本号<br />
            Set or get the version number of the system framework
            </summary>
            <remarks>
            当你要显示本组件框架的版本号的时候，就可以用这个属性来显示
            </remarks>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.DeepClone(System.Object)">
            <summary>
            使用序列化反序列化深度克隆一个对象，该对象需要支持序列化特性<br />
            Cloning an object with serialization deserialization depth that requires support for serialization attributes
            </summary>
            <param name="oringinal">源对象，支持序列化</param>
            <returns>新的一个实例化的对象</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.NonSerializedAttribute"></exception>
            <remarks>
            <note type="warning">
            <paramref name="oringinal"/> 参数必须实现序列化的特性
            </note>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="DeepClone" title="DeepClone示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetUniqueStringByGuidAndRandom">
            <summary>
            获取一串唯一的随机字符串，长度为20，由Guid码和4位数的随机数组成，保证字符串的唯一性<br />
            Gets a string of unique random strings with a length of 20, consisting of a GUID code and a 4-digit random number to guarantee the uniqueness of the string
            </summary>
            <returns>随机字符串数据</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetUniqueStringByGuidAndRandom" title="GetUniqueStringByGuidAndRandom示例" />
            </example>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftBuffer">
            <summary>
            一个线程安全的缓存数据块，支持批量动态修改，添加，并获取快照<br />
            A thread-safe cache data block that supports batch dynamic modification, addition, and snapshot acquisition
            </summary>
            <remarks>
            这个类可以实现什么功能呢，就是你有一个大的数组，作为你的应用程序的中间数据池，允许你往byte[]数组里存放指定长度的子byte[]数组，也允许从里面拿数据，
            这些操作都是线程安全的，当然，本类扩展了一些额外的方法支持，也可以直接赋值或获取基本的数据类型对象。
            </remarks>
            <example>
            此处举例一些数据的读写说明，可以此处的数据示例。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBufferExample.cs" region="SoftBufferExample1" title="SoftBuffer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.#ctor">
            <summary>
            使用默认的大小初始化缓存空间<br />
            Initialize cache space with default size
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.#ctor(System.Int32)">
            <summary>
            使用指定的容量初始化缓存数据块<br />
            Initialize the cache data block with the specified capacity
            </summary>
            <param name="capacity">初始化的容量</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBool(System.Boolean,System.Int32)">
            <summary>
            设置指定的位置bool值，如果超出，则丢弃数据，该位置是指按照位为单位排序的<br />
            Set the bool value at the specified position, if it is exceeded, 
            the data is discarded, the position refers to sorting in units of bits
            </summary>
            <param name="value">bool值</param>
            <param name="destIndex">目标存储的索引</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBool(System.Boolean[],System.Int32)">
            <summary>
            设置指定的位置的bool数组，如果超出，则丢弃数据，该位置是指按照位为单位排序的<br />
            Set the bool array at the specified position, if it is exceeded, 
            the data is discarded, the position refers to sorting in units of bits
            </summary>
            <param name="value">bool数组值</param>
            <param name="destIndex">目标存储的索引</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetBool(System.Int32)">
            <summary>
            获取指定的位置的bool值，如果超出，则引发异常<br />
            Get the bool value at the specified position, if it exceeds, an exception is thrown
            </summary>
            <param name="destIndex">目标存储的索引</param>
            <returns>获取索引位置的bool数据值</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetBool(System.Int32,System.Int32)">
            <summary>
            获取指定位置的bool数组值，如果超过，则引发异常<br />
            Get the bool array value at the specified position, if it exceeds, an exception is thrown
            </summary>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">读取的数组长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <returns>bool数组值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据<br />
            Set the data block at the specified position, if it is exceeded, the data is discarded
            </summary>
            <param name="data">数据块信息</param>
            <param name="destIndex">目标存储的索引</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据
            Set the data block at the specified position, if it is exceeded, the data is discarded
            </summary>
            <param name="data">数据块信息</param>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">准备拷贝的数据长度</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据<br />
            Set the data block at the specified position, if it is exceeded, the data is discarded
            </summary>
            <param name="data">数据块信息</param>
            <param name="sourceIndex">Data中的起始位置</param>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">准备拷贝的数据长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetBytes(System.Int32,System.Int32)">
            <summary>
            获取内存指定长度的数据信息<br />
            Get data information of specified length in memory
            </summary>
            <param name="index">起始位置</param>
            <param name="length">数组长度</param>
            <returns>返回实际的数据信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetBytes">
            <summary>
            获取内存所有的数据信息<br />
            Get all data information in memory
            </summary>
            <returns>实际的数据信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Byte,System.Int32)">
            <summary>
            设置byte类型的数据到缓存区<br />
            Set byte type data to the cache area
            </summary>
            <param name="value">byte数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int16[],System.Int32)">
            <summary>
            设置short数组的数据到缓存区<br />
            Set short array data to the cache area
            </summary>
            <param name="values">short数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int16,System.Int32)">
            <summary>
            设置short类型的数据到缓存区<br />
            Set short type data to the cache area
            </summary>
            <param name="value">short数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt16[],System.Int32)">
            <summary>
            设置ushort数组的数据到缓存区<br />
            Set ushort array data to the cache area
            </summary>
            <param name="values">ushort数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt16,System.Int32)">
            <summary>
            设置ushort类型的数据到缓存区<br />
            Set ushort type data to the cache area
            </summary>
            <param name="value">ushort数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int32[],System.Int32)">
            <summary>
            设置int数组的数据到缓存区<br />
            Set int array data to the cache area
            </summary>
            <param name="values">int数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int32,System.Int32)">
            <summary>
            设置int类型的数据到缓存区<br />
            Set int type data to the cache area
            </summary>
            <param name="value">int数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt32[],System.Int32)">
            <summary>
            设置uint数组的数据到缓存区<br />
            Set uint array data to the cache area
            </summary>
            <param name="values">uint数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt32,System.Int32)">
            <summary>
            设置uint类型的数据到缓存区<br />
            Set uint byte data to the cache area
            </summary>
            <param name="value">uint数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Single[],System.Int32)">
            <summary>
            设置float数组的数据到缓存区<br />
            Set float array data to the cache area
            </summary>
            <param name="values">float数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Single,System.Int32)">
            <summary>
            设置float类型的数据到缓存区<br />
            Set float type data to the cache area
            </summary>
            <param name="value">float数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int64[],System.Int32)">
            <summary>
            设置long数组的数据到缓存区<br />
            Set long array data to the cache area
            </summary>
            <param name="values">long数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int64,System.Int32)">
            <summary>
            设置long类型的数据到缓存区<br />
            Set long type data to the cache area
            </summary>
            <param name="value">long数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt64[],System.Int32)">
            <summary>
            设置ulong数组的数据到缓存区<br />
            Set long array data to the cache area
            </summary>
            <param name="values">ulong数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt64,System.Int32)">
            <summary>
            设置ulong类型的数据到缓存区<br />
            Set ulong byte data to the cache area
            </summary>
            <param name="value">ulong数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Double[],System.Int32)">
            <summary>
            设置double数组的数据到缓存区<br />
            Set double array data to the cache area
            </summary>
            <param name="values">double数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Double,System.Int32)">
            <summary>
            设置double类型的数据到缓存区<br />
            Set double type data to the cache area
            </summary>
            <param name="value">double数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetByte(System.Int32)">
            <summary>
            获取byte类型的数据<br />
            Get byte data
            </summary>
            <param name="index">索引位置</param>
            <returns>byte数值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt16(System.Int32,System.Int32)">
            <summary>
            获取short类型的数组到缓存区<br />
            Get short type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>short数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt16(System.Int32)">
            <summary>
            获取short类型的数据到缓存区<br />
            Get short data to the cache
            </summary>
            <param name="index">索引位置</param>
            <returns>short数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt16(System.Int32,System.Int32)">
            <summary>
            获取ushort类型的数组到缓存区<br />
            Get ushort type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>ushort数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt16(System.Int32)">
            <summary>
            获取ushort类型的数据到缓存区<br />
            Get ushort type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>ushort数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt32(System.Int32,System.Int32)">
            <summary>
            获取int类型的数组到缓存区<br />
            Get int type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>int数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt32(System.Int32)">
            <summary>
            获取int类型的数据到缓存区<br />
            Get int type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>int数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt32(System.Int32,System.Int32)">
            <summary>
            获取uint类型的数组到缓存区<br />
            Get uint type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>uint数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt32(System.Int32)">
            <summary>
            获取uint类型的数据到缓存区<br />
            Get uint type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>uint数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetSingle(System.Int32,System.Int32)">
            <summary>
            获取float类型的数组到缓存区<br />
            Get float type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>float数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetSingle(System.Int32)">
            <summary>
            获取float类型的数据到缓存区<br />
            Get float type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>float数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt64(System.Int32,System.Int32)">
            <summary>
            获取long类型的数组到缓存区<br />
            Get long type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>long数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt64(System.Int32)">
            <summary>
            获取long类型的数据到缓存区<br />
            Get long type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>long数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt64(System.Int32,System.Int32)">
            <summary>
            获取ulong类型的数组到缓存区<br />
            Get ulong type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>ulong数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt64(System.Int32)">
            <summary>
            获取ulong类型的数据到缓存区<br />
            Get ulong type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>ulong数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetDouble(System.Int32,System.Int32)">
            <summary>
            获取double类型的数组到缓存区<br />
            Get double type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>double数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetDouble(System.Int32)">
            <summary>
            获取double类型的数据到缓存区<br />
            Get double type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>double数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetCustomer``1(System.Int32)">
            <summary>
            读取自定义类型的数据，需要规定解析规则<br />
            Read custom types of data, need to specify the parsing rules
            </summary>
            <typeparam name="T">类型名称</typeparam>
            <param name="index">起始索引</param>
            <returns>自定义的数据类型</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetCustomer``1(``0,System.Int32)">
            <summary>
            写入自定义类型的数据到缓存中去，需要规定生成字节的方法<br />
            Write custom type data to the cache, need to specify the method of generating bytes
            </summary>
            <typeparam name="T">自定义类型</typeparam>
            <param name="data">实例对象</param>
            <param name="index">起始地址</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftBuffer.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftBuffer.IsBoolReverseByWord">
            <summary>
            获取或设置当前的bool操作是否按照字节反转<br />
            Gets or sets whether the current bool operation is reversed by bytes
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftCacheArrayBase">
            <summary>
            内存队列的基类
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftCacheArrayBase.DataBytes">
            <summary>
            字节数据流
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftCacheArrayBase.ArrayLength">
            <summary>
            数据的长度
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftCacheArrayBase.HybirdLock">
            <summary>
            数据数组变动时的数据锁
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayBase.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayBase.GetAllData">
            <summary>
            获取原本的数据字节
            </summary>
            <returns>字节数组</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftCacheArrayLong">
            <summary>
            一个内存队列缓存的类，数据类型为Int64
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftCacheArrayLong.DataArray">
            <summary>
            数据的本身面貌
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayLong.#ctor(System.Int32,System.Int32)">
            <summary>
            实例化一个数据对象
            </summary>
            <param name="capacity"></param>
            <param name="defaultValue"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayLong.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayLong.AddValue(System.Int64)">
            <summary>
            线程安全的添加数据
            </summary>
            <param name="value">值</param>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftCacheArrayInt">
            <summary>
            一个内存队列缓存的类，数据类型为Int32
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftCacheArrayInt.DataArray">
            <summary>
            数据的本身面貌
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayInt.#ctor(System.Int32,System.Int32)">
            <summary>
            实例化一个数据对象
            </summary>
            <param name="capacity"></param>
            <param name="defaultValue"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayInt.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayInt.AddValue(System.Int32)">
            <summary>
            线程安全的添加数据
            </summary>
            <param name="value">值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayInt.GetIntArray">
            <summary>
            安全的获取数组队列
            </summary>
            <returns></returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.Exception`1">
            <summary>
            一个自定义的支持序列化反序列化的异常类，具体用法参照第四版《CLR Via C#》P414
            </summary>
            <typeparam name="TExceptionArgs">泛型异常</typeparam>
        </member>
        <member name="F:HslCommunication.BasicFramework.Exception`1.c_args">
            <summary>
            用于反序列化的
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.Exception`1.Args">
            <summary>
            消息
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.#ctor(System.String,System.Exception)">
            <summary>
            实例化一个异常对象
            </summary>
            <param name="message">消息</param>
            <param name="innerException">内部异常类</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.#ctor(`0,System.String,System.Exception)">
            <summary>
            实例化一个异常对象
            </summary>
            <param name="args">异常消息</param>
            <param name="message">消息</param>
            <param name="innerException">内部异常类</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            获取存储对象的序列化数据
            </summary>
            <param name="info">序列化的信息</param>
            <param name="context">流的上下文</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.Exception`1.Message">
            <summary>
            获取描述当前异常的消息
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.Equals(System.Object)">
            <summary>
            确定指定的object是否等于当前的object
            </summary>
            <param name="obj">异常对象</param>
            <returns>是否一致</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.ExceptionArgs">
            <summary>
            异常消息基类
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.ExceptionArgs.Message">
            <summary>
            携带的额外的消息类对象
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftMail">
            <summary>
            软件的邮箱类，用于发送邮箱数据
            </summary>
            <remarks>
            如果您想实现自己的邮件发送中心，就可以去对应的邮件服务器注册，如果是想快速实现邮件的发送，本系统提供了2个静态的已经注册好了的邮箱发送器。
            </remarks>
            <example>
            以下的代码演示了通过静态的发送对象来发送邮件，包含了发送普通的邮件，和发送html邮件。
            <code lang="cs" source="TestProject\HslCommunicationDemo\FormMail.cs" region="SoftMail" title="SoftMail示例" />
            </example>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMail.SoftMailSendFailedCount">
            <summary>
            系统连续发送失败的次数，为了不影响系统，连续三次失败就禁止发送
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftMail.MailSystem163">
            <summary>
            系统提供一个默认的163邮箱发送账号，只要更改接收地址即可发送服务，可能会被拦截
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftMail.MailSystemQQ">
            <summary>
            系统提供一个默认的QQ邮箱发送账号，只要更改接收地址即可发送服务，发送成功概率比较高
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.#ctor(System.Action{System.Net.Mail.SmtpClient},System.String,System.String)">
            <summary>
            实例化一个邮箱发送类，需要指定初始化信息
            </summary>
            <param name="mailIni">初始化的方法</param>
            <param name="addr_From">发送地址，应该和账户匹配</param>
            <param name="addr_to">邮件接收地址</param>
            <remarks>
            初始化的方法比较复杂，需要参照示例代码。
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45\BasicFramework\SoftMail.cs" region="Static Mail" title="SoftMail示例" />
            </example>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMail.smtpClient">
            <summary>
            系统的邮件发送客户端
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMail.MailFromAddress">
            <summary>
            发送邮件的地址
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMail.MailSendAddress">
            <summary>
            邮件发送的地址
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.Exception)">
            <summary>
            发生BUG至邮件地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="ex">异常的BUG，同样试用兼容类型</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String)">
            <summary>
            发送邮件至地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.Boolean)">
            <summary>
            发送邮件至地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="isHtml">是否是html格式化文本</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.Exception,System.String)">
            <summary>
            发生BUG至邮件地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="ex">异常的BUG，同样试用兼容类型</param>
            <param name="addtion">额外信息</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String)">
            <summary>
            发送邮件的方法，需要指定接收地址，主题及内容
            </summary>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String,System.Boolean)">
            <summary>
            发送邮件的方法，默认发送别名，优先级，是否HTML
            </summary>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="isHtml">是否是html格式的内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String[],System.String,System.String,System.Net.Mail.MailPriority,System.Boolean)">
            <summary>
            发送邮件的方法，需要提供完整的参数信息
            </summary>
            <param name="addr_from">发送地址</param>
            <param name="name">发送别名</param>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="priority">优先级</param>
            <param name="isHtml">邮件内容是否是HTML语言</param>
            <returns>发生是否成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftMsgQueue`1">
            <summary>
            一个简单通用的消息队列
            </summary>
            <typeparam name="T">类型</typeparam>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMsgQueue`1.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftMsgQueue`1.all_items">
            <summary>
            所有临时存储的数据
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMsgQueue`1.MaxCache">
            <summary>
            临时消息存储的最大条数，必须大于10
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMsgQueue`1.CurrentItem">
            <summary>
            获取最新添加进去的数据
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftMsgQueue`1.lock_queue">
            <summary>
            将集合进行锁定
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMsgQueue`1.AddNewItem(`0)">
            <summary>
            新增一条数据
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMsgQueue`1.ToSaveString">
            <summary>
            获取存储字符串
            </summary>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMsgQueue`1.LoadByString(System.String)">
            <summary>
            获取加载字符串
            </summary>
            <param name="content"></param>
        </member>
        <member name="T:HslCommunication.BasicFramework.MessageBoard">
            <summary>
            系统的消息类，用来发送消息，和确认消息的
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.NameSend">
            <summary>
            发送方名称
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.NameReceive">
            <summary>
            接收方名称
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.SendTime">
            <summary>
            发送时间
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.Content">
            <summary>
            发送的消息内容
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.HasViewed">
            <summary>
            消息是否已经被查看
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftNumericalOrder">
            <summary>
            一个用于自动流水号生成的类，必须指定保存的文件，实时保存来确认安全
            </summary>
            <remarks>
            <note type="important">
            序号生成器软件，当获取序列号，清空序列号操作后，会自动的将ID号存储到本地的文件中，存储方式采用乐观并发模型实现。
            </note>
            </remarks>
            <example>
            此处举个例子，也是Demo程序的源代码，包含了2个按钮的示例和瞬间调用100万次的性能示例。
            <note type="tip">百万次调用的实际耗时取决于计算机的性能，不同的计算机的表现存在差异，比如作者的：i5-4590cpu,内存ddr3-8G表示差不多在800毫秒左右</note>
            <code lang="cs" source="TestProject\HslCommunicationDemo\FormSeqCreate.cs" region="FormSeqCreate" title="示例代码" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.#ctor(System.String,System.String,System.Int32,System.String)">
            <summary>
            实例化一个流水号生成的对象
            </summary>
            <param name="textHead">流水号的头文本</param>
            <param name="timeFormate">流水号带的时间信息</param>
            <param name="numberLength">流水号数字的标准长度，不够补0</param>
            <param name="fileSavePath">流水号存储的文本位置</param>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.CurrentIndex">
            <summary>
            当前的生成序列号
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.TextHead">
            <summary>
            流水号的文本头
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.TimeFormate">
            <summary>
            时间格式默认年月日
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.NumberLength">
            <summary>
            流水号数字应该显示的长度
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.ToSaveString">
            <summary>
            获取流水号的值
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.LoadByString(System.String)">
            <summary>
            加载流水号
            </summary>
            <param name="content">源字符串信息</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.ClearNumericalOrder">
            <summary>
            清除流水号计数，进行重新计数
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.GetNumericalOrder">
            <summary>
            获取流水号数据
            </summary>
            <returns>新增计数后的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.GetNumericalOrder(System.String)">
            <summary>
            获取流水号数据
            </summary>
            <param name="textHead">指定一个新的文本头</param>
            <returns>带头信息的计数后的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.GetLongOrder">
            <summary>
            单纯的获取数字形式的流水号
            </summary>
            <returns>新增计数后的信息</returns>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.AsyncCoordinator">
            <summary>
            高性能存储块
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftIncrementCount">
            <summary>
            一个简单的不持久化的序号自增类，采用线程安全实现，并允许指定最大数字，将包含该最大值，到达后清空从指定数开始<br />
            A simple non-persistent serial number auto-increment class, which is implemented with thread safety, and allows the maximum number to be specified, which will contain the maximum number, and will be cleared from the specified number upon arrival.
            </summary>
            <example>
            先来看看一个简单的应用的
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftIncrementCountSample.cs" region="Sample1" title="简单示例" />
            再来看看一些复杂的情况
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftIncrementCountSample.cs" region="Sample2" title="复杂示例" />
            其他一些特殊的设定
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftIncrementCountSample.cs" region="Sample3" title="其他示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            实例化一个自增信息的对象，包括最大值，初始值，增量值<br />
            Instantiate an object with incremental information, including the maximum value and initial value, IncreaseTick
            </summary>
            <param name="max">数据的最大值，必须指定</param>
            <param name="start">数据的起始值，默认为0</param>
            <param name="tick">每次的增量值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.GetCurrentValue">
            <summary>
            获取自增信息，获得数据之后，下一次获取将会自增，如果自增后大于最大值，则会重置为最小值，如果小于最小值，则会重置为最大值。<br />
            Get the auto-increment information. After getting the data, the next acquisition will auto-increase. 
            If the auto-increment is greater than the maximum value, it will reset to the minimum value.
            If the auto-increment is smaller than the minimum value, it will reset to the maximum value.
            </summary>
            <returns>计数自增后的值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ResetMaxValue(System.Int64)">
            <summary>
            重置当前序号的最大值，最大值应该大于初始值，如果当前值大于最大值，则当前值被重置为最大值<br />
            Reset the maximum value of the current serial number. The maximum value should be greater than the initial value. 
            If the current value is greater than the maximum value, the current value is reset to the maximum value.
            </summary>
            <param name="max">最大值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ResetStartValue(System.Int64)">
            <summary>
            重置当前序号的初始值，需要小于最大值，如果当前值小于初始值，则当前值被重置为初始值。<br />
            To reset the initial value of the current serial number, it must be less than the maximum value. 
            If the current value is less than the initial value, the current value is reset to the initial value.
            </summary>
            <param name="start">初始值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ResetCurrentValue">
            <summary>
            将当前的值重置为初始值。<br />
            Reset the current value to the initial value.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ResetCurrentValue(System.Int64)">
            <summary>
            将当前的值重置为指定值，该值不能大于max，如果大于max值，就会自动设置为max<br />
            Reset the current value to the specified value. The value cannot be greater than max. If it is greater than max, it will be automatically set to max.
            </summary>
            <param name="value">指定的数据值</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftIncrementCount.IncreaseTick">
            <summary>
            增加的单元，如果设置为0，就是不增加。如果为小于0，那就是减少，会变成负数的可能。<br />
            Increased units, if set to 0, do not increase. If it is less than 0, it is a decrease and it may become a negative number.
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftIncrementCount.MaxValue">
            <summary>
            获取当前的计数器的最大的设置值。<br />
            Get the maximum setting value of the current counter.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:HslCommunication.BasicFramework.GraphDirection">
            <summary>
            图形的方向
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphDirection.Upward">
            <summary>
            向上
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphDirection.Downward">
            <summary>
            向下
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphDirection.Ledtward">
            <summary>
            向左
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphDirection.Rightward">
            <summary>
            向右
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.Paintdata">
            <summary>
            包含整型和字符串描述的数据类型
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.Paintdata.Count">
            <summary>
            数量
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.Paintdata.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.GraphicRender">
            <summary>
            图形的呈现方式
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphicRender.Histogram">
            <summary>
            直方图
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphicRender.Piechart">
            <summary>
            饼图
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphicRender.Linegraph">
            <summary>
            折线图
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftPainting">
            <summary>
            静态类，包含了几个常用的画图方法，获取字符串，绘制小三角等
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.GetGraphicFromArray(System.Int32[],System.Int32,System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            获取一个直方图
            </summary>
            <param name="array">数据数组</param>
            <param name="width">宽度</param>
            <param name="height">高度</param>
            <param name="degree">刻度划分等级</param>
            <param name="lineColor">线条颜色</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.ComputePaintLocationY(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            计算绘图时的相对偏移值
            </summary>
            <param name="max">0-100分的最大值，就是指准备绘制的最大值</param>
            <param name="min">0-100分的最小值，就是指准备绘制的最小值</param>
            <param name="height">实际绘图区域的高度</param>
            <param name="value">需要绘制数据的当前值</param>
            <returns>相对于0的位置，还需要增加上面的偏值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.ComputePaintLocationY(System.Single,System.Single,System.Int32,System.Single)">
            <summary>
            计算绘图时的相对偏移值
            </summary>
            <param name="max">0-100分的最大值，就是指准备绘制的最大值</param>
            <param name="min">0-100分的最小值，就是指准备绘制的最小值</param>
            <param name="height">实际绘图区域的高度</param>
            <param name="value">需要绘制数据的当前值</param>
            <returns>相对于0的位置，还需要增加上面的偏值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.PaintCoordinateDivide(System.Drawing.Graphics,System.Drawing.Pen,System.Drawing.Pen,System.Drawing.Font,System.Drawing.Brush,System.Drawing.StringFormat,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            绘制坐标系中的刻度线
            </summary>
            <param name="g"></param>
            <param name="penLine"></param>
            <param name="penDash"></param>
            <param name="font"></param>
            <param name="brush"></param>
            <param name="sf"></param>
            <param name="degree"></param>
            <param name="max"></param>
            <param name="min"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="left"></param>
            <param name="right"></param>
            <param name="up"></param>
            <param name="down"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.PaintTriangle(System.Drawing.Graphics,System.Drawing.Brush,System.Drawing.Point,System.Int32,HslCommunication.BasicFramework.GraphDirection)">
            <summary>
            根据指定的方向绘制一个箭头
            </summary>
            <param name="g"></param>
            <param name="brush"></param>
            <param name="point"></param>
            <param name="size"></param>
            <param name="direction"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.GetGraphicFromArray(HslCommunication.BasicFramework.Paintdata[],System.Int32,System.Int32,HslCommunication.BasicFramework.GraphicRender)">
            <summary>
            根据数据生成一个可视化的图形
            </summary>
            <param name="array">数据集合</param>
            <param name="width">需要绘制图形的宽度</param>
            <param name="height">需要绘制图形的高度</param>
            <param name="graphic">指定绘制成什么样子的图形</param>
            <returns>返回一个bitmap对象</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftSecurity">
            <summary>
            字符串加密解密相关的自定义类
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSecurity.MD5Encrypt(System.String)">
            <summary>
            加密数据，采用DES对称加密的方式
            </summary>
            <param name="pToEncrypt">待加密的数据</param>
            <returns>加密后的数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSecurity.MD5Encrypt(System.String,System.String)">
            <summary>
            加密数据，采用DES对称加密的方式
            </summary>
            <param name="pToEncrypt">待加密的数据</param>
            <param name="Password">密钥，长度为8，英文或数字</param>
            <returns>加密后的数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSecurity.MD5Decrypt(System.String)">
            <summary>
            解密过程，使用的是DES对称的加密
            </summary>
            <param name="pToDecrypt">等待解密的字符</param>
            <returns>返回原密码，如果解密失败，返回‘解密失败’</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSecurity.MD5Decrypt(System.String,System.String)">
            <summary>
            解密过程，使用的是DES对称的加密
            </summary>
            <param name="pToDecrypt">等待解密的字符</param>
            <param name="password">密钥，长度为8，英文或数字</param>
            <returns>返回原密码，如果解密失败，返回‘解密失败’</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftSqlOperate">
            <summary>
            数据库操作的相关类，包含了常用的方法，避免大量的重复代码
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSql(System.String,System.String)">
            <summary>
            普通的执行SQL语句，并返回影响行数，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，适合插入，更新，删除</param>
            <returns>返回受影响的行数</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSql(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            普通的执行SQL语句，并返回影响行数，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，适合插入，更新，删除</param>
            <returns>返回受影响的行数</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectTable(System.String,System.String)">
            <summary>
            选择数据表的执行SQL语句，并返回最终数据表，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据表</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectTable(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            选择数据表的执行SQL语句，并返回最终数据表，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据表</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectEnumerable``1(System.String,System.String)">
            <summary>
            选择指定类型数据集合执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据集合</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectEnumerable``1(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            选择指定类型数据集合执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据集合</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectObject``1(System.String,System.String)">
            <summary>
            更新指定类型数据执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectObject``1(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            更新指定类型数据执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectCount(System.String,System.String)">
            <summary>
            用于选择聚合函数值的方法，例如Count，Average，Max，Min，Sum等最终只有一个结果值的对象
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>返回的int数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectCount(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            用于选择聚合函数值的方法，例如Count，Average，Max，Min，Sum等最终只有一个结果值的对象
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>返回的int数据</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.ISqlDataType">
            <summary>
            数据库对应类的读取接口
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISqlDataType.LoadBySqlDataReader(System.Data.SqlClient.SqlDataReader)">
            <summary>
            根据sdr对象初始化数据的方法
            </summary>
            <param name="sdr">数据库reader对象</param>
        </member>
        <member name="T:HslCommunication.BasicFramework.SystemVersion">
            <summary>
            系统版本类，由三部分组成，包含了一个大版本，小版本，修订版，还有一个开发者维护的内部版<br />
            System version class, consisting of three parts, including a major version, minor version, revised version, and an internal version maintained by the developer
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.#ctor(System.String)">
            <summary>
            根据格式化字符串的版本号初始化，例如：1.0或1.0.0或1.0.0.0503<br />
            Initialize according to the version number of the formatted string, for example: 1.0 or 1.0.0 or 1.0.0.0503
            </summary>
            <param name="VersionString">格式化的字符串，例如：1.0或1.0.0或1.0.0.0503</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            根据指定的主版本，次版本，修订版来实例化一个对象<br />
            Instantiate an object based on the specified major, minor, and revision
            </summary>
            <param name="main">主版本</param>
            <param name="sec">次版本</param>
            <param name="edit">修订版</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            根据指定的主版本，次版本，修订版，内部版本来实例化一个对象<br />
            Instantiate an object based on the specified major, minor, revision, and build
            </summary>
            <param name="main">主版本</param>
            <param name="sec">次版本</param>
            <param name="edit">修订版</param>
            <param name="inner">内部版本号</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SystemVersion.MainVersion">
            <summary>
            主版本
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SystemVersion.SecondaryVersion">
            <summary>
            次版本
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SystemVersion.EditVersion">
            <summary>
            修订版
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SystemVersion.InnerVersion">
            <summary>
            内部版本号，或者是版本号表示为年月份+内部版本的表示方式
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.ToString(System.String)">
            <summary>
            根据格式化为支持返回的不同信息的版本号<br />
            C返回1.0.0.0<br />
            N返回1.0.0<br />
            S返回1.0
            </summary>
            <param name="format">格式化信息</param>
            <returns>版本号信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.ToString">
            <summary>
            获取版本号的字符串形式，如果内部版本号为0，则显示时不携带
            </summary>
            <returns>版本号信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.Equals(System.Object)">
            <summary>
            判断两个实例是否相等
            </summary>
            <param name="obj">版本号</param>
            <returns>是否一致</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.GetHashCode">
            <summary>
            获取哈希值
            </summary>
            <returns>哈希值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.op_Equality(HslCommunication.BasicFramework.SystemVersion,HslCommunication.BasicFramework.SystemVersion)">
            <summary>
            判断是否相等
            </summary>
            <param name="SV1">第一个版本</param>
            <param name="SV2">第二个版本</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.op_Inequality(HslCommunication.BasicFramework.SystemVersion,HslCommunication.BasicFramework.SystemVersion)">
            <summary>
            判断是否不相等
            </summary>
            <param name="SV1">第一个版本号</param>
            <param name="SV2">第二个版本号</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.op_GreaterThan(HslCommunication.BasicFramework.SystemVersion,HslCommunication.BasicFramework.SystemVersion)">
            <summary>
            判断一个版本是否大于另一个版本
            </summary>
            <param name="SV1">第一个版本</param>
            <param name="SV2">第二个版本</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.op_LessThan(HslCommunication.BasicFramework.SystemVersion,HslCommunication.BasicFramework.SystemVersion)">
            <summary>
            判断第一个版本是否小于第二个版本
            </summary>
            <param name="SV1">第一个版本号</param>
            <param name="SV2">第二个版本号</param>
            <returns>是否小于</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.VersionInfo">
            <summary>
            版本信息类，用于展示版本发布信息
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.VersionInfo.ReleaseDate">
            <summary>
            版本的发行日期
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.VersionInfo.UpdateDetails">
            <summary>
            版本的更新细节
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.VersionInfo.VersionNum">
            <summary>
            版本号
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.VersionInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftZipped">
            <summary>
            一个负责压缩解压数据字节的类
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftZipped.CompressBytes(System.Byte[])">
            <summary>
            压缩字节数据
            </summary>
            <param name="bytes">等待被压缩的数据</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <returns>压缩之后的字节数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftZipped.Decompress(System.Byte[])">
            <summary>
            解压压缩后的数据
            </summary>
            <param name="bytes">压缩后的数据</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <returns>压缩前的原始字节数据</returns>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage">
            <summary>
            Fanuc床子的消息对象
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.ProtocolHeadBytesLength">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.GetContentLengthByHeadBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.CNCRunStatus">
            <summary>
            CNC的运行状态
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCRunStatus.RESET">
            <summary>
            重置
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCRunStatus.STOP">
            <summary>
            停止
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCRunStatus.HOLD">
            <summary>
            等待
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCRunStatus.START">
            <summary>
            启动
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCRunStatus.MSTR">
            <summary>
            MSTR
            </summary>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.CNCWorkMode">
            <summary>
            设备的工作模式
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.MDI">
            <summary>
            手动输入
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.AUTO">
            <summary>
            自动循环
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.EDIT">
            <summary>
            程序编辑
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.HANDLE">
            <summary>
            ×100
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.JOG">
            <summary>
            连续进给
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.TeachInJOG">
            <summary>
            ???
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.TeachInHandle">
            <summary>
            示教
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.INCfeed">
            <summary>
            ???
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.REFerence">
            <summary>
            机床回零
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.ReMoTe">
            <summary>
            ???
            </summary>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.CutterInfo">
            <summary>
            刀具信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CutterInfo.LengthSharpOffset">
            <summary>
            长度形状补偿
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CutterInfo.LengthWearOffset">
            <summary>
            长度磨损补偿
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CutterInfo.RadiusSharpOffset">
            <summary>
            半径形状补偿
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CutterInfo.RadiusWearOffset">
            <summary>
            半径磨损补偿
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.CutterInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.FanucSysInfo">
            <summary>
            Fanuc的系统信息
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSysInfo.#ctor">
            <summary>
            实例化一个空对象
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSysInfo.#ctor(System.Byte[])">
            <summary>
            使用缓存数据来实例化一个对象
            </summary>
            <param name="buffer">原始的字节信息</param>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FanucSysInfo.TypeCode">
            <summary>
            CNC的类型代号
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FanucSysInfo.CncType">
            <summary>
            CNC的类型
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FanucSysInfo.MtType">
            <summary>
            Kind of M/T,
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FanucSysInfo.Series">
            <summary>
            系列信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FanucSysInfo.Version">
            <summary>
            版本号信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FanucSysInfo.Axes">
            <summary>
            Current controlled axes
            </summary>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.FileDirInfo">
            <summary>
            文件或是文件夹的信息
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FileDirInfo.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FileDirInfo.#ctor(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32)">
            <summary>
            使用原始字节来实例化对象
            </summary>
            <param name="byteTransform">字节变换对象</param>
            <param name="buffer">原始的字节信息</param>
            <param name="index">起始的索引信息</param>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FileDirInfo.IsDirectory">
            <summary>
            是否为文件夹，True就是文件夹，False就是文件
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FileDirInfo.Name">
            <summary>
            文件或是文件夹的名称
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FileDirInfo.LastModified">
            <summary>
            最后一次更新时间，当为文件的时候有效
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FileDirInfo.Size">
            <summary>
            文件的大小，当为文件的时候有效
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FileDirInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.FanucSeries0i">
            <summary>
            一个FANUC的机床通信类对象
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.#ctor(System.String,System.Int32)">
            <summary>
            根据IP及端口来实例化一个对象内容
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.FanucSeries0i.TextEncoding">
            <summary>
            获取或设置当前的文本的字符编码信息，如果你不清楚，可以调用<see cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadLanguage"/>方法来自动匹配。<br />
            Get or set the character encoding information of the current text. 
            If you are not sure, you can call the <see cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadLanguage"/> method to automatically match.
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ExtraOnDisconnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysInfo">
            <summary>
            获取fanuc机床设备的基本信息，型号，轴数量等等
            </summary>
            <returns>机床信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSpindleSpeedAndFeedRate">
            <summary>
            主轴转速及进给倍率<br />
            Spindle speed and feedrate override
            </summary>
            <returns>主轴转速及进给倍率</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemProgramCurrent">
            <summary>
            读取程序名及程序号<br />
            Read program name and program number
            </summary>
            <returns>程序名及程序号</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadLanguage">
            <summary>
            读取机床的语言设定信息，具体值的含义参照API文档说明<br />
            Read the language setting information of the machine tool, refer to the API documentation for the meaning of the specific values
            </summary>
            <remarks>此处举几个常用值 0: 英语 1: 日语 2: 德语 3: 法语 4: 中文繁体 6: 韩语 15: 中文简体 16: 俄语 17: 土耳其语</remarks>
            <returns>返回的语言代号</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemMacroValue(System.Int32)">
            <summary>
            读取宏变量，可以用来读取刀具号<br />
            Read macro variable, can be used to read tool number
            </summary>
            <param name="number">刀具号</param>
            <returns>读宏变量信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemMacroValue(System.Int32,System.Int32)">
            <summary>
            读取宏变量，可以用来读取刀具号<br />
            Read macro variable, can be used to read tool number
            </summary>
            <param name="number">宏变量地址</param>
            <param name="length">读取的长度信息</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteSystemMacroValue(System.Int32,System.Double[])">
            <summary>
            写宏变量，需要指定地址及写入的数据<br />
            Write macro variable, need to specify the address and write data
            </summary>
            <param name="number">地址</param>
            <param name="values">数据值</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterLengthShapeOffset(System.Int32,System.Double)">
            <summary>
            根据刀具号写入长度形状补偿，刀具号为1-24<br />
            Write length shape compensation according to the tool number, the tool number is 1-24
            </summary>
            <param name="cutter">刀具号，范围为1-24</param>
            <param name="offset">补偿值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterLengthWearOffset(System.Int32,System.Double)">
            <summary>
            根据刀具号写入长度磨损补偿，刀具号为1-24<br />
            Write length wear compensation according to the tool number, the tool number is 1-24
            </summary>
            <param name="cutter">刀具号，范围为1-24</param>
            <param name="offset">补偿值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterRadiusShapeOffset(System.Int32,System.Double)">
            <summary>
            根据刀具号写入半径形状补偿，刀具号为1-24<br />
            Write radius shape compensation according to the tool number, the tool number is 1-24
            </summary>
            <param name="cutter">刀具号，范围为1-24</param>
            <param name="offset">补偿值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterRadiusWearOffset(System.Int32,System.Double)">
            <summary>
            根据刀具号写入半径磨损补偿，刀具号为1-24<br />
            Write radius wear compensation according to the tool number, the tool number is 1-24
            </summary>
            <param name="cutter">刀具号，范围为1-24</param>
            <param name="offset">补偿值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadFanucAxisLoad">
            <summary>
            读取伺服负载<br />
            Read servo load
            </summary>
            <returns>轴负载</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysAllCoors">
            <summary>
            读取机床的坐标，包括机械坐标，绝对坐标，相对坐标<br />
            Read the coordinates of the machine tool, including mechanical coordinates, absolute coordinates, and relative coordinates
            </summary>
            <returns>数控机床的坐标信息，包括机械坐标，绝对坐标，相对坐标</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemAlarm">
            <summary>
            读取报警信息<br />
            Read alarm information
            </summary>
            <returns>机床的当前的所有的报警信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadTimeData(System.Int32)">
            <summary>
            读取fanuc机床的时间，0是开机时间，1是运行时间，2是切割时间，3是循环时间，4是空闲时间，返回秒为单位的信息<br />
            Read the time of the fanuc machine tool, 0 is the boot time, 1 is the running time, 2 is the cutting time, 
            3 is the cycle time, 4 is the idle time, and returns the information in seconds.
            </summary>
            <param name="timeType">读取的时间类型</param>
            <returns>秒为单位的结果</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAlarmStatus">
            <summary>
            读取报警状态信息<br />
            Read alarm status information
            </summary>
            <returns>报警状态数据</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysStatusInfo">
            <summary>
            读取系统的基本信息状态，工作模式，运行状态，是否急停等等操作<br />
            Read the basic information status of the system, working mode, running status, emergency stop, etc.
            </summary>
            <returns>结果信息数据</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadProgramList">
            <summary>
            读取设备的程序列表<br />
            Read the program list of the device
            </summary>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCutterInfos(System.Int32)">
            <summary>
            读取当前的刀具补偿信息<br />
            Read current tool compensation information
            </summary>
            <param name="cutterNumber">刀具数量</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCutterNumber">
            <summary>
            读取当前的正在使用的刀具号<br />
            Read the tool number currently in use
            </summary>
            <returns>刀具号信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadData(System.Int32,System.Int32,System.Int32)">
            <summary>
            读取寄存器的数据信息，需要传入寄存器的代码，起始地址，结束地址信息<br />
            To read the data information of the register, you need to pass in the code of the register, the start address, and the end address information
            </summary>
            <param name="code">寄存器代码</param>
            <param name="start">起始的地址</param>
            <param name="end">结束的地址</param>
            <returns>包含原始字节信息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteData(System.Int32,System.Int32,System.Byte[])">
            <summary>
            将原始字节的数据写入到指定的寄存器里，需要传入寄存器的代码，起始地址，原始的字节数据信息<br />
            To write the original byte data into the specified register, you need to pass in the code of the register, the starting address, and the original byte data information
            </summary>
            <param name="code">寄存器代码</param>
            <param name="start">起始的地址</param>
            <param name="data">等待写入的原始字节数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadPMCData(System.String,System.UInt16)">
            <summary>
            读取PMC数据，需要传入起始地址和结束地址，返回byte[]数据信息<br />
            To read PMC data, you need to pass in the start address and length, and return byte[] data information
            </summary>
            <remarks>
            地址支持，G,F,Y,X,A,R,T,K,C,D,E 地址，例如 G5
            </remarks>
            <param name="address">起始地址，地址支持，G,F,Y,X,A,R,T,K,C,D,E 地址，例如 G5</param>
            <param name="length">长度信息</param>
            <returns>读取结果</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WritePMCData(System.String,System.Byte[])">
            <summary>
            写入PMC数据，需要传入起始地址和，以及等待写入的byte[]数据信息<br />
            To write PMC data, you need to pass in the start address, as well as the byte[] data information waiting to be written
            </summary>
            <remarks>
            地址支持，G,F,Y,X,A,R,T,K,C,D,E 地址，例如 G5
            </remarks>
            <param name="address">起始地址，地址支持，G,F,Y,X,A,R,T,K,C,D,E 地址，例如 G5</param>
            <param name="value">等待写入的原始字节数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadDeviceWorkPiecesSize">
            <summary>
            读取工件尺寸<br />
            Read workpiece size
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentProgram">
            <summary>
            读取当前的程序内容，只能读取程序的片段，返回程序内容。<br />
            Read the current program content, only read the program fragments, and return the program content.
            </summary>
            <returns>程序内容</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.SetCurrentProgram(System.UInt16)">
            <summary>
            设置指定的程序号为当前的主程序，如果程序号不存在，返回错误信息<br />
            Set the specified program number as the current main program, if the program number does not exist, an error message will be returned
            </summary>
            <param name="programNum">程序号信息</param>
            <returns>是否设置成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.StartProcessing">
            <summary>
            启动加工程序<br />
            Start the processing program
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteProgramFile(System.String)">
            <summary>
            <b>[商业授权]</b> 将指定文件的NC加工程序，下载到数控机床里，返回是否下载成功<br />
            <b>[Authorization]</b> Download the NC machining program of the specified file to the CNC machine tool, and return whether the download is successful
            </summary>
            <remarks>
            程序文件的内容必须%开始，%结束，下面是一个非常简单的例子：<br />
            %<br />
            O0006<br />
            G90G10L2P1<br />
            M30<br />
            %
            </remarks>
            <param name="file">程序文件的路径</param>
            <returns>是否下载成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteProgramContent(System.String,System.Int32,System.String)">
            <summary>
            <b>[商业授权]</b> 将指定程序内容的NC加工程序，写入到数控机床里，返回是否下载成功<br />
            <b>[Authorization]</b> Download the NC machining program to the CNC machine tool, and return whether the download is successful
            </summary>
            <remarks>
            程序文件的内容必须%开始，%结束，下面是一个非常简单的例子：<br />
            %<br />
            O0006<br />
            G90G10L2P1<br />
            M30<br />
            %
            </remarks>
            <param name="program">程序内容信息</param>
            <param name="everyWriteSize">每次写入的长度信息</param>
            <param name="path">程序路径信息，默认为空，就是 //CNC_MEM/USER/PATH1/ 如果需要指定PATH2，需要输入 //CNC_MEM/USER/PATH2/</param>
            <returns>是否下载成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadProgram(System.Int32,System.String)">
            <summary>
            <b>[商业授权]</b> 读取指定程序号的程序内容，可以指定路径信息，路径默认为空就是主路径，//CNC_MEM/USER/PATH1/ ，也可以指定其他路径<br />
            <b>[Authorization]</b> Read the program content of the specified program number
            </summary>
            <param name="program">程序号</param>
            <param name="path">程序路径信息，默认为空，就是 //CNC_MEM/USER/PATH1/ 如果需要指定PATH2，需要输入 //CNC_MEM/USER/PATH2/</param>
            <returns>程序内容</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.DeleteProgram(System.Int32)">
            <summary>
            根据指定的程序号信息，删除当前的程序信息<br />
            According to the designated program number information, delete the current program information
            </summary>
            <param name="program">程序号</param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.DeleteFile(System.String)">
            <summary>
            根据指定的文件名来删除文件，如果是路径，则必须 '/' 结尾，如果是文件，则需要输入完整的文件名，例如：//CNC_MEM/USER/PATH2/O12<br />
            Delete the file according to the specified file name, if it is a path, it must end with '/', if it is a file, you need to enter the complete file name, for example: //CNC_MEM/USER/PATH2/O12
            </summary>
            <param name="fileName">文件名称，也可以是路径信息</param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentForegroundDir">
            <summary>
            读取当前程序的前台路径<br />
            Read the foreground path of the current program
            </summary>
            <returns>程序的路径信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAllDirectoryAndFile(System.String)">
            <summary>
            读取指定路径下的所有的子路径和文件的信息，路径信息，例如 "//CNC_MEM/USER/"
            </summary>
            <param name="path">路径信息，例如 "//CNC_MEM/USER/"</param>
            <returns>文件及路径信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAllDirectoryAndFileCount(System.String)">
            <summary>
            获取指定的路径里所有的文件夹数量和文件数量之和，路径示例：例如 "//CNC_MEM/USER/"， "//CNC_MEM/USER/PATH1/"
            </summary>
            <param name="path">路径信息，例如 "//CNC_MEM/USER/"</param>
            <returns>文件夹数量和文件数量之和</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.SetDeviceProgsCurr(System.String)">
            <summary>
            设置指定路径为当前路径<br />
            Set the specified path as the current path
            </summary>
            <param name="programName">程序名</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentDateTime">
            <summary>
            读取机床的当前时间信息<br />
            Read the current time information of the machine tool
            </summary>
            <returns>时间信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentProduceCount">
            <summary>
            读取当前的已加工的零件数量<br />
            Read the current number of processed parts
            </summary>
            <returns>已经加工的零件数量</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadExpectProduceCount">
            <summary>
            读取期望的加工的零件数量<br />
            Read the expected number of processed parts
            </summary>
            <returns>期望的加工的零件数量</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSpindleSpeedAndFeedRateAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSpindleSpeedAndFeedRate"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemProgramCurrentAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemProgramCurrent"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadLanguageAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadLanguage"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemMacroValueAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemMacroValue(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemMacroValueAsync(System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemMacroValue(System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCutterNumberAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCutterNumber"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteSystemMacroValueAsync(System.Int32,System.Double[])">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteSystemMacroValue(System.Int32,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterLengthSharpOffsetAsync(System.Int32,System.Double)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterLengthShapeOffset(System.Int32,System.Double)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterLengthWearOffsetAsync(System.Int32,System.Double)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterLengthWearOffset(System.Int32,System.Double)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterRadiusSharpOffsetAsync(System.Int32,System.Double)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterRadiusShapeOffset(System.Int32,System.Double)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterRadiusWearOffsetAsync(System.Int32,System.Double)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterRadiusWearOffset(System.Int32,System.Double)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadFanucAxisLoadAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadFanucAxisLoad"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysAllCoorsAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysAllCoors"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemAlarmAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemAlarm"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadTimeDataAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadTimeData(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAlarmStatusAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAlarmStatus"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysStatusInfoAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysStatusInfo"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadProgramListAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadProgramList"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCutterInfosAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCutterInfos(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadDataAsync(System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadData(System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteDataAsync(System.Int32,System.Int32,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteData(System.Int32,System.Int32,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadPMCDataAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadPMCData(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WritePMCDataAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WritePMCData(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadDeviceWorkPiecesSizeAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadDeviceWorkPiecesSize"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentForegroundDirAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentForegroundDir"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAllDirectoryAndFileAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAllDirectoryAndFile(System.String)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAllDirectoryAndFileCountAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAllDirectoryAndFileCount(System.String)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.SetDeviceProgsCurrAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.SetDeviceProgsCurr(System.String)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentDateTimeAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentDateTime"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentProduceCountAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentProduceCount"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadExpectProduceCountAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadExpectProduceCount"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentProgramAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentProgram"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.SetCurrentProgramAsync(System.UInt16)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.SetCurrentProgram(System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.StartProcessingAsync">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.StartProcessing"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteProgramFileAsync(System.String,System.Int32,System.String)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteProgramFile(System.String)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteProgramContentAsync(System.String,System.Int32,System.String)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteProgramContent(System.String,System.Int32,System.String)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadProgramAsync(System.Int32,System.String)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadProgram(System.Int32,System.String)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.DeleteProgramAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.DeleteProgram(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.DeleteFileAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.CNC.Fanuc.FanucSeries0i.DeleteFile(System.String)"/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildReadSingle(System.UInt16,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            构建读取一个命令的数据内容
            </summary>
            <param name="code">命令码</param>
            <param name="a">第一个参数内容</param>
            <param name="b">第二个参数内容</param>
            <param name="c">第三个参数内容</param>
            <param name="d">第四个参数内容</param>
            <param name="e">第五个参数内容</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildReadMulti(System.UInt16,System.UInt16,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            构建读取多个命令的数据内容
            </summary>
            <param name="mode">模式</param>
            <param name="code">命令码</param>
            <param name="a">第一个参数内容</param>
            <param name="b">第二个参数内容</param>
            <param name="c">第三个参数内容</param>
            <param name="d">第四个参数内容</param>
            <param name="e">第五个参数内容</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildWriteSingle(System.UInt16,System.UInt16,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            创建写入byte[]数组的报文信息
            </summary>
            <param name="mode">模式</param>
            <param name="code">命令码</param>
            <param name="a">第一个参数内容</param>
            <param name="b">第二个参数内容</param>
            <param name="c">第三个参数内容</param>
            <param name="d">第四个参数内容</param>
            <param name="data">等待写入的byte数组信息</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildWriteSingle(System.UInt16,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[])">
            <summary>
            创建写入单个double数组的报文信息
            </summary>
            <param name="code">功能码</param>
            <param name="a">第一个参数内容</param>
            <param name="b">第二个参数内容</param>
            <param name="c">第三个参数内容</param>
            <param name="d">第四个参数内容</param>
            <param name="data">等待写入的double数组信息</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildReadArray(System.Byte[][])">
            <summary>
            创建多个命令报文的总报文信息
            </summary>
            <param name="commands">报文命令的数组</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildReadProgramPre(System.Int32,System.String)">
            <summary>
            创建读取运行程序的报文信息
            </summary>
            <param name="program">程序号</param>
            <param name="path">程序路径信息</param>
            <returns>总报文</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ExtraContentArray(System.Byte[])">
            <summary>
            从机床返回的数据里解析出实际的数据内容，去除了一些多余的信息报文。
            </summary>
            <param name="content">返回的报文信息</param>
            <returns>解析之后的报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.SysAlarm">
            <summary>
            当前机床的报警信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAlarm.AlarmId">
            <summary>
            当前报警的ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAlarm.Type">
            <summary>
            当前的报警类型
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAlarm.Axis">
            <summary>
            报警的轴信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAlarm.Message">
            <summary>
            报警的消息
            </summary>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.SysAllCoors">
            <summary>
            系统的坐标信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAllCoors.Absolute">
            <summary>
            绝对坐标
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAllCoors.Machine">
            <summary>
            机械坐标
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAllCoors.Relative">
            <summary>
            相对坐标
            </summary>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.SysStatusInfo">
            <summary>
            系统状态信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Dummy">
            <summary>
            dummy
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.TMMode">
            <summary>
            T/M mode
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.WorkMode">
            <summary>
            selected automatic mode
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.RunStatus">
            <summary>
            running status
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Motion">
            <summary>
            axis, dwell status
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.MSTB">
            <summary>
            m, s, t, b status
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Emergency">
            <summary>
            emergency stop status，为1就是急停，为0就是正常
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Alarm">
            <summary>
            alarm status
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Edit">
            <summary>
            editting status
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.SysStatusInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Controls.UserBottle">
            <summary>
            瓶子控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.#ctor">
            <summary>
            实例化一个新的控件对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserBottle.Value">
            <summary>
            获取或设置瓶子的液位值。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserBottle.IsOpen">
            <summary>
            获取或设置瓶子是否处于打开的状态。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserBottle.BottleTag">
            <summary>
            获取或设置瓶子的标签信息，用于绘制在瓶子上的信息。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserBottle.HeadTag">
            <summary>
            获取或设置瓶子的备注信息，用于绘制在瓶子顶部的信息。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.WndProc(System.Windows.Forms.Message@)">
            <summary>
            重写消息处理机制
            </summary>
            <param name="m">系统消息</param>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重新绘制界面图形
            </summary>
            <param name="e">绘制消息</param>
        </member>
        <member name="F:HslCommunication.Controls.UserBottle.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserButton">
            <summary>
            一个自定义的按钮控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.#ctor">
            <summary>
            实例化一个按钮对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.UIText">
            <summary>
            设置或获取显示的文本
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.TextColor">
            <summary>
            设置或获取显示文本的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.CornerRadius">
            <summary>
            设置按钮的圆角
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.Selected">
            <summary>
            用来设置按钮的选中状态
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.ForeColor">
            <summary>
            已经弃用
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.Text">
            <summary>
            已经弃用
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.OriginalColor">
            <summary>
            按钮的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.EnableColor">
            <summary>
            按钮的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.ActiveColor">
            <summary>
            鼠标挪动时的活动颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.BorderVisiable">
            <summary>
            设置按钮的边框是否可见
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.CustomerInformation">
            <summary>
            存放用户需要保存的一些额外的信息
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.PerformClick">
            <summary>
            触发一次点击的事件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重绘数据区
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.OnClick(System.EventArgs)">
            <summary>
            点击按钮的触发事件
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.OnMouseClick(System.Windows.Forms.MouseEventArgs)">
            <summary>
            点击的时候触发事件
            </summary>
            <param name="e"></param>
        </member>
        <member name="F:HslCommunication.Controls.UserButton.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserClock">
            <summary>
            一个时钟控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserClock.#ctor">
            <summary>
            实例化一个时钟控件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.当前时间">
            <summary>
            获取时钟的当前时间
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.时钟指针颜色">
            <summary>
            获取或设置时钟指针的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.分钟指针颜色">
            <summary>
            获取或设置时钟分钟指针颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.秒钟指针颜色">
            <summary>
            获取或设置秒钟指针颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.显示文本">
            <summary>
            获取或设置时钟的个性化文本
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.显示文本字体">
            <summary>
            字体
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserClock.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重绘控件显示
            </summary>
            <param name="e"></param>
        </member>
        <member name="F:HslCommunication.Controls.UserClock.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserClock.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserClock.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserCurve">
            <summary>
            曲线控件对象
            </summary>
            <remarks>
            详细参照如下的博客:
            </remarks>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.#ctor">
            <summary>
            实例化一个曲线显示的控件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueMaxLeft">
            <summary>
            获取或设置图形的纵坐标的最大值，该值必须大于最小值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueMinLeft">
            <summary>
            获取或设置图形的纵坐标的最小值，该值必须小于最大值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueMaxRight">
            <summary>
            获取或设置图形的纵坐标的最大值，该值必须大于最小值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueMinRight">
            <summary>
            获取或设置图形的纵坐标的最小值，该值必须小于最大值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueSegment">
            <summary>
            获取或设置图形的纵轴分段数
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.IsAbscissaStrech">
            <summary>
            获取或设置所有的数据是否强制在一个界面里显示
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.StrechDataCountMax">
            <summary>
            获取或设置拉伸模式下的最大数据量
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.IsRenderDashLine">
            <summary>
            获取或设置虚线是否进行显示
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ColorLinesAndText">
            <summary>
            获取或设置坐标轴及相关信息文本的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ColorDashLines">
            <summary>
            获取或设置虚线的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.IntervalAbscissaText">
            <summary>
            获取或设置纵向虚线的分隔情况，单位为多少个数据
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.TextAddFormat">
            <summary>
            获取或设置实时数据新增时文本相对应于时间的格式化字符串，默认HH:mm
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.Title">
            <summary>
            获取或设置图标的标题信息
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetCurveText(System.String[])">
            <summary>
            设置曲线的横坐标文本，适用于显示一些固定的曲线信息
            </summary>
            <param name="descriptions">应该和曲线的点数一致</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetLeftCurve(System.String,System.Single[])">
            <summary>
            新增或修改一条指定关键字的左参考系曲线数据，需要指定数据，颜色随机，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data">曲线的具体数据</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetLeftCurve(System.String,System.Single[],System.Drawing.Color)">
            <summary>
            新增或修改一条指定关键字的左参考系曲线数据，需要指定数据，颜色，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
            <param name="lineColor"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetRightCurve(System.String,System.Single[])">
            <summary>
            新增或修改一条指定关键字的右参考系曲线数据，需要指定数据，颜色随机，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetRightCurve(System.String,System.Single[],System.Drawing.Color)">
            <summary>
            新增或修改一条指定关键字的右参考系曲线数据，需要指定数据，颜色，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
            <param name="lineColor"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetCurve(System.String,System.Boolean,System.Single[],System.Drawing.Color,System.Single)">
            <summary>
            新增或修改一条指定关键字的曲线数据，需要指定参考系及数据，颜色，线条宽度
            </summary>
            <param name="key">曲线关键字</param>
            <param name="isLeft">是否以左侧坐标轴为参照系</param>
            <param name="data">数据</param>
            <param name="lineColor">线条颜色</param>
            <param name="thickness">线条宽度</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.RemoveCurve(System.String)">
            <summary>
            移除指定关键字的曲线
            </summary>
            <param name="key">曲线关键字</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.RemoveAllCurve">
            <summary>
            移除指定关键字的曲线
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddCurveData(System.String,System.Single[],System.Boolean)">
            <summary>
            新增指定关键字曲线的一个数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">新增曲线的关键字</param>
            <param name="values"></param>
            <param name="isUpdateUI">是否刷新界面</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddCurveData(System.String,System.Single)">
            <summary>
            新增指定关键字曲线的一个数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">曲线的关键字</param>
            <param name="value">数据值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddCurveData(System.String,System.Single[])">
            <summary>
            新增指定关键字曲线的一组数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">曲线的关键字</param>
            <param name="values">数组值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddCurveData(System.String[],System.Single[])">
            <summary>
            新增指定关键字数组曲线的一组数据，注意该关键字的曲线必须存在，否则无效，一个数据对应一个数组
            </summary>
            <param name="keys">曲线的关键字数组</param>
            <param name="values">数组值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetCurveVisible(System.String,System.Boolean)">
            <summary>
            设置一条曲线是否是可见的，如果该曲线不存在，则无效。
            </summary>
            <param name="key">关键字</param>
            <param name="visible">是否可见</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetCurveVisible(System.String[],System.Boolean)">
            <summary>
            设置多条曲线是否是可见的，如果该曲线不存在，则无效。
            </summary>
            <param name="keys">关键字</param>
            <param name="visible">是否可见</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddLeftAuxiliary(System.Single)">
            <summary>
            新增一条左侧的辅助线，使用默认的文本颜色
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddLeftAuxiliary(System.Single,System.Drawing.Color)">
            <summary>
            新增一条左侧的辅助线，使用指定的颜色
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddLeftAuxiliary(System.Single,System.Drawing.Color,System.Single)">
            <summary>
            新增一条左侧的辅助线
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
            <param name="lineThickness">线条宽度</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddRightAuxiliary(System.Single)">
            <summary>
            新增一条右侧的辅助线，使用默认的文本颜色
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddRightAuxiliary(System.Single,System.Drawing.Color)">
            <summary>
            新增一条右侧的辅助线，使用指定的颜色
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddRightAuxiliary(System.Single,System.Drawing.Color,System.Single)">
            <summary>
            新增一条右侧的辅助线
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
            <param name="lineThickness">线条宽度</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.RemoveAuxiliary(System.Single)">
            <summary>
            移除所有的指定值的辅助曲线，包括左边的和右边的
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.RemoveAllAuxiliary">
            <summary>
            移除所有的辅助线
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserCurve.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.HslCurveItem">
            <summary>
            曲线数据对象
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.HslCurveItem.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.HslCurveItem.Data">
            <summary>
            数据
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.HslCurveItem.LineThickness">
            <summary>
            线条的宽度
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.HslCurveItem.LineColor">
            <summary>
            曲线颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.HslCurveItem.IsLeftFrame">
            <summary>
            是否左侧参考系，True为左侧，False为右侧
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.HslCurveItem.Visible">
            <summary>
            本曲线是否显示出来，默认为显示
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.AuxiliaryLine">
            <summary>
            辅助线对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.Value">
            <summary>
            实际的数据值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.PaintValue">
            <summary>
            实际的数据绘制
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.LineColor">
            <summary>
            辅助线的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.PenDash">
            <summary>
            辅助线的画笔资源
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.LineThickness">
            <summary>
            辅助线的宽度
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.LineTextBrush">
            <summary>
            辅助线文本的画刷
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.IsLeftFrame">
            <summary>
            是否左侧参考系，True为左侧，False为右侧
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.AuxiliaryLine.Dispose">
            <summary>
            释放内存信息
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserDrum">
            <summary>
            一个罐子形状的控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserDrum.#ctor">
            <summary>
            实例化一个罐子形状的控件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.DrumBackColor">
            <summary>
            获取或设置容器罐的背景色。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.BorderColor">
            <summary>
            获取或设置容器罐的边框色。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.Text">
            <summary>
            获取或设置显示的文本信息
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.ForeColor">
            <summary>
            获取或设置文本的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.TextBackColor">
            <summary>
            获取或设置文本的背景色
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserDrum.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserDrum.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserDrum.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserGaugeChart">
            <summary>
            仪表盘控件类
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserGaugeChart.#ctor">
            <summary>
            实例化一个仪表盘控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserGaugeChart.GetCenterPoint">
            <summary>
            获取中心点的坐标
            </summary>
            <returns></returns>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.GaugeBorder">
            <summary>
            获取或设置仪表盘的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.PointerColor">
            <summary>
            获取或设置指针的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.ValueStart">
            <summary>
            获取或设置数值的起始值，默认为0
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.ValueMax">
            <summary>
            获取或设置数值的最大值，默认为100
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.Value">
            <summary>
            获取或设置数值的当前值，应该处于最小值和最大值之间
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.ValueAlarmMax">
            <summary>
            获取或设置数值的上限报警值，设置为超过最大值则无上限报警
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.ValueAlarmMin">
            <summary>
            获取或设置数值的下限报警值，设置为超过最大值则无上限报警
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.SegmentCount">
            <summary>
            获取或设置仪表盘的分割段数，最小为2，最大1000
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.UnitText">
            <summary>
            获取或设置仪表盘的单位描述文本
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.IsTextUnderPointer">
            <summary>
            获取或设置文本是否是指针的下面
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.IsBigSemiCircle">
            <summary>
            通常情况，仪表盘不会大于半个圆，除非本属性设置为 True
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserGaugeChart.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserGaugeChart.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserGaugeChart.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserLantern">
            <summary>
            信号灯的控件类
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserLantern.#ctor">
            <summary>
            实例化一个信号灯控件的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserLantern.LanternBackground">
            <summary>
            获取或设置开关按钮的背景色
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserLantern.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserLantern.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserLantern.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserPieChart">
            <summary>
            一个饼图的控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.#ctor">
            <summary>
            实例化一个饼图的控件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPieChart.IsRenderPercent">
            <summary>
            是否显示百分比信息
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPieChart.IsRenderSmall">
            <summary>
            是否在图形上显示占比非常小的文本信息
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.GetRandomColor">
            <summary>
            随机生成颜色，该颜色相对于白色为深色颜色
            </summary>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.SetDataSource(HslCommunication.Core.HslPieItem[])">
            <summary>
            设置显示的数据源
            </summary>
            <param name="source">特殊的显示对象</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.SetDataSource(System.String[],System.Int32[])">
            <summary>
            根据名称和值进行数据源的显示，两者的长度需要一致
            </summary>
            <param name="names">名称</param>
            <param name="values">值</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="F:HslCommunication.Controls.UserPieChart.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserPipe">
            <summary>
            
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPipe.#ctor">
            <summary>
            管道控件信息
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.LineWidth">
            <summary>
            获取或设置管道线的宽度。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.IsActive">
            <summary>
            获取或设置管道线是否处于活动状态。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.ActiveColor">
            <summary>
            获取或设置管道活动状态的颜色。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.LineColor">
            <summary>
            获取或设置管道的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.MoveSpeed">
            <summary>
            获取或设置管道线的移动速度。该速度和管道的宽度有关
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.LinePoints">
            <summary>
            获取或设置管道线的坐标。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPipe.OnPaintMainWindow(System.Drawing.Graphics)">
            <summary>
            绘制
            </summary>
            <param name="g"></param>
        </member>
        <member name="F:HslCommunication.Controls.UserPipe.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPipe.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserPipe.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserSwitch">
            <summary>
            一个开关按钮类
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserSwitch.#ctor">
            <summary>
            实例化一个开关按钮对象
            </summary>
        </member>
        <member name="E:HslCommunication.Controls.UserSwitch.OnSwitchChanged">
            <summary>
            开关按钮发生变化的事件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserSwitch.SwitchBackground">
            <summary>
            获取或设置开关按钮的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserSwitch.SwitchForeground">
            <summary>
            获取或设置开关按钮的前景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserSwitch.SwitchStatus">
            <summary>
            获取或设置开关按钮的开合状态
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserSwitch.SwitchStatusDescription">
            <summary>
            获取或设置两种开关状态的文本描述，例如：new string[]{"Off","On"}
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserSwitch.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserSwitch.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserSwitch.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserVerticalProgress">
            <summary>
            一个直立的进度条控件，满足不同的情况使用
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserVerticalProgress.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.Cursor">
            <summary>
            获取或设置光标在控件上显示的信息
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.BackColor">
            <summary>
            获取或设置控件的背景颜色值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.ProgressColor">
            <summary>
            获取或设置进度的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.Max">
            <summary>
            进度条的最大值，默认为100
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.Value">
            <summary>
            当前进度条的值，不能大于最大值或小于0
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.IsTextRender">
            <summary>
            是否显示进度
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.BorderColor">
            <summary>
            设置进度条的边框颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.ValueChangeSpeed">
            <summary>
            设置进度变更的速度
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.UseAnimation">
            <summary>
            获取或设置进度条变化的时候是否采用动画效果
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.ProgressStyle">
            <summary>
            进度条的样式
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserVerticalProgress.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserVerticalProgress.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserVerticalProgress.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.ProgressStyle">
            <summary>
            进度条的样式
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.ProgressStyle.Vertical">
            <summary>
            竖直的，纵向的进度条
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.ProgressStyle.Horizontal">
            <summary>
            水平进度条
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Address.AllenBradleySLCAddress">
            <summary>
            罗克韦尔PLC的地址信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.AllenBradleySLCAddress.DataCode">
            <summary>
            获取或设置等待读取的数据的代码<br />
            Get or set the code of the data waiting to be read
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.AllenBradleySLCAddress.DbBlock">
            <summary>
            获取或设置PLC的DB块数据信息<br />
            Get or set PLC DB data information
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.AllenBradleySLCAddress.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.AllenBradleySLCAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.AllenBradleySLCAddress.ParseFrom(System.String)">
            <summary>
            从实际的罗克韦尔的地址里面解析出地址对象，例如 A9:0<br />
            Parse the address object from the actual Rockwell address, such as A9:0
            </summary>
            <param name="address">实际的地址数据信息，例如 A9:0</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.AllenBradleySLCAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            从实际的罗克韦尔的地址里面解析出地址对象，例如 A9:0<br />
            Parse the address object from the actual Rockwell address, such as A9:0
            </summary>
            <param name="address">实际的地址数据信息，例如 A9:0</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.CnetAddressData">
            <summary>
            Cnet协议的地址数据信息，未完成
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.CnetAddressData.DataCode">
            <summary>
            数据的代号，通常是 P,M,L,K,F,T,C,D,R,I,Q,W 等
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.CnetAddressData.DataType">
            <summary>
            数据的类型，通常是 X,B,W,D,L
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.CnetAddressData.ParseFrom(System.String)">
            <summary>
            从实际的PLC的地址里面解析出地址对象<br />
            Resolve the address object from the actual PLC address
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.CnetAddressData.ParseFrom(System.String,System.UInt16)">
            <summary>
            从实际的PLC的地址里面解析出地址对象<br />
            Resolve the address object from the actual PLC address
            </summary>
            <param name="address">PLC的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.DeviceAddressBase">
            <summary>
            所有设备通信类的地址基础类<br />
            Address basic class of all device communication classes
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.DeviceAddressBase.Address">
            <summary>
            获取或设置起始地址<br />
            Get or set the starting address
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.DeviceAddressBase.Parse(System.String)">
            <summary>
            解析字符串的地址<br />
            Parse the address of the string
            </summary>
            <param name="address">地址信息</param>
        </member>
        <member name="M:HslCommunication.Core.Address.DeviceAddressBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Address.DeviceAddressDataBase">
            <summary>
            设备地址数据的信息，通常包含起始地址，数据类型，长度<br />
            Device address data information, usually including the starting address, data type, length
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.DeviceAddressDataBase.AddressStart">
            <summary>
            数字的起始地址，也就是偏移地址<br />
            The starting address of the number, which is the offset address
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.DeviceAddressDataBase.Length">
            <summary>
            读取的数据长度，单位是字节还是字取决于设备方<br />
            The length of the data read, the unit is byte or word depends on the device side
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.DeviceAddressDataBase.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息<br />
            Parsing from the specified address information into real device address information
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.DeviceAddressDataBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Address.FanucPMCAddress">
            <summary>
            Fanuc的PMC地址对象信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FanucPMCAddress.DataCode">
            <summary>
            地址代号信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FanucPMCAddress.AddressEnd">
            <summary>
            结束的地址值
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.FanucPMCAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            根据实际的地址信息，解析出PMC地址信息
            </summary>
            <param name="address">地址信息，例如 R0, G5</param>
            <param name="length">读取的长度信息</param>
            <returns>PMC地址对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.FatekProgramAddress">
            <summary>
            永宏编程口的地址类对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FatekProgramAddress.DataCode">
            <summary>
            数据的类型
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.FatekProgramAddress.Parse(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.FatekProgramAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.FatekProgramAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            从普通的PLC的地址转换为HSL标准的地址信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>是否成功的地址结果</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.FujiCommandSettingTypeAddress">
            <summary>
            富士CommandSettingsType的协议信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FujiCommandSettingTypeAddress.DataCode">
            <summary>
            数据的代号信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FujiCommandSettingTypeAddress.AddressHeader">
            <summary>
            地址的头信息，缓存的情况
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiCommandSettingTypeAddress.Parse(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiCommandSettingTypeAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiCommandSettingTypeAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            从字符串地址解析fuji的实际地址信息，如果解析成功，则 <see cref="P:HslCommunication.OperateResult.IsSuccess"/> 为 True，取 <see cref="P:HslCommunication.OperateResult`1.Content"/> 值即可。
            </summary>
            <param name="address">字符串地址</param>
            <param name="length">读取的长度信息</param>
            <returns>是否解析成功</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.FujiSPBAddress">
            <summary>
            FujiSPB的地址信息，可以携带数据类型，起始地址操作
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FujiSPBAddress.TypeCode">
            <summary>
            数据的类型代码
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FujiSPBAddress.BitIndex">
            <summary>
            当是位地址的时候，用于标记的信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiSPBAddress.GetWordAddress">
            <summary>
            获取读写字数据的时候的地址信息内容
            </summary>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiSPBAddress.GetWriteBoolAddress">
            <summary>
            获取命令，写入字地址的某一位的命令内容
            </summary>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiSPBAddress.GetBitIndex">
            <summary>
            按照位为单位获取相关的索引信息
            </summary>
            <returns>位数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiSPBAddress.ParseFrom(System.String)">
            <summary>
            从实际的Fuji的地址里面解析出地址对象<br />
            Resolve the address object from the actual Fuji address
            </summary>
            <param name="address">富士的地址数据信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiSPBAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            从实际的Fuji的地址里面解析出地址对象<br />
            Resolve the address object from the actual Fuji address
            </summary>
            <param name="address">富士的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.FujiSPHAddress">
            <summary>
            富士SPH地址类对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FujiSPHAddress.TypeCode">
            <summary>
            数据的类型代码
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.FujiSPHAddress.BitIndex">
            <summary>
            当前地址的位索引信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiSPHAddress.ParseFrom(System.String)">
            <summary>
            从实际的Fuji的地址里面解析出地址对象<br />
            Resolve the address object from the actual Fuji address
            </summary>
            <param name="address">富士的地址数据信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.FujiSPHAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            从实际的Fuji的地址里面解析出地址对象<br />
            Resolve the address object from the actual Fuji address
            </summary>
            <param name="address">富士的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.GeSRTPAddress">
            <summary>
            GE的SRTP协议的地址内容，主要包含一个数据代码信息，还有静态的解析地址的方法<br />
            The address content of GE's SRTP protocol mainly includes a data code information, as well as a static method of address resolution
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.GeSRTPAddress.DataCode">
            <summary>
            获取或设置等待读取的数据的代码<br />
            Get or set the code of the data waiting to be read
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.GeSRTPAddress.Parse(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.GeSRTPAddress.ParseFrom(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.Address.GeSRTPAddress.ParseFrom(System.String,System.UInt16,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Address.GeSRTPAddress.ParseFrom(System.String,System.UInt16,System.Boolean)">
            <summary>
            从GE的地址里，解析出实际的带数据码的 <see cref="T:HslCommunication.Core.Address.GeSRTPAddress"/> 地址信息，起始地址会自动减一，和实际的地址相匹配
            </summary>
            <param name="address">实际的地址数据</param>
            <param name="length">读取的长度信息</param>
            <param name="isBit">是否位操作</param>
            <returns>是否成功的GE地址对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.KeyenceNanoAddress">
            <summary>
            基恩士上位链路协议的地址类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.KeyenceNanoAddress.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.KeyenceNanoAddress.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            通过指定的参数来实例化对象
            </summary>
            <param name="dataCode">数据类型</param>
            <param name="address">偏移地址</param>
            <param name="splits">切割但愿长度</param>
        </member>
        <member name="P:HslCommunication.Core.Address.KeyenceNanoAddress.DataCode">
            <summary>
            获取或设置等待读取的数据的代码<br />
            Get or set the code of the data waiting to be read
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.KeyenceNanoAddress.SplitLength">
            <summary>
            获取或设置读取的时候切割的数据长度信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.KeyenceNanoAddress.GetAddressStartFormat">
            <summary>
            获取地址的字符串表示方式
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.KeyenceNanoAddress.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.KeyenceNanoAddress.CalculateAddress(System.String)">
            <summary>
            位地址转换方法，101等同于10.1等同于10*16+1=161<br />
            Bit address conversion method, 101 is equivalent to 10.1 is equivalent to 10 * 16 + 1 = 161
            </summary>
            <param name="address">地址信息</param>
            <returns>实际的位地址信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.KeyenceNanoAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            解析出一个基恩士上位链路协议的地址信息
            </summary>
            <param name="address">字符串地址</param>
            <param name="length">长度信息</param>
            <returns>成功地址</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.McAddressData">
            <summary>
            三菱的数据地址表示形式<br />
            Mitsubishi's data address representation
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.McAddressData.McDataType">
            <summary>
            三菱的数据类型及地址信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息，默认是三菱的地址
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ParseMelsecFrom(System.String,System.UInt16)">
            <summary>
            从实际三菱的地址里面解析出我们需要的地址类型<br />
            Resolve the type of address we need from the actual Mitsubishi address
            </summary>
            <param name="address">三菱的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ParseMelsecRFrom(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.Address.McAddressData.ParseMelsecFrom(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ParseKeyenceFrom(System.String,System.UInt16)">
            <summary>
            从实际基恩士的地址里面解析出我们需要的地址信息<br />
            Resolve the address information we need from the actual Keyence address
            </summary>
            <param name="address">基恩士的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ParsePanasonicFrom(System.String,System.UInt16)">
            <summary>
            从实际松下的地址里面解析出
            </summary>
            <param name="address">松下的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.MelsecFxLinksAddress">
            <summary>
            三菱的FxLinks协议信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.MelsecFxLinksAddress.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.MelsecFxLinksAddress.TypeCode">
            <summary>
            当前的地址类型信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.MelsecFxLinksAddress.Parse(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.MelsecFxLinksAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.MelsecFxLinksAddress.ParseFrom(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Address.MelsecFxLinksAddress.Parse(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Address.MelsecFxLinksAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            从三菱FxLinks协议里面解析出实际的地址信息
            </summary>
            <param name="address">三菱的地址信息</param>
            <param name="length">读取的长度信息</param>
            <returns>解析结果信息</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.OmronFinsAddress">
            <summary>
            欧姆龙的Fins协议的地址类对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.OmronFinsAddress.BitCode">
            <summary>
            进行位操作的指令
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.OmronFinsAddress.WordCode">
            <summary>
            进行字操作的指令
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.OmronFinsAddress.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.OmronFinsAddress.ParseFrom(System.String)">
            <summary>
            从实际的欧姆龙的地址里面解析出地址对象<br />
            Resolve the address object from the actual Omron address
            </summary>
            <param name="address">欧姆龙的地址数据信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.OmronFinsAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            从实际的欧姆龙的地址里面解析出地址对象<br />
            Resolve the address object from the actual Omron address
            </summary>
            <param name="address">欧姆龙的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.S7AddressData">
            <summary>
            西门子的地址数据信息，主要包含数据代码，DB块，偏移地址（偏移地址对于不是CT类型而已，是位为单位的），当处于写入时，Length无效<br />
            Address data information of Siemens, mainly including data code, DB block, offset address, when writing, Length is invalid
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.S7AddressData.DataCode">
            <summary>
            获取或设置等待读取的数据的代码<br />
            Get or set the code of the data waiting to be read
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.S7AddressData.DbBlock">
            <summary>
            获取或设置PLC的DB块数据信息<br />
            Get or set PLC DB data information
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.CalculateAddressStarted(System.String,System.Boolean)">
            <summary>
            计算特殊的地址信息<br />
            Calculate Special Address information
            </summary>
            <param name="address">字符串地址 -> String address</param>
            <param name="isCT">是否是定时器和计数器的地址</param>
            <returns>实际值 -> Actual value</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.ParseFrom(System.String)">
            <summary>
            从实际的西门子的地址里面解析出地址对象<br />
            Resolve the address object from the actual Siemens address
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.ParseFrom(System.String,System.UInt16)">
            <summary>
            从实际的西门子的地址里面解析出地址对象<br />
            Resolve the address object from the actual Siemens address
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.VigorAddress">
            <summary>
            丰炜PLC的地址类对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.VigorAddress.DataCode">
            <summary>
            获取或设置等待读取的数据的代码<br />
            Get or set the code of the data waiting to be read
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.VigorAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.VigorAddress.ParseFrom(System.String,System.UInt16,System.Boolean)">
            <summary>
            从实际的丰炜PLC的地址里面解析出地址对象<br />
            Resolve the address object from the actual Vigor address
            </summary>
            <param name="address">丰炜的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <param name="isBit">是否是对位进行访问的</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.XinJEAddress">
            <summary>
            信捷内部协议的地址类对象<br />
            The address class object of Xinjie internal protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.XinJEAddress.#ctor">
            <summary>
            实例化一个默认的对象<br />
            instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.XinJEAddress.#ctor(System.Byte,System.Int32,System.Int32,System.Byte)">
            <summary>
            指定类型，地址偏移，临界地址来实例化一个对象<br />
            Specify the type, address offset, and critical address to instantiate an object
            </summary>
            <param name="dataCode">数据的类型代号</param>
            <param name="address">偏移地址信息</param>
            <param name="criticalAddress">临界地址信息</param>
            <param name="station">站号信息</param>
        </member>
        <member name="P:HslCommunication.Core.Address.XinJEAddress.DataCode">
            <summary>
            获取或设置等待读取的数据的代码<br />
            Get or set the code of the data waiting to be read
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.XinJEAddress.Station">
            <summary>
            获取或设置当前的站号信息<br />
            Get or set the current station number information
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.XinJEAddress.CriticalAddress">
            <summary>
            获取或设置协议升级时候的临界地址信息<br />
            Get or set the critical address information when the protocol is upgraded
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.XinJEAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.XinJEAddress.ParseFrom(System.String,System.UInt16,System.Byte)">
            <summary>
            从实际的信捷PLC的地址里面解析出地址对象<br />
            Resolve the address object from the actual XinJE address
            </summary>
            <param name="address">信捷的地址数据信息</param>
            <param name="length">读取的长度信息</param>
            <param name="defaultStation">默认的站号信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.XinJEAddress.ParseFrom(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Core.Address.XinJEAddress.ParseFrom(System.String,System.UInt16,System.Byte)"/>
        </member>
        <member name="T:HslCommunication.Core.Address.YokogawaLinkAddress">
            <summary>
            横河PLC的地址表示类<br />
            Yokogawa PLC address display class
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.YokogawaLinkAddress.DataCode">
            <summary>
            获取或设置等待读取的数据的代码<br />
            Get or set the code of the data waiting to be read
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.YokogawaLinkAddress.GetAddressBinaryContent">
            <summary>
            获取当前横河PLC的地址的二进制表述方式<br />
            Obtain the binary representation of the current Yokogawa PLC address
            </summary>
            <returns>二进制数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.YokogawaLinkAddress.Parse(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.YokogawaLinkAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.YokogawaLinkAddress.ParseFrom(System.String,System.UInt16)">
            <summary>
            从普通的PLC的地址转换为HSL标准的地址信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>是否成功的地址结果</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.ModbusAddress">
            <summary>
            Modbus协议地址格式，可以携带站号，功能码，地址信息<br />
            Modbus protocol address format, can carry station number, function code, address information
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.#ctor(System.String)">
            <summary>
            实例化一个对象，使用指定的地址初始化<br />
            Instantiate an object, initialize with the specified address
            </summary>
            <param name="address">传入的地址信息，支持富地址，例如s=2;x=3;100</param>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.#ctor(System.String,System.Byte)">
            <summary>
            实例化一个对象，使用指定的地址及功能码初始化<br />
            Instantiate an object and initialize it with the specified address and function code
            </summary>
            <param name="address">传入的地址信息，支持富地址，例如s=2;x=3;100</param>
            <param name="function">默认的功能码信息</param>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.#ctor(System.String,System.Byte,System.Byte)">
            <summary>
            实例化一个对象，使用指定的地址，站号，功能码来初始化<br />
            Instantiate an object, use the specified address, station number, function code to initialize
            </summary>
            <param name="address">传入的地址信息，支持富地址，例如s=2;x=3;100</param>
            <param name="station">站号信息</param>
            <param name="function">默认的功能码信息</param>
        </member>
        <member name="P:HslCommunication.Core.Address.ModbusAddress.Station">
            <summary>
            获取或设置当前地址的站号信息<br />
            Get or set the station number information of the current address
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.ModbusAddress.Function">
            <summary>
            获取或设置当前地址携带的功能码<br />
            Get or set the function code carried by the current address
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.AddressAdd(System.Int32)">
            <summary>
            地址偏移指定的位置，返回一个新的地址对象<br />
            The address is offset by the specified position and a new address object is returned
            </summary>
            <param name="value">数据值信息</param>
            <returns>新增后的地址信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.AddressAdd">
            <summary>
            地址偏移1，返回一个新的地址对象<br />
            The address is offset by 1 and a new address object is returned
            </summary>
            <returns>新增后的地址信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.GroupFileInfo">
            <summary>
            文件服务器的目录管理类的基本信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.GroupFileInfo.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileInfo.PathName">
            <summary>
            文件目录的名称信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileInfo.FileTotalSize">
            <summary>
            获取或设置文件的总大小
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileInfo.FileCount">
            <summary>
            获取或设置文件的总数量
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileInfo.LastModifyTime">
            <summary>
            获取或设置最后一次文件更新的时间，如果不存在文件，则为理论最小值
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileInfo.LastModifyFile">
            <summary>
            获取或设置最后一次更新的文件的基本信息，如果该目录不存在文件，则本值为空
            </summary>
        </member>
        <member name="M:HslCommunication.Core.GroupFileInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.MqttFileOperateInfo">
            <summary>
            当前MQTT服务器文件操作的对象类<br />
            Object class of current MQTT server file operation
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileOperateInfo.Operate">
            <summary>
            指示上传还是下载的操作，Upload上传，Download下载，Delete删除文件，DeleteFolder删除目录<br />
            Indicate upload or download operation, "Upload": upload, "Download": download, "Delete": delete file, "DeleteFolder": delete directory
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileOperateInfo.Groups">
            <summary>
            文件上传或是下载的类别
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileOperateInfo.FileNames">
            <summary>
            上传,下载或是删除的文件名<br />
            File name uploaded, downloaded or deleted
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileOperateInfo.TimeCost">
            <summary>
            当前操作消耗的时间<br />
            Time consumed by current operation
            </summary>
        </member>
        <member name="T:HslCommunication.Core.MqttFileMonitor">
            <summary>
            监控上传和下载文件的信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.MqttFileMonitor.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.MqttFileMonitor.Add(HslCommunication.Core.MqttFileMonitorItem)">
            <summary>
            增加一个文件监控的对象信息
            </summary>
            <param name="monitorItem">文件监控对象</param>
        </member>
        <member name="M:HslCommunication.Core.MqttFileMonitor.Remove(System.Int64)">
            <summary>
            根据唯一的ID信息，移除相关的文件监控对象
            </summary>
            <param name="uniqueId"></param>
        </member>
        <member name="M:HslCommunication.Core.MqttFileMonitor.GetMonitorItemsSnapShoot">
            <summary>
            获取当前所有的监控文件数据的快照
            </summary>
            <returns>文件监控列表</returns>
        </member>
        <member name="T:HslCommunication.Core.MqttFileMonitorItem">
            <summary>
            单个的监控文件对象，用来监控客户端的信息以及上传下载的速度
            </summary>
        </member>
        <member name="M:HslCommunication.Core.MqttFileMonitorItem.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.UniqueId">
            <summary>
            当前对象的唯一ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.EndPoint">
            <summary>
            当前对象的远程的IP及端口
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.ClientId">
            <summary>
            当前对象的客户端ID
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.UserName">
            <summary>
            当前对象的客户端用户名
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.Operate">
            <summary>
            当前的操作，Upload是上传，Download是下载
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.Groups">
            <summary>
            当前的操作的目录信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.FileName">
            <summary>
            当前操作的文件名
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.SpeedSecond">
            <summary>
            上传或下载的速度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.StartTime">
            <summary>
            当前操作的起始时间
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.LastUpdateTime">
            <summary>
            最后一次更新数据的时间
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.TotalSize">
            <summary>
            文件的总大小
            </summary>
        </member>
        <member name="P:HslCommunication.Core.MqttFileMonitorItem.LastUpdateProgress">
            <summary>
            上一次的更新数据时的进度信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.MqttFileMonitorItem.UpdateProgress(System.Int64,System.Int64)">
            <summary>
            更新当前的文件的状态
            </summary>
            <param name="progress">当前的进度信息</param>
            <param name="total">当前的总大小</param>
        </member>
        <member name="T:HslCommunication.Core.IMessage.AdsNetMessage">
            <summary>
            倍福的ADS协议的信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AdsNetMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AdsNetMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.AlienMessage">
            <summary>
            异形消息对象，用于异形客户端的注册包接收以及验证使用
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AlienMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AlienMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AlienMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.AllenBradleyMessage">
            <summary>
            用于和 AllenBradley PLC 交互的消息协议类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AllenBradleyMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AllenBradleyMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.AllenBradleySLCMessage">
            <summary>
            用于和 AllenBradley PLC 交互的消息协议类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AllenBradleySLCMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AllenBradleySLCMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.DcsNanJingAutoMessage">
            <summary>
            南京自动化研究所推出的DCS设备的消息类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.DcsNanJingAutoMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.DcsNanJingAutoMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.DcsNanJingAutoMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.DLT645Message">
            <summary>
            DLT 645协议的串口透传的消息类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.DLT645Message.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.DLT645Message.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.DLT645Message.PependedUselesByteLength(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.EFORTMessage">
            <summary>
            埃夫特机器人的消息对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.EFORTMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.EFORTMessagePrevious">
            <summary>
            旧版的机器人的消息类对象，保留此类为了实现兼容
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessagePrevious.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.EFORTMessagePrevious.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FanucRobotMessage">
            <summary>
            发那科机器人的网络消息类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FanucRobotMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FanucRobotMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FetchWriteMessage">
            <summary>
            西门子Fetch/Write消息解析协议
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FetchWriteMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FetchWriteMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FetchWriteMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FetchWriteMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FinsMessage">
            <summary>
            用于欧姆龙通信的Fins协议的消息解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FinsMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FinsMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FinsMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FujiCommandSettingTypeMessage">
            <summary>
            Fuji的CommandSettingType的消息类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FujiCommandSettingTypeMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FujiCommandSettingTypeMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FujiSPBMessage">
            <summary>
            富士SPB的消息内容
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FujiSPBMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FujiSPBMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FujiSPHMessage">
            <summary>
            富士SPH协议的报文消息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FujiSPHMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FujiSPHMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.GeSRTPMessage">
            <summary>
            通用电气公司的SRIP协议的消息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.GeSRTPMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.GeSRTPMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.HslMessage">
            <summary>
            本组件系统使用的默认的消息规则，说明解析和反解析规则的
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.HslMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.HslMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.HslMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.HslMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.IEC104Message">
            <summary>
            IEC104消息结构信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.IEC104Message.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.IEC104Message.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.INetMessage">
            <summary>
            本系统的消息类，包含了各种解析规则，数据信息提取规则<br />
            The message class of this system contains various parsing rules and data information extraction rules
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度，第一次接受数据的长度<br />
            Instruction length of the message header, the length of the first received data
            </summary>
            <remarks>
            当最高位字节的最高位为1时，第0和1位为校验的字符数量，第二高位字节表示结束字符之后的剩余字符长度信息，因为一个int占用四个字节，所以最多可以判断2个结束的字符信息。<br />
            When the highest bit of the highest-order byte is 1, the 0th and 1st bits are the number of characters to be checked, 
            and the second high-order byte indicates the length information of the remaining characters after the end character. 
            Because one int occupies four bytes, the maximum It is possible to judge the character information of 2 ends.
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度<br />
            Extract the length of the data to be received from the current header file
            </summary>
            <remarks>
            如果剩余字节的长度小于0，则表示消息头数据还没有接收完整，还需要接收一定的长度(返回值的绝对值)，然后再判断剩余字节长度是否小于0，直到结果大于等于0为止，最多判断的次数为16次，超过16次将返回失败<br />
            If the length of the remaining bytes is less than 0, it means that the message header data has not been received completely, and a certain length (absolute value of the return value) needs to be received, 
            and then it is judged whether the length of the remaining bytes is less than 0 until the result is greater than or equal to 0, 
            the maximum number of judgments is 16, more than 16 times will return failure
            </remarks>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:HslCommunication.Core.IMessage.INetMessage.PependedUselesByteLength(System.Byte[])">
            <summary>
            在接收头报文的时候，返回前置无效的报文头字节长度，默认为0，不处理<br />
            When receiving a header message, return the header byte length of the invalid header, the default is 0, and no processing is performed.
            </summary>
            <param name="headByte">接收到的头子节信息</param>
            <returns>头子节中无效的字节长度信息</returns>
        </member>
        <member name="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性<br />
            Check the legitimacy of the head subsection
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识<br />
            Get the message ID in the header subsection
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes">
            <summary>
            消息头字节<br />
            Message header byte
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes">
            <summary>
            消息内容字节<br />
            Message content byte
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.INetMessage.SendBytes">
            <summary>
            发送的字节信息<br />
            Byte information sent
            </summary>
        </member>
        <member name="T:HslCommunication.Core.IMessage.KukaVarProxyMessage">
            <summary>
            Kuka机器人的 KRC4 控制器中的服务器KUKAVARPROXY
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.KukaVarProxyMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.KukaVarProxyMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.KukaVarProxyMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.LsisFastEnetMessage">
            <summary>
            LSIS的PLC的FastEnet的消息定义
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.LsisFastEnetMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.LsisFastEnetMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.LsisFastEnetMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.LsisFastEnetMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage">
            <summary>
            三菱的A兼容1E帧ASCII协议解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage">
            <summary>
            三菱的A兼容1E帧协议解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage">
            <summary>
            基于MC协议的Qna兼容3E帧协议的ASCII通讯消息机制
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage">
            <summary>
            三菱的Qna兼容3E帧协议解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MemobusMessage">
            <summary>
            Memobus协议的消息定义
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MemobusMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MemobusMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.ModbusTcpMessage">
            <summary>
            Modbus-Tcp协议支持的消息解析类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.ModbusTcpMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.ModbusTcpMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.ModbusTcpMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.ModbusTcpMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.ModbusTcpMessage.IsCheckMessageId">
            <summary>
            获取或设置是否进行检查返回的消息ID和发送的消息ID是否一致，默认为true，也就是检查<br />
            Get or set whether to check whether the returned message ID is consistent with the sent message ID, the default is true, that is, check
            </summary>
        </member>
        <member name="T:HslCommunication.Core.IMessage.NetMessageBase">
            <summary>
            消息类的基类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.NetMessageBase.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.NetMessageBase.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.NetMessageBase.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.NetMessageBase.PependedUselesByteLength(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.PependedUselesByteLength(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.NetMessageBase.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.NetMessageBase.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.NetMessageBase.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.OpenProtocolMessage">
            <summary>
            OpenProtocol协议的消息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.OpenProtocolMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.OpenProtocolMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.S7Message">
            <summary>
            西门子S7协议的消息解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.S7Message.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.S7Message.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.S7Message.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.SAMMessage">
            <summary>
            SAM身份证通信协议的消息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.SAMMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SAMMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SAMMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.SAMMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.SiemensPPIMessage">
            <summary>
            西门子PPI的消息信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.SiemensPPIMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SiemensPPIMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.SpecifiedCharacterMessage">
            <summary>
            专门用于接收指定字符结尾的网络消息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SpecifiedCharacterMessage.#ctor(System.Byte)">
            <summary>
            使用固定的一个字符结尾作为当前的报文接收条件，来实例化一个对象<br />
            Instantiate an object using a fixed end of one character as the current message reception condition
            </summary>
            <param name="endCode">结尾的字符</param>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SpecifiedCharacterMessage.#ctor(System.Byte,System.Byte)">
            <summary>
            使用固定的两个个字符结尾作为当前的报文接收条件，来实例化一个对象<br />
            Instantiate an object using a fixed two-character end as the current message reception condition
            </summary>
            <param name="endCode1">第一个结尾的字符</param>
            <param name="endCode2">第二个结尾的字符</param>
        </member>
        <member name="P:HslCommunication.Core.IMessage.SpecifiedCharacterMessage.EndLength">
            <summary>
            获取或设置在结束字符之后剩余的固定字节长度，有些则还包含两个字节的校验码，这时该值就需要设置为2。<br />
            Gets or sets the remaining fixed byte length after the end character, and some also contain a two-byte check code. In this case, the value needs to be set to 2.
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.SpecifiedCharacterMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SpecifiedCharacterMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SpecifiedCharacterMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.TurckReaderMessage">
            <summary>
            图尔克Reader协议的消息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.TurckReaderMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.TurckReaderMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.TurckReaderMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.YokogawaLinkBinaryMessage">
            <summary>
            横河PLC的以太网的二进制协议
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.YokogawaLinkBinaryMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.YokogawaLinkBinaryMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IReadWriteDevice">
            <summary>
            用于读写的设备接口，相较于<see cref="T:HslCommunication.Core.IReadWriteNet"/>，增加了<see cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Byte[])"/>相关的方法，可以用来和设备进行额外的交互。<br />
            The device interface used for reading and writing. Compared with <see cref="T:HslCommunication.Core.IReadWriteNet"/>, 
            a method related to <see cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Byte[])"/> is added, which can be used for additional interaction with the device .
            </summary>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Byte[])">
            <summary>
            将当前的数据报文发送到设备去，具体使用什么通信方式取决于设备信息，然后从设备接收数据回来，并返回给调用者。<br />
            Send the current data message to the device, the specific communication method used depends on the device information, and then receive the data back from the device and return it to the caller.
            </summary>
            <param name="send">发送的完整的报文信息</param>
            <returns>接收的完整的报文信息</returns>
            <remarks>
            本方法用于实现本组件还未实现的一些报文功能，例如有些modbus服务器会有一些特殊的功能码支持，需要收发特殊的报文，详细请看示例
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            将多个数据报文按顺序发到设备，并从设备接收返回的数据内容，然后拼接成一个Byte[]信息，需要重写<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.UnpackResponseContent(System.Byte[],System.Byte[])"/>方法才能返回正确的结果。<br />
            Send multiple data packets to the device in sequence, and receive the returned data content from the device, and then splicing them into a Byte[] message, 
            you need to rewrite <see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.UnpackResponseContent(System.Byte[],System.Byte[])"/> method to return the correct result.
            </summary>
            <param name="send">发送的报文列表信息</param>
            <returns>是否接收成功</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServerAsync(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServerAsync(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="T:HslCommunication.Core.IReadWriteNet">
            <summary>
            所有的和设备或是交互类统一读写标准，公开了如何读写对方的一些api接口，并支持基于特性的读写操作<br />
            All unified read and write standards for devices and interaction classes, 
            expose how to read and write some API interfaces of each other, and support feature-based read and write operations
            </summary>
            <remarks>
            Modbus类，PLC类均实现了本接口，可以基于本接口实现统一所有的不同种类的设备的数据交互
            </remarks>
            <example>
            此处举例实现modbus，三菱，西门子三种设备的统一的数据交互
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\IReadWriteNet.cs" region="IReadWriteNetExample" title="IReadWriteNet示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.IReadWriteNet.LogNet">
            <summary>
            组件的日志工具，支持日志记录，只要实例化后，当前网络的基本信息，就以<see cref="F:HslCommunication.LogNet.HslMessageDegree.DEBUG"/>等级进行输出<br />
            The component's logging tool supports logging. As long as the instantiation of the basic network information, the output will be output at <see cref="F:HslCommunication.LogNet.HslMessageDegree.DEBUG"/>
            </summary>
            <remarks>
            只要实例化即可以记录日志，实例化的对象需要实现接口 <see cref="T:HslCommunication.LogNet.ILogNet"/> ，本组件提供了三个日志记录类，你可以实现基于 <see cref="T:HslCommunication.LogNet.ILogNet"/>  的对象。</remarks>
            <example>
            如下的实例化适用于所有的Network及其派生类，以下举两个例子，三菱的设备类及服务器类
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="LogNetExample1" title="LogNet示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="LogNetExample2" title="LogNet示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.IReadWriteNet.ConnectionId">
            <summary>
            当前连接的唯一ID号，默认为长度20的guid码加随机数组成，方便列表管理，也可以自己指定<br />
            The unique ID number of the current connection. The default is a 20-digit guid code plus a random number.
            </summary>
            <remarks>
            当前的唯一连接ID信息在DTU的模式下，将发挥关键作用，标记唯一的DTU ID
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)">
            <summary>
            批量读取字节数组信息，需要指定地址和长度，返回原始的字节数组<br />
            Batch read byte array information, need to specify the address and length, return the original byte array
            </summary>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])">
            <summary>
            写入原始的byte数组数据到指定的地址，返回是否写入成功<br />
            Write the original byte array data to the specified address, and return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取<see cref="T:System.Boolean"/>数组信息，需要指定地址和长度，返回<see cref="T:System.Boolean"/> 数组<br />
            Batch read <see cref="T:System.Boolean"/> array information, need to specify the address and length, return <see cref="T:System.Boolean"/> array
            </summary>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的 bool[] 数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)">
            <summary>
            读取单个的<see cref="T:System.Boolean"/>数据信息<br />
            Read a single <see cref="T:System.Boolean"/> data message
            </summary>
            <param name="address">数据地址</param>
            <returns>带有成功标识的 bool 值</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否成功<br />
            Batch write <see cref="T:System.Boolean"/> array data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)">
            <summary>
            写入单个的<see cref="T:System.Boolean"/>数据，返回是否成功<br />
            Write a single <see cref="T:System.Boolean"/> data, and return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)">
            <summary>
            读取16位的有符号的整型数据<br />
            Read 16-bit signed integer data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的short数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取16位的有符号整型数组<br />
            Read 16-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的数组长度</param>
            <returns>带有成功标识的short数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)">
            <summary>
            读取16位的无符号整型<br />
            Read 16-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的ushort数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取16位的无符号整型数组<br />
            Read 16-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的数组长度</param>
            <returns>带有成功标识的ushort数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)">
            <summary>
            读取32位的有符号整型<br />
            Read 32-bit signed integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的int数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取32位有符号整型数组<br />
            Read 32-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的int数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)">
            <summary>
            读取32位的无符号整型<br />
            Read 32-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的uint数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取32位的无符号整型数组<br />
            Read 32-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的uint数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)">
            <summary>
            读取64位的有符号整型<br />
            Read 64-bit signed integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的long数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)">
            <summary>
            读取64位的有符号整型数组<br />
            Read 64-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的long数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)">
            <summary>
            读取64位的无符号整型<br />
            Read 64-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的ulong数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)">
            <summary>
            读取64位的无符号整型的数组<br />
            Read 64-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)">
            <summary>
            读取单浮点数据<br />
            Read single floating point data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的float数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloat" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)">
            <summary>
            读取单浮点精度的数组<br />
            Read single floating point array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的float数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)">
            <summary>
            读取双浮点的数据<br />
            Read double floating point data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的double数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDouble" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)">
            <summary>
            读取双浮点数据的数组<br />
            Read double floating point data array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的double数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)">
            <summary>
            读取字符串数据，默认为最常见的ASCII编码<br />
            Read string data, default is the most common ASCII encoding
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的string数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <summary>
            使用指定的编码，读取字符串数据<br />
            Reads string data using the specified encoding
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <param name="encoding">指定的自定义的编码</param>
            <returns>带有成功标识的string数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadStringEncoding" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)">
            <summary>
            等待指定地址的<see cref="T:System.Boolean"/>值为指定的值，可以指定刷新数据的频率，等待的超时时间，如果超时时间为-1的话，则是无期限等待。<br />
            Waiting for the <see cref="T:System.Boolean"/> value of the specified address to be the specified value, you can specify the frequency of refreshing the data, 
            and the timeout time to wait. If the timeout time is -1, it is an indefinite wait.
            </summary>
            <param name="address">其实地址</param>
            <param name="waitValue">等待检测是值</param>
            <param name="readInterval">读取的频率</param>
            <param name="waitTimeout">等待的超时时间，如果超时时间为-1的话，则是无期限等待。</param>
            <returns>是否等待成功的结果对象，一旦通信失败，或是等待超时就返回失败。否则返回成功，并告知调用方等待了多久。</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)">
            <summary>
            等待指定地址的<see cref="T:System.Int16"/>值为指定的值，可以指定刷新数据的频率，等待的超时时间，如果超时时间为-1的话，则是无期限等待。<br />
            Waiting for the <see cref="T:System.Int16"/> value of the specified address to be the specified value, you can specify the frequency of refreshing the data, 
            and the timeout time to wait. If the timeout time is -1, it is an indefinite wait.
            </summary>
            <param name="address">其实地址</param>
            <param name="waitValue">等待检测是值</param>
            <param name="readInterval">读取的频率</param>
            <param name="waitTimeout">等待的超时时间，如果超时时间为-1的话，则是无期限等待。</param>
            <returns>是否等待成功的结果对象，一旦通信失败，或是等待超时就返回失败。否则返回成功，并告知调用方等待了多久。</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)">
            <summary>
            等待指定地址的<see cref="T:System.UInt16"/>值为指定的值，可以指定刷新数据的频率，等待的超时时间，如果超时时间为-1的话，则是无期限等待。<br />
            Waiting for the <see cref="T:System.UInt16"/> value of the specified address to be the specified value, you can specify the frequency of refreshing the data, 
            and the timeout time to wait. If the timeout time is -1, it is an indefinite wait.
            </summary>
            <param name="address">其实地址</param>
            <param name="waitValue">等待检测是值</param>
            <param name="readInterval">读取的频率</param>
            <param name="waitTimeout">等待的超时时间，如果超时时间为-1的话，则是无期限等待。</param>
            <returns>是否等待成功的结果对象，一旦通信失败，或是等待超时就返回失败。否则返回成功，并告知调用方等待了多久。</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            等待指定地址的<see cref="T:System.Int32"/>值为指定的值，可以指定刷新数据的频率，等待的超时时间，如果超时时间为-1的话，则是无期限等待。<br />
            Waiting for the <see cref="T:System.Int32"/> value of the specified address to be the specified value, you can specify the frequency of refreshing the data, 
            and the timeout time to wait. If the timeout time is -1, it is an indefinite wait.
            </summary>
            <param name="address">其实地址</param>
            <param name="waitValue">等待检测是值</param>
            <param name="readInterval">读取的频率</param>
            <param name="waitTimeout">等待的超时时间，如果超时时间为-1的话，则是无期限等待。</param>
            <returns>是否等待成功的结果对象，一旦通信失败，或是等待超时就返回失败。否则返回成功，并告知调用方等待了多久。</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)">
            <summary>
            等待指定地址的<see cref="T:System.UInt32"/>值为指定的值，可以指定刷新数据的频率，等待的超时时间，如果超时时间为-1的话，则是无期限等待。<br />
            Waiting for the <see cref="T:System.UInt32"/> value of the specified address to be the specified value, you can specify the frequency of refreshing the data, 
            and the timeout time to wait. If the timeout time is -1, it is an indefinite wait.
            </summary>
            <param name="address">其实地址</param>
            <param name="waitValue">等待检测是值</param>
            <param name="readInterval">读取的频率</param>
            <param name="waitTimeout">等待的超时时间，如果超时时间为-1的话，则是无期限等待。</param>
            <returns>是否等待成功的结果对象，一旦通信失败，或是等待超时就返回失败。否则返回成功，并告知调用方等待了多久。</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)">
            <summary>
            等待指定地址的<see cref="T:System.Int64"/>值为指定的值，可以指定刷新数据的频率，等待的超时时间，如果超时时间为-1的话，则是无期限等待。<br />
            Waiting for the <see cref="T:System.Int64"/> value of the specified address to be the specified value, you can specify the frequency of refreshing the data, 
            and the timeout time to wait. If the timeout time is -1, it is an indefinite wait.
            </summary>
            <param name="address">其实地址</param>
            <param name="waitValue">等待检测是值</param>
            <param name="readInterval">读取的频率</param>
            <param name="waitTimeout">等待的超时时间，如果超时时间为-1的话，则是无期限等待。</param>
            <returns>是否等待成功的结果对象，一旦通信失败，或是等待超时就返回失败。否则返回成功，并告知调用方等待了多久。</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)">
            <summary>
            等待指定地址的<see cref="T:System.UInt64"/>值为指定的值，可以指定刷新数据的频率，等待的超时时间，如果超时时间为-1的话，则是无期限等待。<br />
            Waiting for the <see cref="T:System.UInt64"/> value of the specified address to be the specified value, you can specify the frequency of refreshing the data, 
            and the timeout time to wait. If the timeout time is -1, it is an indefinite wait.
            </summary>
            <param name="address">其实地址</param>
            <param name="waitValue">等待检测是值</param>
            <param name="readInterval">读取的频率</param>
            <param name="waitTimeout">等待的超时时间，如果超时时间为-1的话，则是无期限等待。</param>
            <returns>是否等待成功的结果对象，一旦通信失败，或是等待超时就返回失败。否则返回成功，并告知调用方等待了多久。</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WaitAsync(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WaitAsync(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WaitAsync(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WaitAsync(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WaitAsync(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WaitAsync(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WaitAsync(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)">
            <summary>
            写入short数据，返回是否成功<br />
            Write short data, returns whether success
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])">
            <summary>
            写入short数组，返回是否成功<br />
            Write short array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)">
            <summary>
            写入ushort数据，返回是否成功<br />
            Write ushort data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])">
            <summary>
            写入ushort数组，返回是否成功<br />
            Write ushort array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)">
            <summary>
            写入int数据，返回是否成功<br />
            Write int data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])">
            <summary>
            写入int[]数组，返回是否成功<br />
            Write int array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)">
            <summary>
            写入uint数据，返回是否成功<br />
            Write uint data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])">
            <summary>
            写入uint[]数组，返回是否成功<br />
            Write uint array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)">
            <summary>
            写入long数据，返回是否成功<br />
            Write long data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])">
            <summary>
            写入long数组，返回是否成功<br />
            Write long array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)">
            <summary>
            写入ulong数据，返回是否成功<br />
            Write ulong data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])">
            <summary>
            写入ulong数组，返回是否成功<br />
            Write ulong array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)">
            <summary>
            写入float数据，返回是否成功<br />
            Write float data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloat" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])">
            <summary>
            写入float数组，返回是否成功<br />
            Write float array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)">
            <summary>
            写入double数据，返回是否成功<br />
            Write double data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDouble" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])">
            <summary>
            写入double数组，返回是否成功<br />
            Write double array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)">
            <summary>
            写入字符串信息，编码为ASCII<br />
            Write string information, encoded as ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)">
            <summary>
            写入字符串信息，需要指定的编码信息<br />
            Write string information, need to specify the encoding information
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="encoding">指定的编码信息</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)">
            <summary>
            写入指定长度的字符串信息，如果超出，就截断字符串，如果长度不足，那就补0操作，编码为ASCII<br />
            Write string information of the specified length. If it exceeds the value, the string is truncated. 
            If the length is not enough, it is filled with 0 and the encoding is ASCII.
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="length">字符串的长度</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString2" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <summary>
            写入指定长度的字符串信息，如果超出，就截断字符串，如果长度不足，那就补0操作，编码为指定的编码信息<br />
            Write string information of the specified length. If it exceeds the value, the string is truncated. If the length is not enough, 
            then the operation is complemented with 0 , you should specified the encoding information
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="length">字符串的长度</param>
            <param name="encoding">指定的编码信息</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString2" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)">
            <summary>
            读取自定义的数据类型，需要继承自IDataTransfer接口，返回一个新的类型的实例对象。<br />
            To read a custom data type, you need to inherit from the IDataTransfer interface and return an instance object of a new type.
            </summary>
            <typeparam name="T">自定义的类型</typeparam>
            <param name="address">起始地址</param>
            <returns>带有成功标识的自定义类型数据</returns>
            <remarks>
            需要是定义一个类，选择好相对于的ByteTransform实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:HslCommunication.IDataTransfer"/>接口
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerExample" title="ReadCustomer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)">
            <summary>
            读取自定义的数据类型，需要继承自IDataTransfer接口，传入一个实例，对这个实例进行赋值，并返回该实例的对象。<br />
            To read a custom data type, you need to inherit from the IDataTransfer interface, pass in an instance, 
            assign a value to this instance, and return the object of the instance.
            </summary>
            <typeparam name="T">自定义的类型</typeparam>
            <param name="address">起始地址</param>
            <param name="obj">实例</param>
            <returns>带有成功标识的自定义类型数据</returns>
            <remarks>
            需要是定义一个类，选择好相对于的ByteTransform实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:HslCommunication.IDataTransfer"/>接口
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerExample1" title="ReadCustomer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)">
            <summary>
            写入自定义类型的数据，该类型必须继承自IDataTransfer接口<br />
            Write data of a custom type, which must inherit from the IDataTransfer interface
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的<see cref="T:HslCommunication.IDataTransfer"/>实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:HslCommunication.IDataTransfer"/>接口
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteCustomerExample" title="WriteCustomer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Read``1">
            <summary>
            读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考api文档说明<br />
            Read the data content of the Hsl attribute. The attribute is <see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>, please refer to the api documentation for details.
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <returns>包含是否成功的结果对象</returns>
            <example>
            此处演示西门子的读取示例，先定义一个类，重点是将需要读取的数据，写入到属性的特性中去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ObjectDefineExample" title="特性实现示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadObjectExample" title="ReadObject示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)">
            <summary>
            写入支持Hsl特性的数据，返回是否写入成功，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考api文档说明<br />
            Write data that supports the Hsl attribute, and return whether the write was successful. The attribute is <see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>, please refer to the api documentation for details.
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <returns>包含是否成功的结果对象</returns>
            <example>
            此处演示西门子的读取示例，先定义一个类，重点是将需要读取的数据，写入到属性的特性中去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ObjectDefineExample" title="特性实现示例" />
            接下来就可以实现数据的写入了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteObjectExample" title="WriteObject示例" />
            </example>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)">
            <summary>
            读取结构体类型的数据，根据结构体自身的定义，读取原始字节数组，然后解析出实际的结构体数据，结构体需要实现<see cref="T:HslCommunication.Reflection.HslStructAttribute"/>特性
            </summary>
            <typeparam name="T">类型对象信息</typeparam>
            <param name="address">PLC的地址信息</param>
            <param name="length">读取的地址长度信息</param>
            <returns>如果成功，返回成功的结构体对象</returns>
            <example>
            此处演示西门子的读取示例，先定义一个类，重点是将需要读取的数据，写入到属性的特性中去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="StructDefine" title="特性实现示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadStructExample" title="ReadStruct示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadAsync(System.String,System.UInt16)">
            <summary>
            异步批量读取字节数组信息，需要指定地址和长度，返回原始的字节数组<br />
            Asynchronous batch read byte array information, need to specify the address and length, return the original byte array
            </summary>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Byte[])">
            <summary>
            异步写入原始的byte数组数据到指定的地址，返回是否写入成功<br />
            Asynchronously writes the original byte array data to the specified address, and returns whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteAsync" title="bytes类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String,System.UInt16)">
            <summary>
            异步批量读取<see cref="T:System.Boolean"/>数组信息，需要指定地址和长度，返回<see cref="T:System.Boolean"/> 数组<br />
            Asynchronously batch read <see cref="T:System.Boolean"/> array information, need to specify the address and length, return <see cref="T:System.Boolean"/> array
            </summary>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String)">
            <summary>
            异步读取单个的<see cref="T:System.Boolean"/>数据信息<br />
            Asynchronously read a single <see cref="T:System.Boolean"/> data message
            </summary>
            <param name="address">数据地址</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean[])">
            <summary>
            异步批量写入<see cref="T:System.Boolean"/>数组数据，返回是否成功<br />
            Asynchronously batch write <see cref="T:System.Boolean"/> array data, return success
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean)">
            <summary>
            异步批量写入<see cref="T:System.Boolean"/>数组数据，返回是否成功<br />
            Asynchronously batch write <see cref="T:System.Boolean"/> array data, return success
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String)">
            <summary>
            异步读取16位的有符号的整型数据<br />
            Asynchronously read 16-bit signed integer data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的short数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16Async" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String,System.UInt16)">
            <summary>
            异步读取16位的有符号整型数组<br />
            Asynchronously read 16-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的数组长度</param>
            <returns>带有成功标识的short数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16ArrayAsync" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String)">
            <summary>
            异步读取16位的无符号整型<br />
            Asynchronously read 16-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的ushort数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16Async" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String,System.UInt16)">
            <summary>
            异步读取16位的无符号整型数组<br />
            Asynchronously read 16-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的数组长度</param>
            <returns>带有成功标识的ushort数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16ArrayAsync" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String)">
            <summary>
            异步读取32位的有符号整型<br />
            Asynchronously read 32-bit signed integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的int数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32Async" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)">
            <summary>
            异步读取32位有符号整型数组<br />
            Asynchronously read 32-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的int数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32ArrayAsync" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String)">
            <summary>
            异步读取32位的无符号整型<br />
            Asynchronously read 32-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的uint数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32Async" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)">
            <summary>
            异步读取32位的无符号整型数组<br />
            Asynchronously read 32-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的uint数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32ArrayAsync" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String)">
            <summary>
            异步读取64位的有符号整型<br />
            Asynchronously read 64-bit signed integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的long数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64Async" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)">
            <summary>
            异步读取64位的有符号整型数组<br />
            Asynchronously read 64-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的long数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64ArrayAsync" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String)">
            <summary>
            异步读取64位的无符号整型<br />
            Asynchronously read 64-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的ulong数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64Async" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)">
            <summary>
            异步读取64位的无符号整型的数组<br />
            Asynchronously read 64-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的ulong数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64ArrayAsync" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String)">
            <summary>
            异步读取单浮点数据<br />
            Asynchronously read single floating point data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的float数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloatAsync" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)">
            <summary>
            异步读取单浮点精度的数组<br />
            Asynchronously read single floating point array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的float数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloatArrayAsync" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String)">
            <summary>
            异步读取双浮点的数据<br />
            Asynchronously read double floating point data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的double数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDoubleAsync" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)">
            <summary>
            异步读取双浮点数据的数组<br />
            Asynchronously read double floating point data array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的double数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDoubleArrayAsync" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16)">
            <summary>
            异步读取字符串数据，默认为最常见的ASCII编码<br />
            Asynchronously read string data, default is the most common ASCII encoding
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的string数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadStringAsync" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <summary>
            异步使用指定的编码，读取字符串数据<br />
            Asynchronously reads string data using the specified encoding
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <param name="encoding">指定的自定义的编码</param>
            <returns>带有成功标识的string数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadStringEncoding" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16)">
            <summary>
            异步写入short数据，返回是否成功<br />
            Asynchronously write short data, returns whether success
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16Async" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16[])">
            <summary>
            异步写入short数组，返回是否成功<br />
            Asynchronously write short array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16ArrayAsync" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16)">
            <summary>
            异步写入ushort数据，返回是否成功<br />
            Asynchronously write ushort data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16Async" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16[])">
            <summary>
            异步写入ushort数组，返回是否成功<br />
            Asynchronously write ushort array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16ArrayAsync" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32)">
            <summary>
            异步写入int数据，返回是否成功<br />
            Asynchronously write int data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32Async" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])">
            <summary>
            异步写入int[]数组，返回是否成功<br />
            Asynchronously write int array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32ArrayAsync" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32)">
            <summary>
            异步写入uint数据，返回是否成功<br />
            Asynchronously write uint data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32Async" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])">
            <summary>
            异步写入uint[]数组，返回是否成功<br />
            Asynchronously write uint array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32ArrayAsync" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64)">
            <summary>
            异步写入long数据，返回是否成功<br />
            Asynchronously write long data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64Async" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])">
            <summary>
            异步写入long数组，返回是否成功<br />
            Asynchronously write long array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64ArrayAsync" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64)">
            <summary>
            异步写入ulong数据，返回是否成功<br />
            Asynchronously write ulong data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64Async" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])">
            <summary>
            异步写入ulong数组，返回是否成功<br />
            Asynchronously write ulong array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64ArrayAsync" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single)">
            <summary>
            异步写入float数据，返回是否成功<br />
            Asynchronously write float data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloatAsync" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])">
            <summary>
            异步写入float数组，返回是否成功<br />
            Asynchronously write float array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloatArrayAsync" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double)">
            <summary>
            异步写入double数据，返回是否成功<br />
            Asynchronously write double data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDoubleAsync" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])">
            <summary>
            异步写入double数组，返回是否成功<br />
            Asynchronously write double array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDoubleArrayAsync" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String)">
            <summary>
            异步写入字符串信息，编码为ASCII<br />
            Asynchronously write string information, encoded as ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteStringAsync" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <summary>
            异步写入字符串信息，需要指定的编码信息<br />
            Asynchronously write string information, need to specify the encoding information
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="encoding">指定的编码信息</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteStringAsync" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32)">
            <summary>
            异步写入指定长度的字符串信息，如果超出，就截断字符串，如果长度不足，那就补0操作，编码为ASCII<br />
            Asynchronously write string information of the specified length. If it exceeds the value, the string is truncated. 
            If the length is not enough, it is filled with 0 and the encoding is ASCII.
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="length">字符串的长度</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)">
            <summary>
            异步写入指定长度的字符串信息，如果超出，就截断字符串，如果长度不足，那就补0操作，编码为指定的编码信息<br />
            Asynchronously write string information of the specified length. If it exceeds the value, the string is truncated. If the length is not enough, 
            then the operation is complemented with 0 , you should specified the encoding information
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="length">字符串的长度</param>
            <param name="encoding">指定的编码信息</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:HslCommunication.IDataTransfer"/>接口
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerAsyncExample" title="ReadCustomerAsync示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)"/>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:HslCommunication.IDataTransfer"/>接口
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerAsyncExample1" title="ReadCustomerAsync示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:HslCommunication.IDataTransfer"/>接口
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteCustomerAsyncExample" title="WriteCustomerAsync示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadAsync``1">
            <summary>
            异步读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考api文档说明<br />
            Asynchronously read the data content of the Hsl attribute. The attribute is <see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>, please refer to the api documentation for details.
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <returns>包含是否成功的结果对象</returns>
            <example>
            此处演示西门子的读取示例，先定义一个类，重点是将需要读取的数据，写入到属性的特性中去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ObjectDefineExample" title="特性实现示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadObjectAsyncExample" title="ReadObjectAsync示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteAsync``1(``0)">
            <summary>
            异步写入支持Hsl特性的数据，返回是否写入成功，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考api文档说明<br />
            Asynchronously write data that supports the Hsl attribute, and return whether the write was successful. The attribute is <see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>, please refer to the api documentation for details.
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <returns>包含是否成功的结果对象</returns>
            <example>
            此处演示西门子的读取示例，先定义一个类，重点是将需要读取的数据，写入到属性的特性中去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ObjectDefineExample" title="特性实现示例" />
            接下来就可以实现数据的写入了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteObjectAsyncExample" title="WriteObjectAsync示例" />
            </example>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadStructAsync``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="T:HslCommunication.Core.Net.IRobotNet">
            <summary>
            所有的机器人的统一读写标准，统一的基本的读写操作<br />
            Unified reading and writing standards for all robots, unified basic reading and writing operations
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.IRobotNet.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)">
            <summary>
            根据地址读取机器人的原始的字节数据信息<br />
            Read the robot's original byte data information according to the address
            </summary>
            <param name="address">指定的地址信息，对于某些机器人无效</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)">
            <summary>
            根据地址读取机器人的字符串的数据信息<br />
            Read the string data information of the robot based on the address
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.Byte[])">
            <summary>
            根据地址，来写入设备的相关的字节数据<br />
            According to the address, to write the device related bytes data
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.String)">
            <summary>
            根据地址，来写入设备相关的字符串数据<br />
            According to the address, to write the device related string data
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.ReadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.String)"/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkAlienClient">
            <summary>
            异形客户端的基类，提供了基础的异形操作<br />
            The base class of the profiled client provides the basic profiled operation
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.#ctor">
            <summary>
            默认的无参构造方法<br />
            The default parameterless constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作<br />
            An action performed when a new request is received
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAlienClient.IsResponseAck">
            <summary>
            是否返回响应，默认为 <c>True</c><br />
            The default is <c>True</c>
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAlienClient.IsCheckPwd">
            <summary>
            是否统一检查密码，如果每个会话需要自己检查密码，就需要设置为false<br />
            Whether to check the password uniformly, if each session needs to check the password by itself, it needs to be set to false
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkAlienClient.OnClientConnectedDelegate">
            <summary>
            客户上线的委托事件
            </summary>
            <param name="session">异形客户端的会话信息</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkAlienClient.OnClientConnected">
            <summary>
            当有服务器连接上来的时候触发<br />
            Triggered when a server is connected
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.GetResponse(System.Byte)">
            <summary>
            获取返回的命令信息
            </summary>
            <param name="status">状态</param>
            <returns>回发的指令信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.IsClientOnline(HslCommunication.Core.Net.AlienSession)">
            <summary>
            检测当前的DTU是否在线
            </summary>
            <param name="session">当前的会话信息</param>
            <returns>当前的会话是否在线</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.IsClientPermission(HslCommunication.Core.Net.AlienSession)">
            <summary>
            检测当前的dtu是否允许登录
            </summary>
            <param name="session">当前的会话信息</param>
            <returns>当前的id是否可允许登录</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.SetPassword(System.Byte[])">
            <summary>
            设置密码，需要传入长度为6的字节数组<br />
            To set the password, you need to pass in an array of bytes of length 6
            </summary>
            <param name="password">密码信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.SetTrustClients(System.String[])">
            <summary>
            设置可信任的客户端列表，传入一个DTU的列表信息<br />
            Set up the list of trusted clients, passing in the list information for a DTU
            </summary>
            <param name="clients">客户端列表</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.ToString">
            <inheritdoc/>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkAlienClient.StatusOk">
            <summary>
            状态登录成功
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkAlienClient.StatusLoginRepeat">
            <summary>
            重复登录
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkAlienClient.StatusLoginForbidden">
            <summary>
            禁止登录
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkAlienClient.StatusPasswodWrong">
            <summary>
            密码错误
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.GetMsgFromCode(System.String,System.Int32)">
            <summary>
            获取错误的描述信息
            </summary>
            <param name="dtu">dtu信息</param>
            <param name="code">错误码</param>
            <returns>错误信息</returns>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkAuthenticationServerBase">
            <summary>
            带登录认证的服务器类，可以对连接的客户端进行筛选，放行用户名密码正确的连接，并支持对在线的客户端对象进行管理<br />
            The server class with login authentication can filter connected clients, allow connections with correct username and password, and support online client objects
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.#ctor">
            <summary>
            实例化一个默认的对象<br />
            instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.SocketAcceptExtraCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端的socket登录的时候额外检查的信息，检查当前会话的用户名和密码<br />
            Additional check information when the client's socket logs in, check the username and password of the current session
            </summary>
            <param name="socket">套接字</param>
            <param name="endPoint">终结点</param>
            <returns>验证的结果</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.IsUseAccountCertificate">
            <summary>
            获取或设置是否对客户端启动账号认证<br />
            Gets or sets whether to enable account authentication on the client
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.AddAccount(System.String,System.String)">
            <summary>
            新增账户，如果想要启动账户登录，必须将<see cref="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.IsUseAccountCertificate"/>设置为<c>True</c>。<br />
            Add an account. If you want to activate account login, you must set <see cref="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.IsUseAccountCertificate"/> to <c> True </c>
            </summary>
            <param name="userName">账户名称</param>
            <param name="password">账户名称</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.DeleteAccount(System.String)">
            <summary>
            删除一个账户的信息<br />
            Delete an account's information
            </summary>
            <param name="userName">账户名称</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端登录后，在Ip信息的过滤后，然后触发本方法，进行后续的数据接收，处理，并返回相关的数据信息<br />
            When the client logs in, after filtering the IP information, this method is then triggered to perform subsequent data reception, 
            processing, and return related data information
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endPoint">终端节点</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.SocketAsyncCallBack(System.IAsyncResult)">
            <summary>
            从远程Socket异步接收的数据信息
            </summary>
            <param name="ar">异步接收的对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作，此处进行账户的安全验证<br />
            The operation performed when a new request is received, and the account security verification is performed here
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.SetTrustedIpAddress(System.Collections.Generic.List{System.String})">
            <summary>
            设置并启动受信任的客户端登录并读写，如果为null，将关闭对客户端的ip验证<br />
            Set and start the trusted client login and read and write, if it is null, the client's IP verification will be turned off
            </summary>
            <param name="clients">受信任的客户端列表</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.CheckIpAddressTrusted(System.String)">
            <summary>
            检查该Ip地址是否是受信任的<br />
            Check if the IP address is trusted
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <returns>是受信任的返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.GetTrustedClients">
            <summary>
            获取受信任的客户端列表<br />
            Get a list of trusted clients
            </summary>
            <returns>字符串数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.CloseAction">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.OnlineCount">
            <summary>
            获取在线的客户端的数量<br />
            Get the number of clients online
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkAuthenticationServerBase.OnClientStatusChangeDelegate">
            <summary>
            表示客户端状态变化的委托信息<br />
            Delegate information representing the state change of the client
            </summary>
            <param name="server">当前的服务器对象信息</param>
            <param name="session">当前的客户端会话信息</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkAuthenticationServerBase.OnClientOnline">
            <summary>
            当客户端上线时候的触发的事件<br />
            Event triggered when the client goes online
            </summary>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkAuthenticationServerBase.OnClientOffline">
            <summary>
            当客户端下线时候的触发的事件<br />
            Event triggered when the client goes offline
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.GetOnlineSessions">
            <summary>
            获取当前所有在线的客户端信息，包括IP地址和端口号信息<br />
            Get all current online client information, including IP address and port number information
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.ActiveTimeSpan">
            <summary>
            获取或设置两次数据交互时的最小时间间隔，默认为24小时。如果超过该设定的时间不进行数据交互，服务器就会强制断开当前的连接操作。<br />
            Get or set the minimum time interval between two data interactions, the default is 24 hours. 
            If the data exchange is not performed for more than the set time, the server will forcibly disconnect the current connection operation.
            </summary>
            <remarks>
            举例设置为10分钟，ActiveTimeSpan = TimeSpan.FromMinutes( 10 );
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.AddClient(HslCommunication.Core.Net.AppSession)">
            <summary>
            新增一个在线的客户端信息<br />
            Add an online client information
            </summary>
            <param name="session">会话内容</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.RemoveClient(HslCommunication.Core.Net.AppSession,System.String)">
            <summary>
            移除一个在线的客户端信息<br />
            Remove an online client message
            </summary>
            <param name="session">会话内容</param>
            <param name="reason">下线的原因</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing">是否托管对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkBase">
            <summary>
            本系统所有网络类的基类，该类为抽象类，无法进行实例化，如果想使用里面的方法来实现自定义的网络通信，请通过继承使用。<br />
            The base class of all network classes in this system. This class is an abstract class and cannot be instantiated. 
            If you want to use the methods inside to implement custom network communication, please use it through inheritance.
            </summary>
            <remarks>
            本类提供了丰富的底层数据的收发支持，包含<see cref="T:HslCommunication.Core.IMessage.INetMessage"/>消息的接收，<c>MQTT</c>以及<c>Redis</c>,<c>websocket</c>协议的实现
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.#ctor">
            <summary>
            实例化一个NetworkBase对象，令牌的默认值为空，都是0x00<br />
            Instantiate a NetworkBase object, the default value of the token is empty, both are 0x00
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkBase.LogNet">
            <summary>
            组件的日志工具，支持日志记录，只要实例化后，当前网络的基本信息，就以<see cref="F:HslCommunication.LogNet.HslMessageDegree.DEBUG"/>等级进行输出<br />
            The component's logging tool supports logging. As long as the instantiation of the basic network information, the output will be output at <see cref="F:HslCommunication.LogNet.HslMessageDegree.DEBUG"/>
            </summary>
            <remarks>
            只要实例化即可以记录日志，实例化的对象需要实现接口 <see cref="T:HslCommunication.LogNet.ILogNet"/> ，本组件提供了三个日志记录类，你可以实现基于 <see cref="T:HslCommunication.LogNet.ILogNet"/>  的对象。</remarks>
            <example>
            如下的实例化适用于所有的Network及其派生类，以下举两个例子，三菱的设备类及服务器类
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="LogNetExample1" title="LogNet示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="LogNetExample2" title="LogNet示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkBase.Token">
            <summary>
            网络类的身份令牌，在hsl协议的模式下会有效，在和设备进行通信的时候是无效的<br />
            Network-type identity tokens will be valid in the hsl protocol mode and will not be valid when communicating with the device
            </summary>
            <remarks>
            适用于Hsl协议相关的网络通信类，不适用于设备交互类。
            </remarks>
            <example>
            此处以 <see cref="T:HslCommunication.Enthernet.NetSimplifyServer"/> 服务器类及 <see cref="T:HslCommunication.Enthernet.NetSimplifyClient"/> 客户端类的令牌设置举例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="TokenClientExample" title="Client示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="TokenServerExample" title="Server示例" />
            </example>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkBase.fileCacheSize">
            <summary>
            文件传输的时候的缓存大小，直接影响传输的速度，值越大，传输速度越快，越占内存，默认为100K大小<br />
            The size of the cache during file transfer directly affects the speed of the transfer. The larger the value, the faster the transfer speed and the more memory it takes. The default size is 100K.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.Receive(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Int32,System.Action{System.Int64,System.Int64})">
            <summary>
            接收固定长度的字节数组，允许指定超时时间，默认为60秒，当length大于0时，接收固定长度的数据内容，当length小于0时，buffer长度的缓存数据<br />
            Receiving a fixed-length byte array, allowing a specified timeout time. The default is 60 seconds. When length is greater than 0, 
            fixed-length data content is received. When length is less than 0, random data information of a length not greater than 2048 is received.
            </summary>
            <param name="socket">网络通讯的套接字<br />Network communication socket</param>
            <param name="buffer">等待接收的数据缓存信息</param>
            <param name="offset">开始接收数据的偏移地址</param>
            <param name="length">准备接收的数据长度，当length大于0时，接收固定长度的数据内容，当length小于0时，接收不大于1024长度的随机数据信息</param>
            <param name="timeOut">单位：毫秒，超时时间，默认为60秒，如果设置小于0，则不检查超时时间</param>
            <param name="reportProgress">当前接收数据的进度报告，有些协议支持传输非常大的数据内容，可以给与进度提示的功能</param>
            <returns>包含了字节数据的结果类</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.Receive(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Action{System.Int64,System.Int64})">
            <summary>
            接收固定长度的字节数组，允许指定超时时间，默认为60秒，当length大于0时，接收固定长度的数据内容，当length小于0时，接收不大于2048长度的随机数据信息<br />
            Receiving a fixed-length byte array, allowing a specified timeout time. The default is 60 seconds. When length is greater than 0, 
            fixed-length data content is received. When length is less than 0, random data information of a length not greater than 2048 is received.
            </summary>
            <param name="socket">网络通讯的套接字<br />Network communication socket</param>
            <param name="length">准备接收的数据长度，当length大于0时，接收固定长度的数据内容，当length小于0时，接收不大于1024长度的随机数据信息</param>
            <param name="timeOut">单位：毫秒，超时时间，默认为60秒，如果设置小于0，则不检查超时时间</param>
            <param name="reportProgress">当前接收数据的进度报告，有些协议支持传输非常大的数据内容，可以给与进度提示的功能</param>
            <returns>包含了字节数据的结果类</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveCommandLineFromSocket(System.Net.Sockets.Socket,System.Byte,System.Int32)">
            <summary>
            接收一行命令数据，需要自己指定这个结束符，默认超时时间为60秒，也即是60000，单位是毫秒<br />
            To receive a line of command data, you need to specify the terminator yourself. The default timeout is 60 seconds, which is 60,000, in milliseconds.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endCode">结束符信息</param>
            <param name="timeout">超时时间，默认为60000，单位为毫秒，也就是60秒</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveCommandLineFromSocket(System.Net.Sockets.Socket,System.Byte,System.Byte,System.Int32)">
            <summary>
            接收一行命令数据，需要自己指定这个结束符，默认超时时间为60秒，也即是60000，单位是毫秒<br />
            To receive a line of command data, you need to specify the terminator yourself. The default timeout is 60 seconds, which is 60,000, in milliseconds.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endCode1">结束符1信息</param>
            <param name="endCode2">结束符2信息</param>
            /// <param name="timeout">超时时间，默认无穷大，单位毫秒</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveByMessage(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <summary>
            接收一条完整的 <seealso cref="T:HslCommunication.Core.IMessage.INetMessage"/> 数据内容，需要指定超时时间，单位为毫秒。 <br />
            Receive a complete <seealso cref="T:HslCommunication.Core.IMessage.INetMessage"/> data content, Need to specify a timeout period in milliseconds
            </summary>
            <param name="socket">网络的套接字</param>
            <param name="timeOut">超时时间，单位：毫秒</param>
            <param name="netMessage">消息的格式定义</param>
            <param name="reportProgress">接收消息的时候的进度报告</param>
            <returns>带有是否成功的byte数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.Send(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            发送消息给套接字，直到完成的时候返回，经过测试，本方法是线程安全的。<br />
            Send a message to the socket until it returns when completed. After testing, this method is thread-safe.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="data">字节数据</param>
            <returns>发送是否成功的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.Send(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送消息给套接字，直到完成的时候返回，经过测试，本方法是线程安全的。<br />
            Send a message to the socket until it returns when completed. After testing, this method is thread-safe.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="data">字节数据</param>
            <param name="offset">偏移的位置信息</param>
            <param name="size">发送的数据总数</param>
            <returns>发送是否成功的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.String,System.Int32)">
            <summary>
            创建一个新的socket对象并连接到远程的地址，默认超时时间为10秒钟，需要指定ip地址以及端口号信息<br />
            Create a new socket object and connect to the remote address. The default timeout is 10 seconds. You need to specify the IP address and port number.
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.String,System.Int32,System.Int32)">
            <summary>
            创建一个新的socket对象并连接到远程的地址，需要指定ip地址以及端口号信息，还有超时时间，单位是毫秒<br />
            To create a new socket object and connect to a remote address, you need to specify the IP address and port number information, and the timeout period in milliseconds
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="timeOut">连接的超时时间</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.Net.IPEndPoint,System.Int32,System.Net.IPEndPoint)">
            <summary>
            创建一个新的socket对象并连接到远程的地址，需要指定远程终结点，超时时间（单位是毫秒），如果需要绑定本地的IP或是端口，传入 local对象<br />
            To create a new socket object and connect to the remote address, you need to specify the remote endpoint, 
            the timeout period (in milliseconds), if you need to bind the local IP or port, pass in the local object
            </summary>
            <param name="endPoint">连接的目标终结点</param>
            <param name="timeOut">连接的超时时间</param>
            <param name="local">如果需要绑定本地的IP地址，就需要设置当前的对象</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReadStream(System.IO.Stream,System.Byte[])">
            <summary>
            读取流中的数据到缓存区，读取的长度需要按照实际的情况来判断<br />
            Read the data in the stream to the buffer area. The length of the read needs to be determined according to the actual situation.
            </summary>
            <param name="stream">数据流</param>
            <param name="buffer">缓冲区</param>
            <returns>带有成功标志的读取数据长度</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.WriteStream(System.IO.Stream,System.Byte[])">
            <summary>
            将缓冲区的数据写入到流里面去<br />
            Write the buffer data to the stream
            </summary>
            <param name="stream">数据流</param>
            <param name="buffer">缓冲区</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CheckRemoteToken(System.Byte[])">
            <summary>
            检查当前的头子节信息的令牌是否是正确的，仅用于某些特殊的协议实现<br />
            Check whether the token of the current header subsection information is correct, only for some special protocol implementations
            </summary>
            <param name="headBytes">头子节数据</param>
            <returns>令牌是验证成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendBaseAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Byte[])">
            <summary>
            [自校验] 发送字节数据并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-check] Send the byte data and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="headCode">头指令</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendBytesAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.Byte[])">
            <summary>
            [自校验] 发送字节数据并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-check] Send the byte data and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStringAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String)">
            <summary>
            [自校验] 直接发送字符串数据并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-checking] Send string data directly and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStringAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String[])">
            <summary>
            [自校验] 直接发送字符串数组并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-check] Send string array directly and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="sends">发送的字符串数组</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendAccountAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String,System.String)">
            <summary>
            [自校验] 直接发送字符串数组并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-check] Send string array directly and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="name">用户名</param>
            <param name="pwd">密码</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveAndCheckBytes(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 接收一条完整的同步数据，包含头子节和内容字节，基础的数据，如果结果异常，则结束通讯<br />
            [Self-checking] Receive a complete synchronization data, including header subsection and content bytes, basic data, if the result is abnormal, the communication ends
            </summary>
            <param name="socket">套接字</param>
            <param name="timeOut">超时时间设置，如果为负数，则不检查超时</param>
            <returns>包含是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException">result</exception>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveStringContentFromSocket(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 从网络中接收一个字符串数据，如果结果异常，则结束通讯<br />
            [Self-checking] Receive a string of data from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">套接字</param>
            <param name="timeOut">接收数据的超时时间</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveStringArrayContentFromSocket(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 从网络中接收一个字符串数组，如果结果异常，则结束通讯<br />
            [Self-check] Receive an array of strings from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">套接字</param>
            <param name="timeOut">接收数据的超时时间</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveBytesContentFromSocket(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 从网络中接收一串字节数据，如果结果异常，则结束通讯<br />
            [Self-checking] Receive a string of byte data from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">套接字的网络</param>
            <param name="timeout">超时时间</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveLong(System.Net.Sockets.Socket)">
            <summary>
            从网络中接收Long数据<br />
            Receive Long data from the network
            </summary>
            <param name="socket">套接字网络</param>
            <returns>long数据结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendLong(System.Net.Sockets.Socket,System.Int64)">
            <summary>
            将long数据发送到套接字<br />
            Send long data to the socket
            </summary>
            <param name="socket">网络套接字</param>
            <param name="value">long数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStreamToSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <summary>
            发送一个流的所有数据到指定的网络套接字，需要指定发送的数据长度，支持按照百分比的进度报告<br />
            Send all the data of a stream to the specified network socket. You need to specify the length of the data to be sent. It supports the progress report in percentage.
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">内存流</param>
            <param name="receive">发送的数据长度</param>
            <param name="report">进度报告的委托</param>
            <param name="reportByPercent">进度报告是否按照百分比报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.WriteStreamFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <summary>
            从套接字中接收所有的数据然后写入到指定的流当中去，需要指定数据的长度，支持按照百分比进行进度报告<br />
            Receives all data from the socket and writes it to the specified stream. The length of the data needs to be specified, and progress reporting is supported in percentage.
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">数据流</param>
            <param name="totalLength">所有数据的长度</param>
            <param name="report">进度报告</param>
            <param name="reportByPercent">进度报告是否按照百分比</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnectAsync(System.Net.IPEndPoint,System.Int32,System.Net.IPEndPoint)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.Net.IPEndPoint,System.Int32,System.Net.IPEndPoint)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnectAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnectAsync(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveAsync(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.Receive(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveAsync(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Int32,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.Receive(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Int32,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveCommandLineFromSocketAsync(System.Net.Sockets.Socket,System.Byte,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveCommandLineFromSocket(System.Net.Sockets.Socket,System.Byte,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveCommandLineFromSocketAsync(System.Net.Sockets.Socket,System.Byte,System.Byte,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveCommandLineFromSocket(System.Net.Sockets.Socket,System.Byte,System.Byte,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendAsync(System.Net.Sockets.Socket,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.Send(System.Net.Sockets.Socket,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendAsync(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.Send(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveByMessageAsync(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveByMessage(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReadStreamAsync(System.IO.Stream,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReadStream(System.IO.Stream,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.WriteStreamAsync(System.IO.Stream,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.WriteStream(System.IO.Stream,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveLongAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveLong(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendLongAsync(System.Net.Sockets.Socket,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendLong(System.Net.Sockets.Socket,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendBaseAndCheckReceiveAsync(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendBaseAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendBytesAndCheckReceiveAsync(System.Net.Sockets.Socket,System.Int32,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendBytesAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStringAndCheckReceiveAsync(System.Net.Sockets.Socket,System.Int32,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendStringAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStringAndCheckReceiveAsync(System.Net.Sockets.Socket,System.Int32,System.String[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendStringAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendAccountAndCheckReceiveAsync(System.Net.Sockets.Socket,System.Int32,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendAccountAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveAndCheckBytesAsync(System.Net.Sockets.Socket,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveAndCheckBytes(System.Net.Sockets.Socket,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveStringContentFromSocketAsync(System.Net.Sockets.Socket,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveStringContentFromSocket(System.Net.Sockets.Socket,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveStringArrayContentFromSocketAsync(System.Net.Sockets.Socket,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveStringArrayContentFromSocket(System.Net.Sockets.Socket,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveBytesContentFromSocketAsync(System.Net.Sockets.Socket,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveBytesContentFromSocket(System.Net.Sockets.Socket,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStreamToSocketAsync(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendStreamToSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.WriteStreamFromSocketAsync(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.WriteStreamFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveWebSocketPayload(System.Net.Sockets.Socket)">
            <summary>
            从socket接收一条完整的websocket数据，返回<see cref="T:HslCommunication.WebSocket.WebSocketMessage"/>的数据信息<br />
            Receive a complete websocket data from the socket, return the data information of the <see cref="T:HslCommunication.WebSocket.WebSocketMessage"/>
            </summary>
            <param name="socket">网络套接字</param>
            <returns>包含websocket消息的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveFrameWebSocketPayload(System.Net.Sockets.Socket)">
            <summary>
            从socket接收一条<see cref="T:HslCommunication.WebSocket.WebSocketMessage"/>片段数据，返回<see cref="T:HslCommunication.WebSocket.WebSocketMessage"/>的数据信息和是否最后一条数据内容<br />
            Receive a piece of <see cref = "T:HslCommunication.WebSocket.WebSocketMessage" /> fragment data from the socket, return the data information of <see cref = "T:HslCommunication.WebSocket.WebSocketMessage" /> and whether the last data content
            </summary>
            <param name="socket">网络套接字</param>
            <returns>包含websocket消息的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveWebSocketPayloadAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveWebSocketPayload(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveFrameWebSocketPayloadAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveFrameWebSocketPayload(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttRemainingLength(System.Net.Sockets.Socket)">
            <summary>
            基于MQTT协议，从网络套接字中接收剩余的数据长度<br />
            Receives the remaining data length from the network socket based on the MQTT protocol
            </summary>
            <param name="socket">网络套接字</param>
            <returns>网络中剩余的长度数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttMessage(System.Net.Sockets.Socket,System.Int32,System.Action{System.Int64,System.Int64})">
            <summary>
            接收一条完整的MQTT协议的报文信息，包含控制码和负载数据<br />
            Receive a message of a completed MQTT protocol, including control code and payload data
            </summary>
            <param name="socket">网络套接字</param>
            <param name="timeOut">超时时间</param>
            <param name="reportProgress">进度报告，第一个参数是已完成的字节数量，第二个参数是总字节数量。</param>
            <returns>结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttStream(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Int32,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <summary>
            使用MQTT协议从socket接收指定长度的字节数组，然后全部写入到流中，可以指定进度报告<br />
            Use the MQTT protocol to receive a byte array of specified length from the socket, and then write all of them to the stream, and you can specify a progress report
            </summary>
            <param name="socket">网络套接字</param>
            <param name="stream">数据流</param>
            <param name="fileSize">数据大小</param>
            <param name="timeOut">超时时间</param>
            <param name="reportProgress">进度报告，第一个参数是已完成的字节数量，第二个参数是总字节数量。</param>
            <param name="aesCryptography">AES数据加密对象，如果为空，则不进行加密</param>
            <param name="cancelToken">取消的令牌操作信息</param>
            <returns>是否操作成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendMqttStream(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Int32,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <summary>
            使用MQTT协议将流中的数据读取到字节数组，然后都写入到socket里面，可以指定进度报告，主要用于将文件发送到网络。<br />
            Use the MQTT protocol to read the data in the stream into a byte array, and then write them all into the socket. 
            You can specify a progress report, which is mainly used to send files to the network.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="stream">流</param>
            <param name="fileSize">总的数据大小</param>
            <param name="timeOut">超时信息</param>
            <param name="reportProgress">进度报告，第一个参数是已完成的字节数量，第二个参数是总字节数量。</param>
            <param name="aesCryptography">AES数据加密对象，如果为空，则不进行加密</param>
            <param name="cancelToken">取消操作的令牌信息</param>
            <returns>是否操作成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendMqttFile(System.Net.Sockets.Socket,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <summary>
            使用MQTT协议将一个文件发送到网络上去，需要指定文件名，保存的文件名，可选指定文件描述信息，进度报告<br />
            To send a file to the network using the MQTT protocol, you need to specify the file name, the saved file name, 
            optionally specify the file description information, and the progress report
            </summary>
            <param name="socket">网络套接字</param>
            <param name="filename">文件名称</param>
            <param name="servername">对方接收后保存的文件名</param>
            <param name="filetag">文件的描述信息</param>
            <param name="reportProgress">进度报告，第一个参数是已完成的字节数量，第二个参数是总字节数量。</param>
            <param name="aesCryptography">AES数据加密对象，如果为空，则不进行加密</param>
            <param name="cancelToken">用户取消的令牌</param>
            <returns>是否操作成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendMqttFile(System.Net.Sockets.Socket,System.IO.Stream,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <summary>
            使用MQTT协议将一个数据流发送到网络上去，需要保存的文件名，可选指定文件描述信息，进度报告<br />
            Use the MQTT protocol to send a data stream to the network, the file name that needs to be saved, optional file description information, progress report
            </summary>
            <param name="socket">网络套接字</param>
            <param name="stream">数据流</param>
            <param name="servername">对方接收后保存的文件名</param>
            <param name="filetag">文件的描述信息</param>
            <param name="reportProgress">进度报告，第一个参数是已完成的字节数量，第二个参数是总字节数量。</param>
            <param name="aesCryptography">AES数据加密对象，如果为空，则不进行加密</param>
            <param name="cancelToken">用户取消的令牌信息</param>
            <returns>是否操作成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttFile(System.Net.Sockets.Socket,System.Object,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <summary>
            使用MQTT协议从网络接收字节数组，然后写入文件或流中，支持进度报告<br />
            Use MQTT protocol to receive byte array from the network, and then write it to file or stream, support progress report
            </summary>
            <param name="socket">网络套接字</param>
            <param name="source">文件名或是流</param>
            <param name="reportProgress">进度报告</param>
            <param name="aesCryptography">AES数据加密对象，如果为空，则不进行加密</param>
            <param name="cancelToken">用户取消的令牌信息</param>
            <returns>是否操作成功，如果成功，携带文件基本信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttRemainingLengthAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttRemainingLength(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttMessageAsync(System.Net.Sockets.Socket,System.Int32,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttMessage(System.Net.Sockets.Socket,System.Int32,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttStreamAsync(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Int32,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttStream(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Int32,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendMqttStreamAsync(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Int32,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendMqttStream(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Int32,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendMqttFileAsync(System.Net.Sockets.Socket,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendMqttFile(System.Net.Sockets.Socket,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendMqttFileAsync(System.Net.Sockets.Socket,System.IO.Stream,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.SendMqttFile(System.Net.Sockets.Socket,System.IO.Stream,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttFileAsync(System.Net.Sockets.Socket,System.Object,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttFile(System.Net.Sockets.Socket,System.Object,System.Action{System.Int64,System.Int64},HslCommunication.Core.Security.AesCryptography,HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveRedisCommandString(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            接收一行基于redis协议的字符串的信息，需要指定固定的长度<br />
            Receive a line of information based on the redis protocol string, you need to specify a fixed length
            </summary>
            <param name="socket">网络套接字</param>
            <param name="length">字符串的长度</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveRedisCommand(System.Net.Sockets.Socket)">
            <summary>
            从网络接收一条完整的redis报文的消息<br />
            Receive a complete redis message from the network
            </summary>
            <param name="socket">网络套接字</param>
            <returns>接收的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveRedisCommandStringAsync(System.Net.Sockets.Socket,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveRedisCommandString(System.Net.Sockets.Socket,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveRedisCommandAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveRedisCommand(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveHslMessage(System.Net.Sockets.Socket)">
            <summary>
            接收一条hsl协议的数据信息，自动解析，解压，解码操作，获取最后的实际的数据，接收结果依次为暗号，用户码，负载数据<br />
            Receive a piece of hsl protocol data information, automatically parse, decompress, and decode operations to obtain the last actual data. 
            The result is a opCode, user code, and payload data in order.
            </summary>
            <param name="socket">网络套接字</param>
            <returns>接收结果，依次为暗号，用户码，负载数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveHslMessageAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveHslMessage(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveVigorMessage(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            从Socket接收一条VigorPLC的消息数据信息，指定套接字对象及超时时间<br />
            Receive a message data information of VigorPLC from Socket, specify socket object and timeout time
            </summary>
            <param name="socket">套接字对象</param>
            <param name="timeOut">超时时间</param>
            <returns>接收的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveVigorMessageAsync(System.Net.Sockets.Socket,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkBase.ReceiveVigorMessage(System.Net.Sockets.Socket,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.DeleteFileByName(System.String)">
            <summary>
            删除一个指定的文件，如果文件不存在，直接返回 <c>True</c>，如果文件存在则直接删除，删除成功返回 <c>True</c>，如果发生了异常，返回<c>False</c><br />
            Delete a specified file, if the file does not exist, return <c>True</c> directly, if the file exists, delete it directly, 
            if the deletion is successful, return <c>True</c>, if an exception occurs, return <c> False</c>
            </summary>
            <param name="fileName">完整的文件路径</param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkConnectedCip">
            <summary>
            基于连接的CIP协议的基类
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.ExtraOnDisconnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkConnectedCip.SessionHandle">
            <inheritdoc cref="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.SessionHandle"/>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkConnectedCip.OTConnectionId">
            <summary>
            O -> T Network Connection ID
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkConnectedCip.TOConnectionId">
            <summary>
            T -> O Network Connection ID
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.PackCommandService(System.Byte[][])">
            <summary>
            将多个的CIP命令打包成一个服务的命令
            </summary>
            <param name="cip">CIP命令列表</param>
            <returns>服务命令</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.GetLargeForwardOpen(System.UInt16)">
            <summary>
            获取数据通信的前置打开命令，不同的PLC的信息不一样。
            </summary>
            <param name="connectionID">连接的ID信息</param>
            <returns>原始命令数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.GetLargeForwardClose">
            <summary>
            获取数据通信的后置关闭命令，不同的PLC的信息不一样。
            </summary>
            <returns>原始命令数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkConnectedCip.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据解析出真实的数据内容，结果内容分别是原始字节数据，数据类型代码，是否有很多的数据<br />
            The real data content is parsed from the data fed back by the PLC. The result content is the original byte data, 
            the data type code, and whether there is a lot of data.
            </summary>
            <param name="response">PLC的反馈数据</param>
            <param name="isRead">是否是返回的操作</param>
            <returns>带有结果标识的最终数据</returns>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDataServerBase">
            <summary>
            所有虚拟的数据服务器的基类，提供了基本的数据读写，存储加载的功能方法，具体的字节读写需要继承重写。<br />
            The base class of all virtual data servers provides basic methods for reading and writing data and storing and loading. 
            Specific byte reads and writes need to be inherited and override.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.#ctor">
            <summary>
            实例化一个默认的数据服务器的对象<br />
            Instantiate an object of the default data server
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.SaveDataPool(System.String)">
            <summary>
            将本系统的数据池数据存储到指定的文件<br />
            Store the data pool data of this system to the specified file
            </summary>
            <param name="path">指定文件的路径</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.LoadDataPool(System.String)">
            <summary>
            从文件加载数据池信息<br />
            Load datapool information from a file
            </summary>
            <param name="path">文件路径</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.LoadFromBytes(System.Byte[])">
            <summary>
            从字节数据加载数据信息，需要进行重写方法<br />
            Loading data information from byte data requires rewriting method
            </summary>
            <param name="content">字节数据</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.SaveToBytes">
            <summary>
            将数据信息存储到字节数组去，需要进行重写方法<br />
            To store data information into a byte array, a rewrite method is required
            </summary>
            <returns>所有的内容</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.IReadWriteNet.ConnectionId"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.EnableWrite">
            <summary>
            获取或设置当前的服务器是否允许远程客户端进行写入数据操作，默认为<c>True</c><br />
            Gets or sets whether the current server allows remote clients to write data, the default is <c>True</c>
            </summary>
            <remarks>
            如果设置为<c>False</c>，那么所有远程客户端的操作都会失败，直接返回错误码或是关闭连接。
            </remarks>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDataServerBase.DataReceivedDelegate">
            <summary>
            当接收到来自客户的数据信息时触发的对象，该数据可能来自tcp或是串口<br />
            The object that is triggered when receiving data information from the customer, the data may come from tcp or serial port
            </summary>
            <param name="sender">触发的服务器对象</param>
            <param name="source">消息的来源对象</param>
            <param name="data">实际的数据信息</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkDataServerBase.OnDataReceived">
            <summary>
            接收到数据的时候就触发的事件，示例详细参考API文档信息<br />
            An event that is triggered when data is received
            </summary>
            <remarks>
            事件共有三个参数，sender指服务器本地的对象，例如 <see cref="T:HslCommunication.ModBus.ModbusTcpServer"/> 对象，source 指会话对象，网口对象为 <see cref="T:HslCommunication.Core.Net.AppSession"/>，
            串口为<see cref="T:System.IO.Ports.SerialPort"/> 对象，需要根据实际判断，data 为收到的原始数据 byte[] 对象
            </remarks>
            <example>
            我们以Modbus的Server为例子，其他的虚拟服务器同理，因为都集成自本服务器对象
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDataServerBaseSample.cs" region="OnDataReceivedSample" title="数据接收触发的示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.RaiseDataReceived(System.Object,System.Byte[])">
            <summary>
            触发一个数据接收的事件信息<br />
            Event information that triggers a data reception
            </summary>
            <param name="source">数据的发送方</param>
            <param name="receive">接收数据信息</param>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDataServerBase.DataSendDelegate">
            <summary>
            数据发送的时候委托<br />
            Show DataSend To PLC
            </summary>
            <param name="sender">数据发送对象</param>
            <param name="data">数据内容</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkDataServerBase.OnDataSend">
            <summary>
            数据发送的时候就触发的事件<br />
            Events that are triggered when data is sent
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.RaiseDataSend(System.Byte[])">
            <summary>
            触发一个数据发送的事件信息<br />
            Event information that triggers a data transmission
            </summary>
            <param name="send">数据内容</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.GetSerialMessageLogText(System.Byte[])">
            <summary>
            获取串口模式下消息的日志记录方式，可以继承重写。<br />
            Get the logging method of messages in serial mode, which can be inherited and rewritten.
            </summary>
            <param name="data">原始数据</param>
            <returns>消息</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.WordLength">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength"/>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDataServerBase.LogMsgFormatBinary">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkDoubleBase.LogMsgFormatBinary"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.GetWordLength(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDeviceBase.GetWordLength(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.GetNewNetMessage">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.GetNewNetMessage"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.SocketAsyncCallBack(System.IAsyncResult)">
            <summary>
            从远程Socket异步接收的数据信息
            </summary>
            <param name="ar">异步接收的对象</param>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.SerialReceiveAtleastTime">
            <summary>
            获取或设置串口模式下，接收一条数据最短的时间要求，当设备发送的数据非常慢的时候，或是分割发送数据的时候，就需要将本值设置的大一点，默认为20ms<br />
            Get or set the shortest time required to receive a piece of data in serial port mode. 
            When the data sent by the device is very slow, or when the data is divided and sent, you need to set this value to a larger value, the default is 20ms
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.StartSerialSlave(System.String)">
            <summary>
            启动串口的从机服务，使用默认的参数进行初始化串口，9600波特率，8位数据位，无奇偶校验，1位停止位<br />
            Start the slave service of serial, initialize the serial port with default parameters, 9600 baud rate, 8 data bits, no parity, 1 stop bit
            </summary>
            <remarks>
            com支持格式化的方式，例如输入 COM3-9600-8-N-1，COM5-19200-7-E-2，其中奇偶校验的字母可选，N:无校验，O：奇校验，E:偶校验，停止位可选 0, 1, 2, 1.5 四种选项
            </remarks>
            <param name="com">串口信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.StartSerialSlave(System.String,System.Int32)">
            <summary>
            启动串口的从机服务，使用默认的参数进行初始化串口，8位数据位，无奇偶校验，1位停止位<br />
            Start the slave service of serial, initialize the serial port with default parameters, 8 data bits, no parity, 1 stop bit
            </summary>
            <param name="com">串口信息</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.StartSerialSlave(System.String,System.Int32,System.Int32,System.IO.Ports.Parity,System.IO.Ports.StopBits)">
            <summary>
            启动串口的从机服务，使用指定的参数进行初始化串口，指定数据位，指定奇偶校验，指定停止位<br />
            </summary>
            <param name="com">串口信息</param>
            <param name="baudRate">波特率</param>
            <param name="dataBits">数据位</param>
            <param name="parity">奇偶校验</param>
            <param name="stopBits">停止位</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.StartSerialSlave(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            启动串口的从机服务，使用自定义的初始化方法初始化串口的参数<br />
            Start the slave service of serial and initialize the parameters of the serial port using a custom initialization method
            </summary>
            <param name="inni">初始化信息的委托</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.CloseSerialSlave">
            <summary>
            关闭提供从机服务的串口对象<br />
            Close the serial port object that provides slave services
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.SerialPort_DataReceived(System.Object,System.IO.Ports.SerialDataReceivedEventArgs)">
            <summary>
            接收到串口数据的时候触发
            </summary>
            <param name="sender">串口对象</param>
            <param name="e">消息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <summary>
            检查串口接收的数据是否完成的方法，如果接收完成，则返回<c>True</c>
            </summary>
            <param name="buffer">缓存的数据信息</param>
            <param name="receivedLength">当前已经接收的数据长度信息</param>
            <returns>是否接收完成</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.DealWithSerialReceivedData(System.Byte[])">
            <summary>
            处理串口接收数据的功能方法，需要在继承类中进行相关的重写操作
            </summary>
            <param name="data">串口接收到的原始字节数据</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.GetSerialPort">
            <summary>
            获取当前的串口对象信息
            </summary>
            <returns>串口对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing">是否托管对象</param>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDataServerBase.receiveAtleastTime">
            <summary>
            接收一次的数据的最少时间，当重写了报文结束的检查代码时，可以适当的将本值设置的大一点。<br />
            The minimum time to receive the data once, when the check code of the end of the message is rewritten, this value can be appropriately set larger.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadStruct``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Wait(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Wait(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Wait(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Wait(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Wait(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Wait(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Wait(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WaitAsync(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WaitAsync(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WaitAsync(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WaitAsync(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WaitAsync(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WaitAsync(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WaitAsync(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadCustomerAsync``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadAsync``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadStructAsync``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadFloatAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadDoubleAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String)" />
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDeviceBase">
            <summary>
            设备交互类的基类，实现了<see cref="T:HslCommunication.Core.IReadWriteDevice"/>接口的基础方法方法，需要使用继承重写来实现字节读写，bool读写操作。<br />
            The base class of the device interaction class, which implements the basic methods of the <see cref="T:HslCommunication.Core.IReadWriteDevice"/> interface, 
            requires inheritance rewriting to implement byte read and write, and bool read and write operations.
            </summary>
            <remarks>需要继承实现采用使用。</remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength">
            <summary>
            一个字单位的数据表示的地址长度，西门子为2，三菱，欧姆龙，modbusTcp就为1，AB PLC无效<br />
            The address length represented by one word of data, Siemens is 2, Mitsubishi, Omron, modbusTcp is 1, AB PLC is invalid
            </summary>
            <remarks>
            对设备来说，一个地址的数据对应的字节数，或是1个字节或是2个字节，4个字节，通常是这四个选择，当设置为0时，则表示4字节的地址长度信息<br />
            For the device, the number of bytes corresponding to the data of an address, either 1 byte or 2 bytes, 4 bytes, usually these four choices, when set to 0, it means 4 words Section address length information
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.GetWordLength(System.String,System.Int32,System.Int32)">
            <summary>
            一个字单位的数据表示的地址长度，西门子为2，三菱，欧姆龙，modbusTcp就为1，AB PLC无效<br />
            The address length represented by one word of data, Siemens is 2, Mitsubishi, Omron, modbusTcp is 1, AB PLC is invalid
            </summary>
            <remarks>
            对设备来说，一个地址的数据对应的字节数，或是1个字节或是2个字节，通常是这两个选择。<br />
            当前也可以重写来根据不同的地址动态控制不同的地址长度，比如有的地址是一个地址一个字节的，有的地址是一个地址两个字节的
            </remarks>
            <param name="address">读取的设备的地址信息</param>
            <param name="length">读取的数据长度信息</param>
            <param name="dataTypeLength">数据类型的字节长度信息，比如short, 就是2，int,float就是4</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadStruct``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Wait(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Wait(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Wait(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Wait(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Wait(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Wait(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Wait(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WaitAsync(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WaitAsync(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WaitAsync(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WaitAsync(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WaitAsync(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WaitAsync(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WaitAsync(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadCustomerAsync``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadAsync``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadStructAsync``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadFloatAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadDoubleAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String)" />
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDoubleBase">
            <summary>
            支持长连接，短连接两个模式的通用客户端基类 <br />
            Universal client base class that supports long connections and short connections to two modes
            </summary>
            <example>
            无，请使用继承类实例化，然后进行数据交互，当前的类并没有具体的实现。
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.#ctor">
            <summary>
            默认的无参构造函数 <br />
            Default no-parameter constructor
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.pipeSocket">
            <summary>
            当前的网络的管道信息
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.isPersistentConn">
            <summary>
            是否是长连接的状态<br />
            Whether it is a long connection state
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.LogMsgFormatBinary">
            <summary>
            设置日志记录报文是否二进制，如果为False，那就使用ASCII码<br />
            Set whether the log message is binary, if it is False, then use ASCII code
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.UseServerActivePush">
            <summary>
            获取或设置当前的连接是否激活从服务器主动推送的功能
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.GetNewNetMessage">
            <summary>
            获取一个新的消息对象的方法，需要在继承类里面进行重写<br />
            The method to get a new message object needs to be overridden in the inheritance class
            </summary>
            <returns>消息类对象</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform">
            <summary>
            当前的数据变换机制，当你需要从字节数据转换类型数据的时候需要。<br />
            The current data transformation mechanism is required when you need to convert type data from byte data.
            </summary>
            <example>
            主要是用来转换数据类型的，下面仅仅演示了2个方法，其他的类型转换，类似处理。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ByteTransform" title="ByteTransform示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.ConnectTimeOut">
            <summary>
            获取或设置连接的超时时间，单位是毫秒 <br />
            Gets or sets the timeout for the connection, in milliseconds
            </summary>
            <example>
            设置1秒的超时的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ConnectTimeOutExample" title="ConnectTimeOut示例" />
            </example>
            <remarks>
            不适用于异形模式的连接。
            </remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.ReceiveTimeOut">
            <summary>
            获取或设置接收服务器反馈的时间，如果为负数，则不接收反馈 <br />
            Gets or sets the time to receive server feedback, and if it is a negative number, does not receive feedback
            </summary>
            <example>
            设置1秒的接收超时的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReceiveTimeOutExample" title="ReceiveTimeOut示例" />
            </example>
            <remarks>
            超时的通常原因是服务器端没有配置好，导致访问失败，为了不卡死软件，所以有了这个超时的属性。
            </remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.IpAddress">
            <summary>
            获取或是设置远程服务器的IP地址，如果是本机测试，那么需要设置为127.0.0.1 <br />
            Get or set the IP address of the remote server. If it is a local test, then it needs to be set to 127.0.0.1
            </summary>
            <remarks>
            最好实在初始化的时候进行指定，当使用短连接的时候，支持动态更改，切换；当使用长连接后，无法动态更改<br />
            支持使用域名的网址方式，例如：www.hslcommunication.cn
            </remarks>
            <example>
            以下举例modbus-tcp的短连接及动态更改ip地址的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="IpAddressExample" title="IpAddress示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.Port">
            <summary>
            获取或设置服务器的端口号，具体的值需要取决于对方的配置<br />
            Gets or sets the port number of the server. The specific value depends on the configuration of the other party.
            </summary>
            <remarks>
            最好实在初始化的时候进行指定，当使用短连接的时候，支持动态更改，切换；当使用长连接后，无法动态更改
            </remarks>
            <example>
            动态更改请参照 <see cref="P:HslCommunication.Core.Net.NetworkDoubleBase.IpAddress"/> 属性的更改。
            </example>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.IReadWriteNet.ConnectionId"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.SleepTime">
            <summary>
            获取或设置在正式接收对方返回数据前的时候，需要休息的时间，当设置为0的时候，不需要休息。<br />
            Get or set the time required to rest before officially receiving the data from the other party. When it is set to 0, no rest is required.
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.LocalBinding">
            <summary>
            获取或设置绑定的本地的IP地址和端口号信息，如果端口设置为0，代表任何可用的端口<br />
            Get or set the bound local IP address and port number information, if the port is set to 0, it means any available port
            </summary>
            <remarks>
            默认为NULL, 也即是不绑定任何本地的IP及端口号信息，使用系统自动分配的方式。<br />
            The default is NULL, which means that no local IP and port number information are bound, and the system automatically assigns it.
            </remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.AlienSession">
            <summary>
            当前的异形连接对象，如果设置了异形连接的话，仅用于异形模式的情况使用<br />
            The current alien connection object, if alien connection is set, is only used in the case of alien mode
            </summary>
            <remarks>
            具体的使用方法请参照Demo项目中的异形modbus实现。
            </remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.SocketKeepAliveTime">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkServerBase.SocketKeepAliveTime"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.SetPipeSocket(HslCommunication.Core.Pipe.PipeSocket)">
            <summary>
            设置一个新的网络管道，一般来说不需要调用本方法，当多个网口设备共用一个网络连接时才需要使用本方法进行设置共享的管道。<br />
            To set up a new network channel, generally speaking, you do not need to call this method. This method is only needed to set up a shared channel when multiple network port devices share a network connection.
            </summary>
            <remarks>
            如果需要设置共享的网络管道的话，需要是设备类对象实例化之后立即进行设置。<br />
            If you need to set up a shared network pipe, you need to set it immediately after the device class object is instantiated.
            </remarks>
            <param name="pipeSocket">共享的网络通道</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.GetPipeSocket">
            <summary>
            获取当前用于通信的管道信息<br />
            Get the current pipe information used for communication
            </summary>
            <returns>管道对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.SetPersistentConnection">
            <summary>
            在读取数据之前可以调用本方法将客户端设置为长连接模式，相当于跳过了ConnectServer的结果验证，对异形客户端无效，当第一次进行通信时再进行创建连接请求。<br />
            Before reading the data, you can call this method to set the client to the long connection mode, which is equivalent to skipping the result verification of ConnectServer, 
            and it is invalid for the alien client. When the first communication is performed, the connection creation request is performed.
            </summary>
            <example>
            以下的方式演示了另一种长连接的机制
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="SetPersistentConnectionExample" title="SetPersistentConnection示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.IpAddressPing">
            <summary>
            对当前设备的IP地址进行PING的操作，返回PING的结果，正常来说，返回<see cref="F:System.Net.NetworkInformation.IPStatus.Success"/><br />
            PING the IP address of the current device and return the PING result. Normally, it returns <see cref="F:System.Net.NetworkInformation.IPStatus.Success"/>
            </summary>
            <returns>返回PING的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer">
            <summary>
            尝试连接远程的服务器，如果连接成功，就切换短连接模式到长连接模式，后面的每次请求都共享一个通道，使得通讯速度更快速<br />
            Try to connect to a remote server. If the connection is successful, switch the short connection mode to the long connection mode. 
            Each subsequent request will share a channel, making the communication speed faster.
            </summary>
            <returns>返回连接结果，如果失败的话（也即IsSuccess为False），包含失败信息</returns>
            <example>
              简单的连接示例，调用该方法后，连接设备，创建一个长连接的对象，后续的读写操作均公用一个连接对象。
              <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="Connect1" title="连接设备" />
              如果想知道是否连接成功，请参照下面的代码。
              <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="Connect2" title="判断连接结果" />
            </example> 
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer(HslCommunication.Core.Net.AlienSession)">
            <summary>
            使用指定的套接字创建异形客户端，在异形客户端的模式下，网络通道需要被动创建。<br />
            Use the specified socket to create the alien client. In the alien client mode, the network channel needs to be created passively.
            </summary>
            <param name="session">异形客户端对象，查看<seealso cref="T:HslCommunication.Core.Net.NetworkAlienClient"/>类型创建的客户端</param>
            <returns>通常都为成功</returns>
            <example>
              简单的创建示例。
              <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="AlienConnect1" title="连接设备" />
              如果想知道是否创建成功。通常都是成功。
              <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="AlienConnect2" title="判断连接结果" />
            </example> 
            <remarks>
            不能和之前的长连接和短连接混用，详细参考 Demo程序 
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectClose">
            <summary>
            手动断开与远程服务器的连接，如果当前是长连接模式，那么就会切换到短连接模式<br />
            Manually disconnect from the remote server, if it is currently in long connection mode, it will switch to short connection mode
            </summary>
            <returns>关闭连接，不需要查看IsSuccess属性查看</returns>
            <example>
            直接关闭连接即可，基本上是不需要进行成功的判定
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ConnectCloseExample" title="关闭连接结果" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.DecideWhetherQAMessage(System.Net.Sockets.Socket,HslCommunication.OperateResult{System.Byte[]})">
            <summary>
            决定当前的消息是否是应答机制的消息内容，需要在客户端进行重写实现，如果是应答机制，返回 <c>True</c>, 否则返回 <c>False</c><br />
            To determine whether the current message is the message content of the response mechanism, 
            it needs to be rewritten on the client side. If it is the response mechanism, return <c>True</c>, otherwise return <c>False</c>
            </summary>
            <param name="socket">通信使用的网络套接字</param>
            <param name="receive">服务器返回的内容</param>
            <returns>是否应答机制的数据报文</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            根据实际的协议选择是否重写本方法，有些协议在创建连接之后，需要进行一些初始化的信号握手，才能最终建立网络通道。<br />
            Whether to rewrite this method is based on the actual protocol. Some protocols require some initial signal handshake to establish a network channel after the connection is created.
            </summary>
            <param name="socket">网络套接字</param>
            <returns>是否初始化成功，依据具体的协议进行重写</returns>
            <example>
            有些协议不需要握手信号，比如三菱的MC协议，Modbus协议，西门子和欧姆龙就存在握手信息，此处的例子是继承本类后重写的西门子的协议示例
            <code lang="cs" source="HslCommunication_Net45\Profinet\Siemens\SiemensS7Net.cs" region="NetworkDoubleBase Override" title="西门子重连示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <summary>
            根据实际的协议选择是否重写本方法，有些协议在断开连接之前，需要发送一些报文来关闭当前的网络通道<br />
            Select whether to rewrite this method according to the actual protocol. Some protocols need to send some packets to close the current network channel before disconnecting.
            </summary>
            <param name="socket">网络套接字</param>
            <example>
            目前暂无相关的示例，组件支持的协议都不用实现这个方法。
            </example>
            <returns>当断开连接时额外的操作结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ExtraAfterReadFromCoreServer(HslCommunication.OperateResult)">
            <summary>
            和服务器交互完成的时候调用的方法，可以根据读写结果进行一些额外的操作，具体的操作需要根据实际的需求来重写实现<br />
            The method called when the interaction with the server is completed can perform some additional operations based on the read and write results. 
            The specific operations need to be rewritten according to actual needs.
            </summary>
            <param name="read">读取结果</param>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.isUseAccountCertificate">
            <summary>
            是否使用账号登录，这个账户登录的功能是<c>HSL</c>组件创建的服务器特有的功能。<br />
            Whether to log in using an account. The function of this account login is a server-specific function created by the <c> HSL </c> component.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.SetLoginAccount(System.String,System.String)">
            <summary>
            设置当前的登录的账户名和密码信息，并启用账户验证的功能，账户名为空时设置不生效<br />
            Set the current login account name and password information, and enable the account verification function. The account name setting will not take effect when it is empty
            </summary>
            <remarks>
            当对方的服务器是使用HslCommunication创建的虚拟服务器时，例如modbus服务器，西门子s7服务器等等，就支持进行账户名验证操作，此时的客户端连接之前，就需要调用本方法设置账户密码信息。<br />
            When the other party's server is a virtual server created by HslCommunication, such as modbus server, Siemens s7 server, etc., 
            it supports account name verification operation. At this time, before the client connects, you need to call this method to set account password information.
            </remarks>
            <param name="userName">账户名</param>
            <param name="password">密码</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.AccountCertificate(System.Net.Sockets.Socket)">
            <summary>
            认证账号，根据已经设置的用户名和密码，进行发送服务器进行账号认证。<br />
            Authentication account, according to the user name and password that have been set, sending server for account authentication.
            </summary>
            <param name="socket">套接字</param>
            <returns>认证结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.AccountCertificateAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.AccountCertificate(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ExtraOnDisconnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ExtraOnDisconnect(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.CreateSocketAndInitialicationAsync">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.CreateSocketAndInitialication"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.GetAvailableSocketAsync">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.GetAvailableSocket"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServerAsync">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectCloseAsync">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectClose"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServerAsync(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Byte[],System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServerAsync(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServerAsync(System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Byte[],System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.PackCommandWithHeader(System.Byte[])">
            <summary>
            对当前的命令进行打包处理，通常是携带命令头内容，标记当前的命令的长度信息，需要进行重写，否则默认不打包<br />
            The current command is packaged, usually carrying the content of the command header, marking the length of the current command, 
            and it needs to be rewritten, otherwise it is not packaged by default
            </summary>
            <remarks>
            对发送的命令打包之后，直接发送给真实的对方设备了，例如在AB-PLC里面，就重写了打包方法，将当前的会话ID参数传递给PLC设备<br />
            After packaging the sent command, it is directly sent to the real counterpart device. For example, in AB-PLC, 
            the packaging method is rewritten and the current session ID parameter is passed to the PLC device.
            </remarks>
            <param name="command">发送的数据命令内容</param>
            <returns>打包之后的数据结果信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.UnpackResponseContent(System.Byte[],System.Byte[])">
            <summary>
            根据对方返回的报文命令，对命令进行基本的拆包，例如各种Modbus协议拆包为统一的核心报文，还支持对报文的验证<br />
            According to the message command returned by the other party, the command is basically unpacked, for example, 
            various Modbus protocols are unpacked into a unified core message, and the verification of the message is also supported
            </summary>
            <remarks>
            在实际解包的操作过程中，通常对状态码，错误码等消息进行判断，如果校验不通过，将携带错误消息返回<br />
            During the actual unpacking operation, the status code, error code and other messages are usually judged. If the verification fails, the error message will be returned.
            </remarks>
            <param name="send">发送的原始报文数据</param>
            <param name="response">设备方反馈的原始报文内容</param>
            <returns>返回拆包之后的报文信息，默认不进行任何的拆包操作</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.GetAvailableSocket">
            <summary>
            获取本次操作的可用的网络通道，如果是短连接，就重新生成一个新的网络通道，如果是长连接，就复用当前的网络通道。<br />
            Obtain the available network channels for this operation. If it is a short connection, a new network channel is regenerated. 
            If it is a long connection, the current network channel is reused.
            </summary>
            <returns>是否成功，如果成功，使用这个套接字</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.CreateSocketAndInitialication">
            <summary>
            尝试连接服务器，如果成功，并执行<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)"/>的初始化方法，并返回最终的结果。<br />
            Attempt to connect to the server, if successful, and execute the initialization method of <see cref = "M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)" />, and return the final result.
            </summary>
            <returns>带有socket的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            将数据报文发送指定的网络通道上，根据当前指定的<see cref="T:HslCommunication.Core.IMessage.INetMessage"/>类型，返回一条完整的数据指令<br />
            Sends a data message to the specified network channel, and returns a complete data command according to the currently specified <see cref = "T:HslCommunication.Core.IMessage.INetMessage" /> type
            </summary>
            <param name="socket">指定的套接字</param>
            <param name="send">发送的完整的报文信息</param>
            <param name="hasResponseData">是否有等待的数据返回，默认为 true</param>
            <param name="usePackAndUnpack">是否需要对命令重新打包，在重写<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.PackCommandWithHeader(System.Byte[])"/>方法后才会有影响</param>
            <remarks>
            无锁的基于套接字直接进行叠加协议的操作。
            </remarks>
            <example>
            假设你有一个自己的socket连接了设备，本组件可以直接基于该socket实现modbus读取，三菱读取，西门子读取等等操作，前提是该服务器支持多协议，虽然这个需求听上去比较变态，但本组件支持这样的操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReadFromCoreServerExample1" title="ReadFromCoreServer示例" />
            </example>
            <returns>接收的完整的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Byte[],System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            将数据发送到当前的网络通道中，并从网络通道中接收一个<see cref="T:HslCommunication.Core.IMessage.INetMessage"/>指定的完整的报文，网络通道将根据<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.GetAvailableSocket"/>方法自动获取，本方法是线程安全的。<br />
            Send data to the current network channel and receive a complete message specified by <see cref = "T:HslCommunication.Core.IMessage.INetMessage" /> from the network channel. 
            The network channel will be automatically obtained according to the <see cref = "M:HslCommunication.Core.Net.NetworkDoubleBase.GetAvailableSocket" /> method This method is thread-safe.
            </summary>
            <param name="send">发送的完整的报文信息</param>
            <param name="hasResponseData">是否有等待的数据返回，默认为 true</param>
            <param name="usePackAndUnpack">是否需要对命令重新打包，在重写<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.PackCommandWithHeader(System.Byte[])"/>方法后才会有影响</param>
            <returns>接收的完整的报文信息</returns>
            <remarks>
            本方法用于实现本组件还未实现的一些报文功能，例如有些modbus服务器会有一些特殊的功能码支持，需要收发特殊的报文，详细请看示例
            </remarks>
            <example>
            此处举例有个modbus服务器，有个特殊的功能码0x09，后面携带子数据0x01即可，发送字节为 0x00 0x00 0x00 0x00 0x00 0x03 0x01 0x09 0x01
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReadFromCoreServerExample2" title="ReadFromCoreServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.Dispose(System.Boolean)">
            <summary>
            释放当前的资源，并自动关闭长连接，如果设置了的话
            </summary>
            <param name="disposing">是否释放托管的资源信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.Dispose">
            <summary>
            释放当前的资源，如果调用了本方法，那么该对象再使用的时候，需要重新实例化。<br />
            Release the current resource. If this method is called, the object needs to be instantiated again when it is used again.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkFileServerBase">
            <summary>
            文件服务器类的基类，为直接映射文件模式和间接映射文件模式提供基础的方法支持，主要包含了对文件的一些操作的功能<br />
            The base class of the file server class, which provides basic method support for the direct mapping file mode and the indirect mapping file mode, and mainly includes the functions of some operations on files
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.GetFileMarksFromDictionaryWithFileName(System.String)">
            <summary>
            获取当前文件的读写锁，如果没有会自动创建，文件名应该是guid文件名，例如 b35a11ec533147ca80c7f7d1713f015b7909<br />
            Acquire the read-write lock of the current file. If not, it will be created automatically. 
            The file name should be the guid file name, for example, b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="fileName">完整的文件路径</param>
            <returns>返回携带文件信息的读写锁</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ReceiveInformationHead(System.Net.Sockets.Socket)">
            <summary>
            接收本次操作的信息头数据
            </summary>
            <param name="socket">网络套接字</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ReceiveInformationHeadAsync(System.Net.Sockets.Socket)">
            <summary>
            接收本次操作的信息头数据
            </summary>
            <param name="socket">网络套接字</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.CreateRandomFileName">
            <summary>
            获取一个随机的文件名，由GUID码和随机数字组成
            </summary>
            <returns>文件名</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ReturnAbsoluteFilePath(System.String,System.String,System.String)">
            <summary>
            返回服务器的绝对路径，包含根目录的信息  [Root Dir][Factory][Group][Id] 信息
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ReturnAbsoluteFileName(System.String,System.String,System.String,System.String)">
            <summary>
            返回服务器的绝对路径，包含根目录的信息  [Root Dir][Factory][Group][Id][FileName] 信息
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.GetRelativeFileName(System.String,System.String,System.String,System.String)">
            <summary>
            返回相对路径的名称
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.MoveFileToNewFile(System.String,System.String)">
            <summary>
            移动一个文件到新的文件去
            </summary>
            <param name="fileNameOld">旧的文件名称</param>
            <param name="fileNameNew">新的文件名称</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.DeleteFileAndCheck(System.Net.Sockets.Socket,System.String)">
            <summary>
            删除文件并回发确认信息，如果结果异常，则结束通讯
            </summary>
            <param name="socket">网络套接字</param>
            <param name="fullname">完整路径的文件名称</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkFileServerBase.FileUploadDelegate">
            <summary>
            文件上传的委托
            </summary>
            <param name="fileInfo">文件的基本信息</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkFileServerBase.OnFileUploadEvent">
            <summary>
            文件上传的事件，当文件上传的时候触发。
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.OnFileUpload(HslCommunication.Core.FileServerInfo)">
            <summary>
            触发一个文件上传的事件。
            </summary>
            <param name="fileInfo">文件的基本信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.StartInitialization">
            <summary>
            服务器启动时的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.CheckFolderAndCreate">
            <summary>
            检查文件夹是否存在，不存在就创建
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkFileServerBase.FilesDirectoryPath">
            <summary>
            文件所存储的路径
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkFileServerBase.FileMarkIdCount">
            <summary>
            获取当前的文件标记的对象数量<br />
            Get the number of objects marked by the current file
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkFileServerBase.FileCacheSize">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkBase.fileCacheSize"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.GetDirectoryFiles(System.String,System.String,System.String)">
            <summary>
            获取文件夹的所有文件列表
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>文件列表</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.GetDirectories(System.String,System.String,System.String)">
            <summary>
            获取文件夹的所有文件夹列表
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>文件夹列表</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkUdpServerBase">
            <summary>
            Udp服务器程序的基础类，提供了启动服务器的基本实现，方便后续的扩展操作。<br />
            The basic class of the udp server program provides the basic implementation of starting the server to facilitate subsequent expansion operations.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpServerBase.IsStarted">
            <summary>
            服务器引擎是否启动<br />
            Whether the server engine is started
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpServerBase.Port">
            <summary>
            获取或设置服务器的端口号，如果是设置，需要在服务器启动前设置完成，才能生效。<br />
            Gets or sets the port number of the server. If it is set, it needs to be set before the server starts to take effect.
            </summary>
            <remarks>需要在服务器启动之前设置为有效</remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ThreadReceiveCycle">
            <summary>
            后台接收数据的线程
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.SocketAcceptExtraCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端的socket登录的时候额外检查的操作，并返回操作的结果信息。<br />
            The operation is additionally checked when the client's socket logs in, and the result information of the operation is returned.
            </summary>
            <param name="socket">套接字</param>
            <param name="endPoint">终结点</param>
            <returns>验证的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.StartInitialization">
            <summary>
            服务器启动时额外的初始化信息，可以用于启动一些额外的服务的操作。<br />
            The extra initialization information when the server starts can be used to start some additional service operations.
            </summary>
            <remarks>需要在派生类中重写</remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerStart(System.Int32)">
            <summary>
            指定端口号来启动服务器的引擎<br />
            Specify the port number to start the server's engine
            </summary>
            <param name="port">指定一个端口号</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerStart">
            <summary>
            使用已经配置好的端口启动服务器的引擎<br />
            Use the configured port to start the server's engine
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.CloseAction">
            <summary>
            服务器关闭的时候需要做的事情<br />
            Things to do when the server is down
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerClose">
            <summary>
            关闭服务器的引擎<br />
            Shut down the server's engine
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkServerBase">
            <summary>
            服务器程序的基础类，提供了启动服务器的基本实现，方便后续的扩展操作。<br />
            The basic class of the server program provides the basic implementation of starting the server to facilitate subsequent expansion operations.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkServerBase.IsStarted">
            <summary>
            服务器引擎是否启动<br />
            Whether the server engine is started
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkServerBase.Port">
            <summary>
            获取或设置服务器的端口号，如果是设置，需要在服务器启动前设置完成，才能生效。<br />
            Gets or sets the port number of the server. If it is set, it needs to be set before the server starts to take effect.
            </summary>
            <remarks>需要在服务器启动之前设置为有效</remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkServerBase.EnableIPv6">
            <summary>
            获取或设置服务器是否支持IPv6的地址协议信息<br />
            Get or set whether the server supports IPv6 address protocol information
            </summary>
            <remarks>
            默认为 <c>False</c>，也就是不启动
            </remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkServerBase.SocketKeepAliveTime">
            <summary>
            获取或设置客户端的Socket的心跳时间信息，这个是Socket底层自动实现的心跳包，不基于协议层实现。默认小于0，不开启心跳检测，如果需要开启，设置 60_000 比较合适，单位毫秒<br />
            Get or set the heartbeat time information of the Socket of the client. This is the heartbeat packet automatically implemented by the bottom layer of the Socket, not based on the protocol layer. 
            The default value is less than 0, and heartbeat detection is not enabled. If you need to enable it, it is more appropriate to set 60_000, in milliseconds.
            </summary>
            <remarks>
            经测试，在linux上，基于.net core3.1的程序运行时，设置了这个值是无效的。
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.AsyncAcceptCallback(System.IAsyncResult)">
            <summary>
            异步传入的连接申请请求<br />
            Asynchronous incoming connection request
            </summary>
            <param name="iar">异步对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端连接到服务器，并听过额外的检查后，进行回调的方法<br />
            Callback method when the client connects to the server and has heard additional checks
            </summary>
            <param name="socket">socket对象</param>
            <param name="endPoint">远程的终结点</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.SocketAcceptExtraCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端的socket登录的时候额外检查的操作，并返回操作的结果信息。<br />
            The operation is additionally checked when the client's socket logs in, and the result information of the operation is returned.
            </summary>
            <param name="socket">套接字</param>
            <param name="endPoint">终结点</param>
            <returns>验证的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.StartInitialization">
            <summary>
            服务器启动时额外的初始化信息，可以用于启动一些额外的服务的操作。<br />
            The extra initialization information when the server starts can be used to start some additional service operations.
            </summary>
            <remarks>需要在派生类中重写</remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ServerStart(System.Int32)">
            <summary>
            指定端口号来启动服务器的引擎<br />
            Specify the port number to start the server's engine
            </summary>
            <param name="port">指定一个端口号</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ServerStart">
            <summary>
            使用已经配置好的端口启动服务器的引擎<br />
            Use the configured port to start the server's engine
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.CloseAction">
            <summary>
            服务器关闭的时候需要做的事情<br />
            Things to do when the server is down
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ServerClose">
            <summary>
            关闭服务器的引擎<br />
            Shut down the server's engine
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ConnectHslAlientClient(System.String,System.Int32,System.String,System.String)">
            <summary>
            创建一个指定的异形客户端连接，使用Hsl协议来发送注册包<br />
            Create a specified profiled client connection and use the Hsl protocol to send registration packets
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="dtuId">设备唯一ID号，最长11</param>
            <param name="password">密码信息</param>
            <returns>是否成功连接</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ConnectHslAlientClientAsync(System.String,System.Int32,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkServerBase.ConnectHslAlientClient(System.String,System.Int32,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkUdpBase">
            <summary>
            基于Udp的应答式通信类<br />
            Udp - based responsive communication class
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.#ctor">
            <summary>
            实例化一个默认的方法<br />
            Instantiate a default method
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.IpAddress">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.IpAddress"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.Port">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.Port"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.ReceiveTimeout">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ReceiveTimeOut"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ConnectionId"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.ReceiveCacheLength">
            <summary>
            获取或设置一次接收时的数据长度，默认2KB数据长度，特殊情况的时候需要调整<br />
            Gets or sets the length of data received at a time. The default length is 2KB
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.LocalBinding">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.LocalBinding"/>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkUdpBase.LogMsgFormatBinary">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkDoubleBase.LogMsgFormatBinary"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.PackCommandWithHeader(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.PackCommandWithHeader(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.UnpackResponseContent(System.Byte[],System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServer(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServer(System.Byte[],System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServer(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            核心的数据交互读取，发数据发送到通道上去，然后从通道上接收返回的数据<br />
            The core data is read interactively, the data is sent to the serial port, and the returned data is received from the serial port
            </summary>
            <param name="send">完整的报文内容</param>
            <param name="hasResponseData">是否有等待的数据返回，默认为 true</param>
            <param name="usePackAndUnpack">是否需要对命令重新打包，在重写<see cref="M:HslCommunication.Core.Net.NetworkUdpBase.PackCommandWithHeader(System.Byte[])"/>方法后才会有影响</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServerAsync(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServer(System.Byte[],System.Boolean,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServerAsync(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.IpAddressPing">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.IpAddressPing"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkUdpDeviceBase">
            <summary>
            Udp报文协议的内容传送
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpDeviceBase.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpDeviceBase.WordLength">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.GetWordLength(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDeviceBase.GetWordLength(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadStruct``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Wait(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Wait(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Wait(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Wait(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Wait(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Wait(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Wait(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WaitAsync(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WaitAsync(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WaitAsync(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WaitAsync(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WaitAsync(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WaitAsync(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WaitAsync(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadCustomerAsync``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadAsync``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadStructAsync``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadFloatAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadDoubleAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String)" />
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkWebApiBase">
            <summary>
            基于webapi的数据访问的基类，提供了基本的http接口的交互功能<br />
            A base class for data access based on webapi that provides basic HTTP interface interaction
            </summary>
            <remarks>
            当前的基类在.net framework2.0上存在问题，在.net framework4.5及.net standard上运行稳定而且正常
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String)">
            <summary>
            使用指定的ip地址来初始化对象<br />
            Initializes the object using the specified IP address
            </summary>
            <param name="ipAddress">Ip地址信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址及端口号来初始化对象<br />
            Initializes the object with the specified IP address and port number
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>
            使用指定的ip地址，端口号，用户名，密码来初始化对象<br />
            Initialize the object with the specified IP address, port number, username, and password
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
            <param name="name">用户名</param>
            <param name="password">密码</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.AddRequestHeaders(System.Net.Http.Headers.HttpContentHeaders)">
            <summary>
            针对请求的头信息进行额外的处理
            </summary>
            <param name="headers">头信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.Get(System.String)">
            <summary>
            使用GET操作从网络中获取到数据信息
            </summary>
            <param name="rawUrl">除去ip地址和端口的地址</param>
            <returns>返回的数据内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.Post(System.String,System.String)">
            <summary>
            使用POST命令去提交数据内容，然后返回相关的数据信息
            </summary>
            <param name="rawUrl">已经去除ip地址，端口号的api信息</param>
            <param name="body">数据内容</param>
            <returns>从服务器返回的内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.GetAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiBase.Get(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.PostAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiBase.Post(System.String,System.String)"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.IpAddress">
            <summary>
            获取或设置远程服务器的IP地址<br />
            Gets or sets the IP address of the remote server
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.Port">
            <summary>
            获取或设置远程服务器的端口号信息<br />
            Gets or sets the port number information for the remote server
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.UserName">
            <summary>
            获取或设置当前的用户名<br />
            Get or set the current username
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.Password">
            <summary>
            获取或设置当前的密码<br />
            Get or set the current password
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.UseHttps">
            <summary>
            是否启用Https的协议访问，对于Https来说，端口号默认为 443<br />
            Whether to enable Https protocol access, for Https, the port number defaults to 443
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.DefaultContentType">
            <summary>
            默认的内容类型，如果为空，则不进行设置操作。例如设置为 "text/plain", "application/json", "text/html" 等等。<br />
            The default content type, if it is empty, no setting operation will be performed. For example, set to "text/plain", "application/json", "text/html" and so on.
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.UseEncodingISO">
            <summary>
            获取或设置是否使用ISO的编码信息，默认为 False<br />
            Get or set whether to use ISO encoding information, the default is False
            </summary>
            <remarks>
            在访问某些特殊的API的时候，会发生异常"The character set provided in ContentType is invalid...."，这时候，只需要将本属性设置为 True 即可。
            </remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.Client">
            <summary>
            获取当前的HttpClinet的客户端<br />
            Get the current HttpClinet client
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkWebApiDevice">
            <summary>
            一个基于WebApi协议的设备类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.#ctor">
            <summary>
            实例化一个默认的对象，使用127.0.0.1和端口80
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个对象
            </summary>
            <param name="ipAddress">ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiDevice.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiDevice.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.IReadWriteNet.ConnectionId"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiDevice.WordLength">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.GetWordLength(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDeviceBase.GetWordLength(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadStruct``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Wait(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Wait(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Wait(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Wait(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Wait(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Wait(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.Wait(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WaitAsync(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WaitAsync(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WaitAsync(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WaitAsync(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WaitAsync(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WaitAsync(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WaitAsync(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadCustomerAsync``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadAsync``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadStructAsync``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadFloatAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadDoubleAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String)" />
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiDevice.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkWebApiRobotBase">
            <summary>
            机器人的基于webapi接口的基础类信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.#ctor(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.#ctor(System.String,System.Int32,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String,System.Int32,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.ReadByAddress(System.String)">
            <summary>
            等待重写的额外的指令信息的支持。除了url的形式之外，还支持基于命令的数据交互<br />
            Additional instruction information waiting for rewriting is supported.In addition to the url format, command based data interaction is supported
            </summary>
            <param name="address">地址信息</param>
            <returns>是否读取成功的内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.ReadByAddressAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.ReadByAddress(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.Read(System.String)">
            <summary>
            读取对方信息的的数据信息，通常是针对GET的方法信息设计的。如果使用了url=开头，就表示是使用了原生的地址访问<br />
            Read the other side of the data information, usually designed for the GET method information.If you start with url=, you are using native address access
            </summary>
            <param name="address">无效参数</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.ReadString(System.String)">
            <summary>
            读取对方信息的的字符串数据信息，通常是针对GET的方法信息设计的。如果使用了url=开头，就表示是使用了原生的地址访问<br />
            The string data information that reads the other party information, usually designed for the GET method information.If you start with url=, you are using native address access
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.Write(System.String,System.Byte[])">
            <summary>
            使用POST的方式来向对方进行请求数据信息，需要使用url=开头，来表示是使用了原生的地址访问<br />
            Using POST to request data information from the other party, we need to start with url= to indicate that we are using native address access
            </summary>
            <param name="address">指定的地址信息，有些设备可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.Write(System.String,System.String)">
            <summary>
            使用POST的方式来向对方进行请求数据信息，需要使用url=开头，来表示是使用了原生的地址访问<br />
            Using POST to request data information from the other party, we need to start with url= to indicate that we are using native address access
            </summary>
            <param name="address">指定的地址信息</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.ReadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiRobotBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkXBase">
            <summary>
            包含了主动异步接收的方法实现和文件类异步读写的实现<br />
            Contains the implementation of the active asynchronous receiving method and the implementation of asynchronous reading and writing of the file class
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.#ctor">
            <summary>
            默认的无参构造方法<br />
            The default parameterless constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileStreamToSocket(System.Net.Sockets.Socket,System.String,System.Int64,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将文件数据发送至套接字，如果结果异常，则结束通讯<br />
            [Self-check] Send the file data to the socket. If the result is abnormal, the communication is ended.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="filename">完整的文件路径</param>
            <param name="filelength">文件的长度</param>
            <param name="report">进度报告器</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileAndCheckReceive(System.Net.Sockets.Socket,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将文件数据发送至套接字，具体发送细节将在继承类中实现，如果结果异常，则结束通讯<br />
            [Self-checking] Send the file data to the socket. The specific sending details will be implemented in the inherited class. If the result is abnormal, the communication will end
            </summary>
            <param name="socket">套接字</param>
            <param name="filename">文件名称，文件必须存在</param>
            <param name="servername">远程端的文件名称</param>
            <param name="filetag">文件的额外标签</param>
            <param name="fileupload">文件的上传人</param>
            <param name="sendReport">发送进度报告</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileAndCheckReceive(System.Net.Sockets.Socket,System.IO.Stream,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将流数据发送至套接字，具体发送细节将在继承类中实现，如果结果异常，则结束通讯<br />
            [Self-checking] Send stream data to the socket. The specific sending details will be implemented in the inherited class. 
            If the result is abnormal, the communication will be terminated
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">文件名称，文件必须存在</param>
            <param name="servername">远程端的文件名称</param>
            <param name="filetag">文件的额外标签</param>
            <param name="fileupload">文件的上传人</param>
            <param name="sendReport">发送进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileHeadFromSocket(System.Net.Sockets.Socket)">
            <summary>
            [自校验] 从套接字中接收文件头信息<br />
            [Self-checking] Receive file header information from socket
            </summary>
            <param name="socket">套接字的网络</param>
            <returns>包含文件信息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileFromSocket(System.Net.Sockets.Socket,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 从网络中接收一个文件，如果结果异常，则结束通讯<br />
            [Self-checking] Receive a file from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="savename">接收文件后保存的文件名</param>
            <param name="receiveReport">接收进度报告</param>
            <returns>包含文件信息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 从网络中接收一个文件，写入数据流，如果结果异常，则结束通讯，参数顺序文件名，文件大小，文件标识，上传人<br />
            [Self-checking] Receive a file from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="stream">等待写入的数据流</param>
            <param name="receiveReport">接收进度报告</param>
            <returns>文件头结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileStreamToSocketAsync(System.Net.Sockets.Socket,System.String,System.Int64,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkXBase.SendFileStreamToSocket(System.Net.Sockets.Socket,System.String,System.Int64,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileAndCheckReceiveAsync(System.Net.Sockets.Socket,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkXBase.SendFileAndCheckReceive(System.Net.Sockets.Socket,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileAndCheckReceiveAsync(System.Net.Sockets.Socket,System.IO.Stream,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkXBase.SendFileAndCheckReceive(System.Net.Sockets.Socket,System.IO.Stream,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileHeadFromSocketAsync(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileHeadFromSocket(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileFromSocketAsync(System.Net.Sockets.Socket,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileFromSocket(System.Net.Sockets.Socket,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileFromSocketAsync(System.Net.Sockets.Socket,System.IO.Stream,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkXBase.CoreSocket">
            <summary>
            对客户端而言是的通讯用的套接字，对服务器来说是用于侦听的套接字<br />
            A communication socket for the client, or a listening socket for the server
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.ReadWriteNetHelper">
            <summary>
            读写网络的辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.Wait(HslCommunication.Core.IReadWriteNet,System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.Wait(HslCommunication.Core.IReadWriteNet,System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.Wait(HslCommunication.Core.IReadWriteNet,System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.Wait(HslCommunication.Core.IReadWriteNet,System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.Wait(HslCommunication.Core.IReadWriteNet,System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.Wait(HslCommunication.Core.IReadWriteNet,System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.Wait(HslCommunication.Core.IReadWriteNet,System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.ReadCustomer``1(HslCommunication.Core.IReadWriteNet,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.ReadCustomer``1(HslCommunication.Core.IReadWriteNet,System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WriteCustomer``1(HslCommunication.Core.IReadWriteNet,System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.ReadCustomerAsync``1(HslCommunication.Core.IReadWriteNet,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.ReadCustomerAsync``1(HslCommunication.Core.IReadWriteNet,System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WriteCustomerAsync``1(HslCommunication.Core.IReadWriteNet,System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.ReadStruct``1(HslCommunication.Core.IReadWriteNet,System.String,System.UInt16,HslCommunication.Core.IByteTransform,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.ReadStructAsync``1(HslCommunication.Core.IReadWriteNet,System.String,System.UInt16,HslCommunication.Core.IByteTransform,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.ReadWriteNetHelper.ReadStruct``1(HslCommunication.Core.IReadWriteNet,System.String,System.UInt16,HslCommunication.Core.IByteTransform,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WaitAsync(HslCommunication.Core.IReadWriteNet,System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WaitAsync(HslCommunication.Core.IReadWriteNet,System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WaitAsync(HslCommunication.Core.IReadWriteNet,System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WaitAsync(HslCommunication.Core.IReadWriteNet,System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WaitAsync(HslCommunication.Core.IReadWriteNet,System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WaitAsync(HslCommunication.Core.IReadWriteNet,System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.ReadWriteNetHelper.WaitAsync(HslCommunication.Core.IReadWriteNet,System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
            <param name="readWriteNet">通信对象</param>
        </member>
        <member name="T:HslCommunication.Core.Net.AlienSession">
            <summary>
            异形客户端的连接对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AlienSession.#ctor">
            <summary>
            实例化一个默认的参数
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.Socket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.DTU">
            <summary>
            唯一的标识
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.Pwd">
            <summary>
            密码信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.IsStatusOk">
            <summary>
            指示当前的网络状态
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.OnlineTime">
            <summary>
            上线时间
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.OfflineTime">
            <summary>
            最后一次下线的时间
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AlienSession.Offline">
            <summary>
            进行下线操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AlienSession.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.AppSession">
            <summary>
            当前的网络会话信息，还包含了一些客户端相关的基本的参数信息<br />
            The current network session information also contains some basic parameter information related to the client
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AppSession.#ctor">
            <inheritdoc cref="M:HslCommunication.Core.Net.SessionBase.#ctor"/>
        </member>
        <member name="M:HslCommunication.Core.Net.AppSession.#ctor(System.Net.Sockets.Socket)">
            <inheritdoc cref="M:HslCommunication.Core.Net.SessionBase.#ctor(System.Net.Sockets.Socket)"/>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.LoginAlias">
            <summary>
            远程对象的别名信息<br />
            Alias information for remote objects
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.ClientUniqueID">
            <summary>
            客户端唯一的标识，在NetPushServer及客户端类里有使用<br />
            The unique identifier of the client, used in the NetPushServer and client classes
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.AppSession.UdpEndPoint">
            <summary>
            UDP通信中的远程端<br />
            Remote side in UDP communication
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.BytesBuffer">
            <summary>
            数据内容缓存<br />
            data content cache
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.KeyGroup">
            <summary>
            用于关键字分类使用<br />
            Used for keyword classification
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.Tag">
            <summary>
            当前会话绑定的自定义的对象内容<br />
            The content of the custom object bound to the current session
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AppSession.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.AppSession.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Net.AppSession.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.WorkSocket">
            <summary>
            传输数据的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.Content">
            <summary>
            发送的数据内容
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.AlreadySendLength">
            <summary>
            已经发送长度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.Key">
            <summary>
            关键字
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.ClientId">
            <summary>
            客户端的标识
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.FileStateObject">
            <summary>
            文件传送的异步对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.FileStateObject.Stream">
            <summary>
            操作的流
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.SessionBase">
            <summary>
            会话的基类信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.SessionBase.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.SessionBase.#ctor(System.Net.Sockets.Socket)">
            <summary>
            通过指定的<see cref="T:System.Net.Sockets.Socket"/>对象来初始化一个会话内容
            </summary>
            <param name="socket">连接的Socket对象</param>
        </member>
        <member name="P:HslCommunication.Core.Net.SessionBase.WorkSocket">
            <summary>
            实际传输数据的对象，除非你清楚自己在收发什么数据信息，否则尽量不直接使用本<see cref="T:System.Net.Sockets.Socket"/>对象<br />
            The actual data transmission object, unless you know what data information you are sending and receiving, try not to directly use this <see cref="T:System.Net.Sockets.Socket"/> object
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.SessionBase.OnlineTime">
            <summary>
            获取当前的客户端的上线时间<br />
            Get the online time of the current client
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.SessionBase.IpAddress">
            <summary>
            获取当前的远程连接对象的IP地址<br />
            Get the IP address of the current remote connection object
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.SessionBase.IpEndPoint">
            <summary>
            获取当前的连接对象连接的远程客户端<br />
            Get the remote client connected by the current connection object
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.SessionBase.HeartTime">
            <summary>
            获取心跳验证的时间点<br />
            Get the time point of heartbeat verification
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.SessionBase.UpdateHeartTime">
            <summary>
            更新当前的心跳时间<br />
            Update the current heartbeat time
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.SessionBase.UpdateSocket(System.Net.Sockets.Socket)">
            <summary>
            更新当前的<see cref="T:System.Net.Sockets.Socket"/>连接对象信息
            </summary>
            <param name="socket">连接的对象</param>
        </member>
        <member name="T:HslCommunication.Core.Net.StateObject">
            <summary>
            网络中的异步对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.StateObject.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.StateObject.#ctor(System.Int32)">
            <summary>
            实例化一个对象，指定接收或是发送的数据长度
            </summary>
            <param name="length">数据长度</param>
        </member>
        <member name="P:HslCommunication.Core.Net.StateObject.UniqueId">
            <summary>
            唯一的一串信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateObject.WorkSocket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateObject.IsClose">
            <summary>
            是否关闭了通道
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.StateObject.Clear">
            <summary>
            清空旧的数据
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.StateObjectAsync`1">
            <summary>
            携带TaskCompletionSource属性的异步对象
            </summary>
            <typeparam name="T">类型</typeparam>
        </member>
        <member name="M:HslCommunication.Core.Net.StateObjectAsync`1.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.StateObjectAsync`1.#ctor(System.Int32)">
            <summary>
            实例化一个对象，指定接收或是发送的数据长度
            </summary>
            <param name="length">数据长度</param>
        </member>
        <member name="T:HslCommunication.Core.Net.StateOneBase">
            <summary>
            异步消息的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.DataLength">
            <summary>
            本次接收或是发送的数据长度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.AlreadyDealLength">
            <summary>
            已经处理的字节长度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.WaitDone">
            <summary>
            操作完成的信号
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.Buffer">
            <summary>
            缓存器
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.IsError">
            <summary>
            是否发生了错误
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.ErrerMsg">
            <summary>
            错误消息
            </summary>
        </member>
        <member name="T:HslCommunication.Core.NetSupport">
            <summary>
            静态的方法支持类，提供一些网络的静态支持，支持从套接字从同步接收指定长度的字节数据，并支持报告进度。<br />
            The static method support class provides some static support for the network, supports receiving byte data of a specified length from the socket from synchronization, and supports reporting progress.
            </summary>
            <remarks>
            在接收指定数量的字节数据的时候，如果一直接收不到，就会发生假死的状态。接收的数据时保存在内存里的，不适合大数据块的接收。
            </remarks>
        </member>
        <member name="F:HslCommunication.Core.NetSupport.SocketBufferSize">
            <summary>
            Socket传输中的缓冲池大小<br />
            Buffer pool size in socket transmission
            </summary>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.GetSplitLengthFromTotal(System.Int32)">
            <summary>
            根据接收数据的长度信息，合理的分割出单次的长度信息
            </summary>
            <param name="length">要接收数据的总长度信息</param>
            <returns>本次接收数据的长度</returns>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.ReadBytesFromSocket(System.Net.Sockets.Socket,System.Int32,System.Action{System.Int64,System.Int64})">
            <summary>
            从socket的网络中读取数据内容，需要指定数据长度和超时的时间，为了防止数据太大导致接收失败，所以此处接收到新的数据之后就更新时间。<br />
            To read the data content from the socket network, you need to specify the data length and timeout period. In order to prevent the data from being too large and cause the reception to fail, the time is updated after new data is received here.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="receive">接收的长度</param>
            <param name="reportProgress">当前接收数据的进度报告，有些协议支持传输非常大的数据内容，可以给与进度提示的功能</param>
            <returns>最终接收的指定长度的byte[]数据</returns>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.ReceiveBytesFromSocket(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32,System.Action{System.Int64,System.Int64})">
            <summary>
            从socket的网络中读取数据内容，需要指定数据长度和超时的时间，为了防止数据太大导致接收失败，所以此处接收到新的数据之后就更新时间。<br />
            To read the data content from the socket network, you need to specify the data length and timeout period. In order to prevent the data from being too large and cause the reception to fail, the time is updated after new data is received here.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="buffer">缓存的字节数组</param>
            <param name="offset">偏移信息</param>
            <param name="length">接收长度</param>
            <param name="reportProgress">当前接收数据的进度报告，有些协议支持传输非常大的数据内容，可以给与进度提示的功能</param>
            <exception cref="T:HslCommunication.Core.RemoteCloseException">远程关闭的异常信息</exception>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.ReceiveBytesFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Int32,System.Action{System.Int64,System.Int64})">
            <summary>
            从socket的网络中读取数据内容，然后写入到流中
            </summary>
            <param name="socket">网络套接字</param>
            <param name="stream">等待写入的流</param>
            <param name="length">长度信息</param>
            <param name="reportProgress">当前接收数据的进度报告，有些协议支持传输非常大的数据内容，可以给与进度提示的功能</param>
            <exception cref="T:HslCommunication.Core.RemoteCloseException">远程关闭的异常信息</exception>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.CreateSocketAndConnect(System.Net.IPEndPoint,System.Int32,System.Net.IPEndPoint)">
            <summary>
            创建一个新的socket对象并连接到远程的地址，需要指定远程终结点，超时时间（单位是毫秒），如果需要绑定本地的IP或是端口，传入 local对象<br />
            To create a new socket object and connect to the remote address, you need to specify the remote endpoint, 
            the timeout period (in milliseconds), if you need to bind the local IP or port, pass in the local object
            </summary>
            <param name="endPoint">连接的目标终结点</param>
            <param name="timeOut">连接的超时时间</param>
            <param name="local">如果需要绑定本地的IP地址，就需要设置当前的对象</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]},System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.CreateSocketAndConnectAsync(System.Net.IPEndPoint,System.Int32,System.Net.IPEndPoint)">
            <inheritdoc cref="M:HslCommunication.Core.NetSupport.CreateSocketAndConnect(System.Net.IPEndPoint,System.Int32,System.Net.IPEndPoint)"/>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.ReadFromCoreServerAsync(System.Collections.Generic.IEnumerable{System.Byte[]},System.Func{System.Byte[],System.Threading.Tasks.Task{HslCommunication.OperateResult{System.Byte[]}}})">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="T:HslCommunication.Core.Pipe.PipeBase">
            <summary>
            管道的基础类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeBase.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeBase.PipeLockEnter">
            <summary>
            进入管道的锁<br />
            Lock into the pipeline
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeBase.PipeLockLeave">
            <summary>
            离开管道的锁<br />
            Lock out of the pipeline
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeBase.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:HslCommunication.Core.Pipe.PipeSerial">
            <summary>
            串口的管道类对象，可以在不同的串口类中使用一个串口的通道信息<br />
            The pipe class object of the serial port can use the channel information of a serial port in different serial port classes
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.SerialPortInni(System.String,System.Int32,System.Int32,System.IO.Ports.StopBits,System.IO.Ports.Parity)">
            <summary>
            初始化串口信息，波特率，数据位，停止位，奇偶校验需要全部自己来指定<br />
            Start serial port information, baud rate, data bit, stop bit, parity all need to be specified
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
            <param name="dataBits">数据位</param>
            <param name="stopBits">停止位</param>
            <param name="parity">奇偶校验</param>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.SerialPortInni(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            根据自定义初始化方法进行初始化串口信息<br />
            Initialize the serial port information according to the custom initialization method
            </summary>
            <param name="initi">初始化的委托方法</param>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.Open">
            <summary>
            打开一个新的串行端口连接<br />
            Open a new serial port connection
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.IsOpen">
            <summary>
            获取一个值，指示串口是否处于打开状态<br />
            Gets a value indicating whether the serial port is open
            </summary>
            <returns>是或否</returns>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.Close(System.Func{System.IO.Ports.SerialPort,HslCommunication.OperateResult})">
            <summary>
            关闭当前的串口连接<br />
            Close the current serial connection
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSerial.RtsEnable">
            <summary>
            获取或设置一个值，该值指示在串行通信中是否启用请求发送 (RTS) 信号。<br />
            Gets or sets a value indicating whether the request sending (RTS) signal is enabled in serial communication.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.GetPipe">
            <summary>
            获取当前的串口对象信息<br />
            Get current serial port object information
            </summary>
            <returns>串口对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Pipe.PipeSocket">
            <summary>
            基于网络通信的管道信息，可以设置额外的一些参数信息，例如连接超时时间，读取超时时间等等。<br />
            Based on the pipe information of network communication, some additional parameter information can be set, such as connection timeout time, read timeout time and so on.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSocket.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSocket.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的IP地址和端口号来实例化一个对象<br />
            Instantiate an object with the specified IP address and port number
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSocket.IsConnectitonError">
            <summary>
            获取当前的连接状态是否有效<br />
            Get the current connection status is valid
            </summary>
            <returns>如果有效，返回 True, 否则返回 False</returns>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSocket.LocalBinding">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.LocalBinding"/>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSocket.IpAddress">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.IpAddress"/>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSocket.Port">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.Port"/>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSocket.IsSocketError">
            <summary>
            指示长连接的套接字是否处于错误的状态<br />
            Indicates if the long-connected socket is in the wrong state
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSocket.Socket">
            <summary>
            获取或设置当前的客户端用于服务器连接的套接字。<br />
            Gets or sets the socket currently used by the client for server connection.
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSocket.ConnectTimeOut">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ReceiveTimeOut"/>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSocket.ReceiveTimeOut">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ReceiveTimeOut"/>
        </member>
        <member name="P:HslCommunication.Core.Pipe.PipeSocket.SleepTime">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.SleepTime"/>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSocket.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.Core.Pipe.PipeSocket.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Security.AesCryptography">
            <summary>
            实例化一个AES加密解密的对象，默认 <see cref="F:System.Security.Cryptography.CipherMode.ECB"/> 模式的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Security.AesCryptography.#ctor(System.String,System.Security.Cryptography.CipherMode)">
            <summary>
            使用指定的密钥实例化一个AES加密解密的对象，密钥由32位数字或字母组成，例如 12345678123456781234567812345678
            </summary>
            <param name="key">密钥</param>
            <param name="mode">加密的模式，默认为 <see cref="F:System.Security.Cryptography.CipherMode.ECB"/></param>
        </member>
        <member name="M:HslCommunication.Core.Security.AesCryptography.Encrypt(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Security.ICryptography.Encrypt(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Security.AesCryptography.Decrypt(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Security.ICryptography.Decrypt(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Security.AesCryptography.Encrypt(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Security.ICryptography.Encrypt(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Security.AesCryptography.Decrypt(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Security.ICryptography.Decrypt(System.String)"/>
        </member>
        <member name="P:HslCommunication.Core.Security.AesCryptography.Key">
            <inheritdoc cref="P:HslCommunication.Core.Security.ICryptography.Key"/>
        </member>
        <member name="T:HslCommunication.Core.Security.DesCryptography">
            <summary>
            DES加密解密的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Security.DesCryptography.#ctor(System.String)">
            <summary>
            使用指定的密钥来实例化一个加密对象，该密钥右8位的字符和数字组成，例如 12345678
            </summary>
            <param name="key">密钥</param>
        </member>
        <member name="M:HslCommunication.Core.Security.DesCryptography.Encrypt(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Security.ICryptography.Encrypt(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Security.DesCryptography.Decrypt(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Security.ICryptography.Decrypt(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Security.DesCryptography.Encrypt(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Security.ICryptography.Encrypt(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Security.DesCryptography.Decrypt(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Security.ICryptography.Decrypt(System.String)"/>
        </member>
        <member name="P:HslCommunication.Core.Security.DesCryptography.Key">
            <inheritdoc cref="P:HslCommunication.Core.Security.ICryptography.Key"/>
        </member>
        <member name="T:HslCommunication.Core.Security.ICryptography">
            <summary>
            加密解密的数据接口<br />
            Encrypted and decrypted data interface
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Security.ICryptography.Encrypt(System.Byte[])">
            <summary>
            对原始的数据进行加密的操作，返回加密之后的二进制原始数据<br />
            Encrypt the original data and return the encrypted binary original data
            </summary>
            <param name="data">等待加密的数据</param>
            <returns>加密之后的二进制数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.ICryptography.Decrypt(System.Byte[])">
            <summary>
            对原始的数据进行解密的操作，返回解密之后的二进制原始数据<br />
            Decrypt the original data and return the decrypted binary original data
            </summary>
            <param name="data">等待解密的数据</param>
            <returns>解密之后的原始二进制数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.ICryptography.Encrypt(System.String)">
            <summary>
            针对字符串进行加密，并返回加密后的字符串数据，字符串的编码默认为UTF8，加密后返回Base64编码<br />
            Encrypt the string and return the encrypted string data. The encoding of the string is UTF8 by default. After encryption, the Base64 encoding is returned.
            </summary>
            <param name="data">等待加密的字符串</param>
            <returns>加密后的Base64编码</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.ICryptography.Decrypt(System.String)">
            <summary>
            针对Base64字符串进行解密操作，转为二进制数据后进行解密，解密之后使用UTF8编码获取最终的字符串数据<br />
            Decrypt the Base64 string, convert it to binary data, and decrypt it. After decryption, use UTF8 encoding to obtain the final string data.
            </summary>
            <param name="data">base64编码的字符串数据</param>
            <returns>最终的解析完成的字符串</returns>
        </member>
        <member name="P:HslCommunication.Core.Security.ICryptography.Key">
            <summary>
            当前加密的密钥信息<br />
            currently encrypted key information
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Security.RSAHelper">
            <summary>
            RSA加密解密算法的辅助方法，可以用PEM格式的密钥创建公钥，或是私钥对象，然后用来加解密操作。
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Security.RSAHelper.CreateRsaProviderFromPrivateKey(System.String)">
            <summary>
            使用 PEM 格式基于base64编码的私钥来创建一个 RSA 算法加密解密的对象，可以直接用于加密解密操作<br />
            Use the PEM format based on the base64-encoded private key to create an RSA algorithm encryption and decryption object, 
            which can be directly used for encryption and decryption operations
            </summary>
            <param name="privateKeyString">私钥</param>
            <returns>RSA 算法的加密解密对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.RSAHelper.CreateRsaProviderFromPrivateKey(System.Byte[])">
            <summary>
            使用原始的私钥数据（PEM格式）来创建一个 RSA 算法加密解密的对象，可以直接用于加密解密操作<br />
            Use the original private key data (PEM format) to create an RSA algorithm encryption and decryption object, 
            which can be directly used for encryption and decryption operations
            </summary>
            <param name="privateKey">原始的私钥数据</param>
            <returns>RSA 算法的加密解密对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.RSAHelper.GetPrivateKeyFromRSA(System.Security.Cryptography.RSACryptoServiceProvider)">
            <summary>
            从RSA的算法对象里，获取到PEM格式的原始私钥数据，如果需要存储，或是显示，只需要 Convert.ToBase64String 方法<br />
            Obtain the original private key data in PEM format from the RSA algorithm object. If you need to store or display it, 
            you only need the Convert.ToBase64String method
            </summary>
            <param name="rsa">RSA 算法的加密解密对象</param>
            <returns>原始的私钥数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.RSAHelper.GetPublicKeyFromRSA(System.Security.Cryptography.RSACryptoServiceProvider)">
            <summary>
            从RSA的算法对象里，获取到PEM格式的原始公钥数据，如果需要存储，或是显示，只需要 Convert.ToBase64String 方法<br />
            Obtain the original public key data in PEM format from the RSA algorithm object. If you need to store or display it, 
            you only need the Convert.ToBase64String method
            </summary>
            <param name="rsa">RSA 算法的加密解密对象</param>
            <returns>原始的公钥数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.RSAHelper.CreateRsaProviderFromPublicKey(System.String)">
            <summary>
            PEM 格式基于base64编码的公钥来创建一个 RSA 算法加密解密的对象，可以直接用于加密或是验证签名操作<br />
            Use the original public key data (PEM format) to create an RSA algorithm encryption and decryption object, 
            which can be directly used for encryption or signature verification
            </summary>
            <param name="publicKeyString">公钥</param>
            <returns>RSA 算法的加密解密对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.RSAHelper.EncryptLargeDataByRSA(System.Security.Cryptography.RSACryptoServiceProvider,System.Byte[])">
            <summary>
            对原始字节的数据进行加密，不限制长度，因为RSA本身限制了117字节，所以此处进行数据切割加密。<br />
            Encrypt the original byte data without limiting the length, because RSA itself limits 117 bytes, so the data is cut and encrypted here.
            </summary>
            <param name="provider">RSA公钥对象</param>
            <param name="data">等待加密的原始数据</param>
            <returns>加密之后的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.RSAHelper.DecryptLargeDataByRSA(System.Security.Cryptography.RSACryptoServiceProvider,System.Byte[])">
            <summary>
            对超过117字节限制的加密数据进行加密，因为RSA本身限制了117字节，所以此处进行数据切割解密。<br />
            </summary>
            <param name="provider">RSA私钥对象</param>
            <param name="data">等待解密的数据</param>
            <returns>解密之后的结果数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Security.RSAHelper.CreateRsaProviderFromPublicKey(System.Byte[])">
            <summary>
            使用原始的公钥数据（PEM格式）来创建一个 RSA 算法加密解密的对象，可以直接用于加密或是验证签名操作<br />
            Use the original public key data (PEM format) to create an RSA algorithm encryption and decryption object, 
            which can be directly used for encryption or signature verification
            </summary>
            <param name="publicKey">公钥</param>
            <returns>RSA 算法的加密解密对象</returns>
        </member>
        <member name="T:HslCommunication.Core.CoordinationStatus">
            <summary>
            线程的协调逻辑状态
            </summary>
        </member>
        <member name="F:HslCommunication.Core.CoordinationStatus.AllDone">
            <summary>
            所有项完成
            </summary>
        </member>
        <member name="F:HslCommunication.Core.CoordinationStatus.Timeout">
            <summary>
            超时
            </summary>
        </member>
        <member name="F:HslCommunication.Core.CoordinationStatus.Cancel">
            <summary>
            任务取消
            </summary>
        </member>
        <member name="T:HslCommunication.Core.AsyncCoordinator">
            <summary>
            一个线程协调逻辑类，详细参考书籍《CLR Via C#》page:681
            这个类可惜没有报告进度的功能
            </summary>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.AboutToBegin(System.Int32)">
            <summary>
            每次的操作任务开始前必须调用该方法
            </summary>
            <param name="opsToAdd"></param>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.JustEnded">
            <summary>
            在一次任务处理好操作之后，必须调用该方法
            </summary>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.AllBegun(System.Action{HslCommunication.Core.CoordinationStatus},System.Int32)">
            <summary>
            该方法必须在发起所有的操作之后调用
            </summary>
            <param name="callback">回调方法</param>
            <param name="timeout">超时时间</param>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.TimeExpired(System.Object)">
            <summary>
            超时的方法
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.Cancel">
            <summary>
            取消任务的执行
            </summary>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.ReportStatus(HslCommunication.Core.CoordinationStatus)">
            <summary>
            生成一次报告
            </summary>
            <param name="status">报告的状态</param>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.Maxinum(System.Int32@,System.Func{System.Int32,System.Int32})">
            <summary>
            乐观的并发方法模型，具体参照《CLR Via C#》page:686
            </summary>
            <param name="target">唯一的目标数据</param>
            <param name="change">修改数据的算法</param>
            <returns></returns>
        </member>
        <member name="T:HslCommunication.Core.HslAsyncCoordinator">
            <summary>
            一个用于高性能，乐观并发模型控制操作的类，允许一个方法(隔离方法)的安全单次执行
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslAsyncCoordinator.#ctor(System.Action)">
            <summary>
            实例化一个对象，需要传入隔离执行的方法
            </summary>
            <param name="operater">隔离执行的方法</param>
        </member>
        <member name="M:HslCommunication.Core.HslAsyncCoordinator.StartOperaterInfomation">
            <summary>
            启动线程池执行隔离方法
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslAsyncCoordinator.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.HslReadWriteLock">
            <summary>
            一个高性能的读写锁，支持写锁定，读灵活，读时写锁定，写时读锁定
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.ToString">
            <summary>
            返回本对象的描述字符串
            </summary>
            <returns>对象的描述字符串</returns>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.#ctor">
            <summary>
            实例化一个读写锁的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.Enter(System.Boolean)">
            <summary>
            根据读写情况请求锁
            </summary>
            <param name="exclusive">True为写请求，False为读请求</param>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.Leave">
            <summary>
            释放锁，将根据锁状态自动区分读写锁
            </summary>
        </member>
        <member name="T:HslCommunication.Core.SimpleHybirdLock">
            <summary>
            一个简单的混合线程同步锁，采用了基元用户加基元内核同步构造实现<br />
            A simple hybrid thread editing lock, implemented by the base user plus the element kernel synchronization.
            </summary>
            <remarks>
            当前的锁适用于，竞争频率比较低，锁部分的代码运行时间比较久的情况，当前的简单混合锁可以达到最大性能。
            </remarks>
            <example>
            以下演示常用的锁的使用方式，还包含了如何优雅的处理异常锁
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\ThreadLock.cs" region="SimpleHybirdLockExample1" title="SimpleHybirdLock示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.SimpleHybirdLock.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="F:HslCommunication.Core.SimpleHybirdLock.m_waiters">
            <summary>
            基元用户模式构造同步锁
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SimpleHybirdLock.m_waiterLock">
            <summary>
            基元内核模式构造同步锁
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SimpleHybirdLock.Enter">
            <summary>
            获取锁
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SimpleHybirdLock.Leave">
            <summary>
            离开锁
            </summary>
        </member>
        <member name="P:HslCommunication.Core.SimpleHybirdLock.IsWaitting">
            <summary>
            获取当前锁是否在等待当中
            </summary>
        </member>
        <member name="P:HslCommunication.Core.SimpleHybirdLock.SimpleHybirdLockCount">
            <summary>
            获取当前总的所有进入锁的信息<br />
            Get the current total information of all access locks
            </summary>
        </member>
        <member name="P:HslCommunication.Core.SimpleHybirdLock.SimpleHybirdLockWaitCount">
            <summary>
            当前正在等待的锁的统计信息，此时已经发生了竞争了
            </summary>
        </member>
        <member name="T:HslCommunication.Core.SoftMultiTask`1">
            <summary>
            一个用于多线程并发处理数据的模型类，适用于处理数据量非常庞大的情况
            </summary>
            <typeparam name="T">等待处理的数据类型</typeparam>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.#ctor(`0[],System.Func{`0,System.Boolean},System.Int32)">
            <summary>
            实例化一个数据处理对象
            </summary>
            <param name="dataList">数据处理列表</param>
            <param name="operater">数据操作方法，应该是相对耗时的任务</param>
            <param name="threadCount">需要使用的线程数</param>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_opCount">
            <summary>
            操作总数，判定操作是否完成
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_opThreadCount">
            <summary>
            判断是否所有的线程是否处理完成
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_threadCount">
            <summary>
            准备启动的处理数据的线程数量
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_runStatus">
            <summary>
            指示多线程处理是否在运行中，防止冗余调用
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_dataList">
            <summary>
            列表数据
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_operater">
            <summary>
            需要操作的方法
            </summary>
        </member>
        <member name="T:HslCommunication.Core.SoftMultiTask`1.MultiInfo">
            <summary>
            一个双参数委托
            </summary>
            <param name="item"></param>
            <param name="ex"></param>
        </member>
        <member name="T:HslCommunication.Core.SoftMultiTask`1.MultiInfoTwo">
            <summary>
            用于报告进度的委托，当finish等于count时，任务完成
            </summary>
            <param name="finish">已完成操作数量</param>
            <param name="count">总数量</param>
            <param name="success">成功数量</param>
            <param name="failed">失败数量</param>
        </member>
        <member name="E:HslCommunication.Core.SoftMultiTask`1.OnExceptionOccur">
            <summary>
            异常发生时事件
            </summary>
        </member>
        <member name="E:HslCommunication.Core.SoftMultiTask`1.OnReportProgress">
            <summary>
            报告处理进度时发生
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_finishCount">
            <summary>
            已处理完成数量，无论是否异常
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_successCount">
            <summary>
            处理完成并实现操作数量
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_failedCount">
            <summary>
            处理过程中异常数量
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.HybirdLock">
            <summary>
            用于触发事件的混合线程锁
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_isRunningStop">
            <summary>
            指示处理状态是否为暂停状态
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_isQuit">
            <summary>
            指示系统是否需要强制退出
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_isQuitAfterException">
            <summary>
            在发生错误的时候是否强制退出后续的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.StartOperater">
            <summary>
            启动多线程进行数据处理
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.StopOperater">
            <summary>
            暂停当前的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.ResumeOperater">
            <summary>
            恢复暂停的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.EndedOperater">
            <summary>
            直接手动强制结束操作
            </summary>
        </member>
        <member name="P:HslCommunication.Core.SoftMultiTask`1.IsQuitAfterException">
            <summary>
            在发生错误的时候是否强制退出后续的操作
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Singleton">
            <summary>
            一个双检锁的示例，适合一些占内存的静态数据对象，获取的时候才实例化真正的对象
            </summary>
        </member>
        <member name="T:HslCommunication.Core.AdvancedHybirdLock">
            <summary>
            一个高级的混合线程同步锁，采用了基元用户加基元内核同步构造实现，并包含了自旋和线程所有权
            </summary>
            <remarks>
            当竞争的频率很高的时候，锁的时间很短的时候，当前的锁可以获得最大性能。
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.AdvancedHybirdLock.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="P:HslCommunication.Core.AdvancedHybirdLock.SpinCount">
            <summary>
            自旋锁的自旋周期，当竞争频率小，就要设置小，当竞争频率大，就要设置大，锁时间长就设置小，锁时间短就设置大，这样才能达到真正的高性能，默认为1000
            </summary>
        </member>
        <member name="M:HslCommunication.Core.AdvancedHybirdLock.Enter">
            <summary>
            获取锁
            </summary>
        </member>
        <member name="M:HslCommunication.Core.AdvancedHybirdLock.Leave">
            <summary>
            离开锁
            </summary>
        </member>
        <member name="T:HslCommunication.Core.ByteTransformBase">
            <summary>
            数据转换类的基础，提供了一些基础的方法实现，默认 <see cref="F:HslCommunication.Core.DataFormat.CDAB"/> 的顺序，和C#的字节顺序是一致的。<br />
            The basis of the data conversion class provides some basic method implementations. 
            The default order of <see cref="F:HslCommunication.Core.DataFormat.CDAB"/> is consistent with the byte order of C#.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.#ctor(HslCommunication.Core.DataFormat)">
            <summary>
            使用指定的数据解析来实例化对象<br />
            Instantiate the object using the specified data parsing
            </summary>
            <param name="dataFormat">数据规则</param>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransBool(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransBool(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransBool(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransBool(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt16(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt16(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt16(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt16(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt32(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt32(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt32(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt32(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt32(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt32(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt64(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt64(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt64(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt64(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt64(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt64(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransSingle(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransSingle(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransSingle(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransDouble(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransDouble(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransDouble(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransString(System.Byte[],System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransString(System.Byte[],System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.ByteTransDataFormat4(System.Byte[],System.Int32)">
            <summary>
            反转多字节的数据信息
            </summary>
            <param name="value">数据字节</param>
            <param name="index">起始索引，默认值为0</param>
            <returns>实际字节信息</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.ByteTransDataFormat8(System.Byte[],System.Int32)">
            <summary>
            反转多字节的数据信息
            </summary>
            <param name="value">数据字节</param>
            <param name="index">起始索引，默认值为0</param>
            <returns>实际字节信息</returns>
        </member>
        <member name="P:HslCommunication.Core.ByteTransformBase.DataFormat">
            <inheritdoc cref="P:HslCommunication.Core.IByteTransform.DataFormat"/>
        </member>
        <member name="P:HslCommunication.Core.ByteTransformBase.IsStringReverseByteWord">
            <inheritdoc cref="P:HslCommunication.Core.IByteTransform.IsStringReverseByteWord"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.CreateByDateFormat(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.CreateByDateFormat(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.ByteTransformHelper">
            <summary>
            所有数据转换类的静态辅助方法<br />
            Static helper method for all data conversion classes
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromBytes``1(HslCommunication.OperateResult{System.Byte[]},System.Func{System.Byte[],``0})">
            <summary>
            结果转换操作的基础方法，需要支持类型，及转换的委托，并捕获转换时的异常方法
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <param name="result">源</param>
            <param name="translator">实际转换的委托</param>
            <returns>转换结果</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromArray``1(HslCommunication.OperateResult{``0[]})">
            <summary>
            结果转换操作的基础方法，需要支持类型，及转换的委托
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <param name="result">源结果</param>
            <returns>转换结果</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetSuccessResultFromOther``2(HslCommunication.OperateResult{``1},System.Func{``1,``0})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容，所转换的规则
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn">输入类型</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans">转换方法，从类型TIn转换拿到TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``1(HslCommunication.OperateResult{``0},System.Func{``0,HslCommunication.OperateResult})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TIn">输入类型</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans">转换方法，从类型TIn转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``2(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn">输入类型</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans">转换方法，从类型TIn转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``3(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``4(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``5(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``6(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``7(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``8(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``7}},System.Func{``7,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <typeparam name="TIn7">输入类型7</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TIn7的泛型委托</param>
            <param name="trans7">转换方法7，从类型TIn7转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``9(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``7}},System.Func{``7,HslCommunication.OperateResult{``8}},System.Func{``8,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <typeparam name="TIn7">输入类型7</typeparam>
            <typeparam name="TIn8">输入类型8</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TIn7的泛型委托</param>
            <param name="trans7">转换方法7，从类型TIn7转换拿到OperateResult的TIn8的泛型委托</param>
            <param name="trans8">转换方法8，从类型TIn8转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``10(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``7}},System.Func{``7,HslCommunication.OperateResult{``8}},System.Func{``8,HslCommunication.OperateResult{``9}},System.Func{``9,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <typeparam name="TIn7">输入类型7</typeparam>
            <typeparam name="TIn8">输入类型8</typeparam>
            <typeparam name="TIn9">输入类型9</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TIn7的泛型委托</param>
            <param name="trans7">转换方法7，从类型TIn7转换拿到OperateResult的TIn8的泛型委托</param>
            <param name="trans8">转换方法8，从类型TIn8转换拿到OperateResult的TIn9的泛型委托</param>
            <param name="trans9">转换方法9，从类型TIn9转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``11(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``7}},System.Func{``7,HslCommunication.OperateResult{``8}},System.Func{``8,HslCommunication.OperateResult{``9}},System.Func{``9,HslCommunication.OperateResult{``10}},System.Func{``10,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <typeparam name="TIn7">输入类型7</typeparam>
            <typeparam name="TIn8">输入类型8</typeparam>
            <typeparam name="TIn9">输入类型9</typeparam>
            <typeparam name="TIn10">输入类型10</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TIn7的泛型委托</param>
            <param name="trans7">转换方法7，从类型TIn7转换拿到OperateResult的TIn8的泛型委托</param>
            <param name="trans8">转换方法8，从类型TIn8转换拿到OperateResult的TIn9的泛型委托</param>
            <param name="trans9">转换方法9，从类型TIn9转换拿到OperateResult的TIn10的泛型委托</param>
            <param name="trans10">转换方法10，从类型TIn10转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="T:HslCommunication.Core.DataFormat">
            <summary>
            应用于多字节数据的解析或是生成格式<br />
            Parsing or generating format for multibyte data
            </summary>
        </member>
        <member name="F:HslCommunication.Core.DataFormat.ABCD">
            <summary>
            按照顺序排序
            </summary>
        </member>
        <member name="F:HslCommunication.Core.DataFormat.BADC">
            <summary>
            按照单字反转
            </summary>
        </member>
        <member name="F:HslCommunication.Core.DataFormat.CDAB">
            <summary>
            按照双字反转
            </summary>
        </member>
        <member name="F:HslCommunication.Core.DataFormat.DCBA">
            <summary>
            按照倒序排序
            </summary>
        </member>
        <member name="T:HslCommunication.Core.IByteTransform">
            <summary>
            支持转换器的基础接口，规定了实际的数据类型和字节数组进行相互转换的方法。主要为<see cref="T:System.Boolean"/>,<see cref="T:System.Byte"/>,<see cref="T:System.Int16"/>,<see cref="T:System.UInt16"/>,<see cref="T:System.Int32"/>,<see cref="T:System.UInt32"/>,
            <see cref="T:System.Int64"/>,<see cref="T:System.UInt64"/>,<see cref="T:System.Single"/>,<see cref="T:System.Double"/>,<see cref="T:System.String"/>之间的变换关系<br />
            Support the basic interface of the converter, and stipulate the method of mutual conversion between actual data types and byte arrays. Mainly <see cref="T:System.Boolean"/>,<see cref="T:System.Byte"/>,
            <see cref="T:System.Int16"/>,<see cref="T:System.UInt16"/>,<see cref="T:System.Int32"/>,<see cref="T:System.UInt32"/>,<see cref="T:System.Int64"/>,<see cref="T:System.UInt64"/>,<see cref="T:System.Single"/>,<see cref="T:System.Double"/>,
            <see cref="T:System.String"/>The transformation relationship between
            </summary>
            <remarks>
            所有的设备通讯类都内置了该转换的模型，并且已经配置好数据的高地位模式，可以方便的转换信息，当然您也可以手动修改<see cref="P:HslCommunication.Core.IByteTransform.DataFormat"/>属性来满足更加特殊的场景<br />
            All device communication classes have a built-in conversion model, and the high-status mode of the data has been configured, 
            which can easily convert the information. Of course, you can also manually modify the <see cref="P:HslCommunication.Core.IByteTransform.DataFormat"/> attribute to meet more special requirements.
            </remarks>
            <example>
            事实上来说，在不同的PLC设备里，对数据类型的描述通常有所区别。比如说一般PLC所说的字数据，int数据，对于C#来说则是short，ushort。
            </example>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransBool(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取出bool结果，需要传入想要提取的位索引，注意：是从0开始的位索引，10则表示 buffer[1] 的第二位。<br />
            To extract the bool result from the cache, you need to pass in the bit index you want to extract. Note: the bit index starts from 0, and 10 represents the second bit of buffer[1].
            </summary>
            <param name="buffer">等待提取的缓存数据</param>
            <param name="index">位的索引，注意：是从0开始的位索引，10则表示 buffer[1] 的第二位。</param>
            <returns>表示不是 <c>true</c> 就是 <c>false</c> 的 bool 数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransBool(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取出bool数组结果，需要传入想要提取的位索引，注意：是从0开始的位索引，10则表示 buffer[1] 的第二位。长度为 bool 数量的长度，传入 10 则获取 10 个长度的 bool[] 数组。<br />
            To extract the result of the bool array from the cache, you need to pass in the bit index you want to extract. Note: the bit index starts from 0, 
            and 10 represents the second bit of buffer[1]. The length is the length of the number of bools. If you pass in 10, you will get a bool[] array of 10 lengths.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的起始索引，需要传入想要提取的位索引，注意：是从0开始的位索引，10则表示 buffer[1] 的第二位</param>
            <param name="length">读取的 bool 长度，按照位为单位，传入 10 则表示获取 10 个长度的 bool[] </param>
            <returns>bool数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取byte结果，需要指定起始的字节索引<br />
            To extract the byte result from the cache, you need to specify the starting byte index
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>byte对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取byte数组结果，需要指定起始的字节索引，以及指定读取的字节长度<br />
            To extract the byte array result from the cache, you need to specify the starting byte index and the byte length to be read
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>byte数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取short结果，需要指定起始的字节索引，按照字节为单位，一个short占用两个字节<br />
            To extract short results from the cache, you need to specify the starting byte index, in bytes, A short occupies two bytes
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>short对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取short数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 short 数组的长度，如果传入 10 ，则表示提取 10 个连续的 short 数据，该数据共占用 20 字节。<br />
            To extract the result of the short array from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the extracted short array. If 10 is passed in, it means to extract 10 consecutive short data. Occupies 20 bytes.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>short数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            从缓存中提取short二维数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 short 数组的行和列的长度，按照 short 为单位的个数。<br />
            To extract the result of a short two-dimensional array from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the rows and columns of the extracted short array, in terms of the number of shorts.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="row">二维数组行</param>
            <param name="col">二维数组列</param>
            <returns>二维short数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ushort结果，需要指定起始的字节索引，按照字节为单位，一个ushort占用两个字节<br />
            To extract ushort results from the cache, you need to specify the starting byte index, in bytes, A ushort occupies two bytes
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ushort对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ushort数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 ushort 数组的长度，如果传入 10 ，则表示提取 10 个连续的 ushort 数据，该数据共占用 20 字节。<br />
            To extract the ushort array result from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the extracted ushort array. If 10 is passed in, it means to extract 10 consecutive ushort data. Occupies 20 bytes.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ushort数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            从缓存中提取ushort二维数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 ushort 数组的行和列的长度，按照 ushort 为单位的个数。<br />
            To extract the result of the ushort two-dimensional array from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the rows and columns of the extracted ushort array, in terms of the number of ushorts.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="row">二维数组行</param>
            <param name="col">二维数组列</param>
            <returns>二维ushort数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取int结果，需要指定起始的字节索引，按照字节为单位，一个int占用四个字节<br />
            To extract the int result from the cache, you need to specify the starting byte index, in bytes, A int occupies four bytes
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>int对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取int数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 int 数组的长度，如果传入 10 ，则表示提取 10 个连续的 int 数据，该数据共占用 40 字节。<br />
            To extract the int array result from the cache, you need to specify the starting byte index, in bytes,
            and then specify the length of the extracted int array. If 10 is passed in, it means to extract 10 consecutive int data. Occupies 40 bytes.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>int数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            从缓存中提取int二维数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 int 数组的行和列的长度，按照 int 为单位的个数。<br />
            To extract the result of an int two-dimensional array from the cache, you need to specify the starting byte index, 
            in bytes, and then specify the length of the rows and columns of the extracted int array, in the number of int units.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="row">二维数组行</param>
            <param name="col">二维数组列</param>
            <returns>二维int数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取uint结果，需要指定起始的字节索引，按照字节为单位，一个uint占用四个字节<br />
            To extract uint results from the cache, you need to specify the starting byte index, in bytes, A uint occupies four bytes
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>uint对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取uint数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 uint 数组的长度，如果传入 10 ，则表示提取 10 个连续的 uint 数据，该数据共占用 40 字节。<br />
            To extract the uint array result from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the extracted uint array. If 10 is passed in, it means to extract 10 consecutive uint data. Occupies 40 bytes.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>uint数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            从缓存中提取uint二维数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 uint 数组的行和列的长度，按照 uint 为单位的个数。<br />
            To extract the result of a uint two-dimensional array from the cache, you need to specify the starting byte index, 
            in bytes, and then specify the length of the rows and columns of the extracted uint array, in terms of uint as the unit.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="row">二维数组行</param>
            <param name="col">二维数组列</param>
            <returns>uint二维数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取long结果，需要指定起始的字节索引，按照字节为单位，一个long占用八个字节<br />
            To extract the long result from the cache, you need to specify the starting byte index, in bytes, A long occupies eight bytes
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>long对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取long数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 long 数组的长度，如果传入 10 ，则表示提取 10 个连续的 long 数据，该数据共占用 80 字节。<br />
            To extract the long array result from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the long array to be extracted. If 10 is passed in, it means to extract 10 consecutive long data. Occupies 80 bytes.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>long数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            从缓存中提取long二维数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 long 数组的行和列的长度，按照 long 为单位的个数。<br />
            To extract the result of a long two-dimensional array from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the rows and columns of the extracted long array, in long as the number of units.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="row">二维数组行</param>
            <param name="col">二维数组列</param>
            <returns>long二维数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ulong结果，需要指定起始的字节索引，按照字节为单位，一个ulong占用八个字节<b />
            To extract the ulong result from the cache, you need to specify the starting byte index, in bytes, A ulong occupies eight bytes
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ulong对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ulong数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 ulong 数组的长度，如果传入 10 ，则表示提取 10 个连续的 ulong 数据，该数据共占用 80 字节。<br />
            To extract the ulong array result from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the extracted ulong array. If 10 is passed in, it means to extract 10 consecutive ulong data. Occupies 80 bytes.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ulong数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            从缓存中提取ulong二维数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 ulong 数组的行和列的长度，按照 ulong 为单位的个数。<br />
            To extract the result of the ulong two-dimensional array from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the rows and columns of the extracted ulong array, in the number of ulong units.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="row">二维数组行</param>
            <param name="col">二维数组列</param>
            <returns>ulong二维数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取float结果，需要指定起始的字节索引，按照字节为单位，一个float占用四个字节<b />
            To extract the float result from the cache, you need to specify the starting byte index, in units of bytes, A float occupies four bytes
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>float对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取float数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 float 数组的长度，如果传入 10 ，则表示提取 10 个连续的 float 数据，该数据共占用 40 字节。<br />
            To extract the result of the float array from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the extracted float array. If 10 is passed in, it means that 10 consecutive float data are extracted. Occupies 40 bytes.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>float数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            从缓存中提取float二维数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 float 数组的行和列的长度，按照 float 为单位的个数。<br />
            To extract the result of a float two-dimensional array from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the rows and columns of the extracted float array, in terms of the number of floats.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="row">二维数组行</param>
            <param name="col">二维数组列</param>
            <returns>float二维数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取double结果，需要指定起始的字节索引，按照字节为单位，一个double占用八个字节<br />
            To extract the double result from the cache, you need to specify the starting byte index, in bytes, A double occupies eight bytes
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>double对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取double数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 double 数组的长度，如果传入 10 ，则表示提取 10 个连续的 double 数据，该数据共占用 80 字节。<br />
            To extract the double array result from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the extracted double array. If 10 is passed in, it means to extract 10 consecutive double data. Occupies 80 bytes.
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>double数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            从缓存中提取double二维数组结果，需要指定起始的字节索引，按照字节为单位，然后指定提取的 double 数组的行和列的长度，按照 double 为单位的个数。<br />
            To extract the result of a double two-dimensional array from the cache, you need to specify the starting byte index, in bytes, 
            and then specify the length of the rows and columns of the extracted double array, in terms of the number of doubles.
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="row">二维数组行</param>
            <param name="col">二维数组列</param>
            <returns>double二维数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransString(System.Byte[],System.Text.Encoding)">
            <summary>
            从缓存中提取string结果，使用指定的编码将全部的缓存转为字符串<br />
            Extract the string result from the cache, use the specified encoding to convert all the cache into a string
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="encoding">字符串的编码</param>
            <returns>string对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            从缓存中的部分字节数组转化为string结果，使用指定的编码，指定起始的字节索引，字节长度信息。<br />
            Convert a part of the byte array in the buffer into a string result, use the specified encoding, specify the starting byte index, and byte length information.
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">byte数组长度</param>
            <param name="encoding">字符串的编码</param>
            <returns>string对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Boolean)">
            <summary>
            bool变量转化缓存数据，一般来说单bool只能转化为0x01 或是 0x00<br />
            The bool variable is converted to cache data, a single bool can only be converted to 0x01 or 0x00
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Boolean[])">
            <summary>
            将bool数组变量转化缓存数据，如果数组长度不满足8的倍数，则自动补0操作。<br />
            Convert the bool array variable to the cache data. If the length of the array does not meet a multiple of 8, it will automatically add 0.
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte)">
            <summary>
            将byte变量转化缓存数据<br />
            Convert byte variables into cached data
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16)">
            <summary>
            short变量转化缓存数据，一个short数据可以转为2个字节的byte数组<br />
            Short variable is converted to cache data, a short data can be converted into a 2-byte byte array
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16[])">
            <summary>
            short数组变量转化缓存数据，n个长度的short数组，可以转为2*n个长度的byte数组<br />
            The short array variable transforms the buffered data, a short array of n lengths can be converted into a byte array of 2*n lengths
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16)">
            <summary>
            ushort变量转化缓存数据，一个ushort数据可以转为2个字节的Byte数组<br />
            ushort variable converts buffer data, a ushort data can be converted into a 2-byte Byte array
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16[])">
            <summary>
            ushort数组变量转化缓存数据，n个长度的ushort数组，可以转为2*n个长度的byte数组<br />
            The ushort array variable transforms the buffer data, the ushort array of n length can be converted into a byte array of 2*n length
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32)">
            <summary>
            int变量转化缓存数据，一个int数据可以转为4个字节的byte数组<br />
            Int variable converts cache data, an int data can be converted into a 4-byte byte array
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32[])">
            <summary>
            int数组变量转化缓存数据，n个长度的int数组，可以转为4*n个长度的byte数组<br />
            The int array variable transforms the cache data, the int array of n length can be converted to the byte array of 4*n length
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32)">
            <summary>
            uint变量转化缓存数据，一个uint数据可以转为4个字节的byte数组<br />
            uint variable converts buffer data, a uint data can be converted into a 4-byte byte array
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32[])">
            <summary>
            uint数组变量转化缓存数据，n个长度的uint数组，可以转为4*n个长度的byte数组<br />
            uint array variable converts buffer data, uint array of n length can be converted to byte array of 4*n length
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64)">
            <summary>
            long变量转化缓存数据，一个long数据可以转为8个字节的byte数组<br />
            Long variable is converted into cache data, a long data can be converted into 8-byte byte array
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64[])">
            <summary>
            long数组变量转化缓存数据，n个长度的long数组，可以转为8*n个长度的byte数组<br />
            The long array variable transforms the buffer data, the long array of n length can be converted into the byte array of 8*n length
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64)">
            <summary>
            ulong变量转化缓存数据，一个ulong数据可以转为8个字节的byte数组<br />
            Ulong variable converts cache data, a ulong data can be converted into 8-byte byte array
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64[])">
            <summary>
            ulong数组变量转化缓存数据，n个长度的ulong数组，可以转为8*n个长度的byte数组<br />
            The ulong array variable transforms the buffer data, the ulong array of n length can be converted to the byte array of 8*n length
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Single)">
            <summary>
            float变量转化缓存数据，一个float数据可以转为4个字节的byte数组<br />
            Float variable is converted into cache data, a float data can be converted into a 4-byte byte array
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Single[])">
            <summary>
            float数组变量转化缓存数据，n个长度的float数组，可以转为4*n个长度的byte数组<br />
            Float array variable converts buffer data, n-length float array can be converted into 4*n-length byte array
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Double)">
            <summary>
            double变量转化缓存数据，一个double数据可以转为8个字节的byte数组<br />
            The double variable is converted to cache data, a double data can be converted into an 8-byte byte array
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Double[])">
            <summary>
            double数组变量转化缓存数据，n个长度的double数组，可以转为8*n个长度的byte数组<br />
            The double array variable transforms the buffer data, the double array of n length can be converted to the byte array of 8*n length
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.String,System.Text.Encoding)">
            <summary>
            使用指定的编码字符串转化缓存数据<br />
            Use the specified encoding string to convert the cached data
            </summary>
            <param name="value">等待转化的数据</param>
            <param name="encoding">字符串的编码方式</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.String,System.Int32,System.Text.Encoding)">
            <summary>
            使用指定的编码字符串转化缓存数据，指定转换之后的字节长度信息<br />
            Use the specified encoding string to convert the cached data, specify the byte length information after conversion
            </summary>
            <param name="value">等待转化的数据</param>
            <param name="length">转换之后的数据长度</param>
            <param name="encoding">字符串的编码方式</param>
            <returns>buffer数据</returns>
        </member>
        <member name="P:HslCommunication.Core.IByteTransform.DataFormat">
            <summary>
            获取或设置数据解析的格式，可选ABCD, BADC，CDAB，DCBA格式，对int,uint,float,double,long,ulong类型有作用<br />
            Get or set the format of the data analysis, optional ABCD, BADC, CDAB, DCBA format, effective for int, uint, float, double, long, ulong type
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IByteTransform.IsStringReverseByteWord">
            <summary>
            获取或设置在解析字符串的时候是否将字节按照字单位反转<br />
            Gets or sets whether to reverse the bytes in word units when parsing strings
            </summary>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.CreateByDateFormat(HslCommunication.Core.DataFormat)">
            <summary>
            根据指定的<see cref="P:HslCommunication.Core.IByteTransform.DataFormat"/>格式，来实例化一个新的对象，除了<see cref="P:HslCommunication.Core.IByteTransform.DataFormat"/>不同，其他都相同<br />
            According to the specified <see cref="P:HslCommunication.Core.IByteTransform.DataFormat"/> format, to instantiate a new object, except that <see cref="P:HslCommunication.Core.IByteTransform.DataFormat"/> is different, everything else is the same
            </summary>
            <param name="dataFormat">数据格式</param>
            <returns>新的<see cref="T:HslCommunication.Core.IByteTransform"/>对象</returns>
        </member>
        <member name="T:HslCommunication.Core.RegularByteTransform">
            <summary>
            常规的字节转换类<br />
            Regular byte conversion class
            </summary>
        </member>
        <member name="M:HslCommunication.Core.RegularByteTransform.#ctor">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor"/>
        </member>
        <member name="M:HslCommunication.Core.RegularByteTransform.#ctor(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.RegularByteTransform.CreateByDateFormat(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.CreateByDateFormat(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.RegularByteTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.ReverseBytesTransform">
            <summary>
            字节倒序的转换类，字节的顺序和C#的原生字节的顺序是完全相反的，高字节在前，低字节在后。<br />
            In the reverse byte order conversion class, the byte order is completely opposite to the native byte order of C#, 
            with the high byte first and the low byte following.
            </summary>
            <remarks>
            适用西门子PLC的S7协议的数据转换
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.#ctor">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.#ctor(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransUInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.CreateByDateFormat(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.CreateByDateFormat(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.ReverseWordTransform">
            <summary>
            按照字节错位的数据转换类<br />
            Data conversion class according to byte misalignment
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.#ctor">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.#ctor(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="P:HslCommunication.Core.ReverseWordTransform.IsInteger16Reverse">
            <summary>
            获取或设置双字节的整数是否进行翻转操作，主要针对的类型为 <see cref="T:System.Int16"/> 和 <see cref="T:System.UInt16"/><br />
            Get or set whether the double-byte integer is to be flipped, the main types are <see cref="T:System.Int16"/> and <see cref="T:System.UInt16"/>
            </summary>
            <remarks>
            默认为 <c>True</c>，即发生数据翻转，当修改为 <c>False</c> 时，和C#的字节顺序一致
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.TransInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.TransUInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.TransByte(System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.TransByte(System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.CreateByDateFormat(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.CreateByDateFormat(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.AsciiControl">
            <summary>
            控制型的ascii资源信息<br />
            Controlled ascii resource information
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.NUL">
            <summary>
            空字符
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.SOH">
            <summary>
            标题开始<br />
            start of headling
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.STX">
            <summary>
            正文开始<br />
            start of text
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.ETX">
            <summary>
            正文结束<br />
            end of text
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.EOT">
            <summary>
            传输结束<br />
            end of transmission
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.ENQ">
            <summary>
            请求<br />
            enquiry
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.ACK">
            <summary>
            接到通知<br />
            acknowledge
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.BEL">
            <summary>
            响铃<br />
            bell
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.BS">
            <summary>
            退格<br />
            backspace
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.HT">
            <summary>
            水平制表符<br />
            horizontal tab
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.LF">
            <summary>
            换行符<br />
            NL line feed, new line
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.VT">
            <summary>
            垂直制表符<br />
            vertical tab
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.FF">
            <summary>
            换页键<br />
            NP form feed, new page
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.CR">
            <summary>
            回车键<br />
            carriage return
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.SO">
            <summary>
            不用切换<br />
            shift out
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.SI">
            <summary>
            启用切换<br />
            shift in
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.DLE">
            <summary>
            数据链路定义<br />
            data link escape
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.DC1">
            <summary>
            设备控制1<br />
            device control 1
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.DC2">
            <summary>
            设备控制2<br />
            device control 2
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.DC3">
            <summary>
            设备控制3<br />
            device control 3
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.DC4">
            <summary>
            设备控制4<br />
            device control 4
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.NAK">
            <summary>
            拒绝接收<br />
            negative acknowledge
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.SYN">
            <summary>
            同步空闲<br />
            synchronous idle
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.ETB">
            <summary>
            传输块结束<br />
            end of trans. block
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.CAN">
            <summary>
            取消<br />
            cancel
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.EM">
            <summary>
            介质中断<br />
            end of medium
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.SUB">
            <summary>
            替补<br/>
            substitute
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.ESC">
            <summary>
            溢出<br />
            escape
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.FS">
            <summary>
            文件分隔符<br />
            file separator
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.GS">
            <summary>
            分组符<br />
            group separator
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.RS">
            <summary>
            记录分离符<br />
            record separator
            </summary>
        </member>
        <member name="F:HslCommunication.Core.AsciiControl.US">
            <summary>
            单元分隔符<br />
            unit separator
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Types.CertificateDegree">
            <summary>
            证书等级
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Types.CertificateDegree.Read">
            <summary>
            只允许读取数据的等级
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Types.CertificateDegree.ReadWrite">
            <summary>
            允许同时读写数据的等级
            </summary>
        </member>
        <member name="T:HslCommunication.Core.HslCancelToken">
            <summary>
            取消操作的令牌<br />
            Token to cancel the operation
            </summary>
        </member>
        <member name="P:HslCommunication.Core.HslCancelToken.IsCancelled">
            <summary>
            是否取消的操作<br />
            Whether to cancel the operation
            </summary>
        </member>
        <member name="T:HslCommunication.Core.HslHelper">
            <summary>
            HslCommunication的一些静态辅助方法<br />
            Some static auxiliary methods of HslCommunication
            </summary>
        </member>
        <member name="P:HslCommunication.Core.HslHelper.HslRandom">
            <summary>
            项目的随机数信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.ExtractParameter(System.String@,System.String,System.Int32)">
            <summary>
            解析地址的附加参数方法，比如你的地址是s=100;D100，可以提取出"s"的值的同时，修改地址本身，如果"s"不存在的话，返回给定的默认值<br />
            The method of parsing additional parameters of the address, for example, if your address is s=100;D100, you can extract the value of "s" and modify the address itself. If "s" does not exist, return the given default value
            </summary>
            <param name="address">复杂的地址格式，比如：s=100;D100</param>
            <param name="paraName">等待提取的参数名称</param>
            <param name="defaultValue">如果提取的参数信息不存在，返回的默认值信息</param>
            <returns>解析后的新的数据值或是默认的给定的数据值</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.ExtractParameter(System.String@,System.String)">
            <summary>
            解析地址的附加参数方法，比如你的地址是s=100;D100，可以提取出"s"的值的同时，修改地址本身，如果"s"不存在的话，返回错误的消息内容<br />
            The method of parsing additional parameters of the address, for example, if your address is s=100;D100, you can extract the value of "s" and modify the address itself. 
            If "s" does not exist, return the wrong message content
            </summary>
            <param name="address">复杂的地址格式，比如：s=100;D100</param>
            <param name="paraName">等待提取的参数名称</param>
            <returns>解析后的参数结果内容</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.ExtractStartIndex(System.String@)">
            <summary>
            解析地址的起始地址的方法，比如你的地址是 A[1] , 那么将会返回 1，地址修改为 A，如果不存在起始地址，那么就不修改地址，返回 -1<br />
            The method of parsing the starting address of the address, for example, if your address is A[1], then it will return 1, 
            and the address will be changed to A. If the starting address does not exist, then the address will not be changed and return -1
            </summary>
            <param name="address">复杂的地址格式，比如：A[0] </param>
            <returns>如果存在，就起始位置，不存在就返回 -1</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.ExtractTransformParameter(System.String@,HslCommunication.Core.IByteTransform)">
            <summary>
            解析地址的附加<see cref="T:HslCommunication.Core.DataFormat"/>参数方法，比如你的地址是format=ABCD;D100，可以提取出"format"的值的同时，修改地址本身，如果"format"不存在的话，返回默认的<see cref="T:HslCommunication.Core.IByteTransform"/>对象<br />
            Parse the additional <see cref="T:HslCommunication.Core.DataFormat"/> parameter method of the address. For example, if your address is format=ABCD;D100,
            you can extract the value of "format" and modify the address itself. If "format" does not exist, 
            Return the default <see cref="T:HslCommunication.Core.IByteTransform"/> object
            </summary>
            <param name="address">复杂的地址格式，比如：format=ABCD;D100</param>
            <param name="defaultTransform">默认的数据转换信息</param>
            <returns>解析后的参数结果内容</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.SplitReadLength(System.Int32,System.UInt16,System.UInt16)">
            <summary>
            切割当前的地址数据信息，根据读取的长度来分割成多次不同的读取内容，需要指定地址，总的读取长度，切割读取长度<br />
            Cut the current address data information, and divide it into multiple different read contents according to the read length. 
            You need to specify the address, the total read length, and the cut read length
            </summary>
            <param name="address">整数的地址信息</param>
            <param name="length">读取长度信息</param>
            <param name="segment">切割长度信息</param>
            <returns>切割结果</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.SplitWriteData``1(System.Int32,``0[],System.UInt16,System.Int32)">
            <summary>
            根据指定的长度切割数据数组，返回地址偏移量信息和数据分割信息
            </summary>
            <typeparam name="T">数组类型</typeparam>
            <param name="address">起始的地址</param>
            <param name="value">实际的数据信息</param>
            <param name="segment">分割的基本长度</param>
            <param name="addressLength">一个地址代表的数据长度</param>
            <returns>切割结果内容</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.GetBitIndexInformation(System.String@)">
            <summary>
            获取地址信息的位索引，在地址最后一个小数点的位置
            </summary>
            <param name="address">地址信息</param>
            <returns>位索引的位置</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.GetIpAddressFromInput(System.String)">
            <summary>
            从当前的字符串信息获取IP地址数据，如果是ip地址直接返回，如果是域名，会自动解析IP地址，否则抛出异常<br />
            Get the IP address data from the current string information, if it is an ip address, return directly, 
            if it is a domain name, it will automatically resolve the IP address, otherwise an exception will be thrown
            </summary>
            <param name="value">输入的字符串信息</param>
            <returns>真实的IP地址信息</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.ReadSpecifiedLengthFromStream(System.IO.Stream,System.Int32)">
            <summary>
            从流中接收指定长度的字节数组
            </summary>
            <param name="stream">流</param>
            <param name="length">数据长度</param>
            <returns>二进制的字节数组</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.WriteStringToStream(System.IO.Stream,System.String)">
            <summary>
            将字符串的内容写入到流中去
            </summary>
            <param name="stream">数据流</param>
            <param name="value">字符串内容</param>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.ReadStringFromStream(System.IO.Stream)">
            <summary>
            从流中读取一个字符串内容
            </summary>
            <param name="stream">数据流</param>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.WriteBinaryToStream(System.IO.Stream,System.Byte[])">
            <summary>
            将二进制的内容写入到数据流之中
            </summary>
            <param name="stream">数据流</param>
            <param name="value">原始字节数组</param>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.ReadBinaryFromStream(System.IO.Stream)">
            <summary>
            从流中读取二进制的内容
            </summary>
            <param name="stream">数据流</param>
            <returns>字节数组</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.GetUTF8Bytes(System.String)">
            <summary>
            从字符串的内容提取UTF8编码的字节，加了对空的校验
            </summary>
            <param name="message">字符串内容</param>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.PathCombine(System.String[])">
            <summary>
            将多个路径合成一个更完整的路径，这个方法是多平台适用的
            </summary>
            <param name="paths">路径的集合</param>
            <returns>总路径信息</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.ByteArrayToStruct``1(System.Byte[])">
            <summary>
            <b>[商业授权]</b> 将原始的字节数组，转换成实际的结构体对象，需要事先定义好结构体内容，否则会转换失败<br />
            <b>[Authorization]</b> To convert the original byte array into an actual structure object, 
            the structure content needs to be defined in advance, otherwise the conversion will fail
            </summary>
            <typeparam name="T">自定义的结构体</typeparam>
            <param name="content">原始的字节内容</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.CalculateStartBitIndexAndLength(System.Int32,System.UInt16,System.Int32@,System.UInt16@,System.Int32@)">
            <summary>
            根据当前的位偏移地址及读取位长度信息，计算出实际的字节索引，字节数，字节位偏移
            </summary>
            <param name="addressStart">起始地址</param>
            <param name="length">读取的长度</param>
            <param name="newStart">返回的新的字节的索引，仍然按照位单位</param>
            <param name="byteLength">字节长度</param>
            <param name="offset">当前偏移的信息</param>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.CalculateBitStartIndex(System.String)">
            <summary>
            根据字符串内容，获取当前的位索引地址，例如输入 6,返回6，输入15，返回15，输入B，返回11
            </summary>
            <param name="bit">位字符串</param>
            <returns>结束数据</returns>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.CreateTwoArrayFromOneArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            将一个一维数组中的所有数据按照行列信息拷贝到二维数组里，返回当前的二维数组
            </summary>
            <typeparam name="T">数组的类型对象</typeparam>
            <param name="array">一维数组信息</param>
            <param name="row">行</param>
            <param name="col">列</param>
        </member>
        <member name="M:HslCommunication.Core.HslHelper.IsAddressEndWithIndex(System.String)">
            <summary>
            判断当前的字符串表示的地址，是否以索引为结束
            </summary>
            <param name="address">PLC的字符串地址信息</param>
            <returns>是否以索引结束</returns>
        </member>
        <member name="T:HslCommunication.Core.HslPieItem">
            <summary>
            饼图的基本元素
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslPieItem.#ctor">
            <summary>
            实例化一个饼图基本元素的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.HslPieItem.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="P:HslCommunication.Core.HslPieItem.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="P:HslCommunication.Core.HslPieItem.Back">
            <summary>
            背景颜色
            </summary>
        </member>
        <member name="T:HslCommunication.Core.ISessionContext">
            <summary>
            连接会话信息的上下文，主要是对账户信息的验证<br />
            The context of the connection session information, mainly the verification of account information
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ISessionContext.UserName">
            <summary>
            当前的用户名信息<br />
            current username information
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ISessionContext.ClientId">
            <summary>
            当前的会话的ID信息<br />
            ID information of the current session
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ISessionContext.Tag">
            <summary>
            当前的会话信息关联的自定义信息<br />
            Custom information associated with the current session information
            </summary>
        </member>
        <member name="T:HslCommunication.Core.RemoteCloseException">
            <summary>
            远程对象关闭的异常信息<br />
            Exception information of remote object close
            </summary>
        </member>
        <member name="M:HslCommunication.Core.RemoteCloseException.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="T:HslCommunication.Core.SessionContext">
            <inheritdoc cref="T:HslCommunication.Core.ISessionContext"/>
        </member>
        <member name="P:HslCommunication.Core.SessionContext.UserName">
            <inheritdoc cref="P:HslCommunication.Core.ISessionContext.UserName"/>
        </member>
        <member name="P:HslCommunication.Core.SessionContext.ClientId">
            <inheritdoc cref="P:HslCommunication.Core.ISessionContext.ClientId"/>
        </member>
        <member name="P:HslCommunication.Core.SessionContext.Tag">
            <inheritdoc cref="P:HslCommunication.Core.ISessionContext.Tag"/>
        </member>
        <member name="T:HslCommunication.Core.ValueLimit">
            <summary>
            一个数据范围管理的的类型对象，可以方便的管理一个数据值的最大值，最小值，平均值信息。<br />
            A type object managed by a data range can conveniently manage the maximum, minimum, and average information of a data value.
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ValueLimit.MaxValue">
            <summary>
            当前的数据的最大值<br />
            The maximum value of the current data
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ValueLimit.MinValue">
            <summary>
            当前的数据的最小值<br />
            The minimum value of the current data
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ValueLimit.Average">
            <summary>
            当前的数据的平均值<br />
            Average value of current data
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ValueLimit.StartValue">
            <summary>
            当前的数据的起始值<br />
            The starting value of the current data
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ValueLimit.Current">
            <summary>
            当前的数据的当前值，也是最后一次更新的数据值<br />
            The current value of the current data is also the last updated data value
            </summary>
        </member>
        <member name="P:HslCommunication.Core.ValueLimit.Count">
            <summary>
            当前的数据的更新总个数<br />
            The total number of current data updates
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ValueLimit.SetNewValue(System.Double)">
            <summary>
            重新设置当前的最新值，然后计算新的最大值，最小值，平均值等信息<br />
            Reset the current latest value, and then calculate the new maximum, minimum, average and other information
            </summary>
            <param name="value">新的数据值信息</param>
            <returns>新的值对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ValueLimit.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.ValueLimit.op_Equality(HslCommunication.Core.ValueLimit,HslCommunication.Core.ValueLimit)">
            <summary>
            判断是否相等
            </summary>
            <param name="value1">第一个数据值</param>
            <param name="value2">第二个数据值</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:HslCommunication.Core.ValueLimit.op_Inequality(HslCommunication.Core.ValueLimit,HslCommunication.Core.ValueLimit)">
            <summary>
            判断是否相等
            </summary>
            <param name="value1">第一个数据值</param>
            <param name="value2">第二个数据值</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:HslCommunication.Core.ValueLimit.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.ValueLimit.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.FileBaseInfo">
            <summary>
            文件的基础信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileBaseInfo.Name">
            <summary>
            文件名称
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileBaseInfo.Size">
            <summary>
            文件大小
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileBaseInfo.Tag">
            <summary>
            文件的标识，注释
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileBaseInfo.Upload">
            <summary>
            文件上传人的名称
            </summary>
        </member>
        <member name="T:HslCommunication.Core.FileGroupInfo">
            <summary>
            文件的分类信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileGroupInfo.Command">
            <summary>
            命令码
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileGroupInfo.FileName">
            <summary>
            文件名
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileGroupInfo.FileNames">
            <summary>
            文件名列表
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileGroupInfo.Factory">
            <summary>
            第一级分类信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileGroupInfo.Group">
            <summary>
            第二级分类信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileGroupInfo.Identify">
            <summary>
            第三级分类信息
            </summary>
        </member>
        <member name="T:HslCommunication.Core.FileServerInfo">
            <summary>
            文件在服务器上的信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileServerInfo.ActualFileFullName">
            <summary>
            文件的真实路径
            </summary>
        </member>
        <member name="T:HslCommunication.Core.FileMarkId">
            <summary>
            文件标记对象类，标记了一个文件的当前状态，是否处于下载中，删除的操作信息<br />
            File tag object class, which marks the current status of a file, whether it is downloading, or delete operation information
            </summary>
        </member>
        <member name="M:HslCommunication.Core.FileMarkId.#ctor(HslCommunication.LogNet.ILogNet,System.String)">
            <summary>
            实例化一个文件标记对象，需要传入日志信息和文件名<br />
            To instantiate a file tag object, you need to pass in log information and file name
            </summary>
            <param name="logNet">日志对象</param>
            <param name="fileName">完整的文件名称</param>
        </member>
        <member name="P:HslCommunication.Core.FileMarkId.CreateTime">
            <summary>
            当前的对象创建的时间<br />
            Current object creation time
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileMarkId.ActiveTime">
            <summary>
            当前的对象最后一次活跃的时间<br />
            Last active time of the current object
            </summary>
        </member>
        <member name="P:HslCommunication.Core.FileMarkId.DownloadTimes">
            <summary>
            当前的文件的读取次数，通常也是下载次数。<br />
            The current number of reads of the file, usually also the number of downloads.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.FileMarkId.AddOperation(System.Action)">
            <summary>
            新增一个对当前的文件的操作，如果没有读取，就直接执行，如果有读取，就等待读取完成的时候执行。<br />
            Add an operation on the current file. If there is no read, it will be executed directly. If there is a read, it will be executed when the read is completed.
            </summary>
            <param name="action">对当前文件的操作内容</param>
        </member>
        <member name="M:HslCommunication.Core.FileMarkId.CanClear">
            <summary>
            获取该对象是否能被清除<br />
            Gets whether the object can be cleared
            </summary>
            <returns>是否能够删除</returns>
        </member>
        <member name="M:HslCommunication.Core.FileMarkId.EnterReadOperator">
            <summary>
            进入文件的读取状态<br />
            Enter the read state of the file
            </summary>
        </member>
        <member name="M:HslCommunication.Core.FileMarkId.LeaveReadOperator">
            <summary>
            离开本次的文件读取状态，如果没有任何的客户端在读取了，就执行缓存队列里的操作信息。<br />
            Leaving the current file reading status, if no client is reading, the operation information in the cache queue is executed.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.FileMarkId.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.GroupFileContainer">
            <summary>
            文件集容器，绑定一个文件夹的文件信息组，提供了文件夹的文件信息的获取，更新接口<br />
            File set container, which binds the file information group of a folder, provides the file information acquisition and update interface of the folder
            </summary>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.#ctor(HslCommunication.LogNet.ILogNet,System.String)">
            <summary>
            实例化一个新的指定目录的文件管理容器<br />
            Instantiates a new file management container for the specified directory
            </summary>
            <param name="logNet">日志记录对象，可以为空</param>
            <param name="path">文件的路径</param>
        </member>
        <member name="P:HslCommunication.Core.GroupFileContainer.JsonArrayContent">
            <summary>
            包含所有文件列表信息的json文本缓存<br />
            JSON text cache containing all file list information
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileContainer.FileCount">
            <summary>
            获取文件的数量<br />
            Get the number of files
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileContainer.TotalDownloadTimes">
            <summary>
            获取当前目录中所有子文件的下载次数统计<br />
            Get the download count of all subfiles in the current directory
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileContainer.DirectoryPath">
            <summary>
            当前的目录信息<br />
            Current catalog information
            </summary>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.GetGroupFileInfo(System.Boolean)">
            <summary>
            获取当前目录所有文件的大小之和<br />
            Get the sum of the size of all files in the current directory
            </summary>
            <param name="withLastFileInfo">是否携带最新的文件信息</param>
        </member>
        <member name="T:HslCommunication.Core.GroupFileContainer.FileCountChangedDelegate">
            <summary>
            文件数量变化的委托信息<br />
            Order information for changes in the number of files
            </summary>
            <param name="container">文件列表容器</param>
            <param name="fileCount">文件的数量</param>
        </member>
        <member name="E:HslCommunication.Core.GroupFileContainer.FileCountChanged">
            <summary>
            当文件数量发生变化的时候触发的事件<br />
            Event triggered when the number of files changes
            </summary>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.GetCurrentFileMappingName(System.String)">
            <summary>
            下载文件时调用，根据当前的文件名称，例如 123.txt 获取到在文件服务器里映射的文件名称，例如返回 b35a11ec533147ca80c7f7d1713f015b7909<br />
            Called when downloading a file. Get the file name mapped in the file server according to the current file name, such as 123.txt. 
            For example, return b35a11ec533147ca80c7f7d1713f015b7909.
            </summary>
            <param name="fileName">文件的实际名称</param>
            <returns>文件名映射过去的实际的文件名字</returns>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.UpdateFileMappingName(System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            上传文件时掉用，通过比对现有的文件列表，如果没有，就重新创建列表信息<br />
            Used when uploading files, by comparing existing file lists, if not, re-creating list information
            </summary>
            <param name="fileName">文件名，带后缀，不带任何的路径</param>
            <param name="fileSize">文件的大小</param>
            <param name="mappingName">文件映射名称</param>
            <param name="owner">文件的拥有者</param>
            <param name="description">文件的额外描述</param>
            <returns>映射的文件名称</returns>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.GetUploadTimeByFileName(System.String)">
            <summary>
            根据文件的名称获取对应的文件信息<br />
            Get the corresponding file information according to the file name
            </summary>
            <param name="fileName">文件的真实名称</param>
            <returns>是否获取成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.DeleteFile(System.String)">
            <summary>
            删除一个文件信息，传入文件实际的名称，例如 123.txt 返回被删除的文件的guid名称，例如返回 b35a11ec533147ca80c7f7d1713f015b7909   此方法存在同名文件删除的风险<br />
            Delete a file information. Pass in the actual name of the file. For example, 123.txt returns the guid name of the deleted file. For example, it returns b35a11ec533147ca80c7f7d1713f015b7909. There is a risk of deleting the file with the same name
            </summary>
            <param name="fileName">实际的文件名称，如果 123.txt</param>
            <returns>映射之后的文件名，例如 b35a11ec533147ca80c7f7d1713f015b7909</returns>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.FileExists(System.String)">
            <summary>
            判断当前的文件名是否在文件的列表里，传入文件实际的名称，例如 123.txt，如果文件存在，返回 true, 如果不存在，返回 false<br />
            Determine whether the current file name is in the file list, and pass in the actual file name, such as 123.txt, 
            if it exists, return true, if it does not exist, return false
            </summary>
            <param name="fileName">实际的文件名称，如果 123.txt</param>
            <returns>如果文件存在，返回 true, 如果不存在，返回 false</returns>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.DeleteFileByGuid(System.String)">
            <summary>
            删除一个文件信息，传入文件唯一的guid的名称，例如 b35a11ec533147ca80c7f7d1713f015b7909 返回被删除的文件的guid名称<br />
            Delete a file information, pass in the unique GUID name of the file, for example b35a11ec533147ca80c7f7d1713f015b7909 return the GUID name of the deleted file
            </summary>
            <param name="guidName">实际的文件名称，如果 b35a11ec533147ca80c7f7d1713f015b7909</param>
            <returns>映射之后的文件名，例如 b35a11ec533147ca80c7f7d1713f015b7909</returns>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.ClearAllFiles">
            <summary>
            删除当前目录下所有的文件信息，返回等待被删除的文件列表，是映射文件名：b35a11ec533147ca80c7f7d1713f015b7909<br />
            Delete all file information in the current directory, and return to the list of files waiting to be deleted, 
            which is the mapping file name: b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <returns>映射之后的文件列表，例如 b35a11ec533147ca80c7f7d1713f015b7909</returns>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.CacheJsonArrayContent">
            <summary>
            缓存JSON文本的方法，该机制使用乐观并发模型完成<br />
            Method for caching JSON text, which is done using an optimistic concurrency model
            </summary>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.LoadByPath(System.String)">
            <summary>
            从目录进行加载数据，必须实例化的时候加载，加载失败会导致系统异常，旧的文件丢失<br />
            Load data from the directory, it must be loaded when instantiating. Failure to load will cause system exceptions and old files will be lost
            </summary>
            <param name="path">当前的文件夹路径信息</param>
        </member>
        <member name="M:HslCommunication.Core.GroupFileContainer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.GroupFileItem">
            <summary>
            单个文件的存储信息，用来表示在文件目录管理器里表示所有的文件信息的<br />
            Storage information of a single file, used to represent all file information in the file directory manager
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileItem.FileName">
            <summary>
            文件的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileItem.FileSize">
            <summary>
            文件的大小
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileItem.MappingName">
            <summary>
            文件的映射名称
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileItem.DownloadTimes">
            <summary>
            文件的下载次数
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileItem.UploadTime">
            <summary>
            文件的上传时间
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileItem.Owner">
            <summary>
            文件的上传人，拥有者
            </summary>
        </member>
        <member name="P:HslCommunication.Core.GroupFileItem.Description">
            <summary>
            文件的额外描述
            </summary>
        </member>
        <member name="M:HslCommunication.Core.GroupFileItem.GetTextFromFileSize">
            <summary>
            获取文件的大小描述<br />
            Get file size description
            </summary>
            <returns>文件大小的字符串描述形式</returns>
        </member>
        <member name="M:HslCommunication.Core.GroupFileItem.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.NetHandle">
            <summary>
            用于网络传递的信息头，使用上等同于int
            </summary>
            <remarks>
            通常用于<see cref="T:HslCommunication.Enthernet.NetComplexServer"/>和<see cref="T:HslCommunication.Enthernet.NetComplexClient"/>之间的通信，以及<see cref="T:HslCommunication.Enthernet.NetSimplifyServer"/>和<see cref="T:HslCommunication.Enthernet.NetSimplifyClient"/>通讯
            </remarks>
            <example>
            使用上等同于int，只是本结构体允许将4字节的int拆分成3部分单独访问
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetHandle.cs" region="NetHandleExample" title="NetHandle示例" />
            </example>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Implicit(System.Int32)~HslCommunication.NetHandle">
            <summary>
            赋值操作，可以直接赋值int数据
            </summary>
            <param name="value">int数值</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Implicit(HslCommunication.NetHandle)~System.Int32">
            <summary>
            也可以赋值给int数据
            </summary>
            <param name="netHandle">netHandle对象</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Equality(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            判断是否相等
            </summary>
            <param name="netHandle1">第一个数</param>
            <param name="netHandle2">第二个数</param>
            <returns>等于返回<c>True</c>，否则<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Inequality(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            判断是否不相等
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>等于返回<c>False</c>，否则<c>True</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Addition(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            两个数值相加
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>返回两个指令的和</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Subtraction(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            两个数值相减
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>返回两个指令的差</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_LessThan(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            判断是否小于另一个数值
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>小于则返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_GreaterThan(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            判断是否大于另一个数值
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>大于则返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.#ctor(System.Int32)">
            <summary>
            初始化一个暗号对象
            </summary>
            <param name="value">使用一个默认的数值进行初始化</param>
        </member>
        <member name="M:HslCommunication.NetHandle.#ctor(System.Byte,System.Byte,System.UInt16)">
            <summary>
            根据三个值来初始化暗号对象
            </summary>
            <param name="major">主暗号</param>
            <param name="minor">次暗号</param>
            <param name="identifier">暗号编号</param>
        </member>
        <member name="F:HslCommunication.NetHandle.m_CodeValue">
            <summary>
            完整的暗号值
            </summary>
        </member>
        <member name="F:HslCommunication.NetHandle.m_CodeMajor">
            <summary>
            主暗号分类0-255
            </summary>
        </member>
        <member name="F:HslCommunication.NetHandle.m_CodeMinor">
            <summary>
            次要的暗号分类0-255
            </summary>
        </member>
        <member name="F:HslCommunication.NetHandle.m_CodeIdentifier">
            <summary>
            暗号的编号分类0-65535
            </summary>
        </member>
        <member name="P:HslCommunication.NetHandle.CodeValue">
            <summary>
            完整的暗号值
            </summary>
        </member>
        <member name="P:HslCommunication.NetHandle.CodeMajor">
            <summary>
            主暗号分类0-255
            </summary>
        </member>
        <member name="P:HslCommunication.NetHandle.CodeMinor">
            <summary>
            次要的暗号分类0-255
            </summary>
        </member>
        <member name="P:HslCommunication.NetHandle.CodeIdentifier">
            <summary>
            暗号的编号分类0-65535
            </summary>
        </member>
        <member name="M:HslCommunication.NetHandle.ToString">
            <summary>
            获取完整的暗号数据
            </summary>
            <returns>返回暗号的字符串表示形式</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.Equals(System.Object)">
            <summary>
            判断两个实例是否相同
            </summary>
            <param name="obj">对比的对象</param>
            <returns>相同返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.GetHashCode">
            <summary>
            获取哈希值
            </summary>
            <returns>返回当前对象的哈希值</returns>
        </member>
        <member name="T:HslCommunication.HslProtocol">
            <summary>
            用于本程序集访问通信的暗号说明
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.HeadByteLength">
            <summary>
            规定所有的网络传输指令头都为32字节
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolBufferSize">
            <summary>
            所有网络通信中的缓冲池数据信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolCheckSecends">
            <summary>
            用于心跳程序的暗号信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolClientQuit">
            <summary>
            客户端退出消息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolClientRefuseLogin">
            <summary>
            因为客户端达到上限而拒绝登录
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolClientAllowLogin">
            <summary>
            允许客户端登录到服务器
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolAccountLogin">
            <summary>
            客户端登录的暗号信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolAccountRejectLogin">
            <summary>
            客户端拒绝登录的暗号信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserString">
            <summary>
            说明发送的只是文本信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserBytes">
            <summary>
            发送的数据就是普通的字节数组
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserBitmap">
            <summary>
            发送的数据就是普通的图片数据
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserException">
            <summary>
            发送的数据是一条异常的数据，字符串为异常消息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserStringArray">
            <summary>
            说明发送的数据是字符串的数组
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileDownload">
            <summary>
            请求文件下载的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileUpload">
            <summary>
            请求文件上传的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileDelete">
            <summary>
            请求删除文件的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileCheckRight">
            <summary>
            文件校验成功
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileCheckError">
            <summary>
            文件校验失败
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileSaveError">
            <summary>
            文件保存失败
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileDirectoryFiles">
            <summary>
            请求文件列表的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileDirectories">
            <summary>
            请求子文件的列表暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolProgressReport">
            <summary>
            进度返回暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolErrorMsg">
            <summary>
            返回的错误信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFilesDelete">
            <summary>
            请求删除多个文件的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFolderDelete">
            <summary>
            请求删除文件夹的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileExists">
            <summary>
            请求当前的文件是否存在
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolEmptyFolderDelete">
            <summary>
            请求删除文件夹的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFolderInfo">
            <summary>
            请求指定文件夹的文件大小
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFolderInfos">
            <summary>
            指定目录的所有子目录的文件统计信息，每个文件夹的文件数量，所有文件大小，最后更新时间
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolNoZipped">
            <summary>
            不压缩数据字节
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolZipped">
            <summary>
            压缩数据字节
            </summary>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandBytes(System.Int32,System.Int32,System.Guid,System.Byte[])">
            <summary>
            生成终极传送指令的方法，所有的数据均通过该方法出来
            </summary>
            <param name="command">命令头</param>
            <param name="customer">自用自定义</param>
            <param name="token">令牌</param>
            <param name="data">字节数据</param>
            <returns>包装后的数据信息</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandAnalysis(System.Byte[],System.Byte[])">
            <summary>
            解析接收到数据，先解压缩后进行解密
            </summary>
            <param name="head">指令头</param>
            <param name="content">指令的内容</param>
            <return>真实的数据内容</return>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandBytes(System.Int32,System.Guid,System.Byte[])">
            <summary>
            获取发送字节数据的实际数据，带指令头
            </summary>
            <param name="customer">用户数据</param>
            <param name="token">令牌</param>
            <param name="data">字节信息</param>
            <returns>包装后的指令信息</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandBytes(System.Int32,System.Guid,System.String)">
            <summary>
            获取发送字节数据的实际数据，带指令头
            </summary>
            <param name="customer">用户数据</param>
            <param name="token">令牌</param>
            <param name="data">字符串数据信息</param>
            <returns>包装后的指令信息</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandBytes(System.Int32,System.Guid,System.String[])">
            <summary>
            获取发送字节数据的实际数据，带指令头
            </summary>
            <param name="customer">用户数据</param>
            <param name="token">令牌</param>
            <param name="data">字符串数据信息</param>
            <returns>包装后的指令信息</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.PackStringArrayToByte(System.String)">
            <inheritdoc cref="M:HslCommunication.HslProtocol.PackStringArrayToByte(System.String[])"/>
        </member>
        <member name="M:HslCommunication.HslProtocol.PackStringArrayToByte(System.String[])">
            <summary>
            将字符串打包成字节数组内容
            </summary>
            <param name="data">字符串数组</param>
            <returns>打包后的原始数据内容</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.UnPackStringArrayFromByte(System.Byte[])">
            <summary>
            将字节数组还原成真实的字符串数组
            </summary>
            <param name="content">原始字节数组</param>
            <returns>解析后的字符串内容</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.ExtractHslData(System.Byte[])">
            <summary>
            从接收的数据内容提取出用户的暗号和数据内容
            </summary>
            <param name="content">数据内容</param>
            <returns>包含结果对象的信息</returns>
        </member>
        <member name="T:HslCommunication.Reflection.HslDeviceAddressAttribute">
            <summary>
            应用于Hsl组件库读取的动态地址解析，具体用法为创建一个类，创建数据属性，如果这个属性需要绑定PLC的真实数据，就在属性的特性上应用本特性。<br />
            Applied to the dynamic address resolution read by the Hsl component library, the specific usage is to create a class and create data attributes. 
            If this attribute needs to be bound to the real data of the PLC, this feature is applied to the characteristics of the attribute.
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslDeviceAddressAttribute.DeviceType">
            <summary>
            设备的类型，如果指定了特殊的PLC，那么该地址就可以支持多种不同PLC<br />
            The type of equipment, if a special PLC is specified, then the address can support a variety of different PLCs
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslDeviceAddressAttribute.Address">
            <summary>
            数据的地址信息，真实的设备的地址信息<br />
            Data address information, real device address information
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslDeviceAddressAttribute.Length">
            <summary>
            读取的数据长度<br />
            Length of data read
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.#ctor(System.String)">
            <summary>
            实例化一个地址特性，指定地址信息，用于单变量的数据<br />
            Instantiate an address feature, specify the address information, for single variable data
            </summary>
            <param name="address">真实的地址信息</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.#ctor(System.String,System.Type)">
            <summary>
            实例化一个地址特性，指定地址信息，用于单变量的数据，并指定设备类型<br />
            Instantiate an address feature, specify address information, data for a single variable, and specify the device type
            </summary>
            <param name="address">真实的地址信息</param>
            <param name="deviceType">设备的地址信息</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个地址特性，指定地址信息和数据长度，通常应用于数组的批量读取<br />
            Instantiate an address feature, specify address information and data length, usually used in batch reading of arrays
            </summary>
            <param name="address">真实的地址信息</param>
            <param name="length">读取的数据长度</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.#ctor(System.String,System.Int32,System.Type)">
            <summary>
            实例化一个地址特性，指定地址信息和数据长度，通常应用于数组的批量读取，并指定设备的类型，可用于不同种类的PLC<br />
            Instantiate an address feature, specify address information and data length, usually used in batch reading of arrays, 
            and specify the type of equipment, which can be used for different types of PLCs
            </summary>
            <param name="address">真实的地址信息</param>
            <param name="length">读取的数据长度</param>
            <param name="deviceType">设备类型</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.GetDataLength">
            <summary>
            获取数据的数量信息，如果小于0，则返回1<b />
            Get the quantity information of the data, if it is less than 0, return 1
            </summary>
            <returns>数据的个数</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Reflection.HslAddressProperty">
            <summary>
            Hsl相关地址的属性信息
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslAddressProperty.DeviceAddressAttribute">
            <summary>
            该属性绑定的地址特性
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslAddressProperty.PropertyInfo">
            <summary>
            地址绑定的属性信息
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslAddressProperty.ByteOffset">
            <summary>
            起始的字节偏移信息
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslAddressProperty.ByteLength">
            <summary>
            读取的字节的长度信息
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslAddressProperty.Buffer">
            <summary>
            缓存的数据对象
            </summary>
        </member>
        <member name="T:HslCommunication.Reflection.HslMqttApiAttribute">
            <summary>
            可以指定方法变成对外公开的API接口，如果方法不实现该特性，将不对外公开方法，无法获取相关的接口权限<br />
            You can specify the method to become an externally public API interface. If the method does not implement this feature, 
            the method will not be publicly disclosed, and the related interface permissions cannot be obtained
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslMqttApiAttribute.ApiTopic">
            <summary>
            当前指定的ApiTopic信息，如果当前的方法接口不指定别名，那么就使用当前的方法名称<br />
            The currently specified ApiTopic information, if the current method interface does not specify an alias, 
            then the current method name is used
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslMqttApiAttribute.Description">
            <summary>
            当前方法的注释内容<br />
            The comment content of the current method
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslMqttApiAttribute.PropertyUnfold">
            <summary>
            当前的属性是否需要展开API信息，默认不展开<br />
            Whether the current attribute needs to expand the API information, it is not expanded by default
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslMqttApiAttribute.HttpMethod">
            <summary>
            如果当前的API接口是支持Http的请求方式，当前属性有效，例如GET,POST<br />
            If the current API interface is a request method that supports Http, the current attributes are valid, such as GET, POST
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslMqttApiAttribute.#ctor(System.String)">
            <summary>
            指定描述内容来实例化一个的对象<br />
            Specify the description content to instantiate an object
            </summary>
            <param name="description">当前接口的描述信息</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslMqttApiAttribute.#ctor(System.String,System.String)">
            <summary>
            指定接口的路由信息及描述内容来实例化一个的对象<br />
            Specify the routing information and description content of the interface to instantiate an object
            </summary>
            <param name="apiTopic">指重新定当前接口的路由信息</param>
            <param name="description">当前接口的描述信息</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslMqttApiAttribute.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="T:HslCommunication.Reflection.HslMqttPermissionAttribute">
            <summary>
            可以指定方法的权限内容，可以限定MQTT会话的ClientID信息或是UserName内容<br />
            
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslMqttPermissionAttribute.ClientID">
            <summary>
            ClientId的限定内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslMqttPermissionAttribute.UserName">
            <summary>
            UserName的限定内容
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslMqttPermissionAttribute.CheckClientID(System.String)">
            <summary>
            检查当前的客户端ID是否通过
            </summary>
            <param name="clientID">ID信息</param>
            <returns>是否检测成功</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslMqttPermissionAttribute.CheckUserName(System.String)">
            <summary>
            检查当前的用户名是否通过
            </summary>
            <param name="name">用户名</param>
            <returns>是否检测成功</returns>
        </member>
        <member name="T:HslCommunication.Reflection.HslRedisKeyAttribute">
            <summary>
            对应redis的一个键值信息的内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisKeyAttribute.KeyName">
            <summary>
            键值的名称
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisKeyAttribute.#ctor(System.String)">
            <summary>
            根据键名来读取写入当前的数据信息
            </summary>
            <param name="key">键名</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslRedisListItemAttribute">
            <summary>
            对应redis的一个列表信息的内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListItemAttribute.ListKey">
            <summary>
            列表键值的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListItemAttribute.Index">
            <summary>
            当前的位置的索引
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisListItemAttribute.#ctor(System.String,System.Int64)">
            <summary>
            根据键名来读取写入当前的列表中的单个信息
            </summary>
            <param name="listKey">列表键名</param>
            <param name="index">当前的索引位置</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslRedisListAttribute">
            <summary>
            对应redis的一个列表信息的内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListAttribute.ListKey">
            <summary>
            列表键值的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListAttribute.StartIndex">
            <summary>
            当前的位置的索引
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListAttribute.EndIndex">
            <summary>
            当前位置的结束索引
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisListAttribute.#ctor(System.String)">
            <summary>
            根据键名来读取写入当前的列表中的多个信息
            </summary>
            <param name="listKey">列表键名</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisListAttribute.#ctor(System.String,System.Int64)">
            <summary>
            根据键名来读取写入当前的列表中的多个信息
            </summary>
            <param name="listKey">列表键名</param>
            <param name="startIndex">开始的索引信息</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisListAttribute.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            根据键名来读取写入当前的列表中的多个信息
            </summary>
            <param name="listKey">列表键名</param>
            <param name="startIndex">开始的索引信息</param>
            <param name="endIndex">结束的索引位置，-1为倒数第一个，以此类推。</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslRedisHashFieldAttribute">
            <summary>
            对应redis的一个哈希信息的内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisHashFieldAttribute.HaskKey">
            <summary>
            哈希键值的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisHashFieldAttribute.Field">
            <summary>
            当前的哈希域名称
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisHashFieldAttribute.#ctor(System.String,System.String)">
            <summary>
            根据键名来读取写入当前的哈希的单个信息
            </summary>
            <param name="hashKey">哈希键名</param>
            <param name="filed">哈希域名称</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslReflectionHelper">
            <summary>
            反射的辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.GetHslDeviceAddressAttribute(System.Type,System.Reflection.PropertyInfo)">
            <summary>
            从属性中获取对应的设备类型的地址特性信息
            </summary>
            <param name="deviceType">设备类型信息</param>
            <param name="property">属性信息</param>
            <returns>设备类型信息</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.Read``1(HslCommunication.Core.IReadWriteNet)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考论坛的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="readWrite">读写接口的实现</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.Write``1(``0,HslCommunication.Core.IReadWriteNet)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考论坛的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="data">自定义的数据对象</param>
            <param name="readWrite">数据读写对象</param>
            <returns>包含是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.PraseStructContent``1(System.Byte[],System.Int32,HslCommunication.Core.IByteTransform)">
            <summary>
            根据类型信息，直接从原始字节解析出类型对象，然后赋值给对应的对象，该对象的属性需要支持特性 <see cref="T:HslCommunication.Reflection.HslStructAttribute"/> 才支持设置
            </summary>
            <typeparam name="T">类型信息</typeparam>
            <param name="buffer">缓存信息</param>
            <param name="startIndex">起始偏移地址</param>
            <param name="byteTransform">数据变换规则对象</param>
            <returns>新的实例化的类型对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.PraseStructContent(System.Object,System.Byte[],System.Int32,HslCommunication.Core.IByteTransform)">
            <summary>
            根据结构体的定义，将原始字节的数据解析出来，然后赋值给对应的对象，该对象的属性需要支持特性 <see cref="T:HslCommunication.Reflection.HslStructAttribute"/> 才支持设置
            </summary>
            <param name="obj">类型对象信息</param>
            <param name="buffer">读取的缓存数据信息</param>
            <param name="startIndex">起始的偏移地址</param>
            <param name="byteTransform">数据变换规则对象</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.SetPropertyExp``2(System.Reflection.PropertyInfo,``0,``1)">
            <summary>
            使用表达式树的方式来给一个属性赋值
            </summary>
            <param name="propertyInfo">属性信息</param>
            <param name="obj">对象信息</param>
            <param name="objValue">实际的值</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.ReadAsync``1(HslCommunication.Core.IReadWriteNet)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考论坛的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="readWrite">读写接口的实现</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.WriteAsync``1(``0,HslCommunication.Core.IReadWriteNet)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考论坛的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="data">自定义的数据对象</param>
            <param name="readWrite">数据读写对象</param>
            <returns>包含是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.Read``1(HslCommunication.Enthernet.Redis.RedisClient)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>，
            <see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="redis">Redis的数据对象</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.Write``1(``0,HslCommunication.Enthernet.Redis.RedisClient)">
            <summary>
            从设备里写入支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/> ，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            需要注意的是写入并不支持<see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>特性，详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="data">等待写入的数据参数</param>
            <param name="redis">Redis的数据对象</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.ReadAsync``1(HslCommunication.Enthernet.Redis.RedisClient)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>，
            <see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="redis">Redis的数据对象</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.WriteAsync``1(``0,HslCommunication.Enthernet.Redis.RedisClient)">
            <summary>
            从设备里写入支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/> ，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            需要注意的是写入并不支持<see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>特性，详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="data">等待写入的数据参数</param>
            <param name="redis">Redis的数据对象</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.GetParametersFromJson(HslCommunication.Core.ISessionContext,System.Reflection.ParameterInfo[],System.String)">
            <summary>
            从Json数据里解析出真实的数据信息，根据方法参数列表的类型进行反解析，然后返回实际的数据数组<br />
            Analyze the real data information from the Json data, perform de-analysis according to the type of the method parameter list, 
            and then return the actual data array
            </summary>
            <param name="context">当前的会话内容</param>
            <param name="parameters">提供的参数列表信息</param>
            <param name="json">参数变量信息</param>
            <returns>已经填好的实际数据的参数数组对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.GetParametersFromUrl(HslCommunication.Core.ISessionContext,System.Reflection.ParameterInfo[],System.String)">
            <summary>
            从url数据里解析出真实的数据信息，根据方法参数列表的类型进行反解析，然后返回实际的数据数组<br />
            Analyze the real data information from the url data, perform de-analysis according to the type of the method parameter list, 
            and then return the actual data array
            </summary>
            <param name="context">当前的会话内容</param>
            <param name="parameters">提供的参数列表信息</param>
            <param name="url">参数变量信息</param>
            <returns>已经填好的实际数据的参数数组对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.GetParametersFromJson(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <summary>
            从方法的参数列表里，提取出实际的示例参数信息，返回一个json对象，注意：该数据是示例的数据，具体参数的限制参照服务器返回的数据声明。<br />
            From the parameter list of the method, extract the actual example parameter information, and return a json object. Note: The data is the example data, 
            and the specific parameter restrictions refer to the data declaration returned by the server.
            </summary>
            <param name="method">当前需要解析的方法名称</param>
            <param name="parameters">当前的参数列表信息</param>
            <returns>当前的参数对象信息</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.GetOperateResultJsonFromObj(System.Object)">
            <summary>
            将一个对象转换成 <see cref="T:HslCommunication.OperateResult`1"/> 的string 类型的对象，用于远程RPC的数据交互 
            </summary>
            <param name="obj">自定义的对象</param>
            <returns>转换之后的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.GetHslPropertyInfos(System.Type,System.Type,System.Object,HslCommunication.Core.IByteTransform)">
            <summary>
            根据提供的类型对象，解析出符合 <see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/> 特性的地址列表
            </summary>
            <param name="valueType">数据类型</param>
            <param name="deviceType">设备类型</param>
            <param name="obj">类型的对象信息</param>
            <param name="byteTransform">数据变换对象</param>
            <returns>地址列表信息</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.SetPropertyValueFrom(HslCommunication.Core.IByteTransform,System.Object,System.Collections.Generic.List{HslCommunication.Reflection.HslAddressProperty},System.Byte[])">
            <summary>
            根据地址列表信息，数据缓存，自动解析基础类型的数据，赋值到自定义的对象上去
            </summary>
            <param name="byteTransform">数据解析对象</param>
            <param name="obj">数据对象信息</param>
            <param name="properties">地址属性列表</param>
            <param name="buffer">缓存数据信息</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslStructAttribute">
            <summary>
            结构体的字节偏移信息定义
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslStructAttribute.#ctor(System.Int32)">
            <summary>
            指定偏移地址来实例化一个对象
            </summary>
            <param name="index">字节偏移字节信息，如果是bool，就是位偏移地址，按照位为单位</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslStructAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            指定偏移地址和长度信息来实例化一个对象
            </summary>
            <param name="index">字节偏移字节信息，如果是bool，就是位偏移地址，按照位为单位</param>
            <param name="length">长度信息，如果是普通类型，则表示数组，如果是字符串，则表示字符串占用的最大字节长度</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslStructAttribute.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            指定偏移地址，长度信息，编码信息来实例化一个对象，通常应用于字符串数据
            </summary>
            <param name="index">字节偏移字节信息，如果是bool，就是位偏移地址，按照位为单位</param>
            <param name="length">长度信息，如果是普通类型，则表示数组，如果是字符串，则表示字符串占用的最大字节长度</param>
            <param name="encoding">编码信息，如果是字符串类型，则表示字符串的编码信息，可选 ASCII UNICODE UTF8 GB2312 ANSI BIG-UNICODE</param>
        </member>
        <member name="P:HslCommunication.Reflection.HslStructAttribute.Index">
            <summary>
            字节偏移字节信息，如果是bool，就是位偏移地址，按照位为单位
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslStructAttribute.Length">
            <summary>
            长度信息，如果是普通类型，则表示数组，如果是字符串，则表示字符串占用的最大字节长度
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslStructAttribute.Encoding">
            <summary>
            编码信息，如果是字符串类型，则表示字符串的编码信息，可选 ASCII UNICODE UTF8 GB2312 ANSI BIG-UNICODE
            </summary>
        </member>
        <member name="M:HslCommunication.HslSecurity.ByteEncrypt(System.Byte[])">
            <summary>
            加密方法，只对当前的程序集开放
            </summary>
            <param name="enBytes">等待加密的数据</param>
            <returns>加密后的字节数据</returns>
        </member>
        <member name="M:HslCommunication.HslSecurity.ByteDecrypt(System.Byte[])">
            <summary>
            解密方法，只对当前的程序集开放
            </summary>
            <param name="deBytes">等待解密的数据</param>
            <returns>解密后的字节数据</returns>
        </member>
        <member name="T:HslCommunication.HslExtension">
            <summary>
            扩展的辅助类方法
            </summary>
        </member>
        <member name="M:HslCommunication.HslExtension.ToHexString(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToHexString(System.Byte[],System.Char)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToHexString(System.Byte[],System.Char,System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToHexBytes(System.String)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.HexStringToBytes(System.String)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToByteArray(System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.BoolArrayToByte(System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToBoolArray(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ReverseNew``1(``0[])">
            <summary>
            获取当前数组的倒序数组，这是一个新的实例，不改变原来的数组值<br />
            Get the reversed array of the current byte array, this is a new instance, does not change the original array value
            </summary>
            <param name="value">输入的原始数组</param>
            <returns>反转之后的数组信息</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.ToBoolArray(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolValue(System.Byte[],System.Int32,System.Int32)">
            <summary>
            获取Byte数组的第 bytIndex 个位置的，boolIndex偏移的bool值<br />
            Get the bool value of the bytIndex position of the Byte array and the boolIndex offset
            </summary>
            <param name="bytes">字节数组信息</param>
            <param name="bytIndex">字节的偏移位置</param>
            <param name="boolIndex">指定字节的位偏移</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolByIndex(System.Byte[],System.Int32)">
            <summary>
            获取Byte数组的第 boolIndex 偏移的bool值，这个偏移值可以为 10，就是第 1 个字节的 第3位 <br />
            Get the bool value of the boolIndex offset of the Byte array. The offset value can be 10, which is the third bit of the first byte
            </summary>
            <param name="bytes">字节数组信息</param>
            <param name="boolIndex">指定字节的位偏移</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolByIndex(System.Byte,System.Int32)">
            <summary>
            获取Byte的第 boolIndex 偏移的bool值，比如3，就是第4位 <br />
            Get the bool value of Byte's boolIndex offset, such as 3, which is the 4th bit
            </summary>
            <param name="byt">字节信息</param>
            <param name="boolIndex">指定字节的位偏移</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolByIndex(System.Int16,System.Int32)">
            <summary>
            获取short类型数据的第 boolIndex (从0起始)偏移的bool值，比如3，就是第4位 <br />
            Get the bool value of the boolIndex (starting from 0) offset of the short type data, such as 3, which is the 4th bit
            </summary>
            <param name="value">short数据值</param>
            <param name="boolIndex">位偏移索引，从0开始</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolByIndex(System.UInt16,System.Int32)">
            <summary>
            获取ushort类型数据的第 boolIndex (从0起始)偏移的bool值，比如3，就是第4位 <br />
            Get the bool value of the boolIndex (starting from 0) offset of the ushort type data, such as 3, which is the 4th bit
            </summary>
            <param name="value">ushort数据值</param>
            <param name="boolIndex">位偏移索引，从0开始</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolByIndex(System.Int32,System.Int32)">
            <summary>
            获取int类型数据的第 boolIndex (从0起始)偏移的bool值，比如3，就是第4位 <br />
            Get the bool value of the boolIndex (starting from 0) offset of the int type data, such as 3, which is the 4th bit
            </summary>
            <param name="value">int数据值</param>
            <param name="boolIndex">位偏移索引，从0开始</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolByIndex(System.UInt32,System.Int32)">
            <summary>
            获取uint类型数据的第 boolIndex (从0起始)偏移的bool值，比如3，就是第4位 <br />
            Get the bool value of the boolIndex (starting from 0) offset of the uint type data, such as 3, which is the 4th bit
            </summary>
            <param name="value">uint数据值</param>
            <param name="boolIndex">位偏移索引，从0开始</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolByIndex(System.Int64,System.Int32)">
            <summary>
            获取long类型数据的第 boolIndex (从0起始)偏移的bool值，比如3，就是第4位 <br />
            Get the bool value of the boolIndex (starting from 0) offset of the long type data, such as 3, which is the 4th bit
            </summary>
            <param name="value">long数据值</param>
            <param name="boolIndex">位偏移索引，从0开始</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolByIndex(System.UInt64,System.Int32)">
            <summary>
            获取ulong类型数据的第 boolIndex (从0起始)偏移的bool值，比如3，就是第4位 <br />
            Get the bool value of the boolIndex (starting from 0) offset of the ulong type data, such as 3, which is the 4th bit
            </summary>
            <param name="value">ulong数据值</param>
            <param name="boolIndex">位偏移索引，从0开始</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetStringOrEndChar(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            从字节数组里提取字符串数据，如果碰到0x00字节，就直接结束
            </summary>
            <param name="buffer">原始字节信息</param>
            <param name="index">起始的偏移地址</param>
            <param name="length">字节长度信息</param>
            <param name="encoding">编码</param>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.SetBoolByIndex(System.Byte,System.Int32,System.Boolean)">
            <summary>
            设置Byte的第 boolIndex 位的bool值，可以强制为 true 或是 false, 不影响其他的位<br />
            Set the bool value of the boolIndex bit of Byte, which can be forced to true or false, without affecting other bits
            </summary>
            <param name="byt">字节信息</param>
            <param name="boolIndex">指定字节的位偏移</param>
            <param name="value">bool的值</param>
            <returns>修改之后的byte值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.SetBoolByIndex(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            设置Byte[]的第 boolIndex 位的bool值，可以强制为 true 或是 false, 不影响其他的位，如果是第 10 位，则表示第 1 个字节的第 2 位（都是从 0 地址开始算的）<br />
            Set the bool value of the boolIndex bit of Byte[], which can be forced to true or false, without affecting other bits. 
            If it is the 10th bit, it means the second bit of the first byte (both starting from the 0 address Calculated)
            </summary>
            <param name="buffer">字节数组信息</param>
            <param name="boolIndex">位偏移的索引</param>
            <param name="value">bool的值</param>
        </member>
        <member name="M:HslCommunication.HslExtension.SetBoolByIndex(System.Int16,System.Int32,System.Boolean)">
            <summary>
            修改short数据的某个位，并且返回修改后的值，不影响原来的值。位索引为 0~15，之外的值会引发异常<br />
            Modify a bit of short data and return the modified value without affecting the original value. Bit index is 0~15, values outside will raise an exception
            </summary>
            <param name="shortValue">等待修改的short值</param>
            <param name="boolIndex">位索引，位索引为 0~15，之外的值会引发异常</param>
            <param name="value">bool值</param>
            <returns>修改之后的short值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.SetBoolByIndex(System.UInt16,System.Int32,System.Boolean)">
            <summary>
            修改ushort数据的某个位，并且返回修改后的值，不影响原来的值。位索引为 0~15，之外的值会引发异常<br />
            Modify a bit of ushort data and return the modified value without affecting the original value. Bit index is 0~15, values outside will raise an exception
            </summary>
            <param name="ushortValue">等待修改的ushort值</param>
            <param name="boolIndex">位索引，位索引为 0~15，之外的值会引发异常</param>
            <param name="value">bool值</param>
            <returns>修改之后的ushort值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.SetBoolByIndex(System.Int32,System.Int32,System.Boolean)">
            <summary>
            修改int数据的某个位，并且返回修改后的值，不影响原来的值。位索引为 0~31，之外的值会引发异常<br />
            Modify a bit of int data and return the modified value without affecting the original value. Bit index is 0~31, values outside will raise an exception
            </summary>
            <param name="intValue">等待修改的int值</param>
            <param name="boolIndex">位索引，位索引为 0~31，之外的值会引发异常</param>
            <param name="value">bool值</param>
            <returns>修改之后的int值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.SetBoolByIndex(System.UInt32,System.Int32,System.Boolean)">
            <summary>
            修改uint数据的某个位，并且返回修改后的值，不影响原来的值。位索引为 0~31，之外的值会引发异常<br />
            Modify a bit of uint data and return the modified value without affecting the original value. Bit index is 0~31, values outside will raise an exception
            </summary>
            <param name="uintValue">等待修改的uint值</param>
            <param name="boolIndex">位索引，位索引为 0~31，之外的值会引发异常</param>
            <param name="value">bool值</param>
            <returns>修改之后的uint值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.SetBoolByIndex(System.Int64,System.Int32,System.Boolean)">
            <summary>
            修改long数据的某个位，并且返回修改后的值，不影响原来的值。位索引为 0~63，之外的值会引发异常<br />
            Modify a bit of long data and return the modified value without affecting the original value. Bit index is 0~63, values outside will raise an exception
            </summary>
            <param name="longValue">等待修改的long值</param>
            <param name="boolIndex">位索引，位索引为 0~63，之外的值会引发异常</param>
            <param name="value">bool值</param>
            <returns>修改之后的long值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.SetBoolByIndex(System.UInt64,System.Int32,System.Boolean)">
            <summary>
            修改ulong数据的某个位，并且返回修改后的值，不影响原来的值。位索引为 0~63，之外的值会引发异常<br />
            Modify a bit of ulong data and return the modified value without affecting the original value. Bit index is 0~63, values outside will raise an exception
            </summary>
            <param name="ulongValue">等待修改的ulong值</param>
            <param name="boolIndex">位索引，位索引为 0~63，之外的值会引发异常</param>
            <param name="value">bool值</param>
            <returns>修改之后的ulong值</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.RemoveDouble``1(``0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveDouble``1(``0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.RemoveBegin``1(``0[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveBegin``1(``0[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.RemoveLast``1(``0[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveLast``1(``0[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.SelectMiddle``1(``0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectMiddle``1(``0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.SelectBegin``1(``0[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectBegin``1(``0[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.SelectLast``1(``0[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectLast``1(``0[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.GetValueOrDefault``1(Newtonsoft.Json.Linq.JObject,System.String,``0)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.GetValueFromJsonObject``1(Newtonsoft.Json.Linq.JObject,System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.SpliceArray``1(``0[],``0[][])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.SpliceArray``1(``0[][])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.RemoveLast(System.String,System.Int32)">
            <summary>
            移除指定字符串数据的最后 length 个字符。如果字符串本身的长度不足 length，则返回为空字符串。<br />
            Remove the last "length" characters of the specified string data. If the length of the string itself is less than length, 
            an empty string is returned.
            </summary>
            <param name="value">等待操作的字符串数据</param>
            <param name="length">准备移除的长度信息</param>
            <returns>移除之后的数据信息</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.IncreaseBy``1(``0[],``0)">
            <summary>
            将指定的数据添加到数组的每个元素上去，使用表达式树的形式实现，将会修改原数组。不适用byte类型
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">原始数据</param>
            <param name="value">数据值</param>
            <returns>返回的结果信息</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.CopyArray``1(``0[])">
            <summary>
            拷贝当前的实例数组，是基于引用层的浅拷贝，如果类型为值类型，那就是深度拷贝，如果类型为引用类型，就是浅拷贝
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="value">数组对象</param>
            <returns>拷贝的结果内容</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.ToArrayString``1(``0[])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToArrayString``1(``0[],System.String)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0,System.String)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToStringArray``1(System.String,System.Func{System.String,``0})">
            <summary>
            将字符串数组转换为实际的数据数组。例如字符串格式[1,2,3,4,5]，可以转成实际的数组对象<br />
            Converts a string array into an actual data array. For example, the string format [1,2,3,4,5] can be converted into an actual array object
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="value">字符串数据</param>
            <param name="selector">转换方法</param>
            <returns>实际的数组</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.ToStringArray``1(System.String)">
            <summary>
            将字符串数组转换为实际的数据数组。支持byte,sbyte,bool,short,ushort,int,uint,long,ulong,float,double，使用默认的十进制，例如字符串格式[1,2,3,4,5]，可以转成实际的数组对象<br />
            Converts a string array into an actual data array. Support byte, sbyte, bool, short, ushort, int, uint, long, ulong, float, double, use the default decimal, 
            such as the string format [1,2,3,4,5], which can be converted into an actual array Object
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="value">字符串数据</param>
            <returns>实际的数组</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.BeginReceiveResult(System.Net.Sockets.Socket,System.AsyncCallback,System.Object)">
            <summary>
            启动接收数据，需要传入回调方法，传递对象<br />
            To start receiving data, you need to pass in a callback method and pass an object
            </summary>
            <param name="socket">socket对象</param>
            <param name="callback">回调方法</param>
            <param name="obj">数据对象</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.BeginReceiveResult(System.Net.Sockets.Socket,System.AsyncCallback)">
            <summary>
            启动接收数据，需要传入回调方法，传递对象默认为socket本身<br />
            To start receiving data, you need to pass in a callback method. The default object is the socket itself.
            </summary>
            <param name="socket">socket对象</param>
            <param name="callback">回调方法</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.EndReceiveResult(System.Net.Sockets.Socket,System.IAsyncResult)">
            <summary>
            结束挂起的异步读取，返回读取的字节数，如果成功的情况。<br />
            Ends the pending asynchronous read and returns the number of bytes read, if successful.
            </summary>
            <param name="socket">socket对象</param>
            <param name="ar">回调方法</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.SplitDot(System.String)">
            <summary>
            根据英文小数点进行切割字符串，去除空白的字符<br />
            Cut the string according to the English decimal point and remove the blank characters
            </summary>
            <param name="str">字符串本身</param>
            <returns>切割好的字符串数组，例如输入 "100.5"，返回 "100", "5"</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.ToJsonString(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            获取当前对象的JSON格式表示的字符串。<br />
            Gets the string represented by the JSON format of the current object.
            </summary>
            <returns>字符串对象</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.GetPEMPrivateKey(System.Security.Cryptography.RSACryptoServiceProvider)">
            <inheritdoc cref="M:HslCommunication.Core.Security.RSAHelper.GetPrivateKeyFromRSA(System.Security.Cryptography.RSACryptoServiceProvider)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.GetPEMPublicKey(System.Security.Cryptography.RSACryptoServiceProvider)">
            <inheritdoc cref="M:HslCommunication.Core.Security.RSAHelper.GetPublicKeyFromRSA(System.Security.Cryptography.RSACryptoServiceProvider)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.EncryptLargeData(System.Security.Cryptography.RSACryptoServiceProvider,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Security.RSAHelper.EncryptLargeDataByRSA(System.Security.Cryptography.RSACryptoServiceProvider,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.DecryptLargeData(System.Security.Cryptography.RSACryptoServiceProvider,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Security.RSAHelper.DecryptLargeDataByRSA(System.Security.Cryptography.RSACryptoServiceProvider,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.Write(System.IO.MemoryStream,System.Byte[])">
            <inheritdoc cref="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.WriteReverse(System.IO.MemoryStream,System.UInt16)">
            <summary>
            将<see cref="T:System.UInt16"/>数据写入到字节流，字节顺序为相反<br />
            Write <see cref="T:System.UInt16"/> data to the byte stream, the byte order is reversed
            </summary>
            <param name="ms">字节流</param>
            <param name="value">等待写入的值</param>
        </member>
        <member name="M:HslCommunication.HslExtension.SetKeepAlive(System.Net.Sockets.Socket,System.Int32,System.Int32)">
            <summary>
            设置套接字的活动时间和活动间歇时间，此值会设置到socket低级别的控制中，传入值如果为负数，则表示不使用 KeepAlive 功能。<br />
            Set the active time and active intermittent time of the socket. This value will be set to the low-level control of the socket.
            If the incoming value is a negative number, it means that the KeepAlive function is not used.
            </summary>
            <param name="socket">套接字对象</param>
            <param name="keepAliveTime">保持活动时间</param>
            <param name="keepAliveInterval">保持活动的间歇时间</param>
            <returns>返回获取的参数的字节</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.IniSerialByFormatString(System.IO.Ports.SerialPort,System.String)">
            <summary>
            使用格式化的串口参数信息来初始化串口的参数，举例：9600-8-N-1，分别表示波特率，数据位，奇偶校验，停止位，当然也可以携带串口名称，例如：COM3-9600-8-N-1，linux环境也是支持的。<br />
            Use the formatted serial port parameter information to initialize the serial port parameters, for example: 9600-8-N-1, which means baud rate, data bit, parity, 
            stop bit, of course, can also carry the serial port name, for example: COM3- 9600-8-N-1, linux environment is also supported.
            </summary>
            <remarks>
            其中奇偶校验的字母可选，N:无校验，O：奇校验，E:偶校验，停止位可选 0, 1, 2, 1.5 四种选项<br />
            Among them, the letters of the parity check are optional, N: no check, O: odd check, E: even check, stop bit optional 0, 1, 2, 1.5 four options
            </remarks>
            <param name="serialPort">串口对象信息</param>
            <param name="format">格式化的参数内容，例如：9600-8-N-1</param>
        </member>
        <member name="M:HslCommunication.HslExtension.Receive(System.IO.Ports.SerialPort,System.Int32,System.Int32,System.Int32)">
            <summary>
            从串口接收指定长度的字节数组信息，还可以指定超时时间，以及休眠间歇时间。<br />
            Receive byte array information of specified length from the serial port, and can also specify the timeout time and sleep intermittent time.
            </summary>
            <param name="serialPort">串口信息</param>
            <param name="length">准备接收的字节长度</param>
            <param name="timeout">超时时间</param>
            <param name="sleepTime">间歇休眠时间</param>
            <returns>接收的结果内容对象</returns>
        </member>
        <member name="T:HslCommunication.HslTimeOut">
            <summary>
            超时操作的类<br />
            a class use to indicate the time-out of the connection
            </summary>
            <remarks>
            本类自动启动一个静态线程来处理
            </remarks>
        </member>
        <member name="M:HslCommunication.HslTimeOut.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.UniqueId">
            <summary>
            当前超时对象的唯一ID信息，没实例化一个对象，id信息就会自增1<br />
            The unique ID information of the current timeout object. If an object is not instantiated, the id information will increase by 1
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.StartTime">
            <summary>
            操作的开始时间<br />
            Start time of operation
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.IsSuccessful">
            <summary>
            操作是否成功，当操作完成的时候，需要设置为<c>True</c>，超时检测自动结束。如果一直为<c>False</c>，超时检测到超时，设置<see cref="P:HslCommunication.HslTimeOut.IsTimeout"/>为<c>True</c><br />
            Whether the operation is successful, when the operation is completed, it needs to be set to <c>True</c>, 
            and the timeout detection will automatically end. If it is always <c>False</c>, 
            the timeout is detected by the timeout, set <see cref="P:HslCommunication.HslTimeOut.IsTimeout"/> to <c>True</c>
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.DelayTime">
            <summary>
            延时的时间，单位毫秒<br />
            Delay time, in milliseconds
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.WorkSocket">
            <summary>
            连接超时用的Socket，本超时对象主要针对套接字的连接，接收数据的超时检测，也可以设置为空，用作其他用途的超时检测。<br />
            Socket used for connection timeout. This timeout object is mainly for socket connection and timeout detection of received data. 
            It can also be set to empty for other purposes.
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.IsTimeout">
            <summary>
            是否发生了超时的操作，当调用方因为异常结束的时候，需要对<see cref="P:HslCommunication.HslTimeOut.IsTimeout"/>进行判断，是否因为发送了超时导致的异常<br />
            Whether a timeout operation has occurred, when the caller ends abnormally, 
            it needs to judge <see cref="P:HslCommunication.HslTimeOut.IsTimeout"/>, whether it is an exception caused by a timeout sent
            </summary>
        </member>
        <member name="M:HslCommunication.HslTimeOut.GetConsumeTime">
            <summary>
            获取到目前为止所花费的时间<br />
            Get the time spent so far
            </summary>
            <returns>时间信息</returns>
        </member>
        <member name="M:HslCommunication.HslTimeOut.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.HslTimeOut.HandleTimeOutCheck(HslCommunication.HslTimeOut)">
            <summary>
            新增一个超时检测的对象，当操作完成的时候，需要自行标记<see cref="T:HslCommunication.HslTimeOut"/>对象的<see cref="P:HslCommunication.HslTimeOut.IsSuccessful"/>为<c>True</c><br />
            Add a new object for timeout detection. When the operation is completed, 
            you need to mark the <see cref="P:HslCommunication.HslTimeOut.IsSuccessful"/> of the <see cref="T:HslCommunication.HslTimeOut"/> object as <c>True</c>
            </summary>
            <param name="timeOut">超时对象</param>
        </member>
        <member name="P:HslCommunication.HslTimeOut.TimeOutCheckCount">
            <summary>
            获取当前检查超时对象的个数<br />
            Get the number of current check timeout objects
            </summary>
        </member>
        <member name="M:HslCommunication.HslTimeOut.GetHslTimeOutsSnapShoot">
            <summary>
            获取当前的所有的等待超时检查对象列表，请勿手动更改对象的属性值<br />
            Get the current list of all waiting timeout check objects, do not manually change the property value of the object
            </summary>
            <returns>HslTimeOut数组，请勿手动更改对象的属性值</returns>
        </member>
        <member name="M:HslCommunication.HslTimeOut.HandleTimeOutCheck(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            新增一个超时检测的对象，需要指定socket，超时时间，返回<see cref="T:HslCommunication.HslTimeOut"/>对象，用作标记完成信息<br />
            Add a new object for timeout detection, you need to specify the socket, the timeout period, 
            and return the <see cref="T:HslCommunication.HslTimeOut"/> object for marking completion information
            </summary>
            <param name="socket">网络套接字</param>
            <param name="timeout">超时时间，单位为毫秒<br />Timeout period, in milliseconds</param>
        </member>
        <member name="M:HslCommunication.HslTimeOut.CheckTimeOut(System.Object)">
            <summary>
            整个HslCommunication的检测超时的核心方法，由一个单独的线程运行，线程的优先级很高，当前其他所有的超时信息都可以放到这里处理<br />
            The core method of detecting the timeout of th e entire HslCommunication is run by a separate thread. 
            The priority of the thread is very high. All other timeout information can be processed here.
            </summary>
            <param name="obj">需要传入线程的id信息</param>
        </member>
        <member name="T:HslCommunication.IDataTransfer">
            <summary>
            用于PLC通讯及ModBus自定义数据类型的读写操作
            </summary>
            <remarks>
            主要应用于设备实现设备类的自定义的数据类型读写，以此达到简化代码的操作，但是有一个前提，该数据处于连续的数据区块
            </remarks>
            <example>
            此处举例读取三菱的自定义的数据，先实现接口，然后再读写操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerExample" title="ReadCustomer示例" />
            </example>
        </member>
        <member name="P:HslCommunication.IDataTransfer.ReadCount">
            <summary>
            读取的数据长度，对于西门子，等同于字节数，对于三菱和Modbus为字节数的一半
            </summary>
        </member>
        <member name="M:HslCommunication.IDataTransfer.ParseSource(System.Byte[])">
            <summary>
            从字节数组进行解析实际的对象
            </summary>
            <param name="Content">从远程读取的数据源</param>
        </member>
        <member name="M:HslCommunication.IDataTransfer.ToSource">
            <summary>
            将对象生成字符源，写入PLC中
            </summary>
            <returns>准备写入到远程的数据</returns>
        </member>
        <member name="T:HslCommunication.OperateResult">
            <summary>
            操作结果的类，只带有成功标志和错误信息<br />
            The class that operates the result, with only success flags and error messages
            </summary>
            <remarks>
            当 <see cref="P:HslCommunication.OperateResult.IsSuccess"/> 为 True 时，忽略 <see cref="P:HslCommunication.OperateResult.Message"/> 及 <see cref="P:HslCommunication.OperateResult.ErrorCode"/> 的值
            </remarks>
        </member>
        <member name="M:HslCommunication.OperateResult.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult.IsSuccess">
            <summary>
            指示本次操作是否成功。<br />
            Indicates whether this operation was successful.
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult.Message">
            <summary>
            具体的错误描述。<br />
            Specific error description.
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult.ErrorCode">
            <summary>
            具体的错误代码。<br />
            The specific error code.
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult.ToMessageShowString">
            <summary>
            获取错误代号及文本描述。<br />
            Get the error code and text description.
            </summary>
            <returns>包含错误码及错误消息</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CopyErrorFromOther``1(``0)">
            <summary>
            从另一个结果类中拷贝错误信息，主要是针对错误码和错误消息。<br />
            Copy error information from another result class, mainly for error codes and error messages.
            </summary>
            <typeparam name="TResult">支持结果类及派生类</typeparam>
            <param name="result">结果类及派生类的对象</param>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``1(``0)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T">结果类型</typeparam>
            <param name="content">如果操作成功将赋予的结果内容</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``1">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T">结果类型</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``2(``0,``1)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``2">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``3(``0,``1,``2)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <param name="content3">如果操作成功将赋予的结果内容三</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``3">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``4(``0,``1,``2,``3)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <param name="content3">如果操作成功将赋予的结果内容三</param>
            <param name="content4">如果操作成功将赋予的结果内容四</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``4">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``5(``0,``1,``2,``3,``4)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <param name="content3">如果操作成功将赋予的结果内容三</param>
            <param name="content4">如果操作成功将赋予的结果内容四</param>
            <param name="content5">如果操作成功将赋予的结果内容五</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``5">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <param name="content3">如果操作成功将赋予的结果内容三</param>
            <param name="content4">如果操作成功将赋予的结果内容四</param>
            <param name="content5">如果操作成功将赋予的结果内容五</param>
            <param name="content6">如果操作成功将赋予的结果内容六</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``6">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <param name="content3">如果操作成功将赋予的结果内容三</param>
            <param name="content4">如果操作成功将赋予的结果内容四</param>
            <param name="content5">如果操作成功将赋予的结果内容五</param>
            <param name="content6">如果操作成功将赋予的结果内容六</param>
            <param name="content7">如果操作成功将赋予的结果内容七</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``7">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <param name="content3">如果操作成功将赋予的结果内容三</param>
            <param name="content4">如果操作成功将赋予的结果内容四</param>
            <param name="content5">如果操作成功将赋予的结果内容五</param>
            <param name="content6">如果操作成功将赋予的结果内容六</param>
            <param name="content7">如果操作成功将赋予的结果内容七</param>
            <param name="content8">如果操作成功将赋予的结果内容八</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``8">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``9(``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <typeparam name="T9">泛型参数九</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <param name="content3">如果操作成功将赋予的结果内容三</param>
            <param name="content4">如果操作成功将赋予的结果内容四</param>
            <param name="content5">如果操作成功将赋予的结果内容五</param>
            <param name="content6">如果操作成功将赋予的结果内容六</param>
            <param name="content7">如果操作成功将赋予的结果内容七</param>
            <param name="content8">如果操作成功将赋予的结果内容八</param>
            <param name="content9">如果操作成功将赋予的结果内容九</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``9">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <typeparam name="T9">泛型参数九</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Convert``10(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，如果当前结果为失败，则返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            if the current result is a failure, then return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <typeparam name="T9">泛型参数九</typeparam>
            <typeparam name="T10">泛型参数十</typeparam>
            <param name="content1">如果操作成功将赋予的结果内容一</param>
            <param name="content2">如果操作成功将赋予的结果内容二</param>
            <param name="content3">如果操作成功将赋予的结果内容三</param>
            <param name="content4">如果操作成功将赋予的结果内容四</param>
            <param name="content5">如果操作成功将赋予的结果内容五</param>
            <param name="content6">如果操作成功将赋予的结果内容六</param>
            <param name="content7">如果操作成功将赋予的结果内容七</param>
            <param name="content8">如果操作成功将赋予的结果内容八</param>
            <param name="content9">如果操作成功将赋予的结果内容九</param>
            <param name="content10">如果操作成功将赋予的结果内容十</param>
            <returns>最终的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.ConvertFailed``10">
            <summary>
            将当前的结果对象转换到指定泛型的结果类对象，直接返回指定泛型的失败结果类对象<br />
            Convert the current result object to the result class object of the specified generic type, 
            and directly return the result class object of the specified generic type failure
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <typeparam name="T9">泛型参数九</typeparam>
            <typeparam name="T10">泛型参数十</typeparam>
            <returns>最终失败的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then(System.Func{HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``1(System.Func{HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``2(System.Func{HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``3(System.Func{HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``4(System.Func{HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``5(System.Func{HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``6(System.Func{HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``7(System.Func{HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``8(System.Func{HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``9(System.Func{HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <typeparam name="T9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.Then``10(System.Func{HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="T1">泛型参数一</typeparam>
            <typeparam name="T2">泛型参数二</typeparam>
            <typeparam name="T3">泛型参数三</typeparam>
            <typeparam name="T4">泛型参数四</typeparam>
            <typeparam name="T5">泛型参数五</typeparam>
            <typeparam name="T6">泛型参数六</typeparam>
            <typeparam name="T7">泛型参数七</typeparam>
            <typeparam name="T8">泛型参数八</typeparam>
            <typeparam name="T9">泛型参数九</typeparam>
            <typeparam name="T10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``1(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T">目标数据类型</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``2(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``3(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``4(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``5(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``6(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``7(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``8(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``9(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <typeparam name="T9">目标数据类型九</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``10(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <typeparam name="T9">目标数据类型九</typeparam>
            <typeparam name="T10">目标数据类型十</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult">
            <summary>
            创建并返回一个成功的结果对象
            </summary>
            <returns>成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``1(``0)">
            <summary>
            创建并返回一个成功的结果对象，并带有一个参数对象
            </summary>
            <typeparam name="T">参数类型</typeparam>
            <param name="value">类型的值对象</param>
            <returns>成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``2(``0,``1)">
            <summary>
            创建并返回一个成功的结果对象，并带有两个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``3(``0,``1,``2)">
            <summary>
            创建并返回一个成功的结果对象，并带有三个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``4(``0,``1,``2,``3)">
            <summary>
            创建并返回一个成功的结果对象，并带有四个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``5(``0,``1,``2,``3,``4)">
            <summary>
            创建并返回一个成功的结果对象，并带有五个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            创建并返回一个成功的结果对象，并带有六个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            创建并返回一个成功的结果对象，并带有七个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            创建并返回一个成功的结果对象，并带有八个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``9(``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>
            创建并返回一个成功的结果对象，并带有九个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <typeparam name="T9">第九个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <param name="value9">类型九对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``10(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>
            创建并返回一个成功的结果对象，并带有十个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <typeparam name="T9">第九个参数类型</typeparam>
            <typeparam name="T10">第十个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <param name="value9">类型九对象</param>
            <param name="value10">类型十对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`1">
            <summary>
            操作结果的泛型类，允许带一个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`1.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`1.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`1.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`1.Content">
            <summary>
            用户自定义的泛型数据
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Check(System.Func{`0,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Check(System.Func{`0,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then(System.Func{`0,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``1(System.Func{`0,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``2(System.Func{`0,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``3(System.Func{`0,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``4(System.Func{`0,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``5(System.Func{`0,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``6(System.Func{`0,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``7(System.Func{`0,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``8(System.Func{`0,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``9(System.Func{`0,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`1.Then``10(System.Func{`0,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`2">
            <summary>
            操作结果的泛型类，允许带两个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`2.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`2.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`2.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`2.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`2.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Check(System.Func{`0,`1,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">可以自由指定的错误信息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Check(System.Func{`0,`1,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then(System.Func{`0,`1,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``1(System.Func{`0,`1,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``2(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``3(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``4(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``5(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``6(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``7(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``8(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``9(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`2.Then``10(System.Func{`0,`1,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`3">
            <summary>
            操作结果的泛型类，允许带三个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`3.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`3.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`3.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`3.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`3.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`3.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Check(System.Func{`0,`1,`2,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Check(System.Func{`0,`1,`2,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then(System.Func{`0,`1,`2,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``1(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``2(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``3(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``4(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``5(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``6(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``7(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``8(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``9(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`3.Then``10(System.Func{`0,`1,`2,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`4">
            <summary>
            操作结果的泛型类，允许带四个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`4.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`4.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`4.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`4.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`4.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`4.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`4.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Check(System.Func{`0,`1,`2,`3,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Check(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``1(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``2(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``3(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``4(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``5(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``6(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``7(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``8(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``9(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`4.Then``10(System.Func{`0,`1,`2,`3,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`5">
            <summary>
            操作结果的泛型类，允许带五个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`5.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`5.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`5.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Check(System.Func{`0,`1,`2,`3,`4,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Check(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``1(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``2(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``3(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``4(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``5(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``6(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``7(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``8(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``9(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`5.Then``10(System.Func{`0,`1,`2,`3,`4,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`6">
            <summary>
            操作结果的泛型类，允许带六个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`6.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`6.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`6.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content6">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Check(System.Func{`0,`1,`2,`3,`4,`5,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Check(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``1(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``2(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``3(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``4(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``5(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``6(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``7(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``8(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``9(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`6.Then``10(System.Func{`0,`1,`2,`3,`4,`5,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`7">
            <summary>
            操作结果的泛型类，允许带七个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`7.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`7.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`7.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Check(System.Func{`0,`1,`2,`3,`4,`5,`6,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Check(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``2(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``3(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``4(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``5(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``6(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``7(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``8(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``9(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`7.Then``10(System.Func{`0,`1,`2,`3,`4,`5,`6,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`8">
            <summary>
            操作结果的泛型类，允许带八个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`8.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`8.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`8.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Check(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Check(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``2(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``3(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``4(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``5(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``6(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``7(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``8(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``9(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`8.Then``10(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`9">
            <summary>
            操作结果的泛型类，允许带九个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
            <typeparam name="T9">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`9.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`9.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`9.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content9">
            <summary>
            用户自定义的泛型数据9
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Check(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Check(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``2(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``3(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``4(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``5(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``6(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``7(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``8(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``9(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`9.Then``10(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`10">
            <summary>
            操作结果的泛型类，允许带十个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
            <typeparam name="T9">泛型类</typeparam>
            <typeparam name="T10">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`10.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`10.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`10.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content9">
            <summary>
            用户自定义的泛型数据9
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content10">
            <summary>
            用户自定义的泛型数据10
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Check(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,System.Boolean},System.String)">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <param name="message">检查失败的错误消息</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Check(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult})">
            <summary>
            返回一个检查结果对象，可以进行自定义的数据检查。<br />
            Returns a check result object that allows you to perform custom data checks.
            </summary>
            <param name="check">检查的委托方法</param>
            <returns>如果检查成功，则返回对象本身，如果失败，返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。
            </summary>
            <typeparam name="TResult">泛型参数</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``2(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``3(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1,``2}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``4(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1,``2,``3}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``5(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1,``2,``3,``4}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``6(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``7(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``8(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``9(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="M:HslCommunication.OperateResult`10.Then``10(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,HslCommunication.OperateResult{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>
            指定接下来要做的是内容，当前对象如果成功，就返回接下来的执行结果，如果失败，就返回当前对象本身。<br />
            Specify what you want to do next, return the result of the execution of the current object if it succeeds, and return the current object itself if it fails.
            </summary>
            <typeparam name="TResult1">泛型参数一</typeparam>
            <typeparam name="TResult2">泛型参数二</typeparam>
            <typeparam name="TResult3">泛型参数三</typeparam>
            <typeparam name="TResult4">泛型参数四</typeparam>
            <typeparam name="TResult5">泛型参数五</typeparam>
            <typeparam name="TResult6">泛型参数六</typeparam>
            <typeparam name="TResult7">泛型参数七</typeparam>
            <typeparam name="TResult8">泛型参数八</typeparam>
            <typeparam name="TResult9">泛型参数九</typeparam>
            <typeparam name="TResult10">泛型参数十</typeparam>
            <param name="func">等待当前对象成功后执行的内容</param>
            <returns>返回整个方法链最终的成功失败结果</returns>
        </member>
        <member name="T:HslCommunication.DCS.DcsNanJingAuto">
            <summary>
            南京自动化研究所的DCS系统，基于modbus实现，但是不是标准的实现
            </summary>
        </member>
        <member name="M:HslCommunication.DCS.DcsNanJingAuto.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.DCS.DcsNanJingAuto.#ctor(System.String,System.Int32,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.DCS.DcsNanJingAuto.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.DCS.DcsNanJingAuto.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.DCS.DcsNanJingAuto.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.DCS.DcsNanJingAuto.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.DCS.DcsNanJingAuto.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.DTU.DTUServer">
            <summary>
            DTU的服务器信息，本服务器支持任意的hsl支持的网络对象，包括plc信息，modbus设备等等，通过DTU来连接，
            然后支持多个连接对象。如果需要支持非hsl的注册报文，需要重写相关的方法<br />
            DTU server information, the server supports any network objects supported by hsl, 
            including plc information, modbus devices, etc., connected through DTU, and then supports multiple connection objects. 
            If you need to support non-HSL registration messages, you need to rewrite the relevant methods
            </summary>
            <remarks>
            针对异形客户端进行扩展信息
            </remarks>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.#ctor(System.Collections.Generic.List{HslCommunication.DTU.DTUSettingType})">
            <summary>
            根据配置的列表信息来实例化相关的DTU服务器<br />
            Instantiate the relevant DTU server according to the configured list information
            </summary>
            <param name="dTUSettings">DTU的配置信息</param>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.#ctor(System.String[],HslCommunication.Core.Net.NetworkDeviceBase[])">
            <summary>
            根据配置的列表信息来实例化相关的DTU服务器<br />
            Instantiate the relevant DTU server according to the configured list information
            </summary>
            <param name="dtuId">Dtu信息</param>
            <param name="networkDevices">设备信息</param>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.IsClientOnline(HslCommunication.Core.Net.AlienSession)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.DTU.DTUServer.Item(System.String)">
            <summary>
            根据DTU信息获取设备的连接对象<br />
            Obtain the connection object of the device according to the DTU information
            </summary>
            <param name="dtuId">设备的id信息</param>
            <returns>设备的对象</returns>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.GetAlienSessions">
            <summary>
            获取所有的会话信息，是否在线，上线的基本信息<br />
            Get all the session information, whether it is online, online basic information
            </summary>
            <returns>会话列表</returns>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.GetDevices">
            <summary>
            获取所有的设备的信息，可以用来读写设备的数据信息<br />
            Get all device information, can be used to read and write device data information
            </summary>
            <returns>设备数组</returns>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.DTU.DTUSettingType">
            <summary>
            DTU的类型设置器
            </summary>
        </member>
        <member name="P:HslCommunication.DTU.DTUSettingType.DtuId">
            <summary>
            设备的唯一ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.DTU.DTUSettingType.DtuType">
            <summary>
            当前的设备的类型
            </summary>
        </member>
        <member name="P:HslCommunication.DTU.DTUSettingType.JsonParameter">
            <summary>
            额外的参数都存放在json里面
            </summary>
        </member>
        <member name="M:HslCommunication.DTU.DTUSettingType.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.DTU.DTUSettingType.GetClient">
            <summary>
            根据类型，获取连接对象
            </summary>
            <returns>获取设备的连接对象</returns>
        </member>
        <member name="T:HslCommunication.Enthernet.NetComplexClient">
            <summary>
            一个基于异步高性能的客户端网络类，支持主动接收服务器的消息
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/7697782.html">http://www.cnblogs.com/dathlin/p/7697782.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormComplexNet.cs" region="NetComplexClient" title="NetComplexClient示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.IsClientStart">
            <summary>
            客户端系统是否启动
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.ConnectFailedCount">
            <summary>
            重连接失败的次数
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.ClientAlias">
            <summary>
            客户端登录的标识名称，可以为ID号，也可以为登录名
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.EndPointServer">
            <summary>
            远程服务器的IP地址和端口
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.ServerTime">
            <summary>
            服务器的时间，自动实现和服务器同步
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.DelayTime">
            <summary>
            系统与服务器的延时时间，单位毫秒
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.LoginSuccess">
            <summary>
            客户端启动成功的事件，重连成功也将触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.LoginFailed">
            <summary>
            连接失败时触发的事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.MessageAlerts">
            <summary>
            服务器的异常，启动，等等一般消息产生的时候，出发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.BeforReConnected">
            <summary>
            在客户端断开后并在重连服务器之前触发，用于清理系统资源
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.ClientClose">
            <summary>
            关闭该客户端引擎
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.ClientStart">
            <summary>
            启动客户端引擎，连接服务器系统
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.AwaitToConnect">
            <summary>
            连接服务器之前的消息提示，如果是重连的话，就提示10秒等待信息
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.Send(HslCommunication.NetHandle,System.String)">
            <summary>
            服务器端用于数据发送文本的方法
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">发送的文本</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.Send(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            服务器端用于发送字节的方法
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="bytes">实际发送的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.ThreadHeartCheck">
            <summary>
            心跳线程的方法
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetComplexServer">
            <summary>
            高性能的异步网络服务器类，适合搭建局域网聊天程序，消息推送程序
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/8097897.html">http://www.cnblogs.com/dathlin/p/8097897.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\ComplexNetServer\FormServer.cs" region="NetComplexServer" title="NetComplexServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.#ctor">
            <summary>
            实例化一个网络服务器类对象
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexServer.ConnectMax">
            <summary>
            所支持的同时在线客户端的最大数量，默认为10000个
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexServer.IsSaveLogClientLineChange">
            <summary>
            获取或设置服务器是否记录客户端上下线信息，默认为true
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexServer.ClientCount">
            <summary>
            所有在线客户端的数量
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.StartInitialization">
            <summary>
            初始化操作
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.CloseAction">
            <summary>
            关闭网络时的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.AppSessionRemoteClose(HslCommunication.Core.Net.AppSession)">
            <summary>
            让客户端正常下线，调用本方法即可自由控制会话客户端强制下线操作。
            </summary>
            <param name="session">会话对象</param>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.AllClientsStatusChange">
            <summary>
            客户端的上下限状态变更时触发，仅作为在线客户端识别
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.ClientOnline">
            <summary>
            当客户端上线的时候，触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.ClientOffline">
            <summary>
            当客户端下线的时候，触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.Send(HslCommunication.Core.Net.AppSession,HslCommunication.NetHandle,System.String)">
            <summary>
            服务器端用于数据发送文本的方法
            </summary>
            <param name="session">数据发送对象</param>
            <param name="customer">用户自定义的数据对象，如不需要，赋值为0</param>
            <param name="str">发送的文本</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.Send(HslCommunication.Core.Net.AppSession,HslCommunication.NetHandle,System.Byte[])">
            <summary>
            服务器端用于发送字节的方法
            </summary>
            <param name="session">数据发送对象</param>
            <param name="customer">用户自定义的数据对象，如不需要，赋值为0</param>
            <param name="bytes">实际发送的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.SendAllClients(HslCommunication.NetHandle,System.String)">
            <summary>
            服务端用于发送所有数据到所有的客户端
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">需要传送的实际的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.SendAllClients(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            服务端用于发送所有数据到所有的客户端
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="data">需要群发客户端的字节数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.SendClientByAlias(System.String,HslCommunication.NetHandle,System.String)">
            <summary>
            根据客户端设置的别名进行发送消息
            </summary>
            <param name="Alias">客户端上线的别名</param>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">需要传送的实际的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.SendClientByAlias(System.String,HslCommunication.NetHandle,System.Byte[])">
            <summary>
            根据客户端设置的别名进行发送消息
            </summary>
            <param name="Alias">客户端上线的别名</param>
            <param name="customer">用户自定义的命令头</param>
            <param name="data">需要传送的实际的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.DeviceNet">
            <summary>
            通用设备的基础网络信息
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.DeviceNet.#ctor">
            <summary>
            实例化一个通用的设备类
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.DeviceNet.ClientOnline">
            <summary>
            当客户端上线的时候，触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.DeviceNet.ClientOffline">
            <summary>
            当客户端下线的时候，触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.DeviceNet.AcceptString">
            <summary>
            按照ASCII文本的方式进行触发接收的数据
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.DeviceNet.AcceptBytes">
            <summary>
            按照字节的方式进行触发接收的数据
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.DeviceNet.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="T:HslCommunication.Enthernet.DeviceState">
            <summary>
            通用设备的基础状态
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.DeviceEndPoint">
            <summary>
            设备的连接地址
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.ConnectTime">
            <summary>
            设备的连接时间
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.WorkSocket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.ReceiveTime">
            <summary>
            上次接收到信息的时间
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.IpAddress">
            <summary>
            设备的ip地址
            </summary>
        </member>
        <member name="F:HslCommunication.Enthernet.DeviceState.Buffer">
            <summary>
            缓冲内存块
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.AdvancedFileServer">
            <summary>
            文件管理类服务器，负责服务器所有分类文件的管理，特点是不支持文件附加数据，但是支持直接访问文件名
            </summary>
            <remarks>
            本文件的服务器不支持存储文件携带的额外信息，是直接将文件存放在服务器指定目录下的，文件名不更改，特点是服务器查看方便。
            </remarks>
            <example>
            以下的示例来自Demo项目，创建了一个简单的服务器对象。
            <code lang="cs" source="TestProject\FileNetServer\FormFileServer.cs" region="Advanced Server" title="AdvancedFileServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.StartInitialization">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.CheckFolderAndCreate">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.ReceiveFileFromSocketAndMoveFile(System.Net.Sockets.Socket,System.String,System.String)">
            <summary>
            从网络套接字接收文件并移动到目标的文件夹中，如果结果异常，则结束通讯
            </summary>
            <param name="socket"></param>
            <param name="savename"></param>
            <param name="fileNameNew"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.ReceiveFileFromSocketAndMoveFileAsync(System.Net.Sockets.Socket,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.AdvancedFileServer.ReceiveFileFromSocketAndMoveFile(System.Net.Sockets.Socket,System.String,System.String)"/>
        </member>
        <member name="P:HslCommunication.Enthernet.AdvancedFileServer.FilesDirectoryPathTemp">
            <summary>
            用于接收上传文件时的临时文件夹，临时文件使用结束后会被删除<br />
            Used to receive the temporary folder when uploading files. The temporary files will be deleted after use
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.FileClientBase">
            <summary>
            文件传输客户端基类，提供上传，下载，删除的基础服务<br />
            File transfer client base class, providing basic services for uploading, downloading, and deleting
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileClientBase.ServerIpEndPoint">
            <summary>
            文件管理服务器的ip地址及端口<br />
            IP address and port of the file management server
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileClientBase.ConnectTimeOut">
            <summary>
            获取或设置连接的超时时间，默认10秒<br />
            Gets or sets the connection timeout time. The default is 10 seconds.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.SendFactoryGroupId(System.Net.Sockets.Socket,System.String,System.String,System.String)">
            <summary>
            发送三个文件分类信息到服务器端，方便后续开展其他的操作。<br />
            Send the three file classification information to the server to facilitate subsequent operations.
            </summary>
            <param name="socket">套接字对象</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.SendFactoryGroupIdAsync(System.Net.Sockets.Socket,System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.FileClientBase.SendFactoryGroupId(System.Net.Sockets.Socket,System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFileBase(System.String,System.String,System.String,System.String)">
            <summary>
            删除服务器上的文件，需要传入文件信息，以及文件绑定的分类信息。<br />
            To delete a file on the server, you need to pass in the file information and the classification information of the file binding.
            </summary>
            <param name="fileName">文件的名称</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFileBase(System.String[],System.String,System.String,System.String)">
            <summary>
            删除服务器上的文件列表，需要传入文件信息，以及文件绑定的分类信息。<br />
            To delete a file on the server, you need to pass in the file information and the classification information of the file binding.
            </summary>
            <param name="fileNames">所有等待删除的文件的名称</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFolderBase(System.String,System.String,System.String)">
            <summary>
            删除服务器上的指定目录的所有文件，需要传入分类信息。<br />
            To delete all files in the specified directory on the server, you need to input classification information
            </summary>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteEmptyFoldersBase(System.String,System.String,System.String)">
            <summary>
            删除服务器上的指定目录的所有空文件目录，需要传入分类信息。<br />
            Delete all the empty file directories in the specified directory on the server, need to input classification information
            </summary>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFileBaseAsync(System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.FileClientBase.DeleteFileBase(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFileBaseAsync(System.String[],System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.FileClientBase.DeleteFileBase(System.String[],System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFolderBaseAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.FileClientBase.DeleteFolderBase(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteEmptyFoldersBaseAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.FileClientBase.DeleteEmptyFoldersBase(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DownloadFileBase(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.Object)">
            <summary>
            下载服务器的文件数据，并且存储到对应的内容里去。<br />
            Download the file data of the server and store it in the corresponding content.
            </summary>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <param name="fileName">服务器的文件名称</param>
            <param name="processReport">下载的进度报告，第一个数据是已完成总接字节数，第二个数据是总字节数。</param>
            <param name="source">数据源信息，决定最终存储到哪里去</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DownloadFileBaseAsync(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.Object)">
            <inheritdoc cref="M:HslCommunication.Enthernet.FileClientBase.DownloadFileBase(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.Object)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.UploadFileBase(System.Object,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传文件给服务器，需要指定上传的数据内容，上传到服务器的分类信息，支持进度汇报功能。<br />
            To upload files to the server, you need to specify the content of the uploaded data, 
            the classification information uploaded to the server, and support the progress report function.
            </summary>
            <param name="source">数据源，可以是文件名，也可以是数据流</param>
            <param name="serverName">在服务器保存的文件名，不包含驱动器路径</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <param name="fileTag">文件的描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">汇报进度，第一个数据是已完成总接字节数，第二个数据是总字节数。</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.UploadFileBaseAsync(System.Object,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.FileClientBase.UploadFileBase(System.Object,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.IntegrationFileClient">
            <summary>
            与服务器文件引擎交互的客户端类，支持操作Advanced引擎和Ultimate引擎，用来上传，下载，删除服务器中的文件操作。<br />
            The client class that interacts with the server file engine, supports the operation of the Advanced engine and the Ultimate engine,
            and is used to upload, download, and delete file operations on the server.
            </summary>
            <remarks>
            这里需要需要的是，本客户端支持Advanced引擎和Ultimate引擎文件服务器，服务的类型需要您根据自己的需求来选择。
            <note type="important">需要注意的是，三个分类信息，factory, group, id 的字符串是不区分大小写的。</note>
            </remarks>
            <example>
            此处只演示创建实例，具体的上传，下载，删除的例子请参照对应的方法
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Intergration File Client" title="IntegrationFileClient示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.#ctor">
            <summary>
            实例化一个默认的对象，需要提前指定服务器的远程地址<br />
            Instantiate a default object, you need to specify the remote address of the server in advance
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的Ip地址及端口号实例化一个对象<br />
            Instantiate an object with the specified IP address and port number
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="P:HslCommunication.Enthernet.IntegrationFileClient.FileCacheSize">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkBase.fileCacheSize"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String,System.String,System.String,System.String)">
            <summary>
            删除服务器的文件操作，需要指定文件名称，文件的三级分类信息<br />
            Delete the file operation of the server, you need to specify the file name and the three-level classification information of the file
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String)">
            <summary>
            删除服务器的文件操作，此处文件的分类为空<br />
            Delete the file operation of the server, the classification of the file is empty here
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String[],System.String,System.String,System.String)">
            <summary>
            删除服务器的文件数组操作，需要指定文件名称，文件的三级分类信息<br />
            Delete the file operation of the server, you need to specify the file names and the three-level classification information of the file
            </summary>
            <param name="fileNames">文件名称数组，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFolderFiles(System.String,System.String,System.String)">
            <summary>
            删除服务器的文件夹的所有文件操作，文件的三级分类信息<br />
            Delete all file operations of the server folder, the three-level classification information of the file
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteEmptyFolders(System.String,System.String,System.String)">
            <summary>
            删除服务器的文件夹的所有空的子文件目录操作，需要传入文件的三级分类信息<br />
            To delete all empty sub-file directories of the server's folder, you need to pass in the three-level classification information of the file
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.GetGroupFileInfo(System.String,System.String,System.String)">
            <summary>
            获取服务器文件夹的指定目录的文件统计信息，包括文件数量，总大小，最后更新时间<br />
            Get the file statistics of the specified directory of the server folder, including the number of files, the total size, and the last update time
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>返回路径的信息，包含文件大小，数量，最后更新时间</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.GetSubGroupFileInfos(System.String,System.String,System.String)">
            <summary>
            获取服务器文件夹的指定目录的所有子目录的文件信息，包括每个子目录的文件数量，总大小，最后更新时间<br />
            Get the file information of all subdirectories of the specified directory of the server folder, including the number of files in each subdirectory, the total size, and the last update time
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>返回路径的信息，包含文件大小，数量，最后更新时间</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFileAsync(System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFileAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFileAsync(System.String[],System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String[],System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFolderFilesAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFolderFiles(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteEmptyFoldersAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteEmptyFolders(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.GetGroupFileInfoAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.GetGroupFileInfo(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.GetSubGroupFileInfosAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.GetGroupFileInfo(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)">
            <summary>
            下载服务器的文件到本地的文件操作，需要指定下载的文件的名字，三级分类信息，本次保存的文件名，支持进度报告。<br />
            To download a file from the server to a local file, you need to specify the name of the downloaded file, 
            the three-level classification information, the name of the file saved this time, and support for progress reports.
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="processReport">下载的进度报告，第一个数据是已完成总接字节数，第二个数据是总字节数。</param>
            <param name="fileSaveName">准备本地保存的名称</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是服务器不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Download File" title="DownloadFile示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.IO.Stream)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFileAsync(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFileAsync(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.IO.Stream)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.IO.Stream)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFileAsync(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作，如果该文件已经存在，那么就更新这个文件。<br />
            Upload a local file to the server. If the file already exists, update the file.
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="serverName">服务器存储的文件名称，带后缀，例如123.txt</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作，服务器存储的文件名就是当前文件默认的名称
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作，服务器存储的文件名就是当前文件默认的名称
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作，服务器存储的文件名就是当前文件默认的名称，其余参数默认为空
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.IO.Stream,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传数据流到服务器操作
            </summary>
            <param name="stream">数据流内容</param>
            <param name="serverName">服务器存储的文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.Drawing.Bitmap,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传内存图片到服务器操作
            </summary>
            <param name="bitmap">内存图片，不能为空</param>
            <param name="serverName">服务器存储的文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFileAsync(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFileAsync(System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFileAsync(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFileAsync(System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFileAsync(System.IO.Stream,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.IO.Stream,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFileAsync(System.Drawing.Bitmap,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.Drawing.Bitmap,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadPathFileNames(System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的文档<br />
            Get all documents in the specified path
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="DownloadPathFileNames" title="DownloadPathFileNames示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadPathFileNamesAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadPathFileNames(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadPathFolders(System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的目录<br />
            Get all directories under the specified path
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="DownloadPathFolders" title="DownloadPathFolders示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadPathFoldersAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadPathFolders(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.IsFileExists(System.String,System.String,System.String,System.String)">
            <summary>
            检查当前的文件是否在服务器端存在，列表中需要存在文件的名称，映射的文件也需要存在。<br />
            Check whether the current file exists on the server side, the name of the file must exist in the list, and the mapped file must also exist.
            </summary>
            <param name="fileName">当前的文件名称，举例123.txt</param>
            <param name="factory">第一级分类信息</param>
            <param name="group">第二级分类信息</param>
            <param name="id">第三级分类信息</param>
            <returns>是否存在，存在返回true, 否则，返回false</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.IsFileExistsAsync(System.String,System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.IsFileExists(System.String,System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadStringArrays``1(System.Int32,System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的路径或是文档信息
            </summary>
            <param name="protocol">指令</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <typeparam name="T">数组的类型</typeparam>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadStringArraysAsync``1(System.Int32,System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadStringArrays``1(System.Int32,System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.UltimateFileServer">
            <summary>
            一个终极文件管理服务器，可以实现对所有的文件分类管理，本服务器支持读写分离，支持同名文件，
            客户端使用<see cref="T:HslCommunication.Enthernet.IntegrationFileClient"/>进行访问，支持上传，下载，删除，请求文件列表，校验文件是否存在操作。<br />
            An ultimate file management server, which can realize classified management of all files. This server supports read-write separation, 
            supports files with the same name, and the client uses <see cref="T:HslCommunication.Enthernet.IntegrationFileClient"/> to access, 
            supports upload, download, delete, and request files List, check whether the file exists operation.
            </summary>
            <remarks>
            本文件的服务器支持存储文件携带上传人的信息，备注信息，文件名被映射成了新的名称，无法在服务器直接查看文件信息。
            </remarks>
            <example>
            以下的示例来自Demo项目，创建了一个简单的服务器对象。
            <code lang="cs" source="TestProject\FileNetServer\FormFileServer.cs" region="Ultimate Server" title="UltimateFileServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.GroupFileContainerCount">
            <summary>
            获取当前的针对文件夹的文件管理容器的数量<br />
            Get the current number of file management containers for the folder
            </summary>
        </member>
        <member name="F:HslCommunication.Enthernet.UltimateFileServer.m_dictionary_group_marks">
            <summary>
            所有文件组操作的词典锁
            </summary>
        </member>
        <member name="F:HslCommunication.Enthernet.UltimateFileServer.hybirdLock">
            <summary>
            词典的锁
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.GetGroupFromFilePath(System.String)">
            <summary>
            获取当前目录的文件列表管理容器，如果没有会自动创建，通过该容器可以实现对当前目录的文件进行访问<br />
            Get the file list management container of the current directory. If not, it will be created automatically. 
            Through this container, you can access files in the current directory.
            </summary>
            <param name="filePath">路径信息</param>
            <returns>文件管理容器信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.DeleteGroupFile(HslCommunication.Core.GroupFileContainer)">
            <summary>
            清除系统中所有空的路径信息
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.ReceiveFileFromSocketAndUpdateGroup(System.Net.Sockets.Socket,System.String)">
            <summary>
            从套接字接收文件并保存，更新文件列表
            </summary>
            <param name="socket">套接字</param>
            <param name="savename">保存的文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.ReceiveFileFromSocketAndUpdateGroupAsync(System.Net.Sockets.Socket,System.String)">
            <summary>
            从套接字接收文件并保存，更新文件列表
            </summary>
            <param name="socket">套接字</param>
            <param name="savename">保存的文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.TransformFactFileName(System.String,System.String,System.String,System.String)">
            <summary>
            根据文件的显示名称转化为真实存储的名称，例如 123.txt 获取到在文件服务器里映射的文件名称，例如返回 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件显示名称</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.DeleteExsistingFile(System.String,System.String)">
            <summary>
            删除已经存在的文件信息，文件的名称需要是guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="path">文件的路径</param>
            <param name="fileName">文件的guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909</param>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.DeleteExsistingFile(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            删除已经存在的文件信息，文件的名称需要是guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="path">文件的路径</param>
            <param name="fileNames">文件的guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909</param>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.HttpServer">
            <summary>
            一个支持完全自定义的Http服务器，支持返回任意的数据信息，方便调试信息，详细的案例请查看API文档信息<br />
            A Http server that supports fully customized, supports returning arbitrary data information, which is convenient for debugging information. For detailed cases, please refer to the API documentation information
            </summary>
            <example>
            我们先来看看一个最简单的例子，如何进行实例化的操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample1" title="基本的实例化" />
            通常来说，基本的实例化，返回固定的数据并不能满足我们的需求，我们需要返回自定义的数据，有一个委托，我们需要自己指定方法.
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample2" title="自定义返回" />
            我们实际的需求可能会更加的复杂，不同的网址会返回不同的数据，所以接下来我们需要对网址信息进行判断。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample3" title="区分网址" />
            如果我们想增加安全性的验证功能，比如我们的api接口需要增加用户名和密码的功能，那么我们也可以实现
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample4" title="安全实现" />
            当然了，如果我们想反回一个完整的html网页，也是可以实现的，甚至添加一些js的脚本，下面的例子就简单的说明了如何操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample5" title="返回html" />
            如果需要实现跨域的操作，可以将属性<see cref="P:HslCommunication.Enthernet.HttpServer.IsCrossDomain"/> 设置为<c>True</c>
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.#ctor">
            <summary>
            实例化一个默认的对象，当前的运行，需要使用管理员的模式运行<br />
            Instantiate a default object, the current operation, you need to use the administrator mode to run
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.Start(System.Int32)">
            <summary>
            启动服务器，正常调用该方法时，应该使用try...catch...来捕获错误信息<br />
            Start the server and use try...catch... to capture the error message when calling this method normally
            </summary>
            <param name="port">端口号信息</param>
            <exception cref="T:System.Net.HttpListenerException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.Close">
            <summary>
            关闭服务器<br />
            Shut down the server
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.HandleRequest(System.Net.HttpListenerRequest,System.Net.HttpListenerResponse,System.String)">
            <summary>
            根据客户端的请求进行处理的核心方法，可以返回自定义的数据内容，只需要集成重写即可。<br />
            The core method of processing according to the client's request can return custom data content, and only needs to be integrated and rewritten.
            </summary>
            <param name="request">请求</param>
            <param name="response">回应</param>
            <param name="data">Body数据</param>
            <returns>返回的内容</returns>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.DealWithHttpListenerRequest">
            <summary>
            额外的处理请求信息的委托定义，将可以自定义处理一些特殊的请求头数据，例如一些账户相关的其他属性，语言属性等等。<br />
            Additional delegate definitions for processing request information will be able to customize some special request header data, 
            such as some other account-related attributes, language attributes, and so on.
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.LogStatistics">
            <summary>
            获取当前的日志统计信息，可以获取到每个API的每天的调度次数信息，缓存60天数据，如果需要存储本地，需要调用<see cref="M:HslCommunication.LogNet.LogStatisticsDict.SaveToFile(System.String)"/>方法。<br />
            Get the current log statistics, you can get the daily scheduling times information of each API, and cache 60-day data. 
            If you need to store it locally, you need to call the <see cref="M:HslCommunication.LogNet.LogStatisticsDict.SaveToFile(System.String)"/> method.
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.ServerEncoding">
            <summary>
            获取或设置当前服务器的编码信息，默认为UTF8编码<br />
            Get or set the encoding information of the current server, the default is UTF8 encoding
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.IsCrossDomain">
            <summary>
            获取或设置是否支持跨域操作<br />
            Get or set whether to support cross-domain operations
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.HandleRequestFunc">
            <summary>
            获取或设置当前的自定义的处理信息，如果不想继承实现方法，可以使用本属性来关联你自定义的方法。<br />
            Get or set the current custom processing information. If you don't want to inherit the implementation method, you can use this attribute to associate your custom method.
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.Port">
            <summary>
            获取当前的端口号信息<br />
            Get current port number information
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.GetAllRpcApiInfo">
            <summary>
            获取当前所有注册的RPC接口信息，将返回一个数据列表。<br />
            Get all currently registered RPC interface information, and a data list will be returned.
            </summary>
            <returns>信息列表</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.RegisterHttpRpcApi(System.String,System.Object)">
            <summary>
            注册一个RPC的服务接口，可以指定当前的控制器名称，以及提供RPC服务的原始对象<br />
            Register an RPC service interface, you can specify the current controller name, 
            and the original object that provides the RPC service
            </summary>
            <param name="api">前置的接口信息，可以理解为MVC模式的控制器</param>
            <param name="obj">原始对象信息</param>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.RegisterHttpRpcApi(System.Object)">
            <inheritdoc cref="M:HslCommunication.Enthernet.HttpServer.RegisterHttpRpcApi(System.String,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.SetLoginAccessControl(HslCommunication.MQTT.MqttCredential[])">
            <summary>
            设置登录的账户信息，如果需要自己控制，可以自己实现委托<see cref="P:HslCommunication.Enthernet.HttpServer.HandleRequestFunc"/><br />
            Set the login account information, if you need to control by yourself, you can implement the delegation by yourself<see cref="P:HslCommunication.Enthernet.HttpServer.HandleRequestFunc"/>
            </summary>
            <param name="credentials">用户名的列表信息</param>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.HandleObjectMethod(System.Net.HttpListenerRequest,System.String,System.String,System.Object,System.Action{System.Net.HttpListenerRequest,HslCommunication.Core.ISessionContext})">
            <summary>
            使用指定的对象来返回网络的API接口，前提是传入的数据为json参数，返回的数据为json数据，详细参照说明<br />
            Use the specified object to return the API interface of the network, 
            provided that the incoming data is json parameters and the returned data is json data, 
            please refer to the description for details
            </summary>
            <param name="request">当前的请求信息</param>
            <param name="deceodeUrl">已经解码过的Url地址信息</param>
            <param name="json">json格式的参数信息</param>
            <param name="obj">等待解析的api解析的对象</param>
            <param name="action">额外的解析Request参数的方法</param>
            <returns>等待返回客户的结果</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.GetMethodName(System.String)">
            <summary>
            根据完整的地址获取当前的url地址信息
            </summary>
            <param name="url">地址信息</param>
            <returns>方法名称</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.HandleObjectMethod(System.Net.HttpListenerRequest,System.String,System.String,HslCommunication.MQTT.MqttRpcApiInfo,System.Action{System.Net.HttpListenerRequest,HslCommunication.Core.ISessionContext})">
            <summary>
            使用指定的对象来返回网络的API接口，前提是传入的数据为json参数，返回的数据为json数据，详细参照说明<br />
            Use the specified object to return the API interface of the network, 
            provided that the incoming data is json parameters and the returned data is json data, 
            please refer to the description for details
            </summary>
            <param name="request">当前的请求信息</param>
            <param name="deceodeUrl">已经解码过的Url地址信息</param>
            <param name="json">json格式的参数信息</param>
            <param name="apiInformation">等待解析的api解析的对象</param>
            <param name="action">额外的解析Request参数的方法</param>
            <returns>等待返回客户的结果</returns>
        </member>
        <member name="T:HslCommunication.Enthernet.NetPlainSocket">
            <summary>
            一个基于明文的socket中心
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口号来实例化这个对象
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.ConnectServer">
            <summary>
            连接服务器
            </summary>
            <returns>返回是否连接成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.ConnectClose">
            <summary>
            关闭当前的连接对象
            </summary>
            <returns>错误信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.SendString(System.String)">
            <summary>
            发送字符串到网络上去
            </summary>
            <param name="text">文本信息</param>
            <returns>发送是否成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.ReConnectServer(System.Object)">
            <summary>
            是否是处于重连的状态
            </summary>
            <param name="obj">无用的对象</param>
        </member>
        <member name="E:HslCommunication.Enthernet.NetPlainSocket.ReceivedString">
            <summary>
            当接收到字符串时候的触发事件
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPlainSocket.Encoding">
            <summary>
            当前的编码器
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:HslCommunication.Enthernet.AppPushSession">
            <summary>
            当前的推送的会话的基本信息
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.NetPushClient">
            <summary>
            发布订阅类的客户端，使用指定的关键订阅相关的数据推送信息
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/8992315.html">http://www.cnblogs.com/dathlin/p/8992315.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormPushNet.cs" region="FormPushNet" title="NetPushClient示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="key">订阅关键字</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.CreatePush(System.Action{HslCommunication.Enthernet.NetPushClient,System.String})">
            <summary>
            创建数据推送服务
            </summary>
            <param name="pushCallBack">触发数据推送的委托</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.CreatePush">
            <summary>
            创建数据推送服务，使用事件绑定的机制实现
            </summary>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.ClosePush">
            <summary>
            关闭消息推送的界面
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPushClient.KeyWord">
            <summary>
            本客户端的关键字
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPushClient.ReConnectTime">
            <summary>
            获取或设置重连服务器的间隔时间，单位：毫秒
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetPushClient.OnReceived">
            <summary>
            当接收到数据的事件信息，接收到数据的时候触发。
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetPushServer">
            <summary>
            发布订阅服务器的类，支持按照关键字进行数据信息的订阅
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/8992315.html">http://www.cnblogs.com/dathlin/p/8992315.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\PushNetServer\FormServer.cs" region="NetPushServer" title="NetPushServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.ServerClose">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.PushString(System.String,System.String)">
            <summary>
            主动推送数据内容
            </summary>
            <param name="key">关键字</param>
            <param name="content">数据内容</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.RemoveKey(System.String)">
            <summary>
            移除关键字信息，通常应用于一些特殊临时用途的关键字
            </summary>
            <param name="key">关键字</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.CreatePushRemote(System.String,System.Int32,System.String)">
            <summary>
            创建一个远程服务器的数据推送操作，以便推送给子客户端
            </summary>
            <param name="ipAddress">远程的IP地址</param>
            <param name="port">远程的端口号</param>
            <param name="key">订阅的关键字</param>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPushServer.OnlineCount">
            <summary>
            在线客户端的数量
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPushServer.PushCacheAfterConnect">
            <summary>
            在客户端上线之后，是否推送缓存的数据，默认设置为true
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.RemoveGroupOnline(System.String,System.String)">
            <summary>
            移除客户端的数据信息
            </summary>
            <param name="key">指定的客户端</param>
            <param name="clientID">指定的客户端唯一的id信息</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.PushGroupClient">
            <summary>
            订阅分类的核心组织对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.AddPushClient(HslCommunication.Core.Net.AppSession)">
            <summary>
            新增一个订阅的会话
            </summary>
            <param name="session">会话</param>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.RemovePushClient(System.String)">
            <summary>
            移除一个订阅的会话
            </summary>
            <param name="clientID">客户端唯一的ID信息</param>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.PushString(System.String,System.Action{HslCommunication.Core.Net.AppSession,System.String})">
            <summary>
            使用固定的发送方法将数据发送出去
            </summary>
            <param name="content">数据内容</param>
            <param name="send">指定的推送方法</param>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.RemoveAllClient">
            <summary>
            移除并关闭所有的客户端
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.HasPushedContent">
            <summary>
            获取是否推送过数据
            </summary>
            <returns>True代表有，False代表没有</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.Dispose(System.Boolean)">
            <summary>
            释放当前的程序所占用的资源
            </summary>
            <param name="disposing">是否释放资源</param>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.Dispose">
            <summary>
            释放当前的对象所占用的资源
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.IRedisConnector">
            <summary>
            关于Redis实现的接口<see cref="T:HslCommunication.Algorithms.ConnectPool.IConnector"/>，从而实现了数据连接池的操作信息
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.IRedisConnector.IsConnectUsing">
            <inheritdoc cref="P:HslCommunication.Algorithms.ConnectPool.IConnector.IsConnectUsing"/>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.IRedisConnector.GuidToken">
            <inheritdoc cref="P:HslCommunication.Algorithms.ConnectPool.IConnector.GuidToken"/>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.IRedisConnector.LastUseTime">
            <inheritdoc cref="P:HslCommunication.Algorithms.ConnectPool.IConnector.LastUseTime"/>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.IRedisConnector.Redis">
            <summary>
            Redis的连接对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.IRedisConnector.Close">
            <inheritdoc cref="M:HslCommunication.Algorithms.ConnectPool.IConnector.Close"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.IRedisConnector.Open">
            <inheritdoc cref="M:HslCommunication.Algorithms.ConnectPool.IConnector.Open"/>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisClientPool">
            <summary>
            <b>[商业授权]</b> Redis客户端的连接池类对象，用于共享当前的连接池，合理的动态调整连接对象，然后进行高效通信的操作，默认连接数无限大。<br />
            <b>[Authorization]</b> The connection pool class object of the Redis client is used to share the current connection pool, 
            reasonably dynamically adjust the connection object, and then perform efficient communication operations, 
            The default number of connections is unlimited
            </summary>
            <remarks>
            本连接池的实现仅对商业授权用户开放，用于提供服务器端的与Redis的并发读写能力。使用上和普通的 <see cref="T:HslCommunication.Enthernet.Redis.RedisClient"/> 没有区别，
            但是在高并发上却高性能的多，占用的连接也更少，这一切都是连接池自动实现的。
            </remarks>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个默认的客户端连接池对象，需要指定实例Redis对象时的IP，端口，密码信息<br />
            To instantiate a default client connection pool object, you need to specify the IP, port, and password information when the Redis object is instantiated
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号信息</param>
            <param name="password">密码，如果没有，请输入空字符串</param>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.#ctor(System.String,System.Int32,System.String,System.Action{HslCommunication.Enthernet.Redis.RedisClient})">
            <summary>
            实例化一个默认的客户端连接池对象，需要指定实例Redis对象时的IP，端口，密码信息，以及可以指定额外的初始化操作<br />
            To instantiate a default client connection pool object, you need to specify the IP, port, 
            and password information when the Redis object is instantiated, and you can specify additional initialization operations
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号信息</param>
            <param name="password">密码，如果没有，请输入空字符串</param>
            <param name="initialize">额外的初始化信息，比如修改db块的信息。</param>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.RedisClientPool.GetRedisConnectPool">
            <summary>
            获取当前的连接池管理对象信息<br />
            Get current connection pool management object information
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.RedisClientPool.MaxConnector">
            <inheritdoc cref="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.MaxConnector"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteKey(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKey(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteKey(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExistsKey(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExpireKey(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ExpireKey(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadAllKeys(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAllKeys(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.MoveKey(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.MoveKey(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.PersistKey(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.PersistKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadRandomKey">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadRandomKey"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.RenameKey(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.RenameKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyType(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyType(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyTTL(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyTTL(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteKeyAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteKey(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExistsKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExistsKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExpireKeyAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExpireKey(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadAllKeysAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadAllKeys(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.MoveKeyAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.MoveKey(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.PersistKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.PersistKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadRandomKeyAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadRandomKey"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.RenameKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.RenameKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyTypeAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyType(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyTTLAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyTTL(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.AppendKey(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.AppendKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DecrementKey(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DecrementKey(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKey(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKey(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyRange(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyRange(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadAndWriteKey(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAndWriteKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKey(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKey(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKey(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKey(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKey(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKey(System.String[],System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKey(System.String[],System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKey(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteAndPublishKey(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteAndPublishKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteExpireKey(System.String,System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteExpireKey(System.String,System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKeyIfNotExists(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyIfNotExists(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKeyRange(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyRange(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyLength(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.AppendKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.AppendKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DecrementKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.DecrementKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DecrementKeyAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.DecrementKey(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyRangeAsync(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyRange(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadAndWriteKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadAndWriteKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKeyAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKey(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKeyAsync(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementKey(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKey(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKeyAsync(System.String[],System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKey(System.String[],System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteAndPublishKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteAndPublishKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteExpireKeyAsync(System.String,System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteExpireKey(System.String,System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKeyIfNotExistsAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKeyIfNotExists(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKeyRangeAsync(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteKeyRange(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyLengthAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadKeyLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListInsertBefore(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertBefore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListInsertAfter(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertAfter(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.GetListLength(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.GetListLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadListByIndex(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadListByIndex(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPop(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPush(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPush(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPushX(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPushX(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRange(System.String,System.Int64,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRange(System.String,System.Int64,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRemoveElementMatch(System.String,System.Int64,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRemoveElementMatch(System.String,System.Int64,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListSet(System.String,System.Int64,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListSet(System.String,System.Int64,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListTrim(System.String,System.Int64,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListTrim(System.String,System.Int64,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPop(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPopLeftPush(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPopLeftPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPush(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPush(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPushX(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPushX(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListInsertBeforeAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListInsertBefore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListInsertAfterAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListInsertAfter(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.GetListLengthAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.GetListLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadListByIndexAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadListByIndex(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPopAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPushAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPushAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPush(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPushXAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListLeftPushX(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRangeAsync(System.String,System.Int64,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRange(System.String,System.Int64,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRemoveElementMatchAsync(System.String,System.Int64,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRemoveElementMatch(System.String,System.Int64,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListSetAsync(System.String,System.Int64,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListSet(System.String,System.Int64,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListTrimAsync(System.String,System.Int64,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListTrim(System.String,System.Int64,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPopAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPopLeftPushAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPopLeftPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPushAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPushAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPush(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPushXAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ListRightPushX(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteHashKey(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteHashKey(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExistsHashKey(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKey(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeyAll(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyAll(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementHashKey(System.String,System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementHashKey(System.String,System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeys(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeys(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeyLength(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKey(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKey(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKey(System.String,System.String[],System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String[],System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKeyNx(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKeyNx(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashValues(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashValues(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteHashKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteHashKeyAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.DeleteHashKey(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExistsHashKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ExistsHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeyAllAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeyAll(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementHashKeyAsync(System.String,System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementHashKey(System.String,System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementHashKeyAsync(System.String,System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.IncrementHashKey(System.String,System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeysAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeys(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeyLengthAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeyLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKeyAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashKey(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKeyAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKey(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKeyAsync(System.String,System.String[],System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKey(System.String,System.String[],System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKeyNxAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteHashKeyNx(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashValuesAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadHashValues(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetAdd(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetAdd(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetAdd(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetAdd(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetCard(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetCard(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiff(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiff(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiffStore(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiffStore(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInter(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetInter(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInter(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetInter(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInterStore(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInterStore(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetIsMember(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetIsMember(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetMembers(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetMembers(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetMove(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetMove(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetPop(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRandomMember(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMember(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRandomMember(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMember(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRemove(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemove(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRemove(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemove(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnion(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnion(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnion(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnion(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnionStore(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnionStore(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetAddAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetAdd(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetAddAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetAdd(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetCardAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetCard(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiffAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiff(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiffAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiff(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiffStoreAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiffStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiffStoreAsync(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetDiffStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInterAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInter(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInterAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInter(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInterStoreAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInterStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInterStoreAsync(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetInterStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetIsMemberAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetIsMember(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetMembersAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetMembers(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetMoveAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetMove(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetPopAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRandomMemberAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRandomMember(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRandomMemberAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRandomMember(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRemoveAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRemove(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRemoveAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetRemove(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnionAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnion(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnionAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnion(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnionStoreAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnionStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnionStoreAsync(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SetUnionStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetAdd(System.String,System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAdd(System.String,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetAdd(System.String,System.String[],System.Double[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAdd(System.String,System.String[],System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetCard(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCard(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetCount(System.String,System.Double,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCount(System.String,System.Double,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetIncreaseBy(System.String,System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetIncreaseBy(System.String,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRange(System.String,System.Int32,System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRange(System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRangeByScore(System.String,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRangeByScore(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRank(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRank(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemove(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemove(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemove(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemove(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemoveRangeByRank(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByRank(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemoveRangeByScore(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByScore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRange(System.String,System.Int32,System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRange(System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRangeByScore(System.String,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRangeByScore(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRank(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRank(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetScore(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetScore(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetAddAsync(System.String,System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetAdd(System.String,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetAddAsync(System.String,System.String[],System.Double[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetAdd(System.String,System.String[],System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetCardAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetCard(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetCountAsync(System.String,System.Double,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetCount(System.String,System.Double,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetIncreaseByAsync(System.String,System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetIncreaseBy(System.String,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRangeAsync(System.String,System.Int32,System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRange(System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRangeByScoreAsync(System.String,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRangeByScore(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRankAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRank(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemoveAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemove(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemoveAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemove(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemoveRangeByRankAsync(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemoveRangeByRank(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemoveRangeByScoreAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetRemoveRangeByScore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRangeAsync(System.String,System.Int32,System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRange(System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRangeByScoreAsync(System.String,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRangeByScore(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRankAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetReverseRank(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetScoreAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ZSetScore(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.Read``1">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Read``1"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadAsync``1">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.Read``1"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.WriteAsync``1(``0)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.Save">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Save"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SaveAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SaveAsync"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadServerTime">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadServerTime"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.Ping">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Ping"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DBSize">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DBSize"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.FlushDB">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.FlushDB"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ChangePassword(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ChangePassword(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadServerTimeAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ReadServerTime"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.PingAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.Ping"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.DBSizeAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.DBSize"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.FlushDBAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.FlushDB"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ChangePasswordAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.ChangePassword(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.Publish(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Publish(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.PublishAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.Publish(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SelectDB(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SelectDB(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.SelectDBAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClientPool.SelectDB(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClientPool.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisHelper">
            <summary>
            提供了redis辅助类的一些方法
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.PackStringCommand(System.String[])">
            <summary>
            将字符串数组打包成一个redis的报文信息
            </summary>
            <param name="commands">字节数据信息</param>
            <returns>结果报文信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.PackSubscribeCommand(System.String[])">
            <summary>
            生成一个订阅多个主题的报文信息
            </summary>
            <param name="topics">多个的主题信息</param>
            <returns>结果报文信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.PackUnSubscribeCommand(System.String[])">
            <summary>
            生成一个取消订阅多个主题的报文信息
            </summary>
            <param name="topics">多个的主题信息</param>
            <returns>结果报文信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.GetNumberFromCommandLine(System.Byte[])">
            <summary>
            从原始的结果数据对象中提取出数字数据
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.GetLongNumberFromCommandLine(System.Byte[])">
            <summary>
            从原始的结果数据对象中提取出数字数据
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.GetStringFromCommandLine(System.Byte[])">
            <summary>
            从结果的数据对象里提取字符串的信息
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.GetStringsFromCommandLine(System.Byte[])">
            <summary>
            从redis的结果数据中分析出所有的字符串信息
            </summary>
            <param name="commandLine">结果数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisSubscribe">
            <summary>
            Redis协议的订阅操作，一个对象订阅一个或是多个频道的信息，当发生网络异常的时候，内部会进行自动重连，并恢复之前的订阅信息。<br />
            In the subscription operation of the Redis protocol, an object subscribes to the information of one or more channels. 
            When a network abnormality occurs, the internal will automatically reconnect and restore the previous subscription information.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口。<br />
            To instantiate a publish and subscribe client, you need to specify the ip address and port.
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.#ctor(System.String,System.Int32,System.String[])">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字。<br />
            To instantiate a publish-subscribe client, you need to specify the ip address, port, and subscription keyword.
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="keys">订阅关键字</param>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字。<br />
            To instantiate a publish-subscribe client, you need to specify the ip address, port, and subscription keyword.
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="key">订阅关键字</param>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.RedisSubscribe.Password">
            <summary>
            如果Redis服务器设置了密码，此处就需要进行设置。必须在 <see cref="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ConnectServer"/> 方法调用前设置。<br />
            If the Redis server has set a password, it needs to be set here. Must be set before the <see cref="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ConnectServer"/> method is called.
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.RedisSubscribe.ConnectTimeOut">
            <summary>
            获取或设置当前连接超时时间，主要对 <see cref="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ConnectServer"/> 方法有影响，默认值为 5000，也即是5秒。<br />
            Get or set the current connection timeout period, which mainly affects the <see cref="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ConnectServer"/> method. The default value is 5000, which is 5 seconds.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.SubscribeMessage(System.String)">
            <summary>
            从Redis服务器订阅一个或多个主题信息<br />
            Subscribe to one or more topics from the redis server
            </summary>
            <param name="topic">主题信息</param>
            <returns>订阅结果</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.SubscribeMessage(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisSubscribe.SubscribeMessage(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.UnSubscribeMessage(System.String[])">
            <summary>
            取消订阅多个主题信息，取消之后，当前的订阅数据就不在接收到。<br />
            Unsubscribe from multiple topic information. After cancellation, the current subscription data will not be received.
            </summary>
            <param name="topics">主题信息</param>
            <returns>取消订阅结果</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.UnSubscribeMessage(System.String)">
            <summary>
            取消已经订阅的主题信息
            </summary>
            <param name="topic">主题信息</param>
            <returns>取消订阅结果</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ConnectServer">
            <summary>
            连接Redis的服务器，如果已经初始化了订阅的Topic信息，那么就会直接进行订阅操作。
            </summary>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ConnectClose">
            <summary>
            关闭消息推送的界面
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisSubscribe.RedisMessageReceiveDelegate">
            <summary>
            当接收到Redis订阅的信息的时候触发<br />
            Triggered when receiving Redis subscription information
            </summary>
            <param name="topic">主题信息</param>
            <param name="message">数据信息</param>
        </member>
        <member name="E:HslCommunication.Enthernet.Redis.RedisSubscribe.OnRedisMessageReceived">
            <summary>
            当接收到Redis订阅的信息的时候触发
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisClient">
            <summary>
            这是一个redis的客户端类，支持读取，写入，发布订阅，但是不支持订阅，如果需要订阅，请使用另一个类<see cref="T:HslCommunication.Enthernet.Redis.RedisSubscribe"/>
            </summary>
            <remarks>
            本类库的API指令的参考及注释来源：http://doc.redisfans.com/index.html
            </remarks>
            <example>
            基本的操作如下所示，举例了几个比较常见的指令，更多的需要参考api接口描述
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="SampleBasic" title="基本操作代码" />
            如下是基于特性的操作，有必要说明以下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample1" title="基础的使用" />
            总的来说，当读取的数据种类比较多的时候，读取的关键字比较多的时候，处理起来就比较的麻烦，此处推荐一个全新的写法，为了更好的对比，我们假设实现一种需求
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample2" title="同等代码" />
            为此我们只需要实现一个特性类即可。代码如下：(注意，实际是很灵活的，类型都是自动转换的)
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="SampleClass" title="数据类" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个客户端的对象，用于和服务器通信
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="password">密码，如果服务器没有设置，密码设置为null</param>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.#ctor(System.String)">
            <summary>
            实例化一个客户端对象，需要手动指定Ip地址和端口
            </summary>
            <param name="password">密码，如果服务器没有设置，密码设置为null</param>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadCustomer(System.String)">
            <summary>
            自定义的指令交互方法，该指令用空格分割，举例：LTRIM AAAAA 0 999 就是收缩列表，GET AAA 就是获取键值，需要对返回的数据进行二次分析
            </summary>
            <param name="command">举例：LTRIM AAAAA 0 999 就是收缩列表，GET AAA 就是获取键值</param>
            <returns>从服务器返回的结果数据对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadCustomerAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadCustomer(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateNumberFromServer(System.String[])">
            <summary>
            向服务器请求指定，并返回数字的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>数字的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateLongNumberFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回long数字的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>long数字的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStringFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回字符串的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>字符串的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStringsFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回字符串数组的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>字符串数组的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStatusFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回状态的结果对象，通常用于写入的判断，或是请求类型的判断
            </summary>
            <param name="commands">命令数组</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateNumberFromServerAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.OperateNumberFromServer(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateLongNumberFromServerAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.OperateLongNumberFromServer(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStringFromServerAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStringFromServer(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStringsFromServerAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStringsFromServer(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStatusFromServerAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStatusFromServer(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKey(System.String[])">
            <summary>
            删除给定的一个或多个 key 。不存在的 key 会被忽略。
            </summary>
            <param name="keys">关键字</param>
            <returns>被删除 key 的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKey(System.String)">
            <summary>
            删除给定的一个或多个 key 。不存在的 key 会被忽略。
            </summary>
            <param name="key">关键字</param>
            <returns>被删除 key 的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsKey(System.String)">
            <summary>
            检查给定 key 是否存在。若 key 存在，返回 1 ，否则返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>若 key 存在，返回 1 ，否则返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExpireKey(System.String,System.Int32)">
            <summary>
            为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。设置成功返回 1 。当 key 不存在或者不能为 key 设置生存时间时，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="seconds">当前key的生存时间，单位为秒</param>
            <returns>
            设置成功返回 1 。当 key 不存在或者不能为 key 设置生存时间时，返回 0 。
            </returns>
            <remarks>
            在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。<br />
            生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写( overwrite)，这意味着，如果一个命令只是修改( alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替( replace)它的话，那么生存时间不会被改变。<br />
            比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。<br />
            另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。<br />
            RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key( 以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。<br />
            使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。<br />
            更新生存时间<br />
            可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。<br />
            过期时间的精确度<br />
            在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。<br />
            Redis 2.1.3 之前的不同之处<br />
            在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制( replication)层的限制而作出的，现在这一限制已经被修复。<br />
            </remarks>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAllKeys(System.String)">
            <summary>
            查找所有符合给定模式 pattern 的 key 。
            * 匹配数据库中所有 key。
            h?llo 匹配 hello ， hallo 和 hxllo 等。
            h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。
            </summary>
            <param name="pattern">给定模式</param>
            <returns>符合给定模式的 key 列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.MoveKey(System.String,System.Int32)">
            <summary>
            将当前数据库的 key 移动到给定的数据库 db 当中。
            如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。
            因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。
            </summary>
            <param name="key">关键字</param>
            <param name="db">数据块</param>
            <returns>是否移动成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.PersistKey(System.String)">
            <summary>
            移除给定 key 的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。
            当生存时间移除成功时，返回 1 .
            如果 key 不存在或 key 没有设置生存时间，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>
            当生存时间移除成功时，返回 1 .
            如果 key 不存在或 key 没有设置生存时间，返回 0 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadRandomKey">
            <summary>
            从当前数据库中随机返回(不删除)一个 key 。
            当数据库不为空时，返回一个 key 。
            当数据库为空时，返回 nil 。
            </summary>
            <returns>
            当数据库不为空时，返回一个 key 。
            当数据库为空时，返回 nil 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.RenameKey(System.String,System.String)">
            <summary>
            将 key 改名为 newkey 。
            当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。
            当 newkey 已经存在时， RENAME 命令将覆盖旧值。
            </summary>
            <param name="key1">旧的key</param>
            <param name="key2">新的key</param>
            <returns>
            改名成功时提示 OK ，失败时候返回一个错误。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyType(System.String)">
            <summary>
            返回 key 所储存的值的类型。none (key不存在)，string (字符串)，list (列表)，set (集合)，zset (有序集)，hash (哈希表)
            </summary>
            <param name="key">关键字</param>
            <returns>类型</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyTTL(System.String)">
            <summary>
            以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。
            </summary>
            <param name="key">关键字</param>
            <returns>当 key 不存在时，返回 -2 。当 key 存在但没有设置剩余生存时间时，返回 -1 。否则，以秒为单位，返回 key 的剩余生存时间。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKeyAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKey(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExpireKeyAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ExpireKey(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAllKeysAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAllKeys(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.MoveKeyAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.MoveKey(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.PersistKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.PersistKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadRandomKeyAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadRandomKey"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.RenameKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.RenameKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyTypeAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyType(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyTTLAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyTTL(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.AppendKey(System.String,System.String)">
            <summary>
            如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。
            如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。
            返回追加 value 之后， key 中字符串的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <returns>
            追加 value 之后， key 中字符串的长度。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKey(System.String)">
            <summary>
            将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            本操作的值限制在 64 位(bit)有符号数字表示之内。
            返回执行 DECR 命令之后 key 的值。
            </summary>
            <param name="key">关键字</param>
            <returns>执行 DECR 命令之后 key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKey(System.String,System.Int64)">
            <summary>
            将 key 所储存的值减去减量 decrement 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            本操作的值限制在 64 位(bit)有符号数字表示之内。
            返回减去 decrement 之后， key 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="value">操作的值</param>
            <returns>返回减去 decrement 之后， key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKey(System.String)">
            <summary>
            返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil 。
            假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。
            </summary>
            <param name="key">关键字</param>
            <returns>当 key 不存在时，返回 nil ，否则，返回 key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyRange(System.String,System.Int32,System.Int32)">
            <summary>
            返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。
            负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。
            返回截取得出的子字符串。
            </summary>
            <param name="key">关键字</param>
            <param name="start">截取开始的位置</param>
            <param name="end">截取结束的位置</param>
            <returns>返回截取得出的子字符串。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAndWriteKey(System.String,System.String)">
            <summary>
            将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">新的值</param>
            <returns>返回给定 key 的旧值。当 key 没有旧值时，也即是， key 不存在时，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String)">
            <summary>
            将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            返回执行 INCR 命令之后 key 的值。
            </summary>
            <param name="key">关键字</param>
            <returns>返回执行 INCR 命令之后 key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Int64)">
            <summary>
            将 key 所储存的值加上增量 increment 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">增量数据</param>
            <returns>加上 increment 之后， key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Single)">
            <summary>
            将 key 所储存的值加上增量 increment 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBYFLOAT 操作。
            如果命令执行成功，那么 key 的值会被更新为（执行加法之后的）新值，并且新值会以字符串的形式返回给调用者
            </summary>
            <param name="key">关键字</param>
            <param name="value">增量数据</param>
            <returns>执行命令之后 key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKey(System.String[])">
            <summary>
            返回所有(一个或多个)给定 key 的值。
            如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 null 。因此，该命令永不失败。
            </summary>
            <param name="keys">关键字数组</param>
            <returns>一个包含所有给定 key 的值的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKey(System.String[],System.String[])">
            <summary>
            同时设置一个或多个 key-value 对。
            如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作。
            </summary>
            <param name="keys">关键字数组</param>
            <param name="values">值数组</param>
            <returns>总是返回 OK (因为 MSET 不可能失败)</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKey(System.String,System.String)">
            <summary>
            将字符串值 value 关联到 key 。
            如果 key 已经持有其他值， SET 就覆写旧值，无视类型。
            对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时，这个键原有的 TTL 将被清除。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns> SET 在设置操作成功完成时，才返回 OK 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteAndPublishKey(System.String,System.String)">
            <summary>
            将字符串值 value 关联到 key 。并发布一个订阅的频道数据，都成功时，才返回成功
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteExpireKey(System.String,System.String,System.Int64)">
            <summary>
            将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在， SETEX 命令将覆写旧值。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="seconds">生存时间，单位秒</param>
            <returns>设置成功时返回 OK 。当 seconds 参数不合法时，返回一个错误。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyIfNotExists(System.String,System.String)">
            <summary>
            将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。设置成功，返回 1 。设置失败，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns>设置成功，返回 1 。设置失败，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyRange(System.String,System.String,System.Int32)">
            <summary>
            用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。不存在的 key 当作空白字符串处理。返回被 SETRANGE 修改之后，字符串的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="offset">起始的偏移量</param>
            <returns>被 SETRANGE 修改之后，字符串的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyLength(System.String)">
            <summary>
            返回 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。返回符串值的长度。当 key 不存在时，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>字符串值的长度。当 key 不存在时，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.AppendKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.AppendKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKeyAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKey(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyRangeAsync(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyRange(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAndWriteKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAndWriteKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKeyAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKeyAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKeyAsync(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKey(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyAsync(System.String[],System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKey(System.String[],System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteAndPublishKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteAndPublishKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteExpireKeyAsync(System.String,System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteExpireKey(System.String,System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyIfNotExistsAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyIfNotExists(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyRangeAsync(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyRange(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyLengthAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertBefore(System.String,System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 当中，位于值 pivot 之前。
            当 pivot 不存在于列表 key 时，不执行任何操作。
            当 key 不存在时， key 被视为空列表，不执行任何操作。
            如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="pivot">原先的值</param>
            <returns>
            如果命令执行成功，返回插入操作完成之后，列表的长度。
            如果没有找到 pivot ，返回 -1 。
            如果 key 不存在或为空列表，返回 0 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertAfter(System.String,System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 当中，位于值 pivot 之后。
            当 pivot 不存在于列表 key 时，不执行任何操作。
            当 key 不存在时， key 被视为空列表，不执行任何操作。
            如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="pivot">原先的值</param>
            <returns>
            如果命令执行成功，返回插入操作完成之后，列表的长度。
            如果没有找到 pivot ，返回 -1 。
            如果 key 不存在或为空列表，返回 0 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.GetListLength(System.String)">
            <summary>
            返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 .如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <returns>列表 key 的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadListByIndex(System.String,System.Int64)">
            <summary>
            返回列表 key 中，下标为 index 的元素。下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="index">索引位置</param>
            <returns>列表中下标为 index 的元素。如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPop(System.String)">
            <summary>
            移除并返回列表 key 的头元素。列表的头元素。当 key 不存在时，返回 nil 。
            </summary>
            <param name="key">关键字信息</param>
            <returns>列表的头元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String)">
            <summary>
            将一个或多个值 value 插入到列表 key 的表头，如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。返回执行 LPUSH 命令后，列表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>执行 LPUSH 命令后，列表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String[])">
            <summary>
            将一个或多个值 value 插入到列表 key 的表头，如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。返回执行 LPUSH 命令后，列表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="values">值</param>
            <returns>执行 LPUSH 命令后，列表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPushX(System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。
            返回LPUSHX 命令执行之后，表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>是否插入数据成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRange(System.String,System.Int64,System.Int64)">
            <summary>
            返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。
            下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
            返回一个列表，包含指定区间内的元素。
            </summary>
            <param name="key">关键字</param>
            <param name="start">开始的索引</param>
            <param name="stop">结束的索引</param>
            <returns>返回一个列表，包含指定区间内的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRemoveElementMatch(System.String,System.Int64,System.String)">
            <summary>
            根据参数 count 的值，移除列表中与参数 value 相等的元素。count 的值可以是以下几种：
            count > 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。
            count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。
            count = 0 : 移除表中所有与 value 相等的值。
            返回被移除的数量。
            </summary>
            <param name="key">关键字</param>
            <param name="count">移除参数</param>
            <param name="value">匹配的值</param>
            <returns>被移除元素的数量。因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListSet(System.String,System.Int64,System.String)">
            <summary>
            设置数组的某一个索引的数据信息，当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="index">索引位置</param>
            <param name="value">值</param>
            <returns>操作成功返回 ok ，否则返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListTrim(System.String,System.Int64,System.Int64)">
            <summary>
            对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。
            举个例子，执行命令 LTRIM list 0 2 ，表示只保留列表 list 的前三个元素，其余元素全部删除。
            下标( index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
            当 key 不是列表类型时，返回一个错误。
            </summary>
            <param name="key">关键字信息</param>
            <param name="start">起始的索引信息</param>
            <param name="end">结束的索引信息</param>
            <returns>操作成功返回 ok ，否则返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPop(System.String)">
            <summary>
            移除并返回列表 key 的尾元素。当 key 不存在时，返回 nil 。
            </summary>
            <param name="key">关键字信息</param>
            <returns>列表的尾元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPopLeftPush(System.String,System.String)">
            <summary>
            命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：<br />
            1. 将列表 source 中的最后一个元素( 尾元素)弹出，并返回给客户端。<br />
            2. 将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。<br /><br />
            举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。
            如果 source 不存在，值 nil 被返回，并且不执行其他动作。
            如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转( rotation)操作。
            </summary>
            <param name="key1">第一个关键字</param>
            <param name="key2">第二个关键字</param>
            <returns>返回的移除的对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String)">
            <summary>
            将一个或多个值 value 插入到列表 key 的表尾(最右边)。
            如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>返回执行 RPUSH 操作后，表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String[])">
            <summary>
            将一个或多个值 value 插入到列表 key 的表尾(最右边)。
            如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，
            如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。
            返回执行 RPUSH 操作后，表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="values">值</param>
            <returns>返回执行 RPUSH 操作后，表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPushX(System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。
            和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>RPUSHX 命令执行之后，表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertBeforeAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertBefore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertAfterAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertAfter(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.GetListLengthAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.GetListLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadListByIndexAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadListByIndex(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPopAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPushAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPushAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPushXAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPushX(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRangeAsync(System.String,System.Int64,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRange(System.String,System.Int64,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRemoveElementMatchAsync(System.String,System.Int64,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRemoveElementMatch(System.String,System.Int64,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListSetAsync(System.String,System.Int64,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListSet(System.String,System.Int64,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListTrimAsync(System.String,System.Int64,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListTrim(System.String,System.Int64,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPopAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPopLeftPushAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPopLeftPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPushAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPushAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPushXAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPushX(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String)">
            <summary>
            删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <returns>被成功移除的域的数量，不包括被忽略的域。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String[])">
            <summary>
            删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。返回被成功移除的域的数量，不包括被忽略的域。
            </summary>
            <param name="key">关键字</param>
            <param name="fields">所有的域</param>
            <returns>返回被成功移除的域的数量，不包括被忽略的域。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsHashKey(System.String,System.String)">
            <summary>
            查看哈希表 key 中，给定域 field 是否存在。如果哈希表含有给定域，返回 1 。
            如果哈希表不含有给定域，或 key 不存在，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <returns>如果哈希表含有给定域，返回 1 。如果哈希表不含有给定域，或 key 不存在，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String)">
            <summary>
            返回哈希表 key 中给定域 field 的值。当给定域不存在或是给定 key 不存在时，返回 nil 
            </summary>
            <param name="key">关键值</param>
            <param name="field">域</param>
            <returns>
            给定域的值。
            当给定域不存在或是给定 key 不存在时，返回 nil 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyAll(System.String)">
            <summary>
            返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。
            </summary>
            <param name="key">关键值</param>
            <returns>
            以列表形式返回哈希表的域和域的值。
            若 key 不存在，返回空列表。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Int64)">
            <summary>
            为哈希表 key 中的域 field 的值加上增量 increment 。增量也可以为负数，相当于对给定域进行减法操作。
            如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">增量值</param>
            <returns>返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Single)">
            <summary>
            为哈希表 key 中的域 field 的值加上增量 increment 。增量也可以为负数，相当于对给定域进行减法操作。
            如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">增量值</param>
            <returns>返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeys(System.String)">
            <summary>
            返回哈希表 key 中的所有域。当 key 不存在时，返回一个空表。
            </summary>
            <param name="key">关键值</param>
            <returns>
            一个包含哈希表中所有域的表。
            当 key 不存在时，返回一个空表。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyLength(System.String)">
            <summary>
            返回哈希表 key 中域的数量。
            </summary>
            <param name="key">关键字</param>
            <returns>哈希表中域的数量。当 key 不存在时，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String[])">
            <summary>
            返回哈希表 key 中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个 nil 值。
            因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。
            </summary>
            <param name="key">关键值</param>
            <param name="fields">指定的域</param>
            <returns>
            一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String,System.String)">
            <summary>
            将哈希表 key 中的域 field 的值设为 value 。
            如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。
            如果域 field 已经存在于哈希表中，旧值将被覆盖。
            如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。
            如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">数据值</param>
            <returns>
            如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。
            如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String[],System.String[])">
            <summary>
            同时将多个 field-value (域-值)对设置到哈希表 key 中。
            此命令会覆盖哈希表中已存在的域。
            如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。
            </summary>
            <param name="key">关键字</param>
            <param name="fields">域</param>
            <param name="values">数据值</param>
            <returns>
            如果命令执行成功，返回 OK 。
            当 key 不是哈希表(hash)类型时，返回一个错误
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKeyNx(System.String,System.String,System.String)">
            <summary>
            将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。若域 field 已经存在，该操作无效。
            设置成功，返回 1 。如果给定域已经存在且没有操作被执行，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">数据值</param>
            <returns>设置成功，返回 1 。如果给定域已经存在且没有操作被执行，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashValues(System.String)">
            <summary>
            返回哈希表 key 中所有域的值。当 key 不存在时，返回一个空表。
            </summary>
            <param name="key">关键值</param>
            <returns>
            返回哈希表 key 中所有域的值。
            当 key 不存在时，返回一个空表。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKeyAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsHashKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyAllAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyAll(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKeyAsync(System.String,System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKeyAsync(System.String,System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeysAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeys(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyLengthAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyLength(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKeyAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKeyAsync(System.String,System.String[],System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String[],System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKeyNxAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKeyNx(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashValuesAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashValues(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetAdd(System.String,System.String)">
            <summary>
            将一个member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误。
            </summary>
            <param name="key">关键字信息</param>
            <param name="member">等待添加的元素</param>
            <returns>被添加到集合中的新元素的数量，不包括被忽略的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetAdd(System.String,System.String[])">
            <summary>
            将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误。
            </summary>
            <param name="key">关键字信息</param>
            <param name="members">等待添加的元素</param>
            <returns>被添加到集合中的新元素的数量，不包括被忽略的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetCard(System.String)">
            <summary>
            返回集合 key 的基数(集合中元素的数量)。当 key 不存在时，返回 0 。
            </summary>
            <param name="key">集合 key 的名称</param>
            <returns>集合的基数。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String)">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合之间的差集。
            </summary>
            <param name="key">集合关键字</param>
            <param name="diffKey">集合关键字</param>
            <returns>交集成员的列表。</returns>
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String[])">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合之间的差集。
            </summary>
            <param name="key">集合关键字</param>
            <param name="diffKeys">集合关键字</param>
            <returns>交集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStore(System.String,System.String,System.String)">
            <summary>
            这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">目标集合</param>
            <param name="key">等待操作的集合</param>
            <param name="diffKey">运算的集合</param>
            <returns>结果集中的元素数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStore(System.String,System.String,System.String[])">
            <summary>
            这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">目标集合</param>
            <param name="key">等待操作的集合</param>
            <param name="diffKeys">运算的集合</param>
            <returns>结果集中的元素数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInter(System.String,System.String)">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。
            </summary>
            <param name="key">集合关键字</param>
            <param name="interKey">运算的集合</param>
            <returns>交集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInter(System.String,System.String[])">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。
            </summary>
            <param name="key">集合关键字</param>
            <param name="interKeys">运算的集合</param>
            <returns>交集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStore(System.String,System.String,System.String)">
            <summary>
            这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">目标集合</param>
            <param name="key">等待操作的集合</param>
            <param name="interKey">运算的集合</param>
            <returns>结果集中的成员数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStore(System.String,System.String,System.String[])">
            <summary>
            这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">目标集合</param>
            <param name="key">等待操作的集合</param>
            <param name="interKeys">运算的集合</param>
            <returns>结果集中的成员数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetIsMember(System.String,System.String)">
            <summary>
            判断 member 元素是否集合 key 的成员。如果 member 元素是集合的成员，返回 1 。如果 member 元素不是集合的成员，或 key 不存在，返回 0 。
            </summary>
            <param name="key">集合key</param>
            <param name="member">元素</param>
            <returns>如果 member 元素是集合的成员，返回 1 。如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetMembers(System.String)">
            <summary>
            返回集合 key 中的所有成员。不存在的 key 被视为空集合。
            </summary>
            <param name="key">集合key</param>
            <returns>集合中的所有成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetMove(System.String,System.String,System.String)">
            <summary>
            将 member 元素从 source 集合移动到 destination 集合。如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。
            否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。
            当 source 或 destination 不是集合类型时，返回一个错误。
            </summary>
            <param name="source">原集合</param>
            <param name="destination">目标集合</param>
            <param name="member">元素</param>
            <returns>如果 member 元素被成功移除，返回 1 。如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetPop(System.String)">
            <summary>
            移除并返回集合中的一个随机元素。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。
            </summary>
            <param name="key">集合关键字</param>
            <returns>被移除的随机元素。当 key 不存在或 key 是空集时，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMember(System.String)">
            <summary>
            那么返回集合中的一个随机元素。
            </summary>
            <param name="key">集合关键字</param>
            <returns>返回一个元素；如果集合为空，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMember(System.String,System.Int32)">
            <summary>
            返回集合中的多个随机元素。<br />
            如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。<br />
            如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。
            </summary>
            <param name="key">集合关键字</param>
            <param name="count">元素个数</param>
            <returns>返回一个数组；如果集合为空，返回空数组。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemove(System.String,System.String)">
            <summary>
            移除集合 key 中的一个元素，不存在的 member 元素会被忽略。
            </summary>
            <param name="key">集合关键字</param>
            <param name="member">等待移除的元素</param>
            <returns>被成功移除的元素的数量，不包括被忽略的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemove(System.String,System.String[])">
            <summary>
            移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。
            </summary>
            <param name="key">集合关键字</param>
            <param name="members">等待移除的元素</param>
            <returns>被成功移除的元素的数量，不包括被忽略的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnion(System.String,System.String)">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。
            </summary>
            <param name="key">集合关键字</param>
            <param name="unionKey">并集的集合</param>
            <returns>并集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnion(System.String,System.String[])">
            <summary>
            返回一个或多个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。
            </summary>
            <param name="key">集合关键字</param>
            <param name="unionKeys">并集的集合</param>
            <returns>并集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStore(System.String,System.String,System.String)">
            <summary>
            这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">存储的目标集合</param>
            <param name="key">集合关键字</param>
            <param name="unionKey">并集的集合</param>
            <returns>结果集中的元素数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStore(System.String,System.String,System.String[])">
            <summary>
            这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">存储的目标集合</param>
            <param name="key">集合关键字</param>
            <param name="unionKeys">并集的集合</param>
            <returns>结果集中的元素数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetAddAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetAdd(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetAddAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetAdd(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetCardAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetCard(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStoreAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStoreAsync(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetInter(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetInter(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStoreAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStoreAsync(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetIsMemberAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetIsMember(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetMembersAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetMembers(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetMoveAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetMove(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetPopAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetPop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMemberAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMember(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMemberAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMember(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemoveAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemove(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemoveAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemove(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnion(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnion(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStoreAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStoreAsync(System.String,System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStore(System.String,System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAdd(System.String,System.String,System.Double)">
            <summary>
            将一个 member 元素及其 score 值加入到有序集 key 当中。如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。
            score 值可以是整数值或双精度浮点数。<br />
            如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">有序集合的元素</param>
            <param name="score">每个元素的得分</param>
            <returns>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAdd(System.String,System.String[],System.Double[])">
            <summary>
            将一个或多个 member 元素及其 score 值加入到有序集 key 当中。如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。
            score 值可以是整数值或双精度浮点数。<br />
            如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="members">有序集合的元素</param>
            <param name="scores">每个元素的得分</param>
            <returns>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCard(System.String)">
            <summary>
            返回有序集 key 的基数。
            </summary>
            <param name="key">有序集合的关键字</param>
            <returns>当 key 存在且是有序集类型时，返回有序集的基数。当 key 不存在时，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCount(System.String,System.Double,System.Double)">
            <summary>
            返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="min">最小值，包含</param>
            <param name="max">最大值，包含</param>
            <returns>score 值在 min 和 max 之间的成员的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetIncreaseBy(System.String,System.String,System.Double)">
            <summary>
            为有序集 key 的成员 member 的 score 值加上增量 increment 。可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。
            当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。当 key 不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">成员名称</param>
            <param name="increment">增量数据，可以为负数</param>
            <returns>member 成员的新 score 值，以字符串形式表示。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRange(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序来排列。
            下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。
            </summary>
            <remarks>
            超出范围的下标并不会引起错误。比如说，当 start 的值比有序集的最大下标还要大，或是 start > stop 时， ZRANGE 命令只是简单地返回一个空列表。另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。
            可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, ..., valueN,scoreN 的格式表示。客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。
            </remarks>
            <param name="key">有序集合的关键字</param>
            <param name="start">起始的下标</param>
            <param name="stop">结束的下标</param>
            <param name="withScore">是否带有 score 返回</param>
            <returns>指定区间内，根据参数 withScore 来决定是否带 score 值的有序集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRangeByScore(System.String,System.String,System.String,System.Boolean)">
            <summary>
            返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。
            min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。
            默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 "(" 符号来使用可选的开区间 (小于或大于)。"(5"代表不包含5
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="min">最小值，可以为-inf，代表最高，如果为5，代表大于等于5，如果是(5，代表大于5</param>
            <param name="max">最大值，可以为+inf，代表最低，如果为10，代表小于等于5，如果是(10，代表小于10</param>
            <param name="withScore">是否带有 score 返回</param>
            <returns>指定区间内，带有 score 值(根据参数 withScore 来决定)的有序集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRank(System.String,System.String)">
            <summary>
            返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。排名以 0 为底，也就是说， score 值最小的成员排名为 0 。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">成员 member 的名称</param>
            <returns>如果 member 是有序集 key 的成员，返回 member 的排名。如果 member 不是有序集 key 的成员，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemove(System.String,System.String)">
            <summary>
            移除有序集 key 中的指定成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">等待被移除的成员</param>
            <returns>被成功移除的成员的数量，不包括被忽略的成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemove(System.String,System.String[])">
            <summary>
            移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="members">等待被移除的成员</param>
            <returns>被成功移除的成员的数量，不包括被忽略的成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByRank(System.String,System.Int32,System.Int32)">
            <summary>
            移除有序集 key 中，指定排名(rank)区间内的所有成员。区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。
            下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。
            </summary>
            <param name="key">有序集合的关键</param>
            <param name="start">开始的下标</param>
            <param name="stop">结束的下标</param>
            <returns>被移除成员的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByScore(System.String,System.String,System.String)">
            <summary>
            移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。
            min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。
            默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 "(" 符号来使用可选的开区间 (小于或大于)。例如"(5"代表不包括5
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="min">最小值，可以为-inf，代表最低，如果为5，代表大于等于5，如果是(5，代表大于5</param>
            <param name="max">最大值，可以为+inf，代表最低，如果为10，代表小于等于5，如果是(10，代表小于10</param>
            <returns>被移除成员的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRange(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序来排列。
            下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。
            </summary>
            <remarks>
            超出范围的下标并不会引起错误。比如说，当 start 的值比有序集的最大下标还要大，或是 start > stop 时， ZRANGE 命令只是简单地返回一个空列表。另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。
            可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, ..., valueN,scoreN 的格式表示。客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。
            </remarks>
            <param name="key">有序集合的关键字</param>
            <param name="start">起始的下标</param>
            <param name="stop">结束的下标</param>
            <param name="withScore">是否带有 score 返回</param>
            <returns>指定区间内，根据参数 withScore 来决定是否带 score 值的有序集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRangeByScore(System.String,System.String,System.String,System.Boolean)">
            <summary>
            返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。序集成员按 score 值递减(从大到小)的次序排列。
            min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。
            默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。(5代表不包含5
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="max">最大值，可以为+inf，代表最高，如果为10，代表小于等于5，如果是(10，代表小于10</param>
            <param name="min">最小值，可以为-inf，代表最低，如果为5，代表大于等于5，如果是(5，代表大于5</param>
            <param name="withScore">是否带有 score 返回</param>
            <returns>指定区间内，带有 score 值(根据参数 withScore 来决定)的有序集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRank(System.String,System.String)">
            <summary>
            返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。排名以 0 为底，也就是说，score 值最大的成员排名为 0 。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">成员 member 的名称</param>
            <returns>如果 member 是有序集 key 的成员，返回 member 的排名。如果 member 不是有序集 key 的成员，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetScore(System.String,System.String)">
            <summary>
            返回有序集 key 中，成员 member 的 score 值。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">成员的名称</param>
            <returns>member 成员的 score 值，以字符串形式表示。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAddAsync(System.String,System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAdd(System.String,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAddAsync(System.String,System.String[],System.Double[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAdd(System.String,System.String[],System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCardAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCard(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCountAsync(System.String,System.Double,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCount(System.String,System.Double,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetIncreaseByAsync(System.String,System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetIncreaseBy(System.String,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRangeAsync(System.String,System.Int32,System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRange(System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRangeByScoreAsync(System.String,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRangeByScore(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRankAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRank(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemove(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemove(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByRankAsync(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByRank(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByScoreAsync(System.String,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByScore(System.String,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRangeAsync(System.String,System.Int32,System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRange(System.String,System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRangeByScoreAsync(System.String,System.String,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRangeByScore(System.String,System.String,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRankAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRank(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetScoreAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetScore(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Read``1">
            <summary>
            从设备里读取支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>，
            <see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <returns>包含是否成功的结果对象</returns>
            <example>
            我们来说明下这个方法到底是怎么用的，当我们需要读取redis好几个数据的时候，我们很可能写如下的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample1" title="基础的使用" />
            总的来说，当读取的数据种类比较多的时候，读取的关键字比较多的时候，处理起来就比较的麻烦，此处推荐一个全新的写法，为了更好的对比，我们假设实现一种需求
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample2" title="同等代码" />
            为此我们只需要实现一个特性类即可。代码如下：(注意，实际是很灵活的，类型都是自动转换的)
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="SampleClass" title="数据类" />
            当然了，异步也是一样的，异步的代码就不重复介绍了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample3" title="异步示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Write``1(``0)">
            <summary>
            从设备里写入支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/> ，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            需要注意的是写入并不支持<see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>特性，详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="data">等待写入的数据参数</param>
            <returns>包含是否成功的结果对象</returns>
            <example>
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Read``1" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAsync``1">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Read``1"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteAsync``1(``0)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Save">
            <summary>
            SAVE 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。
            </summary>
            <returns>保存成功时返回 OK 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SaveAsync">
            <summary>
            在后台异步(Asynchronously)保存当前数据库的数据到磁盘。
            BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。
            </summary>
            <returns>反馈信息。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadServerTime">
            <summary>
            获取服务器的时间戳信息，可用于本地时间的数据同步问题
            </summary>
            <returns>带有服务器时间的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Ping">
            <summary>
            向服务器进行PING的操作，服务器会返回PONG操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DBSize">
            <summary>
            返回当前数据库的 key 的数量。
            </summary>
            <returns>当前数据库的 key 的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.FlushDB">
            <summary>
            清空当前的数据库的key信息
            </summary>
            <returns>总是返回 OK 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ChangePassword(System.String)">
            <summary>
            修改Redis的密码信息，如果不需要密码，则传入空字符串即可
            </summary>
            <param name="password">密码信息</param>
            <returns>是否更新了密码信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadServerTimeAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ReadServerTime"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.PingAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Ping"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DBSizeAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.DBSize"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.FlushDBAsync">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.FlushDB"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ChangePasswordAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.ChangePassword(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Publish(System.String,System.String)">
            <summary>
            将信息 message 发送到指定的频道 channel，返回接收到信息 message 的订阅者数量。
            </summary>
            <param name="channel">频道，和关键字不是一回事</param>
            <param name="message">消息</param>
            <returns>接收到信息 message 的订阅者数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.PublishAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Publish(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SelectDB(System.Int32)">
            <summary>
            切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。默认使用 0 号数据库。
            </summary>
            <param name="db">索引值</param>
            <returns>是否切换成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SelectDBAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SelectDB(System.Int32)"/>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisClient.RedisMessageReceiveDelegate">
            <summary>
            当接收到Redis订阅的信息的时候触发<br />
            Triggered when receiving Redis subscription information
            </summary>
            <param name="topic">主题信息</param>
            <param name="message">数据信息</param>
        </member>
        <member name="E:HslCommunication.Enthernet.Redis.RedisClient.OnRedisMessageReceived">
            <summary>
            当接收到Redis订阅的信息的时候触发
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SubscribeMessage(System.String)">
            <summary>
            从Redis服务器订阅一个或多个主题信息<br />
            Subscribe to one or more topics from the redis server
            </summary>
            <param name="topic">主题信息</param>
            <returns>订阅结果</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SubscribeMessage(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SubscribeMessage(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.UnSubscribeMessage(System.String)">
            <summary>
            取消订阅一个或多个主题信息，取消之后，当前的订阅数据就不在接收到。<br />
            Unsubscribe from multiple topic information. After cancellation, the current subscription data will not be received.
            </summary>
            <param name="topic">主题信息</param>
            <returns>取消订阅结果</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.UnSubscribeMessage(System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.UnSubscribeMessage(System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetSimplifyClient">
            <summary>
            同步访问数据的客户端类，用于向服务器请求一些确定的数据信息
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/7697782.html">http://www.cnblogs.com/dathlin/p/7697782.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormSimplifyNet.cs" region="FormSimplifyNet" title="FormSimplifyNet示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个客户端的对象，用于和服务器通信
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">服务器的端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            实例化一个客户端的对象，用于和服务器通信
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">服务器的端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.#ctor">
            <summary>
            实例化一个客户端对象，需要手动指定Ip地址和端口
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，忽略了自定义消息反馈
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.String[])">
            <summary>
            客户端向服务器进行请求，请求字符串数组，忽略了自定义消息反馈
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字节数据
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送的字节内容</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.String[])">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServerBase(System.Byte[])">
            <summary>
            需要发送的底层数据
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServerBase(System.Byte[])">
            <summary>
            需要发送的底层数据
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServerAsync(HslCommunication.NetHandle,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServerAsync(HslCommunication.NetHandle,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServerAsync(HslCommunication.NetHandle,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServerAsync(HslCommunication.NetHandle,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServerAsync(HslCommunication.NetHandle,System.String[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServerAsync(HslCommunication.NetHandle,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServerBaseAsync(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServerBase(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServerBaseAsync(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServerBase(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetSimplifyServer">
            <summary>
            消息处理服务器，主要用来实现接收客户端信息并进行消息反馈的操作，适用于客户端进行远程的调用，要求服务器反馈数据。<br />
            The message processing server is mainly used to implement the operation of receiving client information and performing message feedback. It is applicable to remote calls made by clients and requires the server to feedback data.
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/7697782.html">http://www.cnblogs.com/dathlin/p/7697782.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\SimplifyNetTest\FormServer.cs" region="Simplify Net" title="NetSimplifyServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetSimplifyServer.ReceiveStringEvent">
            <summary>
            接收字符串信息的事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetSimplifyServer.ReceiveStringArrayEvent">
            <summary>
            接收字符串数组信息的事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetSimplifyServer.ReceivedBytesEvent">
            <summary>
            接收字节信息的事件
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.String)">
            <summary>
            向指定的通信对象发送字符串数据
            </summary>
            <param name="session">通信对象</param>
            <param name="customer">用户的指令头</param>
            <param name="str">实际发送的字符串数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.String[])">
            <summary>
            向指定的通信对象发送字符串数组
            </summary>
            <param name="session">通信对象</param>
            <param name="customer">用户的指令头</param>
            <param name="str">实际发送的字符串数组</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.Byte[])">
            <summary>
            向指定的通信对象发送字节数据
            </summary>
            <param name="session">连接对象</param>
            <param name="customer">用户的指令头</param>
            <param name="bytes">实际的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.CloseAction">
            <summary>
            关闭网络的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.AppSessionRemoteClose(HslCommunication.Core.Net.AppSession)">
            <summary>
            让客户端正常下线，调用本方法即可自由控制会话客户端强制下线操作。
            </summary>
            <param name="session">会话对象</param>
        </member>
        <member name="P:HslCommunication.Enthernet.NetSimplifyServer.ClientCount">
            <summary>
            当前在线的客户端数量
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.FileInfoExtension">
            <summary>
            文件的扩展信息
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileInfoExtension.FullName">
            <summary>
            文件的完整名称
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileInfoExtension.ModifiTime">
            <summary>
            文件的修改时间
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileInfoExtension.MD5">
            <summary>
            文件的MD5码
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.NetSoftUpdateServer">
            <summary>
            用于服务器支持软件全自动更新升级的类<br />
            Class for server support software full automatic update and upgrade
            </summary>
            <remarks>
            目前的更新机制是全部文件的更新，没有进行差异化的比较
            </remarks>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSoftUpdateServer.#ctor(System.String)">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
            <param name="updateExeFileName">更新程序的名称</param>
        </member>
        <member name="P:HslCommunication.Enthernet.NetSoftUpdateServer.FileUpdatePath">
            <summary>
            系统升级时客户端所在的目录，默认为C:\HslCommunication
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetSoftUpdateServer.OnlineSessions">
            <summary>
            获取当前在线的客户端数量信息，一般是正在下载中的会话客户端数量。<br />
            Get information about the number of currently online clients, generally the number of session clients that are being downloaded.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSoftUpdateServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSoftUpdateServer.GetAllFiles(System.String,HslCommunication.LogNet.ILogNet)">
            <summary>
            获取所有的文件信息，包括所有的子目录的文件信息<br />
            Get all file information, including file information of all subdirectories
            </summary>
            <param name="dircPath">目标路径</param>
            <param name="logNet">日志信息</param>
            <returns>文件名的列表</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSoftUpdateServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.ForwardSession">
            <summary>
            转发过程中的中间会话信息
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.ForwardSession.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.ForwardSession.#ctor(System.Net.Sockets.Socket)">
            <summary>
            指定客户端的 socket 来实例化一个对象
            </summary>
            <param name="socket">客户端的socket</param>
        </member>
        <member name="P:HslCommunication.Enthernet.ForwardSession.ServerSocket">
            <summary>
            连接服务端的socket
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.ForwardSession.ServerBuffer">
            <summary>
            服务端的缓存数据信息
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.ForwardSession.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.TcpForward">
            <summary>
            用于转发的TCP服务类，可以用来实现TCP协议的转发功能，需要指定本机端口，服务器的ip及端口信息<br />
            The TCP service class used for forwarding can be used to implement the forwarding function of the TCP protocol. It is necessary to specify the local port, the server's ip and port information.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.TcpForward.#ctor(System.Int32,System.String,System.Int32)">
            <summary>
            实例化一个TCP转发的对象，需要本机端口号，远程ip地址及远程端口号
            </summary>
            <param name="localPort">本机侦听的端口号</param>
            <param name="host">远程的IP地址</param>
            <param name="hostPort">远程的端口号信息</param>
        </member>
        <member name="M:HslCommunication.Enthernet.TcpForward.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.TcpForward.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Enthernet.TcpForward.LogMsgFormatBinary">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkDoubleBase.LogMsgFormatBinary"/>
        </member>
        <member name="M:HslCommunication.Enthernet.TcpForward.GetSessionInfos">
            <summary>
            获取所有的会话信息
            </summary>
            <returns>方便用于显示</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.TcpForward.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetUdpClient">
            <summary>
            UDP客户端的类，负责发送数据到服务器，然后从服务器接收对应的数据信息，该数据经过HSL封装<br />
            UDP client class, responsible for sending data to the server, and then receiving the corresponding data information from the server, the data is encapsulated by HSL
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.#ctor(System.String,System.Int32)">
            <summary>
            实例化对象，指定发送的服务器地址和端口号<br />
            Instantiated object, specifying the server address and port number to send
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadFromServer(HslCommunication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，忽略了自定义消息反馈<br />
            The client makes a request to the server, requesting string data, and ignoring custom message feedback
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadFromServer(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字节数据<br />
            The client makes a request to the server, requesting byte data
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送的字节内容</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息<br />
            The client makes a request to the server, requests string data, and returns status information
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字节数据，并返回状态信息<br />
            The client makes a request to the server, requests byte data, and returns status information
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadFromServerBase(System.Byte[])">
            <summary>
            发送的底层数据，然后返回结果数据<br />
            Send the underlying data and then return the result data
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadCustomerFromServerBase(System.Byte[])">
            <summary>
            发送的底层数据，然后返回结果数据，该结果是带Handle信息的。<br />
            Send the underlying data, and then return the result data, the result is with Handle information.
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetUdpServer">
            <summary>
            Udp网络的服务器端类，您可以使用本类构建一个简单的，高性能的udp服务器，接收来自其他客户端的数据，当然，您也可以自定义返回你要返回的数据<br />
            Server-side class of Udp network. You can use this class to build a simple, high-performance udp server that receives data from other clients. Of course, you can also customize the data you want to return.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.#ctor">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Enthernet.NetUdpServer.ReceiveCacheLength">
            <summary>
            获取或设置一次接收时的数据长度，默认2KB数据长度
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.ServerStart(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.RefreshReceive">
            <summary>
            重新开始接收数据
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.DataProcessingCenter(HslCommunication.Core.Net.AppSession,System.Int32,System.Int32,System.Byte[])">
            <summary>
            数据处理中心
            </summary>
            <param name="session">会话信息</param>
            <param name="protocol">暗号</param>
            <param name="customer"></param>
            <param name="content"></param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.String)">
            <summary>
            向指定的通信对象发送字符串数据
            </summary>
            <param name="session">通信对象</param>
            <param name="customer">用户的指令头</param>
            <param name="str">实际发送的字符串数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.Byte[])">
            <summary>
            向指定的通信对象发送字节数据
            </summary>
            <param name="session">连接对象</param>
            <param name="customer">用户的指令头</param>
            <param name="bytes">实际的数据</param>
        </member>
        <member name="E:HslCommunication.Enthernet.NetUdpServer.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetUdpServer.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Instrument.Delixi.DTSU6606Serial">
            <summary>
            DTSU6606型三相四线电子式电能表的Modbus-RTU通信协议
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Delixi.DTSU6606Serial.#ctor">
            <summary>
            实例化一个Modbus-Rtu协议的客户端对象<br />
            Instantiate a client object of the Modbus-Rtu protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Delixi.DTSU6606Serial.#ctor(System.Byte)">
            <summary>
            指定客户端自己的站号来初始化<br />
            Specify the client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Instrument.Delixi.DTSU6606Serial.ReadElectricalParameters">
            <summary>
            读取电表的电参数类，主要包含电压，电流，频率，有功功率，无功功率，视在功率，功率因数<br />
            Read the electrical parameters of the meter, including voltage, current, frequency, active power, reactive power, apparent power, and power factor
            </summary>
            <returns>包含是否成功的电表结果对象</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Delixi.DTSU6606Serial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Instrument.Delixi.ElectricalParameters">
            <summary>
            电参数类
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.VoltageA">
            <summary>
            A相电压，单位V
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.VoltageB">
            <summary>
            B相电压，单位V
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.VoltageC">
            <summary>
            C相电压，单位V
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.CurrentA">
            <summary>
            A相电流，单位A
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.CurrentB">
            <summary>
            B相电流，单位A
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.CurrentC">
            <summary>
            C相电流，单位A
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousActivePowerA">
            <summary>
            瞬时A相有功功率，单位 kw
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousActivePowerB">
            <summary>
            瞬时B相有功功率，单位 kw
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousActivePowerC">
            <summary>
            瞬时C相有功功率，单位 kw
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousTotalActivePower">
            <summary>
            瞬时总有功功率，单位 kw
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousReactivePowerA">
            <summary>
            瞬时A相无功功率，单位 kvar
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousReactivePowerB">
            <summary>
            瞬时B相无功功率，单位 kvar
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousReactivePowerC">
            <summary>
            瞬时C相无功功率，单位 kvar
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousTotalReactivePower">
            <summary>
            瞬时总无功功率，单位 kvar
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousApparentPowerA">
            <summary>
            瞬时A相视在功率，单位 kVA
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousApparentPowerB">
            <summary>
            瞬时B相视在功率，单位 kVA
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousApparentPowerC">
            <summary>
            瞬时C相视在功率，单位 kVA
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.InstantaneousTotalApparentPower">
            <summary>
            瞬时总视在功率，单位 kVA
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.PowerFactorA">
            <summary>
            A相功率因数
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.PowerFactorB">
            <summary>
            B相功率因数
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.PowerFactorC">
            <summary>
            C相功率因数
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.TotalPowerFactor">
            <summary>
            总功率因数
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Delixi.ElectricalParameters.Frequency">
            <summary>
            频率，Hz
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Delixi.ElectricalParameters.ParseFromDelixi(System.Byte[],HslCommunication.Core.IByteTransform)">
            <summary>
            根据德力西电表的原始字节数据，解析出真实的电量参数信息
            </summary>
            <param name="data">原始的字节数据</param>
            <param name="byteTransform">字节变换操作</param>
            <returns>掂量参数信息</returns>
        </member>
        <member name="T:HslCommunication.Instrument.DLT.DLT645">
            <summary>
            基于多功能电能表通信协议实现的通讯类，参考的文档是DLT645-2007，主要实现了对电表数据的读取和一些功能方法，
            在点对点模式下，需要在打开串口后调用 <see cref="M:HslCommunication.Instrument.DLT.DLT645.ReadAddress"/> 方法，数据标识格式为 00-00-00-00，具体参照文档手册。<br />
            The communication type based on the communication protocol of the multifunctional electric energy meter. 
            The reference document is DLT645-2007, which mainly realizes the reading of the electric meter data and some functional methods. 
            In the point-to-point mode, you need to call <see cref="M:HslCommunication.Instrument.DLT.DLT645.ReadAddress" /> method after opening the serial port.
            the data identification format is 00-00-00-00, refer to the documentation manual for details.
            </summary>
            <remarks>
            如果一对多的模式，地址可以携带地址域访问，例如 "s=2;00-00-00-00"，主要使用 <see cref="M:HslCommunication.Instrument.DLT.DLT645.ReadDouble(System.String,System.UInt16)"/> 方法来读取浮点数，
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.ReadString(System.String,System.UInt16)"/> 方法来读取字符串
            </remarks>
            <example>
            具体的地址请参考相关的手册内容，如果没有，可以联系HSL作者或者，下面列举一些常用的地址<br />
            对于电能来说，DI0是结算日的信息，现在的就是写0，上一结算日的就写 01，上12结算日就写 0C
            <list type="table">
              <listheader>
                <term>DI3</term>
                <term>DI2</term>
                <term>DI1</term>
                <term>DI0</term>
                <term>地址示例</term>
                <term>读取方式</term>
                <term>数据项名称</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>00</term>
                <term>00</term>
                <term>00</term>
                <term>00</term>
                <term>00-00-00-00</term>
                <term>ReadDouble</term>
                <term>（当前）组合有功总电能(kwh)</term>
                <term>00-00-01-00到00-00-3F-00分别是组合有功费率1~63电能</term>
              </item>
              <item>
                <term>00</term>
                <term>01</term>
                <term>00</term>
                <term>00</term>
                <term>00-01-00-00</term>
                <term>ReadDouble</term>
                <term>（当前）正向有功总电能(kwh)</term>
                <term>00-01-01-00到00-01-3F-00分别是正向有功费率1~63电能</term>
              </item>
              <item>
                <term>00</term>
                <term>02</term>
                <term>00</term>
                <term>00</term>
                <term>00-02-00-00</term>
                <term>ReadDouble</term>
                <term>（当前）反向有功总电能(kwh)</term>
                <term>00-02-01-00到00-02-3F-00分别是反向有功费率1~63电能</term>
              </item>
              <item>
                <term>00</term>
                <term>03</term>
                <term>00</term>
                <term>00</term>
                <term>00-03-00-00</term>
                <term>ReadDouble</term>
                <term>（当前）组合无功总电能(kvarh)</term>
                <term>00-03-01-00到00-03-3F-00分别是组合无功费率1~63电能</term>
              </item>
              <item>
                <term>00</term>
                <term>09</term>
                <term>00</term>
                <term>00</term>
                <term>00-09-00-00</term>
                <term>ReadDouble</term>
                <term>（当前）正向视在总电能(kvah)</term>
                <term>00-09-01-00到00-09-3F-00分别是正向视在费率1~63电能</term>
              </item>
              <item>
                <term>00</term>
                <term>0A</term>
                <term>00</term>
                <term>00</term>
                <term>00-0A-00-00</term>
                <term>ReadDouble</term>
                <term>（当前）反向视在总电能(kvah)</term>
                <term>00-0A-01-00到00-0A-3F-00分别是反向视在费率1~63电能</term>
              </item>
              <item>
                <term>02</term>
                <term>01</term>
                <term>01</term>
                <term>00</term>
                <term>02-01-01-00</term>
                <term>ReadDouble</term>
                <term>A相电压(V)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>01</term>
                <term>02</term>
                <term>00</term>
                <term>02-01-02-00</term>
                <term>ReadDouble</term>
                <term>B相电压(V)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>01</term>
                <term>03</term>
                <term>00</term>
                <term>02-01-03-00</term>
                <term>ReadDouble</term>
                <term>C相电压(V)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>02</term>
                <term>01</term>
                <term>00</term>
                <term>02-02-01-00</term>
                <term>ReadDouble</term>
                <term>A相电流(A)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>02</term>
                <term>02</term>
                <term>00</term>
                <term>02-02-02-00</term>
                <term>ReadDouble</term>
                <term>B相电流(A)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>02</term>
                <term>03</term>
                <term>00</term>
                <term>02-02-03-00</term>
                <term>ReadDouble</term>
                <term>C相电流(A)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>03</term>
                <term>00</term>
                <term>00</term>
                <term>02-03-00-00</term>
                <term>ReadDouble</term>
                <term>瞬时总有功功率(kw)</term>
                <term>DI1=1时表示A相，2时表示B相，3时表示C相</term>
              </item>
              <item>
                <term>02</term>
                <term>04</term>
                <term>00</term>
                <term>00</term>
                <term>02-04-00-00</term>
                <term>ReadDouble</term>
                <term>瞬时总无功功率(kvar)</term>
                <term>DI1=1时表示A相，2时表示B相，3时表示C相</term>
              </item>
              <item>
                <term>02</term>
                <term>05</term>
                <term>00</term>
                <term>00</term>
                <term>02-05-00-00</term>
                <term>ReadDouble</term>
                <term>瞬时总视在功率(kva)</term>
                <term>DI1=1时表示A相，2时表示B相，3时表示C相</term>
              </item>
              <item>
                <term>02</term>
                <term>06</term>
                <term>00</term>
                <term>00</term>
                <term>02-06-00-00</term>
                <term>ReadDouble</term>
                <term>总功率因素</term>
                <term>DI1=1时表示A相，2时表示B相，3时表示C相</term>
              </item>
              <item>
                <term>02</term>
                <term>07</term>
                <term>01</term>
                <term>00</term>
                <term>02-07-01-00</term>
                <term>ReadDouble</term>
                <term>A相相角(°)</term>
                <term>DI1=1时表示A相，2时表示B相，3时表示C相</term>
              </item>
              <item>
                <term>02</term>
                <term>08</term>
                <term>01</term>
                <term>00</term>
                <term>02-08-01-00</term>
                <term>ReadDouble</term>
                <term>A相电压波形失真度(%)</term>
                <term>DI1=1时表示A相，2时表示B相，3时表示C相</term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>01</term>
                <term>02-80-00-01</term>
                <term>ReadDouble</term>
                <term>零线电流(A)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>02</term>
                <term>02-80-00-02</term>
                <term>ReadDouble</term>
                <term>电网频率(HZ)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>03</term>
                <term>02-80-00-03</term>
                <term>ReadDouble</term>
                <term>一分钟有功总平均功率(kw)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>04</term>
                <term>02-80-00-04</term>
                <term>ReadDouble</term>
                <term>当前有功需量(kw)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>05</term>
                <term>02-80-00-05</term>
                <term>ReadDouble</term>
                <term>当前无功需量(kvar)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>06</term>
                <term>02-80-00-06</term>
                <term>ReadDouble</term>
                <term>当前视在需量(kva)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>07</term>
                <term>02-80-00-07</term>
                <term>ReadDouble</term>
                <term>表内温度(摄氏度)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>08</term>
                <term>02-80-00-08</term>
                <term>ReadDouble</term>
                <term>时钟电池电压(V)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>09</term>
                <term>02-80-00-09</term>
                <term>ReadDouble</term>
                <term>停电抄表电池电压(V)</term>
                <term></term>
              </item>
              <item>
                <term>02</term>
                <term>80</term>
                <term>00</term>
                <term>0A</term>
                <term>02-80-00-0A</term>
                <term>ReadDouble</term>
                <term>内部电池工作时间(分钟)</term>
                <term></term>
              </item>
              <item>
                <term>04</term>
                <term>00</term>
                <term>04</term>
                <term>03</term>
                <term>04-00-04-03</term>
                <term>ReadString("04-00-04-03", 32)</term>
                <term>资产管理编码</term>
                <term></term>
              </item>
              <item>
                <term>04</term>
                <term>00</term>
                <term>04</term>
                <term>0B</term>
                <term>04-00-04-0B</term>
                <term>ReadString("04-00-04-0B", 10)</term>
                <term>电表型号</term>
                <term></term>
              </item>
              <item>
                <term>04</term>
                <term>00</term>
                <term>04</term>
                <term>0C</term>
                <term>04-00-04-0C</term>
                <term>ReadString("04-00-04-0C", 10)</term>
                <term>生产日期</term>
                <term></term>
              </item>
            </list>
            直接串口初始化，打开串口，就可以对数据进行读取了，地址如上图所示。
            </example>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.#ctor(System.String,System.String,System.String)">
            <summary>
            指定地址域，密码，操作者代码来实例化一个对象，密码及操作者代码在写入操作的时候进行验证<br />
            Specify the address field, password, and operator code to instantiate an object, and the password and operator code are validated during write operations, 
            which address field is a 12-character BCD code, for example: 149100007290
            </summary>
            <param name="station">设备的地址信息，是一个12字符的BCD码</param>
            <param name="password">密码，写入的时候进行验证的信息</param>
            <param name="opCode">操作者代码</param>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ReadFromCoreServer(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ActiveDeveice">
            <summary>
            激活设备的命令，只发送数据到设备，不等待设备数据返回<br />
            The command to activate the device, only send data to the device, do not wait for the device data to return
            </summary>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.Read(System.String,System.UInt16)">
            <summary>
            根据指定的数据标识来读取相关的原始数据信息，地址标识根据手册来，从高位到地位，例如 00-00-00-00，分割符可以任意特殊字符或是没有分隔符。<br />
            Read the relevant original data information according to the specified data identifier. The address identifier is based on the manual, 
            from high to position, such as 00-00-00-00. The separator can be any special character or no separator.
            </summary>
            <remarks>
            地址可以携带地址域信息，例如 "s=2;00-00-00-00" 或是 "s=100000;00-00-02-00"，关于数据域信息，需要查找手册，例如:00-01-00-00 表示： (当前)正向有功总电能
            </remarks>
            <param name="address">数据标识，具体需要查找手册来对应</param>
            <param name="length">数据长度信息</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.Write(System.String,System.Byte[])">
            <summary>
            根据指定的数据标识来写入相关的原始数据信息，地址标识根据手册来，从高位到地位，例如 00-00-00-00，分割符可以任意特殊字符或是没有分隔符。<br />
            Read the relevant original data information according to the specified data identifier. The address identifier is based on the manual, 
            from high to position, such as 00-00-00-00. The separator can be any special character or no separator.
            </summary>
            <remarks>
            地址可以携带地址域信息，例如 "s=2;00-00-00-00" 或是 "s=100000;00-00-02-00"，关于数据域信息，需要查找手册，例如:00-01-00-00 表示： (当前)正向有功总电能<br />
            注意：本命令必须与编程键配合使用
            </remarks>
            <param name="address">地址信息</param>
            <param name="value">写入的数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ReadAddress">
            <summary>
            读取设备的通信地址，仅支持点对点通讯的情况，返回地址域数据，例如：149100007290<br />
            Read the communication address of the device, only support point-to-point communication, and return the address field data, for example: 149100007290
            </summary>
            <returns>设备的通信地址</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.WriteAddress(System.String)">
            <summary>
            写入设备的地址域信息，仅支持点对点通讯的情况，需要指定地址域信息，例如：149100007290<br />
            Write the address domain information of the device, only support point-to-point communication, 
            you need to specify the address domain information, for example: 149100007290
            </summary>
            <param name="address">等待写入的地址域</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.BroadcastTime(System.DateTime)">
            <summary>
            广播指定的时间，强制从站与主站时间同步，传入<see cref="T:System.DateTime"/>时间对象，没有数据返回。<br />
            Broadcast the specified time, force the slave station to synchronize with the master station time, 
            pass in the <see cref="T:System.DateTime"/> time object, and no data will be returned.
            </summary>
            <param name="dateTime">时间对象</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.FreezeCommand(System.String)">
            <summary>
            对设备发送冻结命令，默认点对点操作，地址域为 99999999999999 时为广播，数据域格式说明：MMDDhhmm(月日时分)，
            99DDhhmm表示月为周期定时冻结，9999hhmm表示日为周期定时冻结，999999mm表示以小时为周期定时冻结，99999999表示瞬时冻结<br />
            Send a freeze command to the device, the default point-to-point operation, when the address field is 9999999999999, 
            it is broadcast, and the data field format description: MMDDhhmm (month, day, hour and minute), 
            99DDhhmm means the month is the periodic fixed freeze, 9999hhmm means the day is the periodic periodic freeze, 
            and 999999mm means the hour It is periodic timed freezing, 99999999 means instantaneous freezing
            </summary>
            <param name="dataArea">数据域信息</param>
            <returns>是否成功冻结</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ChangeBaudRate(System.String)">
            <summary>
            更改通信速率，波特率可选 600,1200,2400,4800,9600,19200，其他值无效，可以携带地址域信息，s=1;9600 <br />
            Change the communication rate, the baud rate can be 600, 1200, 2400, 4800, 9600, 19200, 
            other values are invalid, you can carry address domain information, s=1;9600
            </summary>
            <param name="baudRate">波特率的信息</param>
            <returns>是否更改成功</returns>
        </member>
        <member name="P:HslCommunication.Instrument.DLT.DLT645.Station">
            <summary>
            获取或设置当前的地址域信息，是一个12个字符的BCD码，例如：149100007290<br />
            Get or set the current address domain information, which is a 12-character BCD code, for example: 149100007290
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.GetAddressByteFromString(System.String)">
            <summary>
            将地址解析成BCD码的地址，并且扩充到12位，不够的补0操作
            </summary>
            <param name="address">地址域信息</param>
            <returns>实际的结果</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.BuildEntireCommand(System.String,System.Byte,System.Byte[])">
            <summary>
            将指定的地址信息，控制码信息，数据域信息打包成完整的报文命令
            </summary>
            <param name="address">地址域信息，地址域由6个字节构成，每字节2位BCD码，地址长度可达12位十进制数。地址域支持锁位寻址，即从若干低位起，剩余高位补AAH作为通配符进行读表操作</param>
            <param name="control">控制码信息</param>
            <param name="dataArea">数据域的内容</param>
            <returns>返回是否报文创建成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.AnalysisBytesAddress(System.String,System.String,System.UInt16)">
            <summary>
            从用户输入的地址信息中解析出真实的地址及数据标识
            </summary>
            <param name="address">用户输入的地址信息</param>
            <param name="defaultStation">默认的地址域</param>
            <param name="length">数据长度信息</param>
            <returns>解析结果信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.GetFormatWithDataArea(System.Byte[])">
            <summary>
            根据不同的数据地址，返回实际的数据格式，然后解析出正确的数据
            </summary>
            <param name="dataArea">数据标识地址，实际的byte数组，地位在前，高位在后</param>
            <returns>实际的数据格式信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.AnalysisIntegerAddress(System.String,System.String)">
            <summary>
            从用户输入的地址信息中解析出真实的地址及数据标识
            </summary>
            <param name="address">用户输入的地址信息</param>
            <param name="defaultStation">默认的地址域</param>
            <returns>解析结果信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.CheckResponse(System.Byte[])">
            <summary>
            检查当前的反馈数据信息是否正确
            </summary>
            <param name="response">从仪表反馈的数据信息</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.FindHeadCode68H(System.Byte[])">
            <summary>
            寻找0x68字节开头的位置信息
            </summary>
            <param name="buffer">缓存数据</param>
            <returns>如果有则为索引位置，如果没有则为空</returns>
        </member>
        <member name="T:HslCommunication.Instrument.DLT.DLT645OverTcp">
            <summary>
            基于多功能电能表通信协议实现的通讯类，参考的文档是DLT645-2007，主要实现了对电表数据的读取和一些功能方法，
            在点对点模式下，需要在连接后调用 <see cref="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadAddress"/> 方法，数据标识格式为 00-00-00-00，具体参照文档手册。<br />
            The communication type based on the communication protocol of the multifunctional electric energy meter. 
            The reference document is DLT645-2007, which mainly realizes the reading of the electric meter data and some functional methods. 
            In the point-to-point mode, you need to call <see cref="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadAddress" /> method after connect the device.
            the data identification format is 00-00-00-00, refer to the documentation manual for details.
            </summary>
            <remarks>
            如果一对多的模式，地址可以携带地址域访问，例如 "s=2;00-00-00-00"，主要使用 <see cref="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadDouble(System.String,System.UInt16)"/> 方法来读取浮点数，
            <see cref="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadString(System.String,System.UInt16)"/> 方法来读取字符串
            </remarks>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.#ctor(System.String,System.Int32,System.String,System.String,System.String)">
            <summary>
            指定IP地址，端口，地址域，密码，操作者代码来实例化一个对象<br />
            Specify the IP address, port, address field, password, and operator code to instantiate an object
            </summary>
            <param name="ipAddress">TcpServer的IP地址</param>
            <param name="port">TcpServer的端口</param>
            <param name="station">设备的站号信息</param>
            <param name="password">密码，写入的时候进行验证的信息</param>
            <param name="opCode">操作者代码</param>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ActiveDeveice">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.ActiveDeveice"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ActiveDeveiceAsync">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.ActiveDeveice"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadAddress">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.ReadAddress"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.WriteAddress(System.String)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.WriteAddress(System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.BroadcastTime(System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.BroadcastTime(System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.FreezeCommand(System.String)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.FreezeCommand(System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ChangeBaudRate(System.String)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.ChangeBaudRate(System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645OverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ReadAddressAsync">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.ReadAddress"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.WriteAddressAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.WriteAddress(System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.BroadcastTimeAsync(System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.BroadcastTime(System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.FreezeCommandAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.FreezeCommand(System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ChangeBaudRateAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Instrument.DLT.DLT645.ChangeBaudRate(System.String)"/>
        </member>
        <member name="P:HslCommunication.Instrument.DLT.DLT645OverTcp.Station">
            <inheritdoc cref="P:HslCommunication.Instrument.DLT.DLT645.Station"/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645OverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Instrument.DLT.DLTControl">
            <summary>
            基本的控制码信息
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.Retain">
            <summary>
            保留
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.Broadcast">
            <summary>
            广播
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ReadData">
            <summary>
            读数据
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ReadFollowData">
            <summary>
            读后续数据
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ReadAddress">
            <summary>
            读通信地址
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.WriteData">
            <summary>
            写数据
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.WriteAddress">
            <summary>
            写通信地址
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.FreezeCommand">
            <summary>
            冻结命令
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ChangeBaudRate">
            <summary>
            更改通信速率
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ChangePassword">
            <summary>
            修改密码
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ClearMaxQuantityDemanded">
            <summary>
            最大需求量清零
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ElectricityReset">
            <summary>
            电表清零
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.EventReset">
            <summary>
            事件清零
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ClosingAlarmPowerpProtection">
            <summary>
            跳合闸、报警、保电
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.MultiFunctionTerminalOutputControlCommand">
            <summary>
            多功能端子输出控制命令
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.SecurityAuthenticationCommand">
            <summary>
            安全认证命令
            </summary>
        </member>
        <member name="T:HslCommunication.Instrument.DLT.DLTTransform">
            <summary>
            DTL数据转换
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLTTransform.TransStringFromDLt(System.Byte[],System.UInt16)">
            <summary>
            Byte[]转ToHexString
            </summary>
            <param name="content">原始的字节内容</param>
            <param name="length">长度信息</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLTTransform.TransDoubleFromDLt(System.Byte[],System.UInt16,System.String)">
            <summary>
            Byte[]转Dlt double[]
            </summary>
            <param name="content">原始的字节数据</param>
            <param name="length">需要转换的数据长度</param>
            <param name="format">当前数据的解析格式</param>
            <returns>结果内容</returns>
        </member>
        <member name="T:HslCommunication.Instrument.IEC.Helper.IECHelper">
            <summary>
            IEC协议的辅助类信息
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.Helper.IECHelper.PackIEC104Message(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte[])">
            <summary>
            将IEC104的报文打包成完整的IEC104标准的协议报文
            </summary>
            <param name="controlField1">控制域1</param>
            <param name="controlField2">控制域2</param>
            <param name="controlField3">控制域3</param>
            <param name="controlField4">控制域4</param>
            <param name="asdu">ASDU报文，包含类型标识，可变结构限定词，传送原因，应用服务器数据单元公共地址，信息体</param>
            <returns>完整的报文消息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.Helper.IECHelper.GetAbsoluteTimeScale(System.DateTime,System.Boolean)">
            <summary>
            根据给定的时间，获取绝对时标的报文数据信息
            </summary>
            <param name="dateTime">时间信息</param>
            <param name="valid">时标是否有效</param>
            <returns>可用于发送的绝对时标的报文</returns>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.Helper.IECHelper.PraseTimeFromAbsoluteTimeScale(System.Byte[],System.Int32)">
            <summary>
            根据给定的绝对时标的原始内容，解析出实际的时间信息。
            </summary>
            <param name="source">原始字节</param>
            <param name="index">数据的偏移索引</param>
            <returns>时间信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.Helper.IECHelper.BuildFrameSMessage(System.Int32)">
            <summary>
            构建一个S帧协议的内容，需要传入接收需要信息
            </summary>
            <param name="receiveID">接收序号信息</param>
            <returns>S帧协议的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.Helper.IECHelper.BuildFrameUMessage(System.Byte)">
            <summary>
            构建一个U帧消息的报文信息，传入功能码，STARTDT: 0x07, STOPDT: 0x13; TESTFR: 0x43
            </summary>
            <param name="controlField">控制码信息</param>
            <returns>U帧的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.Helper.IECHelper.BuildFrameIMessage(System.Int32,System.Int32,System.Byte,System.Byte,System.UInt16,System.UInt16,System.Byte[])">
            <summary>
            构建一个I帧消息的报文信息，传入相关的参数信息，返回完整的104消息报文
            </summary>
            <param name="sendID">发送的序列号</param>
            <param name="receiveID">接收的序列号</param>
            <param name="typeId">类型标识</param>
            <param name="variableStructureQualifier">可变结构限定词</param>
            <param name="reason">传送原因</param>
            <param name="address">应用服务数据单元公共地址</param>
            <param name="body">信息体，最大243个字节的长度</param>
            <returns>用于发送的104报文信息</returns>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.Helper.IECHelper.IEC104ControlStartDT">
            <summary>
            U帧协议里，启动的功能
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.Helper.IECHelper.IEC104ControlStopDT">
            <summary>
            U帧协议里，停止的功能
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.Helper.IECHelper.IEC104ControlTestFR">
            <summary>
            U帧协议里，测试的功能，主站和子站均可发出
            </summary>
        </member>
        <member name="T:HslCommunication.Instrument.IEC.IEC104">
            <summary>
            IEC104规约实现的电力协议
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IEC104.#ctor">
            <summary>
            实例化IEC104协议的通讯对象<br />
            Instantiate the communication object of the IEC104 protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IEC104.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个默认的对象<br />
            Specify the IP address and port number to instantiate a default object
            </summary>
            <param name="ipAddress">IEC104的Ip地址</param>
            <param name="port">IEC104的端口, 默认是2404端口</param>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IEC104.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IEC104.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IEC104.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IEC104.DecideWhetherQAMessage(System.Net.Sockets.Socket,HslCommunication.OperateResult{System.Byte[]})">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IEC104.SendFrameIMessage(System.Byte[])">
            <summary>
            以I消息的格式发送传入的原始字节数据，传入的消息为asdu信息
            </summary>
            <param name="asdu">ASDU报文信息</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="E:HslCommunication.Instrument.IEC.IEC104.OnIEC104MessageReceived">
            <summary>
            当接收到了IEC104的消息触发的事件
            </summary>
        </member>
        <member name="T:HslCommunication.Instrument.IEC.IEC104.TypeID">
            <summary>
            类型信息资源
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_SP_NA_1">
            <summary>
            单点遥信，带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_DP_NA_1">
            <summary>
            双点遥信，带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ST_NA_1">
            <summary>
            步位置信息，带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_BO_NA_1">
            <summary>
            32比特串，带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ME_NA_1">
            <summary>
            归一化遥测值，带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ME_NB_1">
            <summary>
            标度化遥测值，带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ME_NC_1">
            <summary>
            短浮点遥测值，带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_IT_NA_1">
            <summary>
            累计量，带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_PS_NA_1">
            <summary>
            成组单点遥信，只带变位标志
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ME_ND_1">
            <summary>
            归一化遥测值，不带品质描述，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_SP_TB_1">
            <summary>
            单点遥信，带品质描述，带绝对时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_DP_TB_1">
            <summary>
            双点遥信，带品质描述，带绝对时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ST_TB_1">
            <summary>
            步位置信息，带品质描述，带绝对时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_BO_TB_1">
            <summary>
            32比特串，带品质描述，带绝对时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ME_TD_1">
            <summary>
            归一化遥测值，带品质描述，带绝对时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ME_TE_1">
            <summary>
            标度化遥测值，带品质描述，带绝对时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_ME_TF_1">
            <summary>
            短浮点遥测值，带品质描述，带绝对时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_IT_TB_1">
            <summary>
            累计量，带品质描述，带绝对时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SC_NA_1">
            <summary>
            单点遥控，一个报文只有一个遥控信息体，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_DC_NA_1">
            <summary>
            双点遥控，一个报文只有一个遥控信息体，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_RC_NA_1">
            <summary>
            升降遥控，一个报文只有一个遥控信息体，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_NA_1">
            <summary>
            归一化设定值，一个报文只有一个设定值，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_NB_1">
            <summary>
            标度化设定值，一个报文只有一个设定值，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_NC_1">
            <summary>
            短浮点设定值，一个报文只有一个设定值，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_ND_1">
            <summary>
            32比特串设定，一个报文只有一个设定值，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_TA_1">
            <summary>
            单点遥控，一个报文只有一个遥控信息体，带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_TB_1">
            <summary>
            双点遥控，一个报文只有一个遥控信息体，带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_TC_1">
            <summary>
            升降遥控，一个报文只有一个遥控信息体，带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_TD_1">
            <summary>
            归一化设定值，一个报文只有一个设定值，带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_TE_1">
            <summary>
            标度化设定值，一个报文只有一个设定值，带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_TF_1">
            <summary>
            短浮点设定值，一个报文只有一个设定值，带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_TG_1">
            <summary>
            32比特串设定，一个报文只有一个设定值，带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_SE_NE_1">
            <summary>
            归一化设定值，一个报文可以包含多个设定值，不带时标
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.M_EI_NA_1">
            <summary>
            初始化结束，报告厂站初始化完成
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_IC_NA_1">
            <summary>
            总召唤，带不同的限定词可以用于组召唤
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_CI_NA_1">
            <summary>
            累计量召唤，带不同的限定词可以用于组召唤
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_RD_NA_1">
            <summary>
            读命令，读取单个的信息对象值
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_CS_NA_1">
            <summary>
            时钟同步命令，需要通过测量通道延迟加以校正
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_RS_NA_1">
            <summary>
            复位进程命令，使用前需要双方验证
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.IEC.IEC104.TypeID.C_TS_TA_1">
            <summary>
            带时标的测试命令
            </summary>
        </member>
        <member name="T:HslCommunication.Instrument.IEC.IEC104MessageEventArgs">
            <summary>
            IEC104的消息事件
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IEC104MessageEventArgs.#ctor(System.Byte[])">
            <summary>
            指定asdu消息进行实例化一个对象
            </summary>
            <param name="asdu">asdu报文</param>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IEC104MessageEventArgs.ASDU">
            <summary>
            获取或设置当前的asdu信息
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IEC104MessageEventArgs.TypeID">
            <summary>
            类型标识
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IEC104MessageEventArgs.IsAddressContinuous">
            <summary>
            地址是否连续
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IEC104MessageEventArgs.InfoObjectCount">
            <summary>
            信息对象个数
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IEC104MessageEventArgs.TransmissionReason">
            <summary>
            传送原因
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IEC104MessageEventArgs.StationAddress">
            <summary>
            站地址
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IEC104MessageEventArgs.Body">
            <summary>
            信息体
            </summary>
        </member>
        <member name="T:HslCommunication.Instrument.IEC.IecValueObject`1">
            <summary>
            IEC的数据对象，带值，品质信息，地址信息，时标信息
            </summary>
            <typeparam name="T">数据的类型</typeparam>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IecValueObject`1.Value">
            <summary>
            值信息
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IecValueObject`1.Quality">
            <summary>
            品质数据
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IecValueObject`1.Time">
            <summary>
            时间
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.IEC.IecValueObject`1.Address">
            <summary>
            地址
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.IEC.IecValueObject`1.PraseFloat(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            解析出一个浮点数的数据对象
            </summary>
            <param name="source">原始字节信息</param>
            <param name="index">起始偏移地址，字节为单位</param>
            <param name="includeTime">是否包含时标</param>
            <returns>浮点数的结果数据</returns>
        </member>
        <member name="T:HslCommunication.Instrument.Light.ShineInLightSourceController">
            <summary>
            昱行智造科技（深圳）有限公司的光源控制器，可以控制灯的亮暗，控制灯的颜色，通道等信息。
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.SerialPortInni(System.String,System.Int32)">
            <summary>
            初始化串口信息，波特率，8位数据位，1位停止位，偶校验<br />
            Initializes serial port information, baud rate, 8-bit data bit, 1-bit stop bit, even parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.SerialPortInni(System.String)">
            <summary>
            初始化串口信息，57600波特率，8位数据位，1位停止位，偶校验<br />
            Initial serial port information, 57600 baud rate, 8 data bits, 1 stop bit, even parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.Read(System.Byte)">
            <summary>
            读取光源控制器的参数信息，需要传入通道号信息，读取到详细的内容参照<see cref="T:HslCommunication.Instrument.Light.ShineInLightData"/>的值
            </summary>
            <param name="channel">读取的通道信息</param>
            <returns>读取的参数值</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.Write(HslCommunication.Instrument.Light.ShineInLightData)">
            <summary>
            将光源控制器的数据写入到设备，返回是否写入成功
            </summary>
            <param name="data">光源数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.PackCommand(System.Byte,System.Byte[])">
            <summary>
            将命令和数据打包成用于发送的报文
            </summary>
            <param name="cmd">命令</param>
            <param name="data">命令数据</param>
            <returns>可用于发送的报文</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.BuildWriteCommand(HslCommunication.Instrument.Light.ShineInLightData)">
            <summary>
            构建写入数据的报文命令
            </summary>
            <param name="shineInLightData">准备写入的数据</param>
            <returns>报文命令</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.BuildReadCommand(System.Byte)">
            <summary>
            构建读取数据的报文命令
            </summary>
            <param name="channel">通道信息</param>
            <returns>构建读取的命令</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightSourceController.ExtractActualData(System.Byte[])">
            <summary>
            把服务器反馈的数据解析成实际的命令
            </summary>
            <param name="response">反馈的数据</param>
            <returns>结果内容</returns>
        </member>
        <member name="T:HslCommunication.Instrument.Light.ShineInLightData">
            <summary>
            光源的数据信息
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightData.#ctor(System.Byte[])">
            <summary>
            使用指定的原始数据来获取当前的对象
            </summary>
            <param name="data">原始数据</param>
        </member>
        <member name="P:HslCommunication.Instrument.Light.ShineInLightData.Color">
            <summary>
            光源颜色信息，1:红色  2:绿色  3:蓝色  4:白色(默认)
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Light.ShineInLightData.Light">
            <summary>
            光源的亮度信息，00-FF，值越大，亮度越大
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Light.ShineInLightData.LightDegree">
            <summary>
            光源的亮度等级，1-3
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Light.ShineInLightData.WorkMode">
            <summary>
            光源的工作模式，00:延时常亮  01:通道一频闪  02:通道二频闪  03:通道一二频闪  04:普通常亮  05:关闭
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Light.ShineInLightData.Address">
            <summary>
            控制器的地址选择位
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Light.ShineInLightData.PulseWidth">
            <summary>
            脉冲宽度，01-14H
            </summary>
        </member>
        <member name="P:HslCommunication.Instrument.Light.ShineInLightData.Channel">
            <summary>
            通道数据，01-08H的值
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightData.GetSourceData">
            <summary>
            获取原始的数据信息
            </summary>
            <returns>原始的字节信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightData.ParseFrom(System.Byte[])">
            <summary>
            从原始的信息解析光源的数据
            </summary>
            <param name="data">原始的数据信息</param>
        </member>
        <member name="M:HslCommunication.Instrument.Light.ShineInLightData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper">
            <summary>
            RKC温度控制器的辅助类信息，提供了报文的生成，读写的实现的方法<br />
            Auxiliary information of the RKC temperature controller provides a method for message generation and reading and writing
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.BuildReadCommand(System.Byte,System.String)">
            <summary>
            构建读取的报文命令，需要指定站号信息，数据地址
            </summary>
            <param name="station">站号信息</param>
            <param name="address">数据的地址</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.BuildWriteCommand(System.Byte,System.String,System.Double)">
            <summary>
            构建一个写入的报文信息
            </summary>
            <param name="station">站号信息</param>
            <param name="address">地址信息</param>
            <param name="value">等待写入的值</param>
            <returns>是否成功的结果报文</returns>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.ReadDouble(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)">
            <summary>
            从RKC设备读取Double类型的数据信息，地址示例：M1,M2,M3,AA,AB,B1,ER等，更详细的地址及具体含义需要参考API文档<br />
            Read Double type data information from RKC device. Examples of addresses: M1, M2, M3, AA, AB, B1, ER, etc. 
            For more detailed addresses and specific meanings, please refer to the API documentation
            </summary>
            <param name="device">设备通信对象</param>
            <param name="station">表号信息，也叫站号信息</param>
            <param name="address">数据地址信息，地址示例：M1,M2,M3,AA,AB,B1,ER等</param>
            <returns>结果数据对象信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Double)">
            <summary>
            将Double类型的数据写入到RKC设备中去，地址示例：M1,M2,M3,AA,AB,B1,ER等，更详细的地址及具体含义需要参考API文档<br />
            Write Double type data to the RKC device. Examples of addresses: M1, M2, M3, AA, AB, B1, ER, etc. 
            For more detailed addresses and specific meanings, please refer to the API documentation
            </summary>
            <param name="device">设备通信对象</param>
            <param name="station">表号信息，也叫站号信息</param>
            <param name="address">数据的地址信息，地址示例：M1,M2,M3,AA,AB,B1,ER等</param>
            <param name="value">等待写入的值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.ReadDoubleAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.ReadDouble(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Double)"/>
        </member>
        <member name="T:HslCommunication.Instrument.RKC.TemperatureController">
            <summary>
            RKC的CD/CH系列数字式温度控制器的串口类对象，可以读取测量值，CT1输入值，CT2输入值等等，地址的地址需要参考API文档的示例<br />
            The serial port object of RKC's CD/CH series digital temperature controller can read the measured value, CT1 input value, 
            CT2 input value, etc. The address of the address needs to refer to the example of the API document
            </summary>
            <remarks>
            只能使用ReadDouble(string),Write(string,double)方法来读写数据，设备的串口默认参数为 8-1-N,8 个数据位，一个停止位，无奇偶校验<br />
            地址支持站号信息，例如 s=2;M1
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureController.#ctor">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.#ctor"/>
        </member>
        <member name="P:HslCommunication.Instrument.RKC.TemperatureController.Station">
            <inheritdoc cref="P:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureController.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.ReadDouble(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureController.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureController.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.ReadDouble(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureController.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureController.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp">
            <summary>
            RKC的CD/CH系列数字式温度控制器的网口透传类对象，可以读取测量值，CT1输入值，CT2输入值等等，地址的地址需要参考API文档的示例<br />
            RKC's CD/CH series digital temperature controller's network port transparently transmits objects, which can read measured values, CT1 input values, 
            CT2 input values, etc. The address of the address needs to refer to the example of the API document
            </summary>
            <remarks>
            只能使用ReadDouble(string),Write(string,double)方法来读写数据<br />
            地址支持站号信息，例如 s=2;M1
            </remarks>
            <example>
            地址示例如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>数据范围</term>
                <term>出厂方式</term>
                <term>读写方式</term>
              </listheader>
              <item>
                <term>测量值</term>
                <term>M1</term>
                <term>测量低限到测量高限</term>
                <term></term>
                <term>Read</term>
              </item>
              <item>
                <term>CT1输入值</term>
                <term>M2</term>
                <term>0.0到100.0A</term>
                <term></term>
                <term>Read</term>
              </item>
              <item>
                <term>CT2输入值</term>
                <term>M3</term>
                <term>0.0到100.0A</term>
                <term></term>
                <term>Read</term>
              </item>
              <item>
                <term>第一报警输入</term>
                <term>AA</term>
                <term>0 关 1 开</term>
                <term></term>
                <term>Read</term>
              </item>
              <item>
                <term>第二报警输入</term>
                <term>AB</term>
                <term>0 关 1 开</term>
                <term></term>
                <term>Read</term>
              </item>
              <item>
                <term>熄火</term>
                <term>B1</term>
                <term>0 关 1 开</term>
                <term></term>
                <term>Read</term>
              </item>
              <item>
                <term>错误代码</term>
                <term>ER</term>
                <term>0到255</term>
                <term></term>
                <term>Read</term>
              </item>
              <item>
                <term>运行/停止转换</term>
                <term>SR</term>
                <term>0 运行 1 停止</term>
                <term>运行</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>PID控制/自整定</term>
                <term>G1</term>
                <term>0 PID 1 AT</term>
                <term>PID控制</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>设定值（SV1）</term>
                <term>S1</term>
                <term>量程低限到量程高限</term>
                <term>0（0.0）</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>第一报警设定</term>
                <term>A1</term>
                <term>-1999到9999（小数点位置与PV相同）</term>
                <term>50（50.0）</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>第二报警设定</term>
                <term>A2</term>
                <term>-1999到9999（小数点位置与PV相同）</term>
                <term>-50（-50.0）</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>第一加热断线报警设定</term>
                <term>A3</term>
                <term>0.0到100.0A</term>
                <term>0.0</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>第二加热断线报警设定</term>
                <term>A4</term>
                <term>1.0到100.0A</term>
                <term>0.0</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>控制回路断线报警设定</term>
                <term>A5</term>
                <term>0-7200秒</term>
                <term>0</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>比例带 加热侧</term>
                <term>P1</term>
                <term>0-满量程</term>
                <term>30（30.0）</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>积分时间</term>
                <term>I1</term>
                <term>0-3600秒</term>
                <term>240</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>微分时间</term>
                <term>D1</term>
                <term>0-3600秒</term>
                <term>60</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>积分饱和带宽</term>
                <term>W1</term>
                <term>比例带的1%-100%</term>
                <term>100</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>制冷侧比例带</term>
                <term>P2</term>
                <term>比例带的1%-3000%</term>
                <term>3000</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>冷热死区</term>
                <term>V1</term>
                <term>-10.0到10.0</term>
                <term>0（0.0）</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>比例周期（输出1）</term>
                <term>T0</term>
                <term>0-100秒</term>
                <term>20</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>比例周期（输出2）</term>
                <term>T1</term>
                <term>0-100秒</term>
                <term>20</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>自主校正</term>
                <term>G2</term>
                <term>0 自主校正停止 1 自主校正开始</term>
                <term>0</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>PV基准</term>
                <term>PB</term>
                <term>量程低限到量程高, 限温度输入 -1999到+1999 [℉ ]或 -199.9到+999.9 [℉ ]</term>
                <term>0(0.0)</term>
                <term>Read/Write</term>
              </item>
              <item>
                <term>设定数据锁</term>
                <term>LK</term>
                <term>0到7</term>
                <term>0</term>
                <term>Read/Write</term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.#ctor">
            <summary>
            实例化默认的构造方法<br />
            Instantiate the default constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口来实例化一个对象<br />
            Instantiate an object with the specified IP address and port
            </summary>
            <param name="ipAddress">设备的Ip地址</param>
            <param name="port">设备的端口号</param>
        </member>
        <member name="P:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.Station">
            <summary>
            PLC的站号信息，需要和实际的设置值一致，默认为1<br />
            The station number information of the PLC needs to be consistent with the actual setting value. The default is 1.
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.ReadDouble(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.ReadDouble(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Instrument.RKC.Helper.TemperatureControllerHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Instrument.RKC.TemperatureControllerOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Instrument.Temperature.DAM3601">
            <summary>
            阿尔泰科技发展有限公司的DAM3601温度采集模块，基于ModbusRtu开发完成。
            </summary>
            <remarks>
            该温度采集模块是基于modbus-rtu，但不是标准的modbus协议，存在一些小误差，需要重写实现，并且提供了基础的数据转换
            </remarks>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.#ctor(System.Byte)">
            <summary>
            使用站号实例化默认的对象
            </summary>
            <param name="station">站号信息</param>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.ReadAllTemperature">
            <summary>
            读取所有的温度数据，并转化成相关的信息
            </summary>
            <returns>结果数据对象</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.TransformValue(System.Int16)">
            <summary>
            数据转换方法，将读取的值，
            </summary>
            <param name="value">读取的值</param>
            <returns>转换后的值</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.Read(System.String,System.UInt16)">
            <summary>
            从Modbus服务器批量读取寄存器的信息，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"，或者是带功能码格式x=3;1234</param>
            <param name="length">读取的数量</param>
            <returns>带有成功标志的字节信息</returns>
            <example>
            此处演示批量读取的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="ReadExample2" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Language.DefaultLanguage">
            <summary>
            系统的语言基类，默认也即是中文版本
            </summary>
        </member>
        <member name="T:HslCommunication.Language.English">
            <summary>
            English Version Text
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.ILogNet">
            <summary>
            一个通用的日志接口，支持5个等级的日志消息写入，支持设置当前的消息等级，定义一个消息存储前的触发事件。<br />
            A general-purpose log interface, supports the writing of 5 levels of log messages, supports setting the current message level, and defining a trigger event before a message is stored.
            </summary>
            <remarks>
            本组件的日志核心机制，如果您使用了本组件却不想使用本组件的日志组件功能，可以自己实现新的日志组件，只要继承本接口接口。其他常用的日志组件如下：（都是可以实现的）
            <list type="number">
            <item>Log4Net</item>
            <item>NLog</item>
            </list>
            </remarks>
            <example>
            自己实例化操作，在HslCommunication里面，可选三种类型
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example1" title="单文件实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example2" title="限制文件大小实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example3" title="日期存储实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="基本的使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example5" title="所有日志不存储" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example6" title="仅存储ERROR等级" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example7" title="不指定路径" />
            Form的示例，存储日志的使用都是一样的，就是实例化的时候不一致，以下示例代码以单文件日志为例
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormLogNet.cs" region="ILogNet" title="ILogNet示例" />
            </example>
        </member>
        <member name="P:HslCommunication.LogNet.ILogNet.LogSaveMode">
            <summary>
            日志存储模式，1:单文件，2:按大小存储，3:按时间存储<br />
            Log storage mode, 1: single file, 2: storage by size, 3: storage by time
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.ILogNet.LogNetStatistics">
            <summary>
            获取或设置当前的日志记录统计信息，如果你需要统计最近30天的日志，就需要对其实例化，详细参照<see cref="T:HslCommunication.LogNet.LogStatistics"/><br />
            Get or set the current log record statistics. If you need to count the logs of the last 30 days, 
            you need to instantiate it. For details, please refer to <see cref="T:HslCommunication.LogNet.LogStatistics"/>
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.ILogNet.ConsoleOutput">
            <summary>
            获取或设置当前的日志信息在存储的时候是否在控制台进行输出，默认不输出。<br />
            Gets or sets whether the current log information is output on the console when it is stored. It is not output by default.
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.ILogNet.LogThreadID">
            <summary>
            获取或设置是否记录线程ID的数据信息，默认为 <c>True</c>，表示记录，否则，需要设置为 <c>False</c><br />
            Get or set whether to record the data information of the thread ID, the default is <c>True</c>, which means record, otherwise, it needs to be set to <c>False</c><br />
            </summary>
        </member>
        <member name="E:HslCommunication.LogNet.ILogNet.BeforeSaveToFile">
            <summary>
            存储之前引发的事件，允许额外的操作，比如打印控制台，存储数据库等等<br />
            Store previously raised events, allowing additional operations, such as print console, store database, etc.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.RecordMessage(HslCommunication.LogNet.HslMessageDegree,System.String,System.String)">
            <summary>
            通过指定消息等级，关键字，日志信息进行消息记录<br />
            Record messages by specifying message level, keywords, and log information
            </summary>
            <param name="degree">消息等级</param>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteDescrition(System.String)">
            <summary>
            写入一条解释性的信息，不属于消息等级控制的范畴<br />
            Write an explanatory message that is not part of message level control
            </summary>
            <param name="description">解释文本</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteDebug(System.String)">
            <summary>
            写入一条调试日志<br />
            Write a debug log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteDebug(System.String,System.String)">
            <summary>
            写入一条带关键字的调试日志<br />
            Write a debug log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteError(System.String)">
            <summary>
            写入一条错误日志<br />
            Write an error log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteError(System.String,System.String)">
            <summary>
            写入一条带关键字的错误日志<br />
            Write an error log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteException(System.String,System.Exception)">
            <summary>
            写入一条带关键字的异常信息<br />
            Write an exception log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteException(System.String,System.String,System.Exception)">
            <summary>
            写入一条带关键字和描述信息的异常信息<br />
            Write an exception log with keywords and text
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">内容</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteFatal(System.String)">
            <summary>
            写入一条致命日志<br />
            Write an fatal log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteFatal(System.String,System.String)">
            <summary>
            写入一条带关键字的致命日志<br />
            Write an fatal log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteInfo(System.String)">
            <summary>
            写入一条普通日志<br />
            Write an infomation log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteInfo(System.String,System.String)">
            <summary>
            写入一条带关键字的普通日志<br />
            Write an information log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteNewLine">
            <summary>
            写入一行换行符<br />
            Write a newline
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteAnyString(System.String)">
            <summary>
            写入任意字符串<br />
            Write arbitrary string
            </summary>
            <param name="text">文本</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteWarn(System.String)">
            <summary>
            写入一条警告日志<br />
            Write an warn log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteWarn(System.String,System.String)">
            <summary>
            写入一条带关键字的警告日志<br />
            Write an warn log  with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.SetMessageDegree(HslCommunication.LogNet.HslMessageDegree)">
            <summary>
            设置日志的存储等级，高于该等级的才会被存储<br />
            Set the storage level of the logs. Only the logs above this level will be stored.
            </summary>
            <param name="degree">登记信息</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.GetExistLogFileNames">
            <summary>
            获取已存在的日志文件名称<br />
            Get the name of an existing log file
            </summary>
            <returns>文件列表</returns>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.FiltrateKeyword(System.String)">
            <summary>
            过滤掉指定的关键字的日志，该信息不存储，但仍然触发<see cref="E:HslCommunication.LogNet.ILogNet.BeforeSaveToFile"/>事件<br />
            Filter out the logs of the specified keywords, the information is not stored, but the <see cref="E:HslCommunication.LogNet.ILogNet.BeforeSaveToFile" /> event is still triggered
            </summary>
            <param name="keyword">关键字</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.RemoveFiltrate(System.String)">
            <summary>
            移除过滤的关键字存储<br />
            Remove filtered keyword storage
            </summary>
            <param name="keyword">关键字</param>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetBase">
            <summary>
            日志存储类的基类，提供一些基础的服务
            </summary>
            <remarks>
            基于此类可以实现任意的规则的日志存储规则，欢迎大家补充实现，本组件实现了3个日志类
            <list type="number">
            <item>单文件日志类 <see cref="T:HslCommunication.LogNet.LogNetSingle"/></item>
            <item>根据文件大小的类 <see cref="T:HslCommunication.LogNet.LogNetFileSize"/></item>
            <item>根据时间进行存储的类 <see cref="T:HslCommunication.LogNet.LogNetDateTime"/></item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.#ctor">
            <summary>
            实例化一个日志对象<br />
            Instantiate a log object
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogNetBase.m_fileSaveLock">
            <summary>
            文件存储的锁
            </summary>
        </member>
        <member name="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile">
            <inheritdoc cref="E:HslCommunication.LogNet.ILogNet.BeforeSaveToFile"/>
        </member>
        <member name="P:HslCommunication.LogNet.LogNetBase.LogSaveMode">
            <inheritdoc cref="P:HslCommunication.LogNet.ILogNet.LogSaveMode"/>
        </member>
        <member name="P:HslCommunication.LogNet.LogNetBase.LogNetStatistics">
            <inheritdoc cref="P:HslCommunication.LogNet.ILogNet.LogNetStatistics"/>
        </member>
        <member name="P:HslCommunication.LogNet.LogNetBase.ConsoleOutput">
            <inheritdoc cref="P:HslCommunication.LogNet.ILogNet.ConsoleOutput"/>
        </member>
        <member name="P:HslCommunication.LogNet.LogNetBase.LogThreadID">
            <inheritdoc cref="P:HslCommunication.LogNet.ILogNet.LogThreadID"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteDebug(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteDebug(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteDebug(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteDebug(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteInfo(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteInfo(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteInfo(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteInfo(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteWarn(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteWarn(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteWarn(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteWarn(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteError(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteError(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteError(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteError(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteFatal(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteFatal(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteFatal(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteFatal(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteException(System.String,System.Exception)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteException(System.String,System.Exception)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteException(System.String,System.String,System.Exception)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteException(System.String,System.String,System.Exception)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.RecordMessage(HslCommunication.LogNet.HslMessageDegree,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.RecordMessage(HslCommunication.LogNet.HslMessageDegree,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteDescrition(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteDescrition(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteAnyString(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteAnyString(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteNewLine">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteNewLine"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.SetMessageDegree(HslCommunication.LogNet.HslMessageDegree)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.SetMessageDegree(HslCommunication.LogNet.HslMessageDegree)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.FiltrateKeyword(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.FiltrateKeyword(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.RemoveFiltrate(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.RemoveFiltrate(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.GetFileSaveName">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.OnWriteCompleted">
            <summary>
            当写入文件完成的时候触发，这时候已经释放了文件的句柄了。<br />
            Triggered when writing to the file is complete, and the file handle has been released.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.Dispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing">是否初次调用</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:HslCommunication.LogNet.LogPathBase">
            <summary>
            基于路径实现的日志类的基类，提供几个基础的方法信息。<br />
            The base class of the log class implemented based on the path provides several basic method information.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogPathBase.OnWriteCompleted">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogPathBase.GetExistLogFileNames">
            <summary>
            返回所有的日志文件名称，返回一个列表<br />
            Returns all log file names, returns a list
            </summary>
            <returns>所有的日志文件信息</returns>
        </member>
        <member name="F:HslCommunication.LogNet.LogPathBase.fileName">
            <summary>
            当前正在存储的文件名<br />
            File name currently being stored
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogPathBase.filePath">
            <summary>
            存储文件的路径，如果设置为空，就不进行存储。<br />
            The path for storing the file. If it is set to empty, it will not be stored.
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogPathBase.controlFileQuantity">
            <summary>
            控制文件的数量，小于1则不进行任何操作，当设置为10的时候，就限制文件数量为10。<br />
            Control the number of files. If it is less than 1, no operation is performed. When it is set to 10, the number of files is limited to 10.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogPathBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.LogNet.LogStatisticsBase`1">
            <summary>
            一个按照实际进行数据分割的辅助基类，可以用于实现对某个的API按照每天进行调用次数统计，也可以实现对某个设备数据按照天进行最大最小值均值分析，这些都是需要继承实现。<br />
            An auxiliary base class that divides the data according to the actual data can be used to implement statistics on the number of calls per day for a certain API, and it can also implement the maximum and minimum average analysis of a certain device data according to the day. These all need to be inherited. .
            </summary>
            <typeparam name="T">统计的数据类型</typeparam>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.#ctor(HslCommunication.LogNet.GenerateMode,System.Int32)">
            <summary>
            实例化一个新的数据统计内容，需要指定当前的时间统计方式，按小时，按天，按月等等，还需要指定统计的数据数量，比如按天统计30天。<br />
            To instantiate a new data statistics content, you need to specify the current time statistics method, by hour, by day, by month, etc., 
            and also need to specify the number of statistics, such as 30 days by day.
            </summary>
            <param name="generateMode">时间的统计方式</param>
            <param name="arrayLength">数据的数量信息，如果本值为-1，则表示数据一直增长</param>
        </member>
        <member name="P:HslCommunication.LogNet.LogStatisticsBase`1.GenerateMode">
            <summary>
            获取当前的统计类信息时间统计规则<br />
            Get the current statistical information time statistics rule
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.LogStatisticsBase`1.ArrayLength">
            <summary>
            获取当前的统计类信息的数据总量<br />
            Get the total amount of current statistical information
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.Reset(`0[],System.Int64)">
            <summary>
            重置当前的统计信息，需要指定统计的数据内容，最后一个数据的标记信息，本方法主要用于还原统计信息<br />
            To reset the current statistical information, you need to specify the content of the statistical data, 
            and the tag information of the last data. This method is mainly used to restore statistical information
            </summary>
            <param name="statistics">统计结果数据信息</param>
            <param name="lastDataMark">最后一次标记的内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.StatisticsCustomAction(System.Func{`0,`0})">
            <summary>
            新增一个统计信息，将会根据当前的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行自定义的数据操作<br />
            Adding a new statistical information will determine the position to insert the data according to the current time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, Custom data operations on the last number
            </summary>
            <param name="newValue">增对最后一个数的自定义操作</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.StatisticsCustomAction(System.Func{`0,`0},System.DateTime)">
            <summary>
            新增一个统计信息，将会根据当前的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行自定义的数据操作<br />
            Adding a new statistical information will determine the position to insert the data according to the current time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, Custom data operations on the last number
            </summary>
            <param name="newValue">增对最后一个数的自定义操作</param>
            <param name="time">增加的时间信息</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.GetStatisticsSnapshot">
            <summary>
            获取当前的统计信息的数据快照，这是数据的副本，修改了里面的值不影响<br />
            Get a data snapshot of the current statistics. This is a copy of the data. Modifying the value inside does not affect
            </summary>
            <returns>实际的统计数据信息</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.GetStatisticsSnapshotByTime(System.DateTime,System.DateTime)">
            <summary>
            根据指定的时间范围来获取统计的数据信息快照，包含起始时间，包含结束时间，这是数据的副本，修改了里面的值不影响<br />
            Get a snapshot of statistical data information according to the specified time range, including the start time, 
            also the end time. This is a copy of the data. Modifying the value inside does not affect
            </summary>
            <param name="start">起始时间</param>
            <param name="finish">结束时间</param>
            <returns>指定实际范围内的数据副本</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.GetStatisticsSnapAndDataMark">
            <summary>
            获取当前的统计信息的数据快照，这是数据的副本，修改了里面的值不影响<br />
            Get a data snapshot of the current statistics. This is a copy of the data. Modifying the value inside does not affect
            </summary>
            <returns>实际的统计数据信息</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.GetDataMarkFromTimeNow">
            <summary>
            根据当前数据统计的时间模式，获取最新的数据标记信息<br />
            Obtain the latest data mark information according to the time mode of current data statistics
            </summary>
            <returns>数据标记</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsBase`1.GetDataMarkFromDateTime(System.DateTime)">
            <summary>
            根据指定的时间，获取到该时间指定的数据标记信息<br />
            According to the specified time, get the data mark information specified at that time
            </summary>
            <param name="dateTime">指定的时间</param>
            <returns>数据标记</returns>
        </member>
        <member name="F:HslCommunication.LogNet.LogStatisticsBase`1.generateMode">
            <summary>
            当前的实际模式
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.HslEventArgs">
            <summary>
            带有日志消息的事件
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslEventArgs.HslMessage">
            <summary>
            消息信息
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetException">
            <summary>
            日志存储回调的异常信息
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetException.#ctor(System.Exception)">
            <summary>
            使用其他的异常信息来初始化日志异常
            </summary>
            <param name="innerException">异常信息</param>
        </member>
        <member name="T:HslCommunication.LogNet.LogSaveMode">
            <summary>
            日志文件的存储模式
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogSaveMode.SingleFile">
            <summary>
            单个文件的存储模式
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogSaveMode.FileFixedSize">
            <summary>
            根据文件的大小来存储，固定一个大小，不停的生成文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogSaveMode.Time">
            <summary>
            根据时间来存储，可以设置年，季，月，日，小时等等
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.GenerateMode">
            <summary>
            日志文件输出模式
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryMinute">
            <summary>
            按每分钟生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryHour">
            <summary>
            按每个小时生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryDay">
            <summary>
            按每天生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryWeek">
            <summary>
            按每个周生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryMonth">
            <summary>
            按每个月生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEverySeason">
            <summary>
            按每季度生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryYear">
            <summary>
            按每年生成日志文件
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.HslMessageDegree">
            <summary>
            记录消息的等级
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.None">
            <summary>
            一条消息都不记录
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.FATAL">
            <summary>
            记录致命等级及以上日志的消息
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.ERROR">
            <summary>
            记录异常等级及以上日志的消息
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.WARN">
            <summary>
            记录警告等级及以上日志的消息
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.INFO">
            <summary>
            记录信息等级及以上日志的消息
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.DEBUG">
            <summary>
            记录调试等级及以上日志的信息
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.HslMessageItem">
            <summary>
            单条日志的记录信息，包含了消息等级，线程号，关键字，文本信息<br />
            Record information of a single log, including message level, thread number, keywords, text information
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.HslMessageItem.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Id">
            <summary>
            单个记录信息的标识ID，程序重新运行时清空，代表程序从运行以来的日志计数，不管存储的或是未存储的<br />
            The ID of a single record of information. It is cleared when the program is re-run. 
            It represents the log count of the program since it was run, whether stored or unstored.
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Degree">
            <summary>
            消息的等级，包括DEBUG，INFO，WARN，ERROR，FATAL，NONE共计六个等级<br />
            Message levels, including DEBUG, INFO, WARN, ERROR, FATAL, NONE total six levels
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.ThreadId">
            <summary>
            线程ID，发生异常时的线程号<br />
            Thread ID, the thread number when the exception occurred
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Text">
            <summary>
            消息文本，记录日志的时候给定<br />
            Message text, given when logging
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Time">
            <summary>
            记录日志的时间，而非存储日志的时间<br />
            The time the log was recorded, not the time it was stored
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.KeyWord">
            <summary>
            消息的关键字<br />
            Keyword of the message
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Cancel">
            <summary>
            是否取消写入到文件中去，在事件 <see cref="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile"/> 触发的时候捕获即可设置。<br />
            Whether to cancel writing to the file, can be set when the event <see cref="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile"/> is triggered.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.HslMessageItem.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.HslMessageItem.ToStringWithoutKeyword">
            <summary>
            返回表示当前对象的字符串，剔除了关键字<br />
            Returns a string representing the current object, excluding keywords
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetManagment">
            <summary>
            日志类的管理器，提供了基本的功能代码。<br />
            The manager of the log class provides the basic function code.
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogNetManagment.LogFileHeadString">
            <summary>
            日志文件的头标志
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.LogNetManagment.LogNet">
            <summary>
            公开的一个静态变量，允许随意的设置<br />
            Public static variable, allowing arbitrary setting
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetManagment.GetSaveStringFromException(System.String,System.Exception)">
            <summary>
            通过异常文本格式化成字符串用于保存或发送<br />
            Formatted as a string with exception text for saving or sending
            </summary>
            <param name="text">文本消息</param>
            <param name="ex">异常</param>
            <returns>异常最终信息</returns>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetDateTime">
            <summary>
            一个日志组件，可以根据时间来区分不同的文件存储<br />
            A log component that can distinguish different file storages based on time
            </summary>
            <remarks>
            此日志实例将根据日期时间来进行分类，支持的时间分类如下：
            <list type="number">
            <item>分钟</item>
            <item>小时</item>
            <item>天</item>
            <item>周</item>
            <item>月份</item>
            <item>季度</item>
            <item>年份</item>
            </list>
            当然你也可以指定允许存在多少个日志文件，比如我允许存在最多10个文件，如果你的日志是根据天来分文件的，那就是10天的数据。
            同理，如果你的日志是根据年来分文件的，那就是10年的日志文件。
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example3" title="日期存储实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="基本的使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example5" title="所有日志不存储" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example6" title="仅存储ERROR等级" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example7" title="不指定路径" />
            </example>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetDateTime.#ctor(System.String,HslCommunication.LogNet.GenerateMode,System.Int32)">
            <summary>
            实例化一个根据时间存储的日志组件，需要指定每个文件的存储时间范围<br />
            Instantiate a log component based on time, you need to specify the storage time range for each file
            </summary>
            <param name="filePath">文件存储的路径</param>
            <param name="generateMode">存储文件的间隔</param>
            <param name="fileQuantity">指定当前的日志文件数量上限，如果小于0，则不限制，文件一直增加，如果设置为10，就限制最多10个文件，会删除最近时间的10个文件之外的文件。</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetDateTime.GetFileSaveName">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetDateTime.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetFileSize">
            <summary>
            根据文件的大小来存储日志信息，当前的文件大小增长超过设定值，就会创建新的文件来存储，新的文件命名为当前时间。<br />
            Log information is stored according to the size of the file. If the current file size exceeds the set value, a new file is created for storage, and the new file is named the current time.
            </summary>
            <remarks>
            此日志的实例是根据文件的大小储存，例如设置了2M，每隔2M，系统将生成一个新的日志文件。当然你也可以指定允许存在多少个日志文件，
            比如我允许存在最多10个文件，那总量就是20M，旧的文件会被删除掉。
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example2" title="限制文件大小实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="基本的使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example5" title="所有日志不存储" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example6" title="仅存储ERROR等级" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example7" title="不指定路径" />
            </example>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            实例化一个根据文件大小生成新文件的，默认是2M大的文件<br />
            Instantiate a new file based on the file size. The default is 2M.
            </summary>
            <param name="filePath">日志文件的保存路径</param>
            <param name="fileMaxSize">每个日志文件的最大大小，默认2M</param>
            <param name="fileQuantity">指定当前的日志文件数量上限，如果小于0，则不限制，文件一直增加，如果设置为10，就限制最多10个文件，会删除最近时间的10个文件之外的文件。</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.GetFileSaveName">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.GetLastAccessFileName">
            <summary>
            获取之前保存的日志文件，如果文件大小超过了设定值，将会生成新的文件名称<br />
            Obtain the previously saved log file. If the file size exceeds the set value, a new file name will be generated
            </summary>
            <returns>文件名称</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.GetDefaultFileName">
            <summary>
            获取一个新的默认的文件名称<br />
            Get a new default file name
            </summary>
            <returns>完整的文件名</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetSingle">
            <summary>
            单日志文件对象，所有的日志信息的记录都会写入一个文件里面去。文件名指定为空的时候，自动不存储文件。<br />
            Single log file object, all log information records will be written to a file. When the file name is specified as empty, the file is not stored automatically.
            </summary>
            <remarks>
            此日志实例化需要指定一个完整的文件路径，当需要记录日志的时候调用方法，会使得日志越来越大，对于写入的性能没有太大影响，但是会影响文件读取。
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example1" title="单文件实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="基本的使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example5" title="所有日志不存储" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example6" title="仅存储ERROR等级" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example7" title="不指定路径" />
            </example>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.#ctor(System.String)">
            <summary>
            实例化一个单文件日志的对象，如果日志的路径为空，那么就不存储数据，只触发<see cref="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile"/>事件<br />
            Instantiate a single file log object. If the log path is empty, then no data is stored and only the <see cref="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile"/> event is triggered.
            </summary>
            <param name="filePath">文件的路径</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.ClearLog">
            <summary>
            单日志文件允许清空日志内容<br />
            Single log file allows clearing log contents
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.GetAllSavedLog">
            <summary>
            获取单日志文件的所有保存记录<br />
            Get all saved records of a single log file
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.GetExistLogFileNames">
            <summary>
            获取所有的日志文件数组，对于单日志文件来说就只有一个<br />
            Get all log file arrays, only one for a single log file
            </summary>
            <returns>字符串数组，包含了所有的存在的日志数据</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.GetFileSaveName">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.LogNet.LogStatistics">
            <summary>
            一个统计次数的辅助类，可用于实现分析一些次数统计信息，比如统计某个API最近每天的访问次数，
            统计日志组件最近每天访问的次数，调用者只需要关心统计方式和数据个数，详细参照API文档。<br />
            An auxiliary class for counting the number of times, which can be used to realize the analysis of some number of times statistical information, 
            such as counting the number of daily visits of an API, and counting the number of daily visits of the log component. 
            The caller only needs to care about the statistical method and the number of data. Refer to details API documentation.
            </summary>
            <example>
            我们来举个例子：我有个方法，AAA需要记录一下连续60天的调用次数信息
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogStatisticsSample.cs" region="Sample1" title="简单的记录调用次数" />
            因为这个数据是保存在内存里的，程序重新运行就丢失了，如果希望让这个数据一直在程序的话，在软件退出的时候需要存储文件，在软件启动的时候，加载文件数据
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogStatisticsSample.cs" region="Sample2" title="存储与加载" />
            </example>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatistics.#ctor(HslCommunication.LogNet.GenerateMode,System.Int32)">
            <inheritdoc cref="M:HslCommunication.LogNet.LogStatisticsBase`1.#ctor(HslCommunication.LogNet.GenerateMode,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatistics.StatisticsAdd(System.Int64)">
            <summary>
            新增一个统计信息，将会根据当前的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行新增数据 frequency 次<br />
            Adding a new statistical information will determine the position to insert the data according to the current time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, add data to the last number frequency times
            </summary>
            <param name="frequency">新增的次数信息，默认为1</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatistics.StatisticsAddByTime(System.Int64,System.DateTime)">
            <summary>
            新增一个统计信息，将会根据指定的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行新增数据 frequency 次<br />
            Adding a new statistical information will determine the position to insert the data according to the specified time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, add data to the last number frequency times
            </summary>
            <param name="frequency">新增的次数信息</param>
            <param name="time">新增的次数的时间</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatistics.SaveToBinary">
            <summary>
            将当前所有的数据都写入到二进制的内存里去，可以用来写入文件或是网络发送。<br />
            Write all current data into binary memory, which can be used to write files or send over the network.
            </summary>
            <returns>二进制的byte数组</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatistics.SaveToFile(System.String)">
            <summary>
            将当前的统计信息及数据内容写入到指定的文件里面，需要指定文件的路径名称<br />
            Write the current statistical information and data content to the specified file, you need to specify the path name of the file
            </summary>
            <param name="fileName">文件的完整的路径名称</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatistics.LoadFromBinary(System.Byte[])">
            <summary>
            从二进制的数据内容加载，会对数据的合法性进行检查，如果数据不匹配，会报异常<br />
            Loading from the binary data content will check the validity of the data. If the data does not match, an exception will be reported
            </summary>
            <param name="buffer">等待加载的二进制数据</param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatistics.LoadFromFile(System.String)">
            <summary>
            从指定的文件加载对应的统计信息，通常是调用<see cref="M:HslCommunication.LogNet.LogStatistics.SaveToFile(System.String)"/>方法存储的文件，如果文件不存在，将会跳过加载<br />
            Load the corresponding statistical information from the specified file, usually the file stored by calling the <see cref="M:HslCommunication.LogNet.LogStatistics.SaveToFile(System.String)"/> method. 
            If the file does not exist, the loading will be skipped
            </summary>
            <param name="fileName">文件的完整的路径名称</param>
            <exception cref="T:System.Exception">当文件的模式和当前的模式设置不一样的时候，会引发异常</exception>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatistics.ToString">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.LogNet.LogStatistics.TotalSum">
            <summary>
            获取当前的所有的值的总和<br />
            Get the sum of all current values
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.LogStatisticsDict">
            <summary>
            <seealso cref="T:HslCommunication.LogNet.LogStatistics"/>的词典集合类，用于多个数据的统计信息，例如可以统计多个规格的产量信息，统计多个方法的调用次数信息<br />
            The dictionary collection class of <seealso cref="T:HslCommunication.LogNet.LogStatistics"/> is used for the statistical information of multiple data, for example, 
            the output information of multiple specifications can be counted, and the number of calls of multiple methods can be counted.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.#ctor(HslCommunication.LogNet.GenerateMode,System.Int32)">
            <summary>
            根据指定的存储模式，数据个数来实例化一个对象<br />
            According to the specified storage mode, the number of data to instantiate an object
            </summary>
            <param name="generateMode">当前的数据存储模式</param>
            <param name="arrayLength">准备存储的数据总个数</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.GetLogStatistics(System.String)">
            <summary>
            根据给定的关键字信息，获取相关的 <seealso cref="T:HslCommunication.LogNet.LogStatistics"/> 对象，进而执行很多的操作<br />
            According to the given keyword information, obtain related <seealso cref="T:HslCommunication.LogNet.LogStatistics"/> objects, and then perform many operations
            </summary>
            <param name="key">关键字</param>
            <returns>日志对象，如果当前的日志对象不存在，就返回为NULL</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.AddLogStatistics(System.String,HslCommunication.LogNet.LogStatistics)">
            <summary>
            手动新增一个<seealso cref="T:HslCommunication.LogNet.LogStatistics"/>对象，需要指定相关的关键字<br />
            Manually add a <seealso cref="T:HslCommunication.LogNet.LogStatistics"/> object, you need to specify related keywords
            </summary>
            <param name="key">关键字信息</param>
            <param name="logStatistics">日志统计对象</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.RemoveLogStatistics(System.String)">
            <summary>
            移除一个<seealso cref="T:HslCommunication.LogNet.LogStatistics"/>对象，需要指定相关的关键字，如果关键字本来就存在，返回 <c>True</c>, 如果不存在，返回 <c>False</c> <br />
            To remove a <seealso cref="T:HslCommunication.LogNet.LogStatistics"/> object, you need to specify the relevant keyword. If the keyword already exists, return <c>True</c>, if it does not exist, return <c>False</c >
            </summary>
            <param name="key">关键字信息</param>
            <returns>如果关键字本来就存在，返回 <c>True</c>, 如果不存在，返回 <c>False</c> </returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.StatisticsAdd(System.String,System.Int64)">
            <summary>
            新增一个统计信息，将会根据当前的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行新增数据 frequency 次<br />
            Adding a new statistical information will determine the position to insert the data according to the current time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, add data to the last number frequency times
            </summary>
            <param name="key">当前选择的关键字</param>
            <param name="frequency">新增的次数信息，默认为1</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.StatisticsAddByTime(System.String,System.Int64,System.DateTime)">
            <summary>
            新增一个统计信息，将会根据当前的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行新增数据 frequency 次<br />
            Adding a new statistical information will determine the position to insert the data according to the current time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, add data to the last number frequency times
            </summary>
            <param name="key">当前的关键字</param>
            <param name="frequency">新增的次数信息</param>
            <param name="time">新增的次数的时间</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.GetStatisticsSnapshot(System.String)">
            <summary>
            获取当前的统计信息的数据快照，这是数据的副本，修改了里面的值不影响<br />
            Get a data snapshot of the current statistics. This is a copy of the data. Modifying the value inside does not affect
            </summary>
            <param name="key">当前的关键字的信息</param>
            <returns>实际的统计数据信息</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.GetStatisticsSnapshotByTime(System.String,System.DateTime,System.DateTime)">
            <summary>
            根据指定的时间范围来获取统计的数据信息快照，包含起始时间，包含结束时间，这是数据的副本，修改了里面的值不影响<br />
            Get a snapshot of statistical data information according to the specified time range, including the start time, 
            also the end time. This is a copy of the data. Modifying the value inside does not affect
            </summary>
            <param name="key">当前的关键字信息</param>
            <param name="start">起始时间</param>
            <param name="finish">结束时间</param>
            <returns>指定实际范围内的数据副本</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.GetKeys">
            <summary>
            获取所有的关键字的数据信息<br />
            Get data information of all keywords
            </summary>
            <returns>字符串数组</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.SaveToFile(System.String)">
            <summary>
            将当前的统计信息及数据内容写入到指定的文件里面，需要指定文件的路径名称<br />
            Write the current statistical information and data content to the specified file, you need to specify the path name of the file
            </summary>
            <param name="fileName">文件的完整的路径名称</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogStatisticsDict.LoadFromFile(System.String)">
            <summary>
            从指定的文件加载对应的统计信息，通常是调用<see cref="M:HslCommunication.LogNet.LogStatisticsDict.SaveToFile(System.String)"/>方法存储的文件，如果文件不存在，将会跳过加载<br />
            Load the corresponding statistical information from the specified file, usually the file stored by calling the <see cref="M:HslCommunication.LogNet.LogStatisticsDict.SaveToFile(System.String)"/> method. 
            If the file does not exist, the loading will be skipped
            </summary>
            <param name="fileName">文件的完整的路径名称</param>
            <exception cref="T:System.Exception">当文件的模式和当前的模式设置不一样的时候，会引发异常</exception>
        </member>
        <member name="P:HslCommunication.LogNet.LogStatisticsDict.GenerateMode">
            <summary>
            获取当前的统计类信息时间统计规则<br />
            Get the current statistical information time statistics rule
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.LogStatisticsDict.ArrayLength">
            <summary>
            获取当前的统计类信息的数据总量<br />
            Get the total amount of current statistical information
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.LogStatisticsDict.LogStat">
            <summary>
            获取当前词典类自身的日志统计对象，统计所有的元素的统计信息<br />
            Get the log statistics object of the current dictionary class itself, and count the statistics of all elements
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.LogValueLimit">
            <summary>
            一个用于数值范围记录的类，可以按照时间进行分类统计，比如计算一个温度值的每天的开始值，结束值，最大值，最小值，平均值信息。详细见API文档信息。<br />
            A class used to record the value range, which can be classified according to time, such as calculating the start value, end value, 
            maximum value, minimum value, and average value of a temperature value. See the API documentation for details.
            </summary>
            <example>
            我们来举个例子：我们需要对一个温度数据进行分析，分析60天之内的最大值最小值等等信息
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogValueLimitSample.cs" region="Sample1" title="简单的记录调用次数" />
            因为这个数据是保存在内存里的，程序重新运行就丢失了，如果希望让这个数据一直在程序的话，在软件退出的时候需要存储文件，在软件启动的时候，加载文件数据
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogValueLimitSample.cs" region="Sample2" title="存储与加载" />
            </example>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimit.#ctor(HslCommunication.LogNet.GenerateMode,System.Int32)">
            <inheritdoc cref="M:HslCommunication.LogNet.LogStatisticsBase`1.#ctor(HslCommunication.LogNet.GenerateMode,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimit.AnalysisNewValue(System.Double)">
            <summary>
            新增一个数据用于分析，将会根据当前的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行数据更新，包括最大值，最小值，平均值。<br />
            Add a new data for analysis, and will determine the position to insert the data according to the current time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, data update for the last number, including maximum, minimum, and average.
            </summary>
            <param name="value">当前的新的数据值</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimit.AnalysisNewValueByTime(System.Double,System.DateTime)">
            <summary>
            新增一个数据用于分析，将会指定的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行数据更新，包括最大值，最小值，平均值。<br />
            dd a new data for analysis, and will determine the position to insert the data according to the specified time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, data update for the last number, including maximum, minimum, and average.
            </summary>
            <param name="value">当前的新的数据值</param>
            <param name="time">指定的时间信息</param>
        </member>
        <member name="P:HslCommunication.LogNet.LogValueLimit.ValueCount">
            <summary>
            当前设置数据的总的数量<br />
            The total amount of data currently set
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimit.SaveToBinary">
            <summary>
            将当前所有的数据都写入到二进制的内存里去，可以用来写入文件或是网络发送。<br />
            Write all current data into binary memory, which can be used to write files or send over the network.
            </summary>
            <returns>二进制的byte数组</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimit.SaveToFile(System.String)">
            <summary>
            将当前的统计信息及数据内容写入到指定的文件里面，需要指定文件的路径名称<br />
            Write the current statistical information and data content to the specified file, you need to specify the path name of the file
            </summary>
            <param name="fileName">文件的完整的路径名称</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimit.LoadFromBinary(System.Byte[])">
            <summary>
            从二进制的数据内容加载，会对数据的合法性进行检查，如果数据不匹配，会报异常<br />
            Loading from the binary data content will check the validity of the data. If the data does not match, an exception will be reported
            </summary>
            <param name="buffer">等待加载的二进制数据</param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimit.LoadFromFile(System.String)">
            <summary>
            从指定的文件加载对应的统计信息，通常是调用<see cref="M:HslCommunication.LogNet.LogValueLimit.SaveToFile(System.String)"/>方法存储的文件，如果文件不存在，将会跳过加载<br />
            Load the corresponding statistical information from the specified file, usually the file stored by calling the <see cref="M:HslCommunication.LogNet.LogValueLimit.SaveToFile(System.String)"/> method. 
            If the file does not exist, the loading will be skipped
            </summary>
            <param name="fileName">文件的完整的路径名称</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimit.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.LogNet.LogValueLimitDict">
            <summary>
            <seealso cref="T:HslCommunication.LogNet.LogValueLimit"/> 的词典集合类，用于多个数据的统计信息，例如可以统计多个温度变量的最大值，最小值，平均值<br />
            <seealso cref="T:HslCommunication.LogNet.LogValueLimit"/> The dictionary collection class, used for statistical information of multiple data, 
            for example, it can count the maximum, minimum, and average values of multiple temperature variables
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.#ctor(HslCommunication.LogNet.GenerateMode,System.Int32)">
            <summary>
            根据指定的存储模式，数据个数来实例化一个对象<br />
            According to the specified storage mode, the number of data to instantiate an object
            </summary>
            <param name="generateMode">当前的数据存储模式</param>
            <param name="arrayLength">准备存储的数据总个数</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.GetLogValueLimit(System.String)">
            <summary>
            根据给定的关键字信息，获取相关的 <see cref="T:HslCommunication.LogNet.LogValueLimit"/> 对象，进而执行很多的操作<br />
            According to the given keyword information, obtain related <see cref="T:HslCommunication.LogNet.LogValueLimit"/> objects, and then perform many operations
            </summary>
            <param name="key">关键字</param>
            <returns>日志对象，如果当前的日志对象不存在，就返回为NULL</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.AddLogValueLimit(System.String,HslCommunication.LogNet.LogValueLimit)">
            <summary>
            手动新增一个 <see cref="T:HslCommunication.LogNet.LogValueLimit"/> 对象，需要指定相关的关键字<br />
            Manually add a <see cref="T:HslCommunication.LogNet.LogValueLimit"/> object, you need to specify related keywords
            </summary>
            <param name="key">关键字信息</param>
            <param name="logValueLimit">日志数据分析对象</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.RemoveLogValueLimit(System.String)">
            <summary>
            移除一个<seealso cref="T:HslCommunication.LogNet.LogValueLimit"/>对象，需要指定相关的关键字，如果关键字本来就存在，返回 <c>True</c>, 如果不存在，返回 <c>False</c> <br />
            To remove a <seealso cref="T:HslCommunication.LogNet.LogValueLimit"/> object, you need to specify the relevant keyword. If the keyword already exists, return <c>True</c>, if it does not exist, return <c>False</c >
            </summary>
            <param name="key">关键字信息</param>
            <returns>如果关键字本来就存在，返回 <c>True</c>, 如果不存在，返回 <c>False</c> </returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.AnalysisNewValue(System.String,System.Double)">
            <summary>
            新增一个数据用于分析，将会根据当前的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行数据更新，包括最大值，最小值，平均值。<br />
            Add a new data for analysis, and will determine the position to insert the data according to the current time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, data update for the last number, including maximum, minimum, and average.
            </summary>
            <param name="key">当前的关键字</param>
            <param name="value">当前的新的数据值</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.AnalysisNewValueByTime(System.String,System.Double,System.DateTime)">
            <summary>
            新增一个数据用于分析，将会指定的时间来决定插入数据位置，如果数据位置发生了变化，则数据向左发送移动。如果没有移动或是移动完成后，最后一个数进行数据更新，包括最大值，最小值，平均值。<br />
            dd a new data for analysis, and will determine the position to insert the data according to the specified time. If the data position changes, 
            the data will be sent to the left. If there is no movement or after the movement is completed, data update for the last number, including maximum, minimum, and average.
            </summary>
            <param name="key">关键字信息</param>
            <param name="value">当前的新的数据值</param>
            <param name="time">指定的时间信息</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.GetStatisticsSnapshot(System.String)">
            <summary>
            获取当前的统计信息的数据快照，这是数据的副本，修改了里面的值不影响<br />
            Get a data snapshot of the current statistics. This is a copy of the data. Modifying the value inside does not affect
            </summary>
            <param name="key">当前的关键字的信息</param>
            <returns>实际的统计数据信息</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.GetStatisticsSnapshotByTime(System.String,System.DateTime,System.DateTime)">
            <summary>
            根据指定的时间范围来获取统计的数据信息快照，包含起始时间，包含结束时间，这是数据的副本，修改了里面的值不影响<br />
            Get a snapshot of statistical data information according to the specified time range, including the start time, 
            also the end time. This is a copy of the data. Modifying the value inside does not affect
            </summary>
            <param name="key">当前的关键字信息</param>
            <param name="start">起始时间</param>
            <param name="finish">结束时间</param>
            <returns>指定实际范围内的数据副本</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.GetKeys">
            <summary>
            获取所有的关键字的数据信息<br />
            Get data information of all keywords
            </summary>
            <returns>字符串数组</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.SaveToFile(System.String)">
            <summary>
            将当前的统计信息及数据内容写入到指定的文件里面，需要指定文件的路径名称<br />
            Write the current statistical information and data content to the specified file, you need to specify the path name of the file
            </summary>
            <param name="fileName">文件的完整的路径名称</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogValueLimitDict.LoadFromFile(System.String)">
            <summary>
            从指定的文件加载对应的统计信息，通常是调用<see cref="M:HslCommunication.LogNet.LogValueLimitDict.SaveToFile(System.String)"/>方法存储的文件，如果文件不存在，将会跳过加载<br />
            Load the corresponding statistical information from the specified file, usually the file stored by calling the <see cref="M:HslCommunication.LogNet.LogValueLimitDict.SaveToFile(System.String)"/> method. 
            If the file does not exist, the loading will be skipped
            </summary>
            <param name="fileName">文件的完整的路径名称</param>
            <exception cref="T:System.Exception">当文件的模式和当前的模式设置不一样的时候，会引发异常</exception>
        </member>
        <member name="P:HslCommunication.LogNet.LogValueLimitDict.GenerateMode">
            <summary>
            获取当前的统计类信息时间统计规则<br />
            Get the current statistical information time statistics rule
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.LogValueLimitDict.ArrayLength">
            <summary>
            获取当前的统计类信息的数据总量<br />
            Get the total amount of current statistical information
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.LogValueLimitDict.LogStat">
            <summary>
            获取当前词典类自身的日志统计对象，统计所有的元素的数据分析次数<br />
            Get the log statistics object of the current dictionary class itself, count the data analysis times of all elements
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.FormLogNetView">
            <summary>
            日志查看器的窗口类，用于分析统计日志数据
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.FormLogNetView.#ctor">
            <summary>
            实例化一个日志查看器的窗口
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.FormLogNetView.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.FormLogNetView.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.LogNet.FormLogNetView.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetAnalysisControl">
            <summary>
            一个用于日志分析的控件
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.#ctor">
            <summary>
            实例化一个控件信息
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.SetLogNetSource(System.String)">
            <summary>
            设置日志的数据源
            </summary>
            <param name="logSource">直接从日志文件中读到的数据或是来自网络的数据</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.FilterLogSource(System.String)">
            <summary>
            从现有的日志中筛选数据
            </summary>
            <param name="degree"></param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.AnalysisLogSource(System.DateTime,System.DateTime,System.String)">
            <summary>
            底层的数据分析筛选
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="degree"></param>
        </member>
        <member name="F:HslCommunication.LogNet.LogNetAnalysisControl.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.ModBus.IModbus">
            <summary>
            Modbus设备的接口，用来表示Modbus相关的设备对象，<see cref="T:HslCommunication.ModBus.ModbusTcpNet"/>, <see cref="T:HslCommunication.ModBus.ModbusRtu"/>,
            <see cref="T:HslCommunication.ModBus.ModbusAscii"/>,<see cref="T:HslCommunication.ModBus.ModbusRtuOverTcp"/>,<see cref="T:HslCommunication.ModBus.ModbusUdpNet"/>均实现了该接口信息<br />
            Modbus device interface, used to represent Modbus-related device objects, <see cref="T:HslCommunication.ModBus.ModbusTcpNet"/>, 
            <see cref="T:HslCommunication.ModBus.ModbusRtu"/>,<see cref="T:HslCommunication.ModBus.ModbusAscii"/>,<see cref="T:HslCommunication.ModBus.ModbusRtuOverTcp"/>,<see cref="T:HslCommunication.ModBus.ModbusUdpNet"/> all implement the interface information
            </summary>
        </member>
        <member name="P:HslCommunication.ModBus.IModbus.AddressStartWithZero">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero"/>
        </member>
        <member name="P:HslCommunication.ModBus.IModbus.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="P:HslCommunication.ModBus.IModbus.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.IModbus.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="P:HslCommunication.ModBus.IModbus.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="M:HslCommunication.ModBus.IModbus.TranslateToModbusAddress(System.String,System.Byte)">
            <summary>
            将当前的地址信息转换成Modbus格式的地址，如果转换失败，返回失败的消息。默认不进行任何的转换。<br />
            Convert the current address information into a Modbus format address. If the conversion fails, a failure message will be returned. No conversion is performed by default.
            </summary>
            <param name="address">传入的地址</param>
            <param name="modbusCode">Modbus的功能码</param>
            <returns>转换之后Modbus的地址</returns>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusAscii">
            <summary>
            Modbus-Ascii通讯协议的类库，基于rtu类库完善过来，支持标准的功能码，也支持扩展的功能码实现，地址采用富文本的形式，详细见备注说明<br />
            The client communication class of Modbus-Ascii protocol is convenient for data interaction with the server. It supports standard function codes and also supports extended function codes. 
            The address is in rich text. For details, see the remarks.
            </summary>
            <remarks>
            本客户端支持的标准的modbus协议，Modbus-Tcp及Modbus-Udp内置的消息号会进行自增，地址支持富文本格式，具体参考示例代码。<br />
            读取线圈，输入线圈，寄存器，输入寄存器的方法中的读取长度对商业授权用户不限制，内部自动切割读取，结果合并。
            </remarks>
            <example>
            基本的用法请参照下面的代码示例，初始化部分的代码省略
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="Example" title="Modbus示例" />
            复杂的读取数据的代码示例如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="ReadExample" title="read示例" />
            写入数据的代码如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="WriteExample" title="write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.#ctor">
            <summary>
            实例化一个Modbus-ascii协议的客户端对象<br />
            Instantiate a client object of the Modbus-ascii protocol
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.#ctor(System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.#ctor(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusHelper">
            <summary>
            Modbus协议相关辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.Read(HslCommunication.ModBus.IModbus,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.ReadAsync(HslCommunication.ModBus.IModbus,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusHelper.Read(HslCommunication.ModBus.IModbus,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.WriteAsync(HslCommunication.ModBus.IModbus,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.WriteAsync(HslCommunication.ModBus.IModbus,System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.WriteAsync(HslCommunication.ModBus.IModbus,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.WriteMask(HslCommunication.ModBus.IModbus,System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.WriteMaskAsync(HslCommunication.ModBus.IModbus,System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusHelper.WriteMask(HslCommunication.ModBus.IModbus,System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.WriteAsync(HslCommunication.ModBus.IModbus,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.Boolean[])" />
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusHelper.WriteAsync(HslCommunication.ModBus.IModbus,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusHelper.Write(HslCommunication.ModBus.IModbus,System.String,System.Boolean)"/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusInfo">
            <summary>
            Modbus协议相关的一些信息，包括功能码定义，报文的生成的定义等等信息<br />
            Some information related to Modbus protocol, including function code definition, definition of message generation, etc.
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.ReadCoil">
            <summary>
            读取线圈
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.ReadDiscrete">
            <summary>
            读取离散量
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.ReadRegister">
            <summary>
            读取寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.ReadInputRegister">
            <summary>
            读取输入寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteOneCoil">
            <summary>
            写单个线圈
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteOneRegister">
            <summary>
            写单个寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteCoil">
            <summary>
            写多个线圈
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteRegister">
            <summary>
            写多个寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteMaskRegister">
            <summary>
            使用掩码的方式写入寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.FunctionCodeNotSupport">
            <summary>
            不支持该功能码
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.FunctionCodeOverBound">
            <summary>
            该地址越界
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.FunctionCodeQuantityOver">
            <summary>
            读取长度超过最大值
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.FunctionCodeReadWriteException">
            <summary>
            读写异常
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildReadModbusCommand(System.String,System.UInt16,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus读取数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码应该根据bool或是字来区分<br />
            To construct the core message of Modbus reading data, you need to specify the address, length, station number, 
            whether the starting address is 0, and the default function code should be distinguished according to bool or word
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="length">读取的数据长度</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildReadModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            构建Modbus读取数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码应该根据bool或是字来区分<br />
            To construct the core message of Modbus reading data, you need to specify the address, length, station number, 
            whether the starting address is 0, and the default function code should be distinguished according to bool or word
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="length">读取的数据长度</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteBoolModbusCommand(System.String,System.Boolean[],System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入bool数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message that Modbus writes to bool data, you need to specify the address, length,
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="values">bool数组的信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteBoolModbusCommand(System.String,System.Boolean,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入bool数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message that Modbus writes to bool data, you need to specify the address, length, station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="value">bool的信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteBoolModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.Boolean[])">
            <summary>
            构建Modbus写入bool数组的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message that Modbus writes to the bool array, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="values">bool数组的信息</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteBoolModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.Boolean)">
            <summary>
            构建Modbus写入bool数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message that Modbus writes to bool data, you need to specify the address, length, station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="value">bool数据的信息</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteWordModbusCommand(System.String,System.Byte[],System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="values">bool数组的信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteWordModbusCommand(System.String,System.Int16,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="value">short数据信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteWordModbusCommand(System.String,System.UInt16,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="value">bool数组的信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteMaskModbusCommand(System.String,System.UInt16,System.UInt16,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入掩码的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the Modbus write mask core message, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="andMask">进行与操作的掩码信息</param>
            <param name="orMask">进行或操作的掩码信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteWordModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.Byte[])">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="values">bool数组的信息</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteMaskModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.UInt16,System.UInt16)">
            <summary>
            构建Modbus写入掩码数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing mask data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="andMask">等待进行与操作的掩码</param>
            <param name="orMask">等待进行或操作的掩码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteOneRegisterModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.Int16)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="value">short的值</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteOneRegisterModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="value">ushort的值</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.ExtractActualData(System.Byte[])">
            <summary>
            从返回的modbus的书内容中，提取出真实的数据，适用于写入和读取操作<br />
            Extract real data from the content of the returned modbus book, suitable for writing and reading operations
            </summary>
            <param name="response">返回的核心modbus报文信息</param>
            <returns>结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.PackCommandToTcp(System.Byte[],System.UInt16)">
            <summary>
            将modbus指令打包成Modbus-Tcp指令，需要指定ID信息来添加6个字节的报文头<br />
            Pack the Modbus command into Modbus-Tcp command, you need to specify the ID information to add a 6-byte message header
            </summary>
            <param name="modbus">Modbus核心指令</param>
            <param name="id">消息的序号</param>
            <returns>Modbus-Tcp指令</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.ExplodeTcpCommandToCore(System.Byte[])">
            <summary>
            将modbus-tcp的报文数据重新还原成modbus指令，移除6个字节的报文头数据<br />
            Re-modify the message data of modbus-tcp into the modbus command, remove the 6-byte message header data
            </summary>
            <param name="modbusTcp">modbus-tcp的报文</param>
            <returns>modbus数据报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.ExplodeRtuCommandToCore(System.Byte[])">
            <summary>
            将modbus-rtu的数据重新还原成modbus数据，移除CRC校验的内容<br />
            Restore the data of modbus-rtu to modbus data again, remove the content of CRC check
            </summary>
            <param name="modbusRtu">modbus-rtu的报文</param>
            <returns>modbus数据报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.PackCommandToRtu(System.Byte[])">
            <summary>
            将modbus指令打包成Modbus-Rtu指令，在报文的末尾添加CRC16的校验码<br />
            Pack the modbus instruction into Modbus-Rtu instruction, add CRC16 check code at the end of the message
            </summary>
            <param name="modbus">Modbus指令</param>
            <returns>Modbus-Rtu指令</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.TransModbusCoreToAsciiPackCommand(System.Byte[])">
            <summary>
            将一个modbus核心的数据报文，转换成modbus-ascii的数据报文，增加LRC校验，增加首尾标记数据<br />
            Convert a Modbus core data message into a Modbus-ascii data message, add LRC check, and add head and tail tag data
            </summary>
            <param name="modbus">modbus-rtu的完整报文，携带相关的校验码</param>
            <returns>可以用于直接发送的modbus-ascii的报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.TransAsciiPackCommandToCore(System.Byte[])">
            <summary>
            将一个modbus-ascii的数据报文，转换成的modbus核心数据报文，移除首尾标记，移除LRC校验<br />
            Convert a Modbus-ascii data message into a Modbus core data message, remove the first and last tags, and remove the LRC check
            </summary>
            <param name="modbusAscii">modbus-ascii的完整报文，携带相关的校验码</param>
            <returns>可以用于直接发送的modbus的报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.AnalysisAddress(System.String,System.Byte,System.Boolean,System.Byte)">
            <summary>
            分析Modbus协议的地址信息，该地址适应于tcp及rtu模式<br />
            Analysis of the address information of Modbus protocol, the address is adapted to tcp and rtu mode
            </summary>
            <param name="address">带格式的地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="defaultStation">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码信息</param>
            <returns>转换后的地址信息</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.GetDescriptionByErrorCode(System.Byte)">
            <summary>
            通过错误码来获取到对应的文本消息<br />
            Get the corresponding text message through the error code
            </summary>
            <param name="code">错误码</param>
            <returns>错误的文本描述</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.CheckRtuReceiveDataComplete(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Serial.SerialBase.CheckReceiveDataComplete(System.IO.MemoryStream)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.CheckServerRtuReceiveDataComplete(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Serial.SerialBase.CheckReceiveDataComplete(System.IO.MemoryStream)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.CheckAsciiReceiveDataComplete(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Serial.SerialBase.CheckReceiveDataComplete(System.IO.MemoryStream)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.CheckAsciiReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Serial.SerialBase.CheckReceiveDataComplete(System.IO.MemoryStream)"/>
        </member>
        <member name="T:HslCommunication.ModBus.ModBusMonitorAddress">
            <summary>
            服务器端提供的数据监视服务
            </summary>
        </member>
        <member name="P:HslCommunication.ModBus.ModBusMonitorAddress.Address">
            <summary>
            本次数据监视的地址
            </summary>
        </member>
        <member name="E:HslCommunication.ModBus.ModBusMonitorAddress.OnWrite">
            <summary>
            数据写入时触发的事件
            </summary>
        </member>
        <member name="E:HslCommunication.ModBus.ModBusMonitorAddress.OnChange">
            <summary>
            数据改变时触发的事件
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModBusMonitorAddress.SetValue(System.Int16)">
            <summary>
            强制设置触发事件
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModBusMonitorAddress.SetChangeValue(System.Int16,System.Int16)">
            <summary>
            强制设置触发值变更事件
            </summary>
            <param name="before">变更前的值</param>
            <param name="after">变更后的值</param>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusRtu">
            <summary>
            Modbus-Rtu通讯协议的类库，多项式码0xA001，支持标准的功能码，也支持扩展的功能码实现，地址采用富文本的形式，详细见备注说明<br />
            Modbus-Rtu communication protocol class library, polynomial code 0xA001, supports standard function codes, 
            and also supports extended function code implementation. The address is in rich text. For details, see the remark
            </summary>
            <remarks>
            本客户端支持的标准的modbus协议，Modbus-Tcp及Modbus-Udp内置的消息号会进行自增，地址支持富文本格式，具体参考示例代码。<br />
            读取线圈，输入线圈，寄存器，输入寄存器的方法中的读取长度对商业授权用户不限制，内部自动切割读取，结果合并。
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusTcpNet" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.#ctor">
            <summary>
            实例化一个Modbus-Rtu协议的客户端对象<br />
            Instantiate a client object of the Modbus-Rtu protocol
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.#ctor(System.Byte)">
            <summary>
            指定客户端自己的站号来初始化<br />
            Specify the client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtu.AddressStartWithZero">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtu.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtu.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtu.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.IModbus.TranslateToModbusAddress(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadFromCoreServer(System.Byte[])">
            <summary>
            将Modbus报文数据发送到当前的通道中，并从通道中接收Modbus的报文，通道将根据当前连接自动获取，本方法是线程安全的。<br />
            Send Modbus message data to the current channel, and receive Modbus messages from the channel. The channel will automatically obtain it according to the current connection. This method is thread-safe.
            </summary>
            <param name="send">发送的完整的报文信息</param>
            <returns>接收到的Modbus报文信息</returns>
            <remarks>
            需要注意的是，本方法的发送和接收都只需要输入Modbus核心报文，例如读取寄存器0的字数据 01 03 00 00 00 01，最后面两个字节的CRC是自动添加的，收到的数据也是只有modbus核心报文，例如：01 03 02 00 00 , 已经成功校验CRC校验并移除了，所以在解析的时候需要注意。<br />
            It should be noted that the sending and receiving of this method only need to input Modbus core messages, for example, read the word data 01 03 00 00 00 01 of register 0, the last two bytes of CRC are automatically added, 
            and received The data is also only modbus core messages, for example: 01 03 02 00 00, CRC has been successfully checked and removed, so you need to pay attention when parsing.
            </remarks>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadDiscrete(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadDiscrete(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteMask(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Int16)"/>/param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.UInt16)"/>/param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadCoilAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadCoilAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadDiscreteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.ReadDiscrete(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadDiscreteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.ReadDiscrete(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteOneRegisterAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteOneRegisterAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteMaskAsync(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusRtuOverTcp">
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusRtu"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.#ctor">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.#ctor"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.#ctor(System.String,System.Int32,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtuOverTcp.AddressStartWithZero">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtuOverTcp.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtuOverTcp.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtuOverTcp.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.IModbus.TranslateToModbusAddress(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadDiscrete(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadDiscrete(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteMask(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteOneRegister(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteOneRegister(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadCoilAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoilAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadCoilAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoilAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadDiscreteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscreteAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadDiscreteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscreteAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteOneRegisterAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegisterAsync(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteOneRegisterAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegisterAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteMaskAsync(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBoolAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusTcpNet">
            <summary>
            Modbus-Tcp协议的客户端通讯类，方便的和服务器进行数据交互，支持标准的功能码，也支持扩展的功能码实现，地址采用富文本的形式，详细见API文档说明<br />
            The client communication class of Modbus-Tcp protocol is convenient for data interaction with the server. It supports standard function codes and also supports extended function codes. 
            The address is in rich text. For details, see the remarks.
            </summary>
            <remarks>
            本客户端支持的标准的modbus协议，Modbus-Tcp及Modbus-Udp内置的消息号会进行自增，地址支持富文本格式，具体参考示例代码。<br />
            读取线圈，输入线圈，寄存器，输入寄存器的方法中的读取长度对商业授权用户不限制，内部自动切割读取，结果合并。
            </remarks>
            <example>
            本客户端支持的标准的modbus协议，Modbus-Tcp及Modbus-Udp内置的消息号会进行自增，比如我们想要控制消息号在0-1000之间自增，不能超过一千，可以写如下的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="Sample1" title="序号示例" />
            在标准的Modbus协议里面，客户端发送消息ID给服务器，服务器是需要复制返回客户端的，在HSL里会默认进行检查操作，如果想要忽略消息ID一致性的检查，可以编写如下的方法。
            
            <note type="important">
            地址共可以携带3个信息，最完整的表示方式"s=2;x=3;100"，对应的modbus报文是 02 03 00 64 00 01 的前四个字节，站号，功能码，起始地址，下面举例
            </note>
            当读写int, uint, float, double, long, ulong类型的时候，支持动态指定数据格式，也就是 DataFormat 信息，本部分内容为商业授权用户专有，感谢支持。<br />
            ReadInt32("format=BADC;100") 指示使用BADC的格式来解析byte数组，从而获得int数据，同时支持和站号信息叠加，例如：ReadInt32("format=BADC;s=2;100")
            <list type="definition">
            <item>
                <term>读取线圈</term>
                <description>ReadCoil("100")表示读取线圈100的值，ReadCoil("s=2;100")表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
                <term>读取离散输入</term>
                <description>ReadDiscrete("100")表示读取离散输入100的值，ReadDiscrete("s=2;100")表示读取站号为2，离散地址为100的值</description>
            </item>
            <item>
                <term>读取寄存器</term>
                <description>ReadInt16("100")表示读取寄存器100的值，ReadInt16("s=2;100")表示读取站号为2，寄存器100的值</description>
            </item>
            <item>
                <term>读取输入寄存器</term>
                <description>ReadInt16("x=4;100")表示读取输入寄存器100的值，ReadInt16("s=2;x=4;100")表示读取站号为2，输入寄存器100的值</description>
            </item>
            <item>
                <term>读取寄存器的位</term>
                <description>ReadBool("100.0")表示读取寄存器100第0位的值，ReadBool("s=2;100.0")表示读取站号为2，寄存器100第0位的值，支持读连续的多个位</description>
            </item>
            <item>
                <term>读取输入寄存器的位</term>
                <description>ReadBool("x=4;100.0")表示读取输入寄存器100第0位的值，ReadBool("s=2;x=4;100.0")表示读取站号为2，输入寄存器100第0位的值，支持读连续的多个位</description>
            </item>
            </list>
            对于写入来说也是一致的
            <list type="definition">
            <item>
                <term>写入线圈</term>
                <description>WriteCoil("100",true)表示读取线圈100的值，WriteCoil("s=2;100",true)表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
                <term>写入寄存器</term>
                <description>Write("100",(short)123)表示写寄存器100的值123，Write("s=2;100",(short)123)表示写入站号为2，寄存器100的值123</description>
            </item>
            </list>
            特殊说明部分：
             <list type="definition">
            <item>
                <term>01功能码</term>
                <description>ReadBool("100")</description>
            </item>
            <item>
                <term>02功能码</term>
                <description>ReadBool("x=2;100")</description>
            </item>
            <item>
                <term>03功能码</term>
                <description>Read("100")</description>
            </item>
            <item>
                <term>04功能码</term>
                <description>Read("x=4;100")</description>
            </item>
            <item>
                <term>05功能码</term>
                <description>Write("100", True)</description>
            </item>
            <item>
                <term>06功能码</term>
                <description>Write("100", (short)100);Write("100", (ushort)100)</description>
            </item>
            <item>
                <term>0F功能码</term>
                <description>Write("100", new bool[]{True})   注意：这里和05功能码传递的参数类型不一样</description>
            </item>
            <item>
                <term>10功能码</term>
                <description>如果写一个short想用10功能码：Write("100", new short[]{100})</description>
            </item>
            <item>
                <term>16功能码</term>
                <description>Write("100.2", True) 当写入bool值的方法里，地址格式变为字地址时，就使用16功能码，通过掩码的方式来修改寄存器的某一位，
                需要Modbus服务器支持，对于不支持该功能码的写入无效。</description>
            </item>
            </list>
            基本的用法请参照下面的代码示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="Example1" title="Modbus示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.#ctor">
            <summary>
            实例化一个Modbus-Tcp协议的客户端对象<br />
            Instantiate a client object of the Modbus-Tcp protocol
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化<br />
            Specify the server address, port number, and client's own station number to initialize
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadFromCoreServer(System.Byte[])">
            <summary>
            将Modbus报文数据发送到当前的通道中，并从通道中接收Modbus的报文，通道将根据当前连接自动获取，本方法是线程安全的。<br />
            Send Modbus message data to the current channel, and receive Modbus messages from the channel. The channel will automatically obtain it according to the current connection. This method is thread-safe.
            </summary>
            <param name="send">发送的完整的报文信息</param>
            <returns>接收到的Modbus报文信息</returns>
            <remarks>
            需要注意的是，本方法的发送和接收都只需要输入Modbus核心报文，例如读取寄存器0的字数据 01 03 00 00 00 01，最前面的6个字节是自动添加的，收到的数据也是只有modbus核心报文，例如：01 03 02 00 00 , 所以在解析的时候需要注意。<br />
            It should be noted that the sending and receiving of this method only need to input the Modbus core message, for example, read the word data 01 03 00 00 00 01 of register 0, 
            the first 6 bytes are automatically added, and the received The data is also only modbus core messages, for example: 01 03 02 00 00, so you need to pay attention when parsing.
            </remarks>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadFromCoreServerAsync(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadFromCoreServer(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero">
            <summary>
            获取或设置起始的地址是否从0开始，默认为True<br />
            Gets or sets whether the starting address starts from 0. The default is True
            </summary>
            <remarks>
            <note type="warning">因为有些设备的起始地址是从1开始的，就要设置本属性为<c>False</c></note>
            </remarks>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.Station">
            <summary>
            获取或者重新修改服务器的默认站号信息，当然，你可以再读写的时候动态指定，参见备注<br />
            Get or modify the default station number information of the server. Of course, you can specify it dynamically when reading and writing, see note
            </summary>
            <remarks>
            当你调用 ReadCoil("100") 时，对应的站号就是本属性的值，当你调用 ReadCoil("s=2;100") 时，就忽略本属性的值，读写寄存器的时候同理
            </remarks>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat">
            <inheritdoc cref="P:HslCommunication.Core.ByteTransformBase.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse">
            <summary>
            字符串数据是否按照字来反转，默认为False<br />
            Whether the string data is reversed according to words. The default is False.
            </summary>
            <remarks>
            字符串按照2个字节的排列进行颠倒，根据实际情况进行设置
            </remarks>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.IsCheckMessageId">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.ModbusTcpMessage.IsCheckMessageId"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.MessageId">
            <summary>
            获取modbus协议自增的消息号，你可以自定义modbus的消息号的规则，详细参见<see cref="T:HslCommunication.ModBus.ModbusTcpNet"/>说明，也可以查找<see cref="T:HslCommunication.BasicFramework.SoftIncrementCount"/>说明。<br />
            Get the message number incremented by the modbus protocol. You can customize the rules of the message number of the modbus. For details, please refer to the description of <see cref = "T:HslCommunication.ModBus.ModbusTcpNet" />, or you can find the description of <see cref = "T:HslCommunication.BasicFramework.SoftIncrementCount" />
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.IModbus.TranslateToModbusAddress(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)">
            <summary>
            读取线圈，需要指定起始地址，如果富文本地址不指定，默认使用的功能码是 0x01<br />
            To read the coil, you need to specify the start address. If the rich text address is not specified, the default function code is 0x01.
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <returns>带有成功标志的bool对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)">
            <summary>
            批量的读取线圈，需要指定起始地址，读取长度，如果富文本地址不指定，默认使用的功能码是 0x01<br />
            For batch reading coils, you need to specify the start address and read length. If the rich text address is not specified, the default function code is 0x01.
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="length">读取长度</param>
            <returns>带有成功标志的bool数组对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)">
            <summary>
            读取输入线圈，需要指定起始地址，如果富文本地址不指定，默认使用的功能码是 0x02<br />
            To read the input coil, you need to specify the start address. If the rich text address is not specified, the default function code is 0x02.
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <returns>带有成功标志的bool对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String,System.UInt16)">
            <summary>
            批量的读取输入点，需要指定起始地址，读取长度，如果富文本地址不指定，默认使用的功能码是 0x02<br />
            To read input points in batches, you need to specify the start address and read length. If the rich text address is not specified, the default function code is 0x02
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="length">读取长度</param>
            <returns>带有成功标志的bool数组对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)">
            <summary>
            从Modbus服务器批量读取寄存器的信息，需要指定起始地址，读取长度，如果富文本地址不指定，默认使用的功能码是 0x03，如果需要使用04功能码，那么地址就写成 x=4;100<br />
            To read the register information from the Modbus server in batches, you need to specify the start address and read length. If the rich text address is not specified, 
            the default function code is 0x03. If you need to use the 04 function code, the address is written as x = 4; 100
            </summary>
            <param name="address">起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="length">读取的数量</param>
            <returns>带有成功标志的字节信息</returns>
            <remarks>
            富地址格式，支持携带站号信息，功能码信息，具体参照类的示例代码
            </remarks>
            <example>
            此处演示批量读取的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到Modbus的寄存器上去，需要指定起始地址和数据内容，如果富文本地址不指定，默认使用的功能码是 0x10<br />
            To write data to Modbus registers, you need to specify the start address and data content. If the rich text address is not specified, the default function code is 0x10
            </summary>
            <param name="address">起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="value">写入的数据，长度根据data的长度来指示</param>
            <returns>返回写入结果</returns>
            <remarks>
            富地址格式，支持携带站号信息，功能码信息，具体参照类的示例代码
            </remarks>
            <example>
            此处演示批量写入的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)">
            <summary>
            将数据写入到Modbus的单个寄存器上去，需要指定起始地址和数据值，如果富文本地址不指定，默认使用的功能码是 0x06<br />
            To write data to a single register of Modbus, you need to specify the start address and data value. If the rich text address is not specified, the default function code is 0x06.
            </summary>
            <param name="address">起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="value">写入的short数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)">
            <summary>
            将数据写入到Modbus的单个寄存器上去，需要指定起始地址和数据值，如果富文本地址不指定，默认使用的功能码是 0x06<br />
            To write data to a single register of Modbus, you need to specify the start address and data value. If the rich text address is not specified, the default function code is 0x06.
            </summary>
            <param name="address">起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="value">写入的ushort数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)">
            <summary>
            向设备写入掩码数据，使用0x16功能码，需要确认对方是否支持相关的操作，掩码数据的操作主要针对寄存器。<br />
            To write mask data to the server, using the 0x16 function code, you need to confirm whether the other party supports related operations. 
            The operation of mask data is mainly directed to the register.
            </summary>
            <param name="address">起始地址，起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="andMask">等待与操作的掩码数据</param>
            <param name="orMask">等待或操作的掩码数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoilAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoilAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscreteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscreteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteMaskAsync(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegisterAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegisterAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取线圈或是离散的数据信息，需要指定地址和长度，具体的结果取决于实现，如果富文本地址不指定，默认使用的功能码是 0x01<br />
            To read coils or discrete data in batches, you need to specify the address and length. The specific result depends on the implementation. If the rich text address is not specified, the default function code is 0x01.
            </summary>
            <param name="address">数据地址，比如 "1234" </param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的bool[]数组</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])">
            <summary>
            向线圈中写入bool数组，返回是否写入成功，如果富文本地址不指定，默认使用的功能码是 0x0F<br />
            Write the bool array to the coil, and return whether the writing is successful. If the rich text address is not specified, the default function code is 0x0F.
            </summary>
            <param name="address">要写入的数据地址，比如"1234"</param>
            <param name="values">要写入的实际数组</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)">
            <summary>
            向线圈中写入bool数值，返回是否写入成功，如果富文本地址不指定，默认使用的功能码是 0x05，
            如果你的地址为字地址，例如100.2，那么将使用0x16的功能码，通过掩码的方式来修改寄存器的某一位，需要Modbus服务器支持，否则写入无效。<br />
            Write bool value to the coil and return whether the writing is successful. If the rich text address is not specified, the default function code is 0x05.
            If your address is a word address, such as 100.2, then you will use the function code of 0x16 to modify a bit of the register through a mask. 
            It needs Modbus server support, otherwise the writing is invalid.
            </summary>
            <param name="address">要写入的数据地址，比如"12345"</param>
            <param name="value">要写入的实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusTcpServer">
            <summary>
            <b>[商业授权]</b> Modbus的虚拟服务器，同时支持Tcp和Rtu的机制，支持线圈，离散输入，寄存器和输入寄存器的读写操作，同时支持掩码写入功能，可以用来当做系统的数据交换池<br />
            <b>[Authorization]</b> Modbus virtual server supports Tcp and Rtu mechanisms at the same time, supports read and write operations of coils, discrete inputs, r
            egisters and input registers, and supports mask write function, which can be used as a system data exchange pool
            </summary>
            <remarks>
            可以基于本类实现一个功能复杂的modbus服务器，支持Modbus-Tcp，启动串口后，还支持Modbus-Rtu和Modbus-ASCII，会根据报文进行动态的适配。
            <list type="number">
            <item>线圈，功能码对应01，05，15</item>
            <item>离散输入，功能码对应02</item>
            <item>寄存器，功能码对应03，06，16</item>
            <item>输入寄存器，功能码对应04，输入寄存器在服务器端可以实现读写的操作</item>
            <item>掩码写入，功能码对应22，可以对字寄存器进行位操作</item>
            </list>
            </remarks>
            <example>
            读写的地址格式为富文本地址，具体请参照下面的示例代码。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\ModbusTcpServer.cs" region="ModbusTcpServerExample" title="ModbusTcpServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.#ctor">
            <summary>
            实例化一个Modbus Tcp及Rtu的服务器，支持数据读写操作
            </summary>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.UseModbusRtuOverTcp">
            <summary>
            获取或设置当前的TCP服务器是否使用modbus-rtu报文进行通信，如果设置为 <c>True</c>，那么客户端需要使用 <see cref="T:HslCommunication.ModBus.ModbusRtuOverTcp"/><br />
            Get or set whether the current TCP server uses modbus-rtu messages for communication.
            If it is set to <c>True</c>, then the client needs to use <see cref="T:HslCommunication.ModBus.ModbusRtuOverTcp"/>
            </summary>
            <remarks>
            需要注意的是，本属性设置为<c>False</c>时，客户端使用<see cref="T:HslCommunication.ModBus.ModbusTcpNet"/>，否则，使用<see cref="T:HslCommunication.ModBus.ModbusRtuOverTcp"/>，不能混合使用
            </remarks>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.RequestDelayTime">
            <summary>
            获取或设置两次请求直接的延时时间，单位毫秒，默认是0，不发生延时，设置为20的话，可以有效防止有客户端疯狂进行请求而导致服务器的CPU占用率上升。<br />
            Get or set the direct delay time of two requests, in milliseconds, the default is 0, no delay occurs, if it is set to 20, 
            it can effectively prevent the client from making crazy requests and causing the server's CPU usage to increase.
            </summary>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.StationCheck">
            <summary>
            获取或设置是否启用站号检查的功能，默认为 <c>True</c>, 进行站号检查的操作，站号一致才进行回复数据。<br />
            Get or set whether to enable the function of checking the station number, the default is <c>True</c>, 
            the operation of checking the station number is performed, and the data will be replied only when the station number is consistent.
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadCoil(System.String)">
            <summary>
            读取地址的线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadCoil(System.String,System.UInt16)">
            <summary>
            批量读取地址的线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="length">读取长度</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteCoil(System.String,System.Boolean)">
            <summary>
            写入线圈的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteCoil(System.String,System.Boolean[])">
            <summary>
            写入线圈数组的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadDiscrete(System.String)">
            <summary>
            读取地址的离散线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadDiscrete(System.String,System.UInt16)">
            <summary>
            批量读取地址的离散线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="length">读取长度</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteDiscrete(System.String,System.Boolean)">
            <summary>
            写入离散线圈的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteDiscrete(System.String,System.Boolean[])">
            <summary>
            写入离散线圈数组的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Byte,System.Byte)">
            <summary>
            写入寄存器数据，指定字节数据
            </summary>
            <param name="address">起始地址，示例："100"，如果是输入寄存器："x=4;100"</param>
            <param name="high">高位数据</param>
            <param name="low">地位数据</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CreateExceptionBack(System.Byte[],System.Byte)">
            <summary>
            创建特殊的功能标识，然后返回该信息<br />
            Create a special feature ID and return this information
            </summary>
            <param name="modbusCore">modbus核心报文</param>
            <param name="error">错误码</param>
            <returns>携带错误码的modbus报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CreateReadBack(System.Byte[],System.Byte[])">
            <summary>
            创建返回消息<br />
            Create return message
            </summary>
            <param name="modbusCore">modbus核心报文</param>
            <param name="content">返回的实际数据内容</param>
            <returns>携带内容的modbus报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CreateWriteBack(System.Byte[])">
            <summary>
            创建写入成功的反馈信号<br />
            Create feedback signal for successful write
            </summary>
            <param name="modbus">modbus核心报文</param>
            <returns>携带成功写入的信息</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.AddSubcription(HslCommunication.ModBus.ModBusMonitorAddress)">
            <summary>
            新增一个数据监视的任务，针对的是寄存器地址的数据<br />
            Added a data monitoring task for data at register addresses
            </summary>
            <param name="monitor">监视地址对象</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.RemoveSubcrption(HslCommunication.ModBus.ModBusMonitorAddress)">
            <summary>
            移除一个数据监视的任务<br />
            Remove a data monitoring task
            </summary>
            <param name="monitor">监视地址对象</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.OnRegisterBeforWrite(System.UInt16,System.Int16,System.Int16)">
            <summary>
            在数据变更后，进行触发是否产生订阅<br />
            Whether to generate a subscription after triggering data changes
            </summary>
            <param name="address">数据地址</param>
            <param name="before">修改之前的数</param>
            <param name="after">修改之后的数</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CheckModbusMessageLegal(System.Byte[])">
            <summary>
            检测当前的Modbus接收的指定是否是合法的<br />
            Check if the current Modbus datad designation is valid
            </summary>
            <param name="buffer">缓存数据</param>
            <returns>是否合格</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadFromModbusCore(System.Byte[])">
            <summary>
            Modbus核心数据交互方法，允许重写自己来实现，报文只剩下核心的Modbus信息，去除了MPAB报头信息<br />
            The Modbus core data interaction method allows you to rewrite it to achieve the message. 
            Only the core Modbus information is left in the message, and the MPAB header information is removed.
            </summary>
            <param name="modbusCore">核心的Modbus报文</param>
            <returns>进行数据交互之后的结果</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.GetSerialMessageLogText(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.DealWithSerialReceivedData(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusUdpNet">
            <summary>
            Modbus-Udp协议的客户端通讯类，方便的和服务器进行数据交互，支持标准的功能码，也支持扩展的功能码实现，地址采用富文本的形式，详细见备注说明<br />
            The client communication class of Modbus-Udp protocol is convenient for data interaction with the server. It supports standard function codes and also supports extended function codes. 
            The address is in rich text. For details, see the remarks.
            </summary>
            <remarks>
            本客户端支持的标准的modbus协议，Modbus-Tcp及Modbus-Udp内置的消息号会进行自增，地址支持富文本格式，具体参考示例代码。<br />
            读取线圈，输入线圈，寄存器，输入寄存器的方法中的读取长度对商业授权用户不限制，内部自动切割读取，结果合并。
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusTcpNet" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.#ctor">
            <summary>
            实例化一个MOdbus-Udp协议的客户端对象<br />
            Instantiate a client object of the MOdbus-Udp protocol
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.#ctor(System.String,System.Int32,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.AddressStartWithZero">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.MessageId">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.MessageId"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.IModbus.TranslateToModbusAddress(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadDiscrete(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadDiscrete(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusUdpNet.ReadDiscrete(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteMask(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteOneRegister(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteOneRegister(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadCoilAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoilAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadCoilAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoilAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadDiscreteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscreteAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadDiscreteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscreteAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Int16)"/>/param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.UInt16)"/>/param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteOneRegisterAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteOneRegisterAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteMaskAsync(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteAsync(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.MonitorAddress">
            <summary>
            监视使用的数据缓存
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.MonitorAddress.Address">
            <summary>
            地址
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.MonitorAddress.ValueOrigin">
            <summary>
            原有的值
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.MonitorAddress.ValueNew">
            <summary>
            新的值
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.IMqttSyncConnector">
            <summary>
            关于MqttSyncClient实现的接口<see cref="T:HslCommunication.Algorithms.ConnectPool.IConnector"/>，从而实现了数据连接池的操作信息
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.IMqttSyncConnector.#ctor(HslCommunication.MQTT.MqttConnectionOptions)">
            <summary>
            根据连接的MQTT参数，实例化一个默认的对象<br />
            According to the connected MQTT parameters, instantiate a default object
            </summary>
            <param name="options">连接的参数信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.IMqttSyncConnector.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.IMqttSyncConnector.IsConnectUsing">
            <inheritdoc cref="P:HslCommunication.Algorithms.ConnectPool.IConnector.IsConnectUsing"/>
        </member>
        <member name="P:HslCommunication.MQTT.IMqttSyncConnector.GuidToken">
            <inheritdoc cref="P:HslCommunication.Algorithms.ConnectPool.IConnector.GuidToken"/>
        </member>
        <member name="P:HslCommunication.MQTT.IMqttSyncConnector.LastUseTime">
            <inheritdoc cref="P:HslCommunication.Algorithms.ConnectPool.IConnector.LastUseTime"/>
        </member>
        <member name="P:HslCommunication.MQTT.IMqttSyncConnector.SyncClient">
            <summary>
            MQTT的连接对象
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.IMqttSyncConnector.Close">
            <inheritdoc cref="M:HslCommunication.Algorithms.ConnectPool.IConnector.Close"/>
        </member>
        <member name="M:HslCommunication.MQTT.IMqttSyncConnector.Open">
            <inheritdoc cref="M:HslCommunication.Algorithms.ConnectPool.IConnector.Open"/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttApplicationMessage">
            <summary>
            Mqtt的一次完整消息内容，包含主题，负载数据，消息等级。<br />
            Mqtt's complete message content, including subject, payload data, message level.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttApplicationMessage.QualityOfServiceLevel">
            <summary>
            这个字段表示应用消息分发的服务质量等级保证。分为，最多一次，最少一次，正好一次，只发不推送。<br />
            This field indicates the quality of service level guarantee for application message distribution. Divided into, at most once, at least once, exactly once
            </summary>
            <remarks>
            在实际的开发中的情况下，最多一次是最省性能的，正好一次是最消耗性能的，如果应有场景为推送实时的数据，那么，最多一次的性能是最高的
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttApplicationMessage.Topic">
            <summary>
            主题名（Topic Name）用于识别有效载荷数据应该被发布到哪一个信息通道。<br />
            The Topic Name is used to identify which information channel the payload data should be published to.
            </summary>
            <remarks>
            UTF-8编码字符串中的字符数据必须是按照Unicode规范 [Unicode] 定义的和在RFC3629 [RFC3629] 中重申的有效的UTF-8格式。特别需要指出的是，
            这些数据不能包含字符码在U+D800和U+DFFF之间的数据。如果服务端或客户端收到了一个包含无效UTF-8字符的控制报文，它必须关闭网络连接 [MQTT-1.5.3-1].
            
            PUBLISH报文中的主题名不能包含通配符 [MQTT-3.3.2-2]。
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttApplicationMessage.Payload">
            <summary>
            有效载荷包含将被发布的应用消息。数据的内容和格式是应用特定的。<br />
            The payload contains application messages to be published. The content and format of the data is application specific.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttApplicationMessage.Retain">
            <summary>
            该消息是否在服务器端进行保留，详细的说明参照文档的备注<br />
            Whether the message is retained on the server. For details, refer to the remarks of the document.
            </summary>
            <remarks>
            如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端必须存储这个应用消息和它的服务质量等级（QoS），
            以便它可以被分发给未来的主题名匹配的订阅者 [MQTT-3.3.1-5]。一个新的订阅建立时，对每个匹配的主题名
            ，如果存在最近保留的消息，它必须被发送给这个订阅者 [MQTT-3.3.1-6]。如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，
            它必须丢弃之前为那个主题保留的任何消息。它应该将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都可以选择丢弃它 — 如果这种情况发生了，
            那个主题将没有保留消息 [MQTT-3.3.1-7]
            </remarks>
        </member>
        <member name="M:HslCommunication.MQTT.MqttApplicationMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttClient">
            <summary>
            Mqtt协议的客户端实现，支持订阅消息，发布消息，详细的使用例子参考api文档<br />
            The client implementation of the Mqtt protocol supports subscription messages and publishing messages. For detailed usage examples, refer to the api documentation. 
            </summary>
            <remarks>
            这是一个MQTT的客户端实现，参照MQTT协议的3.1.1版本设计实现的。服务器可以是其他的组件提供的，其他的可以参考示例<br />
            This is an MQTT client implementation, designed and implemented with reference to version 3.1.1 of the MQTT protocol. The server can be provided by other components.
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test2" title="带用户名密码的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test3" title="连接示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test4" title="发布示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test5" title="订阅示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test8" title="网络重连示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.#ctor(HslCommunication.MQTT.MqttConnectionOptions)">
            <summary>
            实例化一个默认的对象
            </summary>
            <param name="options">配置信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.ConnectServer">
            <summary>
            连接服务器，如果连接失败，请稍候重试。<br />
            Connect to the server. If the connection fails, try again later.
            </summary>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.ConnectClose">
            <summary>
            关闭Mqtt服务器的连接。<br />
            Close the connection to the Mqtt server.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.ConnectServerAsync">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.ConnectServer"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.ConnectCloseAsync">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.ConnectClose"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.PublishMessage(HslCommunication.MQTT.MqttApplicationMessage)">
            <summary>
            发布一个MQTT协议的消息到服务器。该消息包含主题，负载数据，消息等级，是否保留信息。<br />
            Publish an MQTT protocol message to the server. The message contains the subject, payload data, message level, and whether to retain information.
            </summary>
            <param name="message">消息</param>
            <returns>发布结果</returns>
            <example>
            参照 <see cref="T:HslCommunication.MQTT.MqttClient"/> 的示例说明。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test4" title="发布示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.PublishMessageAsync(HslCommunication.MQTT.MqttApplicationMessage)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.PublishMessage(HslCommunication.MQTT.MqttApplicationMessage)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(System.String)">
            <summary>
            从服务器订阅一个或多个主题信息<br />
            Subscribe to one or more topics from the server
            </summary>
            <param name="topic">主题信息</param>
            <returns>订阅结果</returns>
            <example>
            参照 <see cref="T:HslCommunication.MQTT.MqttClient"/> 的示例说明。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test5" title="订阅示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(System.String[])">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(HslCommunication.MQTT.MqttSubscribeMessage)">
            <summary>
            向服务器订阅一个主题消息，可以指定订阅的主题数组，订阅的质量等级，还有消息标识符<br />
            To subscribe to a topic message from the server, you can specify the subscribed topic array, 
            the subscription quality level, and the message identifier
            </summary>
            <param name="subcribeMessage">订阅的消息本体</param>
            <returns>是否订阅成功</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.UnSubscribeMessage(System.String[])">
            <summary>
            取消订阅多个主题信息，取消之后，当前的订阅数据就不在接收到，除非服务器强制推送。<br />
            Unsubscribe from multiple topic information. After cancellation, the current subscription data will not be received unless the server forces it to push it.
            </summary>
            <param name="topics">主题信息</param>
            <returns>取消订阅结果</returns>
            <example>
            参照 <see cref="T:HslCommunication.MQTT.MqttClient"/> 的示例说明。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test7" title="订阅示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.UnSubscribeMessage(System.String)">
            <summary>
            取消订阅置顶的主题信息
            </summary>
            <param name="topic">主题信息</param>
            <returns>取消订阅结果</returns>
            <example>
            参照 <see cref="T:HslCommunication.MQTT.MqttClient"/> 的示例说明。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test7" title="订阅示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.SubscribeMessageAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.SubscribeMessageAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(System.String[])"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.UnSubscribeMessageAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.UnSubscribeMessage(System.String[])"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.UnSubscribeMessageAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.UnSubscribeMessage(System.String)"/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttClient.MqttMessageReceiveDelegate">
            <summary>
            当接收到Mqtt订阅的信息的时候触发<br />
            Triggered when receiving Mqtt subscription information
            </summary>
            <param name="client">收到消息时候的client实例对象</param>
            <param name="topic">主题信息</param>
            <param name="payload">负载数据</param>
        </member>
        <member name="E:HslCommunication.MQTT.MqttClient.OnMqttMessageReceived">
            <summary>
            当接收到Mqtt订阅的信息的时候触发
            </summary>
        </member>
        <member name="E:HslCommunication.MQTT.MqttClient.OnNetworkError">
            <summary>
            当网络发生异常的时候触发的事件，用户应该在事件里进行重连服务器
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttClient.OnClientConnectedDelegate">
            <summary>
            连接服务器成功的委托<br />
            Connection server successfully delegated
            </summary>
        </member>
        <member name="E:HslCommunication.MQTT.MqttClient.OnClientConnected">
            <summary>
            当客户端连接成功触发事件，就算是重新连接服务器后，也是会触发的<br />
            The event is triggered when the client is connected successfully, even after reconnecting to the server.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClient.ConnectionOptions">
            <summary>
            获取当前的连接配置参数信息<br />
            Get current connection configuration parameter information
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClient.UseTimerCheckDropped">
            <summary>
            获取或设置是否启动定时器去检测当前客户端是否超时掉线。默认为 <c>True</c><br />
            Get or set whether to start the timer to detect whether the current client timeout and disconnection. Default is <c>True</c>
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClient.IsConnected">
            <summary>
            获取或设置当前的服务器连接是否成功，定时获取本属性可用于实时更新连接状态信息。<br />
            Get or set whether the current server connection is successful or not. 
            This property can be obtained regularly and can be used to update the connection status information in real time.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClient.SubcribeTopics">
            <summary>
            获取当前的客户端对象已经订阅的所有的Topic信息<br />
            Get all Topic information that the current client object has subscribed to
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttClientApplicationMessage">
            <summary>
            来自客户端的一次消息的内容，当前类主要是在MQTT的服务端进行使用<br />
            The content of a message from the client. The current class is mainly used on the MQTT server
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClientApplicationMessage.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.ClientId">
            <summary>
            客户端的Id信息<br />
            Client Id information
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.UserName">
            <summary>
            当前的客户端的用户名<br />
            Username of the current client
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.IsCancelPublish">
            <summary>
            获取或设置当前的消息是否取消发布，默认False，也就是发布出去<br />
            Get or set whether the current message is unpublished, the default is False, which means it is published
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.CreateTime">
            <summary>
            当前消息的生成时间<br />
            The generation time of the current message
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.MsgID">
            <summary>
            当前消息的ID信息，在Qos大于0的时候，才是有值的
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttConnectionOptions">
            <summary>
            连接MQTT服务器的一些参数信息，适用<see cref="T:HslCommunication.MQTT.MqttClient"/>消息发布订阅客户端以及<see cref="T:HslCommunication.MQTT.MqttSyncClient"/>同步请求客户端。<br />
            Some parameter information for connecting to the MQTT server is applicable to the <see cref="T:HslCommunication.MQTT.MqttClient"/> message publishing and subscription client and the <see cref="T:HslCommunication.MQTT.MqttSyncClient"/> synchronization request client.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttConnectionOptions.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.IpAddress">
            <summary>
            Mqtt服务器的ip地址<br />
            IP address of Mqtt server
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.Port">
            <summary>
            端口号。默认1883<br />
            The port number. Default 1883
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.ClientId">
            <summary>
            客户端的id的标识<br />
            ID of the client
            </summary>
            <remarks>
            实际在传输的时候，采用的是UTF8编码的方式来实现。
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.ConnectTimeout">
            <summary>
            连接到服务器的超时时间，默认是5秒，单位是毫秒<br />
            The timeout period for connecting to the server, the default is 5 seconds, the unit is milliseconds
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.WillMessage">
            <summary>
            遗嘱消息，为空或是主题为空则表示不使用遗嘱，该遗嘱对于 <see cref="T:HslCommunication.MQTT.MqttSyncClient"/> 无效
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.Credentials">
            <summary>
            登录服务器的凭证，包含用户名和密码，可以为空<br />
            The credentials for logging in to the server, including the username and password, can be null
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.KeepAlivePeriod">
            <summary>
            设置的参数，最小单位为1s，当超过设置的时间间隔没有发送数据的时候，必须发送PINGREQ报文，否则服务器认定为掉线。<br />
            The minimum unit of the set parameter is 1s. When no data is sent beyond the set time interval, the PINGREQ message must be sent, otherwise the server considers it to be offline.
            </summary>
            <remarks>
            保持连接（Keep Alive）是一个以秒为单位的时间间隔，表示为一个16位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，
            两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其它的控制报文可以发送，
            客户端必须发送一个PINGREQ报文，详细参见 [MQTT-3.1.2-23]
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.KeepAliveSendInterval">
            <summary>
            获取或是设置心跳时间的发送间隔。默认30秒钟<br />
            Get or set the heartbeat time interval. 30 seconds by default
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.CleanSession">
            <summary>
            是否清理会话，如果清理会话（CleanSession）标志被设置为1，客户端和服务端必须丢弃之前的任何会话并开始一个新的会话。
            会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据不能被任何之后的会话重用 [MQTT-3.1.2-6]。默认为清理会话。<br />
            Whether to clean the session. If the CleanSession flag is set to 1, the client and server must discard any previous session and start a new session. 
            The session only lasts as long as the network connection. The state data associated with this session cannot be reused by any subsequent sessions [MQTT-3.1.2-6]. 
            The default is to clean up the session.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.UseRSAProvider">
            <summary>
            获取或设置当前的连接是否加密处理，防止第三方对注册报文进行抓包处理，从而分析出用户名和密码，只适用于基于HslCommunication创建的MQTT Server。<br />
            Get or set whether the current connection is encrypted or not, to prevent the third party from capturing the registration message, 
            so as to analyze the user name and password. It is only applicable to the MQTT Server created based on HslCommunication.
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttControlMessage">
            <summary>
            定义了Mqtt的相关的控制报文的信息
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FAILED">
            <summary>
            操作失败的信息返回
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.CONNECT">
            <summary>
            连接标识
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.CONNACK">
            <summary>
            连接返回的标识
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBLISH">
            <summary>
            发布消息
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBACK">
            <summary>
            QoS 1消息发布收到确认
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBREC">
            <summary>
            发布收到（保证交付第一步）
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBREL">
            <summary>
            发布释放（保证交付第二步）
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBCOMP">
            <summary>
            QoS 2消息发布完成（保证交互第三步）
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.SUBSCRIBE">
            <summary>
            客户端订阅请求
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.SUBACK">
            <summary>
            订阅请求报文确认
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.UNSUBSCRIBE">
            <summary>
            客户端取消订阅请求
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.UNSUBACK">
            <summary>
            取消订阅报文确认
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PINGREQ">
            <summary>
            心跳请求
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PINGRESP">
            <summary>
            心跳响应
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.DISCONNECT">
            <summary>
            客户端断开连接
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.REPORTPROGRESS">
            <summary>
            报告进度
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileNoSense">
            <summary>
            文件传输中没有意义的标记
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileDownload">
            <summary>
            下载文件的命令，一次只能下载一个文件
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileUpload">
            <summary>
            上传文件的命令，一次只能上传一个文件
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileDelete">
            <summary>
            删除文件的命令，一次可以删除多个文件
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileFolderDelete">
            <summary>
            删除目录的命令，目录下面的所有的文件都会被删除
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileFolderFiles">
            <summary>
            遍历指定目录下所有的文件信息
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileFolderPaths">
            <summary>
            遍历指定目录下所有的子目录信息
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileExists">
            <summary>
            文件是否存在
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileFolderInfo">
            <summary>
            指定目录的所有文件信息，包含文件数量，所有文件大小，最后的更新时间
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.FileFolderInfos">
            <summary>
            指定目录的所有子目录的文件统计信息，每个文件夹的文件数量，所有文件大小，最后更新时间
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttCredential">
            <summary>
            Mqtt协议的验证对象，包含用户名和密码<br />
            Authentication object of Mqtt protocol, including username and password
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttCredential.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttCredential.#ctor(System.String,System.String)">
            <summary>
            实例化指定的用户名和密码的对象<br />
            Instantiates an object with the specified username and password
            </summary>
            <param name="name">用户名</param>
            <param name="pwd">密码</param>
        </member>
        <member name="P:HslCommunication.MQTT.MqttCredential.UserName">
            <summary>
            获取或设置用户名<br />
            Get or set username
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttCredential.Password">
            <summary>
            获取或设置密码<br />
            Get or set password
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttCredential.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttHelper">
            <summary>
            Mqtt协议的辅助类，提供了一些协议相关的基础方法，方便客户端和服务器端一起调用。<br />
            The auxiliary class of the Mqtt protocol provides some protocol-related basic methods for the client and server to call together.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.CalculateLengthToMqttLength(System.Int32)">
            <summary>
            根据数据的总长度，计算出剩余的数据长度信息<br />
            According to the total length of the data, calculate the remaining data length information
            </summary>
            <param name="length">数据的总长度</param>
            <returns>计算结果</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildMqttCommand(System.Byte,System.Byte,System.Byte[],System.Byte[],HslCommunication.Core.Security.AesCryptography)">
            <summary>
            将一个数据打包成一个mqtt协议的内容<br />
            Pack a piece of data into a mqtt protocol
            </summary>
            <param name="control">控制码</param>
            <param name="flags">标记</param>
            <param name="variableHeader">可变头的字节内容</param>
            <param name="payLoad">负载数据</param>
            <param name="aesCryptography">AES数据加密对象</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildMqttCommand(System.Byte,System.Byte[],System.Byte[],HslCommunication.Core.Security.AesCryptography)">
            <summary>
            将一个数据打包成一个mqtt协议的内容<br />
            Pack a piece of data into a mqtt protocol
            </summary>
            <param name="head">控制码加标记码</param>
            <param name="variableHeader">可变头的字节内容</param>
            <param name="payLoad">负载数据</param>
            <param name="aesCryptography">AES数据加密对象</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildSegCommandByString(System.String)">
            <summary>
            将字符串打包成utf8编码，并且带有2个字节的表示长度的信息<br />
            Pack the string into utf8 encoding, and with 2 bytes of length information
            </summary>
            <param name="message">文本消息</param>
            <returns>打包之后的信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildSegCommandByString(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttHelper.BuildSegCommandByString(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.ExtraMsgFromBytes(System.Byte[],System.Int32@)">
            <summary>
            从MQTT的缓存信息里，提取文本信息<br />
            Extract text information from MQTT cache information
            </summary>
            <param name="buffer">Mqtt的报文</param>
            <param name="index">索引</param>
            <returns>值</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.ExtraSubscribeMsgFromBytes(System.Byte[],System.Int32@)">
            <summary>
            从MQTT的缓存信息里，提取文本信息<br />
            Extract text information from MQTT cache information
            </summary>
            <param name="buffer">Mqtt的报文</param>
            <param name="index">索引</param>
            <returns>值</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.ExtraIntFromBytes(System.Byte[],System.Int32@)">
            <summary>
            从MQTT的缓存信息里，提取长度信息<br />
            Extract length information from MQTT cache information
            </summary>
            <param name="buffer">Mqtt的报文</param>
            <param name="index">索引</param>
            <returns>值</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildIntBytes(System.Int32)">
            <summary>
            从MQTT的缓存信息里，提取长度信息<br />
            Extract length information from MQTT cache information
            </summary>
            <param name="data">数据信息</param>
            <returns>值</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildConnectMqttCommand(HslCommunication.MQTT.MqttConnectionOptions,System.String,System.Security.Cryptography.RSACryptoServiceProvider)">
            <summary>
            创建MQTT连接服务器的报文信息<br />
            Create MQTT connection server message information
            </summary>
            <param name="connectionOptions">连接配置</param>
            <param name="protocol">协议的内容</param>
            <param name="rsa">数据加密对象</param>
            <returns>返回是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.CheckConnectBack(System.Byte,System.Byte[])">
            <summary>
            根据服务器返回的信息判断当前的连接是否是可用的<br />
            According to the information returned by the server to determine whether the current connection is available
            </summary>
            <param name="code">功能码</param>
            <param name="data">数据内容</param>
            <returns>是否可用的连接</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.GetMqttCodeText(System.Int32)">
            <summary>
            获取当前的错误的描述信息<br />
            Get a description of the current error
            </summary>
            <param name="status">状态信息</param>
            <returns>描述信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildPublishMqttCommand(HslCommunication.MQTT.MqttPublishMessage,HslCommunication.Core.Security.AesCryptography)">
            <summary>
            创建Mqtt发送消息的命令<br />
            Create Mqtt command to send messages
            </summary>
            <param name="message">封装后的消息内容</param>
            <param name="aesCryptography">AES数据加密对象</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildPublishMqttCommand(System.String,System.Byte[],HslCommunication.Core.Security.AesCryptography)">
            <summary>
            创建Mqtt发送消息的命令<br />
            Create Mqtt command to send messages
            </summary>
            <param name="topic">主题消息内容</param>
            <param name="payload">数据负载</param>
            <param name="aesCryptography">AES数据加密对象</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildSubscribeMqttCommand(HslCommunication.MQTT.MqttSubscribeMessage)">
            <summary>
            创建Mqtt订阅消息的命令<br />
            Command to create Mqtt subscription message
            </summary>
            <param name="message">订阅的主题</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildUnSubscribeMqttCommand(HslCommunication.MQTT.MqttSubscribeMessage)">
            <summary>
            创建Mqtt取消订阅消息的命令<br />
            Create Mqtt unsubscribe message command
            </summary>
            <param name="message">订阅的主题</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.ExtraMqttReceiveData(System.Byte,System.Byte[],HslCommunication.Core.Security.AesCryptography)">
            <summary>
            解析从MQTT接受的客户端信息，解析成实际的Topic数据及Payload数据<br />
            Parse the client information received from MQTT and parse it into actual Topic data and Payload data
            </summary>
            <param name="mqttCode">MQTT的命令码</param>
            <param name="data">接收的MQTT原始的消息内容</param>
            <param name="aesCryptography">AES数据加密信息</param>
            <returns>解析的数据结果信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.HandleObjectMethod(HslCommunication.MQTT.MqttSession,HslCommunication.MQTT.MqttClientApplicationMessage,System.Object)">
            <summary>
            使用指定的对象来返回网络的API接口，前提是传入的数据为json参数，返回的数据为json数据，详细参照说明<br />
            Use the specified object to return the API interface of the network, 
            provided that the incoming data is json parameters and the returned data is json data, 
            please refer to the description for details
            </summary>
            <param name="mqttSession">当前的对话状态</param>
            <param name="message">当前传入的消息内容</param>
            <param name="obj">等待解析的api解析的对象</param>
            <returns>等待返回客户的结果</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.HandleObjectMethod(HslCommunication.MQTT.MqttSession,HslCommunication.MQTT.MqttClientApplicationMessage,HslCommunication.MQTT.MqttRpcApiInfo)">
            <summary>
            使用指定的对象来返回网络的API接口，前提是传入的数据为json参数，返回的数据为json数据，详细参照说明<br />
            Use the specified object to return the API interface of the network, 
            provided that the incoming data is json parameters and the returned data is json data, 
            please refer to the description for details
            </summary>
            <param name="mqttSession">当前的对话状态</param>
            <param name="message">当前传入的消息内容</param>
            <param name="apiInformation">当前已经解析好的Api内容对象</param>
            <returns>等待返回客户的结果</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.GetSyncServicesApiInformationFromObject(System.Object)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttHelper.GetSyncServicesApiInformationFromObject(System.String,System.Object,HslCommunication.Reflection.HslMqttPermissionAttribute)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.GetSyncServicesApiInformationFromObject(System.String,System.Object,HslCommunication.Reflection.HslMqttPermissionAttribute)">
            <summary>
            根据当前的对象定义的方法信息，获取到所有支持ApiTopic的方法列表信息，包含API名称，示例参数数据，描述信息。<br />
            According to the method information defined by the current object, the list information of all methods that support ApiTopic is obtained, 
            including the API name, sample parameter data, and description information.
            </summary>
            <param name="api">指定的ApiTopic的前缀，可以理解为控制器，如果为空，就不携带控制器。</param>
            <param name="obj">实际的等待解析的对象</param>
            <param name="permissionAttribute">默认的权限特性</param>
            <returns>返回所有API说明的列表，类型为<see cref="T:HslCommunication.MQTT.MqttRpcApiInfo"/></returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.GetMqttSyncServicesApiFromMethod(System.String,System.Reflection.MethodInfo,System.Object,HslCommunication.Reflection.HslMqttPermissionAttribute)">
            <summary>
            根据当前的方法的委托信息和类对象，生成<see cref="T:HslCommunication.MQTT.MqttRpcApiInfo"/>的API对象信息。
            </summary>
            <param name="api">Api头信息</param>
            <param name="method">方法的委托</param>
            <param name="obj">当前注册的API的源对象</param>
            <param name="permissionAttribute">默认的权限特性</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.GetMqttSyncServicesApiFromProperty(System.String,System.Reflection.PropertyInfo,System.Object,HslCommunication.Reflection.HslMqttPermissionAttribute)">
            <summary>
            根据当前的方法的委托信息和类对象，生成<see cref="T:HslCommunication.MQTT.MqttRpcApiInfo"/>的API对象信息。
            </summary>
            <param name="api">Api头信息</param>
            <param name="property">方法的委托</param>
            <param name="obj">当前注册的API的源对象</param>
            <param name="permissionAttribute">默认的权限特性</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.CheckMqttTopicWildcards(System.String,System.String)">
            <summary>
            判断当前服务器的实际的 topic 的主题，是否满足通配符格式的订阅主题 subTopic
            </summary>
            <param name="topic">服务器的实际的主题信息</param>
            <param name="subTopic">客户端订阅的基于通配符的格式</param>
            <returns>如果返回True, 说明当前匹配成功，应该发送订阅操作</returns>
        </member>
        <member name="T:HslCommunication.MQTT.MqttPublishMessage">
            <summary>
            Mqtt发送的消息封装对象，是对 <see cref="T:HslCommunication.MQTT.MqttApplicationMessage"/> 对象的封装，添加了序号，还有是否重发的信息<br />
            The message encapsulation object sent by Mqtt is an encapsulation of the <see cref="T:HslCommunication.MQTT.MqttApplicationMessage"/> object, with the serial number added, and whether to retransmit
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttPublishMessage.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttPublishMessage.IsSendFirstTime">
            <summary>
            是否第一次发送数据信息<br />
            Whether to send data information for the first time
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttPublishMessage.Identifier">
            <summary>
            当前的消息的标识符，当质量等级为0的时候，不需要重发以及考虑标识情况<br />
            The identifier of the current message, when the quality level is 0, do not need to retransmit and consider the identification situation
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttPublishMessage.Message">
            <summary>
            当前发布消息携带的mqtt的应用消息，包含主题，消息等级，负载。<br />
            The application message of mqtt carried in the current published message, including the subject, message level, and load.
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttQualityOfServiceLevel">
            <summary>
            Mqtt消息的质量等级<br />
            Mqtt message quality level
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttQualityOfServiceLevel.AtMostOnce">
            <summary>
            最多一次
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttQualityOfServiceLevel.AtLeastOnce">
            <summary>
            最少一次
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttQualityOfServiceLevel.ExactlyOnce">
            <summary>
            只有一次
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttQualityOfServiceLevel.OnlyTransfer">
            <summary>
            消息只发送到服务器而不触发发布订阅，该消息质量等级只对HSL的MQTT服务器有效<br />
            The message is only sent to the server without triggering publish and subscribe, the message quality level is only valid for the HSL MQTT server
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer">
            <summary>
            一个Mqtt的服务器类对象，本服务器支持发布订阅操作，支持从服务器强制推送数据，支持往指定的客户端推送，支持基于一问一答的远程过程调用（RPC）的数据交互，支持文件上传下载。根据这些功能从而定制化出满足各个场景的服务器，详细的使用说明可以参见代码api文档示例。<br />
            An Mqtt server class object. This server supports publish and subscribe operations, supports forced push data from the server, 
            supports push to designated clients, supports data interaction based on one-question-one-answer remote procedure calls (RPC), 
            and supports file upload and download . According to these functions, the server can be customized to meet various scenarios. 
            For detailed instructions, please refer to the code api document example.
            </summary>
            <remarks>
            本MQTT服务器功能丰富，可以同时实现，用户名密码验证，在线客户端的管理，数据订阅推送，单纯的数据收发，心跳检测，订阅通配符，同步数据访问，文件上传，下载，删除，遍历，详细参照下面的示例说明<br />
            通配符请查看<see cref="P:HslCommunication.MQTT.MqttServer.TopicWildcard"/>属性，规则参考：http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#appendix-a
            </remarks>
            <example>
            最简单的使用，就是实例化，启动服务即可
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample1" title="简单的实例化" />
            当然了，我们可以稍微的复杂一点，加一个功能，验证连接的客户端操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample2" title="增加验证" />
            我们可以对ClientID，用户名，密码进行验证，那么我们可以动态修改client id么？比如用户名密码验证成功后，client ID我想设置为权限等级。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample2_1" title="动态修改Client ID" />
            如果我想强制该客户端不能主动发布主题，可以这么操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample2_2" title="禁止发布主题" />
            你也可以对clientid进行过滤验证，只要结果返回不是0，就可以了。接下来我们实现一个功能，所有客户端的发布的消息在控制台打印出来,
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample3" title="打印所有发布" />
            捕获客户端刚刚上线的时候，方便我们进行一些额外的操作信息。下面的意思就是返回一个数据，将数据发送到指定的会话内容上去
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample4" title="客户端上线信息" />
            下面演示如何从服务器端发布数据信息，包括多种发布的方法，消息是否驻留，详细看说明即可
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample5" title="服务器发布" />
            下面演示如何支持同步网络访问，当客户端是同步网络访问时，协议内容会变成HUSL，即被视为同步客户端，进行相关的操作，主要进行远程调用RPC，以及查询MQTT的主题列表。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample6" title="同步访问支持" />
            如果需要查看在线信息，可以随时获取<see cref="P:HslCommunication.MQTT.MqttServer.OnlineCount"/>属性，如果需要查看报文信息，可以实例化日志，参考日志的说明即可。<br /><br />
            针对上面同步网络访问，虽然比较灵活，但是什么都要自己控制，无疑增加了代码的复杂度，举个例子，当你的topic分类很多的时候，已经客户端协议多个参数的时候，需要大量的手动解析的代码，
            影响代码美观，而且让代码更加的杂乱，除此之外，还有个巨大的麻烦，服务器提供了很多的topic处理程序（可以换个称呼，暴露的API接口），
            客户端没法清晰的浏览到，需要查找服务器代码才能知晓，而且服务器更新了接口，客户端有需要同步查看服务器的代码才行，以及做权限控制也很麻烦。<br />
            所以在Hsl里面的MQTT服务器，提供了注册API接口的功能，只需要一行注册代码，你的类的方法自动就会变为API解析，所有的参数都是同步解析的，如果你返回的是
            OperateResult&lt;T&gt;类型对象，还支持是否成功的结果报告，否则一律视为json字符串，返回给调用方。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample7" title="基于MQTT的RPC接口实现" />
            如果需要查看在线信息，可以随时获取<see cref="P:HslCommunication.MQTT.MqttServer.OnlineCount"/>属性，如果需要查看报文信息，可以实例化日志，参考日志的说明即可。<br /><br />
            最后介绍一下文件管理服务是如何启动的，在启动了文件管理服务之后，其匹配的客户端 <see cref="T:HslCommunication.MQTT.MqttSyncClient"/> 就可以上传下载，遍历文件了。
            而服务器端做的就是启用服务，如果你需要一些更加自由的权限控制，比如某个账户只能下载，不能其他操作，都是可以实现的。更加多的示例参考DEMO程序。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample8" title="基于MQTT的文件管理服务启动" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.#ctor(System.Security.Cryptography.RSACryptoServiceProvider)">
            <summary>
            实例化一个MQTT协议的服务器<br />
            Instantiate a MQTT protocol server
            </summary>
            <param name="providerServer">
            RSA秘钥对象，默认为空，表示使用随机生成的秘钥信息，如果需要自定义的RSA密钥，则需要实例化当前参数对象，具体通信的时候加密与否，取决于客户端连接的方式。<br />
            The RSA key object, which is empty by default, indicates that the randomly generated key information is used. If a custom RSA key is required, 
            the current parameter object needs to be instantiated. Whether the specific communication is encrypted or not depends on the way the client connects. .
            </param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.StartInitialization">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.RetainTopicPayload(System.String,System.Byte[])">
            <summary>
            将消息进行驻留到内存词典，方便进行其他的功能操作。
            </summary>
            <param name="topic">消息的主题</param>
            <param name="payload">当前的数据负载</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.RetainTopicPayload(System.String,HslCommunication.MQTT.MqttClientApplicationMessage)">
            <summary>
            将消息进行驻留到内存词典，方便进行其他的功能操作。
            </summary>
            <param name="topic">消息的主题</param>
            <param name="message">当前的Mqtt消息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.PublishTopicPayload(HslCommunication.MQTT.MqttSession,System.String,System.Byte[])">
            <summary>
            向指定的客户端发送主题及负载数据<br />
            Sends the topic and payload data to the specified client
            </summary>
            <param name="session">会话内容</param>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.PublishTopicPayload(System.String,System.Byte[],System.Boolean)">
            <summary>
            从服务器向订阅了指定的主题的客户端发送消息，默认消息不驻留<br />
            Sends a message from the server to a client that subscribes to the specified topic; the default message does not retain
            </summary>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
            <param name="retain">指示消息是否驻留</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.PublishAllClientTopicPayload(System.String,System.Byte[],System.Boolean)">
            <summary>
            向所有的客户端强制发送主题及负载数据，默认消息不驻留<br />
            Send subject and payload data to all clients compulsively, and the default message does not retain
            </summary>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
            <param name="retain">指示消息是否驻留</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.PublishTopicPayload(System.String,System.String,System.Byte[],System.Boolean)">
            <summary>
            向指定的客户端ID强制发送消息，默认消息不驻留<br />
            Forces a message to the specified client ID, and the default message does not retain
            </summary>
            <param name="clientId">指定的客户端ID信息</param>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
            <param name="retain">指示消息是否驻留</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ReportProgress(HslCommunication.MQTT.MqttSession,System.String,System.String)">
            <summary>
            向客户端发布一个进度报告的信息，仅用于同步网络的时候才支持进度报告，将进度及消息发送给客户端，比如你的服务器需要分成5个部分完成，可以按照百分比提示给客户端当前服务器发生了什么<br />
            Publish the information of a progress report to the client. The progress report is only supported when the network is synchronized. 
            The progress and the message are sent to the client. For example, your server needs to be divided into 5 parts to complete. 
            You can prompt the client according to the percentage. What happened to the server
            </summary>
            <param name="session">当前的网络会话</param>
            <param name="topic">回发客户端的关键数据，可以是百分比字符串，甚至是自定义的任意功能</param>
            <param name="payload">数据消息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ReportOperateResult(HslCommunication.MQTT.MqttSession,System.String)">
            <summary>
            向客户端发布一个失败的操作信息，仅用于同步网络的时候反馈失败结果，将错误的信息反馈回客户端，客户端就知道服务器发生了什么，为什么反馈失败。<br />
            Publish a failed operation information to the client, which is only used to feed back the failure result when synchronizing the network. 
            If the error information is fed back to the client, the client will know what happened to the server and why the feedback failed.
            </summary>
            <param name="session">当前的网络会话</param>
            <param name="message">错误的消息文本信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ReportOperateResult(HslCommunication.MQTT.MqttSession,HslCommunication.OperateResult{System.String})">
            <summary>
            向客户端发布一个操作结果的信息，仅用于同步网络的时候反馈操作结果，该操作可能成功，可能失败，客户端就知道服务器发生了什么，以及结果如何。<br />
            Publish an operation result information to the client, which is only used to feed back the operation result when synchronizing the network. 
            The operation may succeed or fail, and the client knows what happened to the server and the result.
            </summary>
            <param name="session">当前的网络会话</param>
            <param name="result">结果对象内容</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ReportObjectApiMethod(HslCommunication.MQTT.MqttSession,HslCommunication.MQTT.MqttClientApplicationMessage,System.Object)">
            <summary>
            使用指定的对象来返回网络的API接口，前提是传入的数据为json参数，返回的数据为 <c>OperateResult&lt;string&gt;</c> 数据，详细参照说明<br />
            Use the specified object to return the API interface of the network, 
            provided that the incoming data is json parameters and the returned data is <c>OperateResult&lt;string&gt;</c> data, 
            please refer to the description for details
            </summary>
            <param name="session">当前的会话内容</param>
            <param name="message">客户端发送的消息，其中的payload将会解析为一个json字符串，然后提取参数信息。</param>
            <param name="apiObject">当前的对象的内容信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetAllMqttRpcApiInfo">
            <summary>
            获取当前所有注册的RPC接口信息，将返回一个数据列表。<br />
            Get all currently registered RPC interface information, and a data list will be returned.
            </summary>
            <returns>信息列表</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.RegisterMqttRpcApi(System.String,System.Object,HslCommunication.Reflection.HslMqttPermissionAttribute)">
            <summary>
            注册一个RPC的服务接口，可以指定当前的控制器名称，以及提供RPC服务的原始对象，指定统一的权限控制。<br />
            Register an RPC service interface, you can specify the current controller name, 
            and the original object that provides the RPC service, Specify unified access control
            </summary>
            <param name="api">前置的接口信息，可以理解为MVC模式的控制器</param>
            <param name="obj">原始对象信息</param>
            <param name="permissionAttribute">统一的权限访问配置，将会覆盖单个方法的权限控制。</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.RegisterMqttRpcApi(System.String,System.Object)">
            <summary>
            注册一个RPC的服务接口，可以指定当前的控制器名称，以及提供RPC服务的原始对象<br />
            Register an RPC service interface, you can specify the current controller name, 
            and the original object that provides the RPC service
            </summary>
            <param name="api">前置的接口信息，可以理解为MVC模式的控制器</param>
            <param name="obj">原始对象信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.RegisterMqttRpcApi(System.Object)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttServer.RegisterMqttRpcApi(System.String,System.Object)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.UseFileServer(System.String)">
            <summary>
            启动文件服务功能，协议头为FILE，需要指定服务器存储的文件路径<br />
            Start the file service function, the protocol header is FILE, you need to specify the file path stored by the server
            </summary>
            <param name="filePath">文件的存储路径</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.CloseFileServer">
            <summary>
            关闭文件服务功能
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GroupFileContainerCount">
            <summary>
            获取当前的针对文件夹的文件管理容器的数量<br />
            Get the current number of file management containers for the folder
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetMonitorItemsSnapShoot">
            <summary>
            获取当前实时的文件上传下载的监控信息，操作的客户端信息，文件分类，文件名，上传或下载的速度等<br />
            Obtain current real-time file upload and download monitoring information, operating client information, file classification, file name, upload or download speed, etc.
            </summary>
            <returns>文件的监控信息</returns>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer.FileOperateVerificationDelegate">
            <summary>
            当客户端进行文件操作时，校验客户端合法性的委托，操作码具体查看<seealso cref="T:HslCommunication.MQTT.MqttControlMessage"/>的常量值<br />
            When client performing file operations, verify the legitimacy of the client, and check the constant value of <seealso cref="T:HslCommunication.MQTT.MqttControlMessage"/> for the operation code.
            </summary>
            <param name="session">会话状态</param>
            <param name="code">操作码</param>
            <param name="groups">分类信息</param>
            <param name="fileNames">文件名</param>
            <returns>是否成功</returns>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.FileOperateVerification">
            <summary>
            当客户端进行文件操作时，校验客户端合法性的事件，操作码具体查看<seealso cref="T:HslCommunication.MQTT.MqttControlMessage"/>的常量值<br />
            When client performing file operations, it is an event to verify the legitimacy of the client. For the operation code, check the constant value of <seealso cref="T:HslCommunication.MQTT.MqttControlMessage"/>
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ReceiveMqttFileAndUpdateGroupAsync(HslCommunication.MQTT.MqttSession,System.IO.FileInfo,System.Action{System.Int64,System.Int64})">
            <summary>
            从套接字接收文件并保存，更新文件列表
            </summary>
            <param name="session">当前的会话信息</param>
            <param name="info">保存的信息</param>
            <param name="reportProgress">当前的委托信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetRelativeFileName(System.String[],System.String)">
            <summary>
            返回相对路径的名称
            </summary>
            <param name="groups">文件的分类路径信息</param>
            <param name="fileName">文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ReturnAbsoluteFilePath(System.String[])">
            <summary>
            返回服务器的绝对路径，包含根目录的信息  [Root Dir][A][B][C]... 信息
            </summary>
            <param name="groups">文件的路径分类信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ReturnAbsoluteFileName(System.String[],System.String)">
            <summary>
            返回服务器的绝对路径，包含根目录的信息  [Root Dir][A][B][C]...[FileName] 信息
            </summary>
            <param name="groups">路径分类信息</param>
            <param name="fileName">文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.TransformFactFileName(System.String[],System.String)">
            <summary>
            根据文件的显示名称转化为真实存储的名称，例如 123.txt 获取到在文件服务器里映射的文件名称，例如返回 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="groups">文件的分类信息</param>
            <param name="fileName">文件显示名称</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetGroupFromFilePath(System.String,System.Boolean)">
            <summary>
            获取当前目录的文件列表管理容器，如果没有会自动创建，通过该容器可以实现对当前目录的文件进行访问<br />
            Get the file list management container of the current directory. If not, it will be created automatically. 
            Through this container, you can access files in the current directory.
            </summary>
            <param name="filePath">路径信息</param>
            <param name="create">是否创建容器，当没有发现该路径的容器的情况</param>
            <returns>文件管理容器信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetGroupFromFilePath(System.String[])">
            <summary>
            根据路径信息获取到文件列表管理容器，如果返回空，表示不存在。<br />
            The file list management container is obtained according to the path information. If the return is empty, it means that it does not exist.
            </summary>
            <param name="groups">文件路径信息</param>
            <returns>文件列表管理容器</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetDirectories(System.String[])">
            <summary>
            获取文件夹的所有文件夹列表
            </summary>
            <param name="groups">分类信息</param>
            <returns>文件夹列表</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetFileMarksFromDictionaryWithFileName(System.String)">
            <summary>
            获取当前文件的读写锁，如果没有会自动创建，文件名应该是guid文件名，例如 b35a11ec533147ca80c7f7d1713f015b7909<br />
            Acquire the read-write lock of the current file. If not, it will be created automatically. 
            The file name should be the guid file name, for example, b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="fileName">完整的文件路径</param>
            <returns>返回携带文件信息的读写锁</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.CheckFolderAndCreate">
            <summary>
            检查文件夹是否存在，不存在就创建
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.DeleteExsistingFile(System.String,System.String)">
            <summary>
            删除已经存在的文件信息，文件的名称需要是guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="path">文件的路径</param>
            <param name="fileName">文件的guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.DeleteExsistingFile(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            删除已经存在的文件信息，文件的名称需要是guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="path">文件的路径</param>
            <param name="fileNames">文件的guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909</param>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer.FileChangedDelegate">
            <summary>
            文件变化的委托信息
            </summary>
            <param name="session">当前的会话信息，包含用户的基本信息</param>
            <param name="operateInfo">当前的文件操作信息，具体指示上传，下载，删除操作</param>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.OnFileChangedEvent">
            <summary>
            文件变化的事件，当文件上传的时候，文件下载的时候，文件被删除的时候触发。<br />
            The file change event is triggered when the file is uploaded, when the file is downloaded, or when the file is deleted.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.RemoveAndCloseSession(HslCommunication.MQTT.MqttSession,System.String)">
            <summary>
            让MQTT客户端正常下线，调用本方法即可自由控制会话客户端强制下线操作。
            </summary>
            <param name="session">当前的会话信息</param>
            <param name="reason">当前下线的原因，如果没有，代表正常下线</param>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer.OnClientApplicationMessageReceiveDelegate">
            <summary>
            Mqtt的消息收到委托
            </summary>
            <param name="session">当前会话的内容</param>
            <param name="message">Mqtt的消息</param>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.OnClientApplicationMessageReceive">
             <summary>
             当收到客户端发来的<see cref="T:HslCommunication.MQTT.MqttClientApplicationMessage"/>消息时触发<br />
             Triggered when a <see cref="T:HslCommunication.MQTT.MqttClientApplicationMessage"/> message is received from the client
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer.OnClientConnectedDelegate">
            <summary>
            当前mqtt客户端连接上服务器的事件委托
            </summary>
            <param name="session">当前的会话对象</param>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.OnClientConnected">
            <summary>
            Mqtt的客户端连接上来时触发<br />
            Triggered when Mqtt client connects
            </summary>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.OnClientDisConnected">
            <summary>
            Mqtt的客户端下线时触发<br />
            Triggered when Mqtt client connects
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer.ClientVerificationDelegate">
            <summary>
            验证的委托
            </summary>
            <param name="mqttSession">当前的MQTT的会话内容</param>
            <param name="clientId">客户端的id</param>
            <param name="userName">用户名</param>
            <param name="passwrod">密码</param>
            <returns>0则是通过，否则，就是连接失败</returns>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.ClientVerification">
            <summary>
            当客户端连接时，触发的验证事件<br />
            Validation event triggered when the client connects
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.LogStatistics">
            <inheritdoc cref="P:HslCommunication.Enthernet.HttpServer.LogStatistics"/>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.TopicWildcard">
            <summary>
            获取或设置是否启用订阅主题通配符的功能，默认为 False<br />
            Gets or sets whether to enable the function of subscribing to the topic wildcard, the default is False
            </summary>
            <remarks>
            启动之后，通配符示例：finance/stock/ibm/#; finance/+; '#' 是匹配所有主题，'+' 是匹配一级主题树。<br />
            通配符的规则参考如下的网址：http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#appendix-a
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.OnlineCount">
            <summary>
            获取当前的在线的客户端数量<br />
            Gets the number of clients currently online
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.OnlineSessions">
            <summary>
            获得当前所有的在线的MQTT客户端信息，包括异步的客户端及同步请求的客户端。<br />
            Obtain all current online MQTT client information, including asynchronous client and synchronous request client.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.MqttOnlineSessions">
            <summary>
            获得当前异步客户端在线的MQTT客户端信息。<br />
            Get the MQTT client information of the current asynchronous client online.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.SyncOnlineSessions">
            <summary>
            获得当前同步客户端在线的MQTT客户端信息，如果客户端是短连接，将难以捕获在在线信息。<br />
            Obtain the MQTT client information of the current synchronization client online. If the client is a short connection, it will be difficult to capture the online information. <br />
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.DeleteRetainTopic(System.String)">
            <summary>
            删除服务器里的指定主题的驻留消息。<br />
            Delete the resident message of the specified topic in the server.
            </summary>
            <param name="topic">等待删除的主题关键字</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetAllRetainTopics">
            <summary>
            获取所有的驻留的消息的主题，如果消息发布的时候没有使用Retain属性，就无法通过本方法查到<br />
            Get the subject of all resident messages. If the Retain attribute is not used when the message is published, it cannot be found by this method
            </summary>
            <returns>主题的数组</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetMqttSessionsByTopic(System.String)">
            <summary>
            获取订阅了某个主题的所有的会话列表信息<br />
            Get all the conversation list information subscribed to a topic
            </summary>
            <param name="topic">主题信息</param>
            <returns>会话列表</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttSession">
            <summary>
            Mqtt的会话信息，包含了一些基本的信息内容，客户端的IP地址及端口，Client ID，用户名，活动时间，是否允许发布数据等等<br />
            Mqtt's session information includes some basic information content, the client's IP address and port, Client ID, user name, activity time, whether it is allowed to publish data, etc.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.#ctor(System.Net.IPEndPoint,System.String)">
            <summary>
            实例化一个对象，指定ip地址及端口，以及协议内容<br />
            Instantiate an object, specify ip address and port, and protocol content
            </summary>
            <param name="endPoint">远程客户端的IP地址</param>
            <param name="protocol">协议信息</param>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.EndPoint">
            <summary>
            远程的ip地址端口信息<br />
            Remote ip address port information
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.ClientId">
            <summary>
            当前接收的客户端ID信息<br />
            Client ID information currently received
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.ActiveTime">
            <summary>
            当前客户端的激活时间<br />
            The activation time of the current client
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.OnlineTime">
            <summary>
            获取当前的客户端的上线时间<br />
            Get the online time of the current client
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.ActiveTimeSpan">
            <summary>
            两次活动的最小时间间隔<br />
            Minimum time interval between two activities
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.MqttSocket">
            <summary>
            当前客户端绑定的套接字对象
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.Topics">
            <summary>
            当前客户端订阅的所有的Topic信息<br />
            All Topic information subscribed by the current client
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.UserName">
            <summary>
            当前的用户名<br />
            Current username
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.Protocol">
            <summary>
            当前的协议信息，一般为 "MQTT"，如果是同步客户端那么是 "HUSL"，如果是文件客户端就是 "FILE"<br />
            The current protocol information, generally "MQTT", if it is a synchronous client then it is "HUSL", if it is a file client it is "FILE"
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.WillTopic">
            <summary>
            遗嘱主题
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.WillMessage">
            <summary>
            遗嘱的消息内容
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.AesCryptography">
            <summary>
            获取设置客户端的加密信息
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.Tag">
            <summary>
            当前的会话信息关联的自定义信息<br />
            Custom information associated with the current session information
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.ForbidPublishTopic">
            <summary>
            获取或设置当前的MQTT客户端是否允许发布消息，默认为False，如果设置为True，就是禁止发布消息，服务器不会触发收到消息的事件。<br />
            Gets or sets whether the current MQTT client is allowed to publish messages, the default is False, 
            if set to True, it is forbidden to publish messages, The server does not trigger the event of receiving a message.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.IsClientSubscribe(System.String,System.Boolean)">
            <summary>
            检查当前的会话对象里是否订阅了指定的主题内容<br />
            Check whether the specified topic content is subscribed in the current session object
            </summary>
            <param name="topic">主题信息</param>
            <param name="willcard">订阅的主题是否使用了通配符</param>
            <returns>如果订阅了，返回 True, 否则，返回 False</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.GetTopics">
            <summary>
            获取当前客户端订阅的所有的Topic信息<br />
            Get all Topic information subscribed by the current client
            </summary>
            <returns>主题列表</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.AddSubscribe(System.String)">
            <summary>
            当前的会话信息新增一个订阅的主题信息<br />
            The current session information adds a subscribed topic information
            </summary>
            <param name="topic">主题的信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.AddSubscribe(System.String[])">
            <summary>
            当前的会话信息新增多个订阅的主题信息<br />
            The current session information adds multiple subscribed topic information
            </summary>
            <param name="topics">主题的信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.RemoveSubscribe(System.String)">
            <summary>
            移除会话信息的一个订阅的主题
            </summary>
            <param name="topic">主题</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.RemoveSubscribe(System.String[])">
            <summary>
            移除会话信息的一个订阅的主题<br />
            Remove a subscribed topic from session information
            </summary>
            <param name="topics">主题</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.GetSessionOnlineInfo">
            <summary>
            获取当前的会话信息，包含在线时间的信息<br />
            Get current session information, including online time information
            </summary>
            <returns>会话信息，包含在线时间</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttSubscribeMessage">
            <summary>
            订阅的消息类，用于客户端向服务器请求订阅的信息<br />
            Subscribed message class, used by the client to request subscription information from the server
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSubscribeMessage.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSubscribeMessage.QualityOfServiceLevel">
            <summary>
            这个字段表示应用消息分发的服务质量等级保证。分为，最多一次，最少一次，正好一次<br />
            This field indicates the quality of service guarantee for application message distribution. Divided into, at most once, at least once, exactly once
            </summary>
            <remarks>
            在实际的开发中的情况下，最多一次是最省性能的，正好一次是最消耗性能的，如果应有场景为推送实时的数据，那么，最多一次的性能是最高的
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSubscribeMessage.Identifier">
            <summary>
            当前的消息的标识符，当质量等级为0的时候，不需要重发以及考虑标识情况<br />
            The identifier of the current message, when the quality level is 0, do not need to retransmit and consider the identification situation
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSubscribeMessage.Topics">
            <summary>
            当前订阅的所有的主题的数组信息<br />
            Array information of all topics currently subscribed
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSubscribeMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttSyncClient">
            <summary>
            基于MQTT协议的同步访问的客户端程序，支持以同步的方式访问服务器的数据信息，并及时的反馈结果，当服务器启动文件功能时，也支持文件的上传，下载，删除操作等。<br />
            The client program based on MQTT protocol for synchronous access supports synchronous access to the server's data information and timely feedback of results,
            When the server starts the file function, it also supports file upload, download, and delete operations.
            </summary>
            <remarks>
            在最新的V10.2.0及以上版本中，本客户端支持加密模式，启用加密模式后，就无法通过抓包的报文来分析出用户名密码，以及通信的数据细节，详细可以参考API文档。
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test2" title="带用户名密码的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test3" title="连接示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test4" title="读取数据示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test5" title="带进度报告示例" />
            当MqttServer注册了远程RPC接口的时候，例如将一个plc对象注册是接口对象，或是自定义的接口内容
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test11" title="RPC接口读取" />
            服务器都有什么RPC接口呢？可以通过下面的方式知道
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test12" title="RPC接口列表" />
            关于加密模式，在不加密的情况下，用户名及密码，还有请求的数据信息会被第三方软件窃取，从而泄露一些关键的数据信息，如果使用了HslCommunicationV10.2.0版本以上创建的MQTTServer，
            那么可以在客户端使用加密模式，加密使用RSA+AES混合加密，密钥动态生成，在保证效率的同时，具有很高的安全性。客户端使用加密如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test13" title="加密举例" />
            下面演示文件部分的功能的接口方法，主要包含，上传，下载，删除，遍历操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test6" title="下载文件功能" />
            在实际的窗体界面开发中，会更加的复杂，有个按钮点击下载，还需要支持取消下载操作。可以参考如下的代码：<br />
            <code lang="cs" source="TestProject\HslCommunicationDemo\MQTT\FormMqttFileClient.cs" region="Download Sample" title="带取消的下载功能" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test7" title="上传文件功能" />
            在实际的窗体界面开发中，会更加的复杂，有个按钮点击上传，还需要支持取消上传操作。可以参考如下的代码：<br />
            <code lang="cs" source="TestProject\HslCommunicationDemo\MQTT\FormMqttFileClient.cs" region="Upload File" title="带取消的上传功能" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test8" title="删除文件功能" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test9" title="遍历指定目录的文件名功能" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test10" title="遍历指定目录的所有子目录" />
            上述的两个遍历的方法，就可以遍历出服务器的所有目录和文件了，具体可以参考 Demo 的MQTT文件客户端的演示界面。
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.#ctor(HslCommunication.MQTT.MqttConnectionOptions)">
            <summary>
            实例化一个MQTT的同步客户端<br />
            Instantiate an MQTT synchronization client
            </summary>
            <param name="options">连接的参数信息，可以指定IP地址，端口，账户名，密码，客户端ID信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的ip地址及端口来实例化一个同步的MQTT客户端<br />
            Instantiate a synchronized MQTT client with the specified IP address and port
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            通过指定的ip地址及端口来实例化一个同步的MQTT客户端<br />
            Instantiate a synchronized MQTT client with the specified IP address and port
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.Read(System.String,System.Byte[],System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <summary>
            从MQTT服务器同步读取数据，将payload发送到服务器，然后从服务器返回相关的数据，支持数据发送进度报告，服务器执行进度报告，接收数据进度报告操作<br />
            Synchronously read data from the MQTT server, send the payload to the server, and then return relevant data from the server, 
            support data transmission progress report, the server executes the progress report, and receives the data progress report
            </summary>
            <remarks>
            进度报告可以实现一个比较有意思的功能，可以用来数据的上传和下载，提供一个友好的进度条，因为网络的好坏通常是不确定的。
            </remarks>
            <param name="topic">主题信息</param>
            <param name="payload">负载数据</param>
            <param name="sendProgress">发送数据给服务器时的进度报告，第一个参数为已发送数据，第二个参数为总发送数据</param>
            <param name="handleProgress">服务器处理数据的进度报告，第一个参数Topic自定义，通常用来传送操作百分比，第二个参数自定义，通常用来表示服务器消息</param>
            <param name="receiveProgress">从服务器接收数据的进度报告，第一个参数为已接收数据，第二个参数为总接收数据</param>
            <returns>服务器返回的数据信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadString(System.String,System.String,System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <summary>
            从MQTT服务器同步读取数据，将指定编码的字符串payload发送到服务器，然后从服务器返回相关的数据，并转换为指定编码的字符串，支持数据发送进度报告，服务器执行进度报告，接收数据进度报告操作<br />
            Synchronously read data from the MQTT server, send the specified encoded string payload to the server, 
            and then return the data from the server, and convert it to the specified encoded string,
            support data transmission progress report, the server executes the progress report, and receives the data progress report
            </summary>
            <param name="topic">主题信息</param>
            <param name="payload">负载数据</param>
            <param name="sendProgress">发送数据给服务器时的进度报告，第一个参数为已发送数据，第二个参数为总发送数据</param>
            <param name="handleProgress">服务器处理数据的进度报告，第一个参数Topic自定义，通常用来传送操作百分比，第二个参数自定义，通常用来表示服务器消息</param>
            <param name="receiveProgress">从服务器接收数据的进度报告，第一个参数为已接收数据，第二个参数为总接收数据</param>
            <returns>服务器返回的数据信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRpc``1(System.String,System.String)">
            <summary>
            读取MQTT服务器注册的RPC接口，忽略返回的Topic数据，直接将结果转换为泛型对象，如果JSON转换失败，将返回错误，参数传递主题和数据负载，
            数据负载示例："{\"address\": \"100\",\"length\": 10}" 本质是一个字符串。<br />
            Read the RPC interface registered by the MQTT server, ignore the returned Topic data, and directly convert the result into a generic object. 
            If the JSON conversion fails, an error will be returned. The parameter passes the topic and the data payload. 
            The data payload example: "{\"address\ ": \"100\",\"length\": 10}" is essentially a string.
            </summary>
            <remarks>
            关于类型对象，需要和服务器返回的类型一致，如果服务器返回了 <see cref="T:System.String"/>, 这里也是 <see cref="T:System.String"/>, 如果是自定义对象，客户端没有该类型，可以使用 <see cref="T:Newtonsoft.Json.Linq.JObject"/>
            </remarks>
            <typeparam name="T">泛型对象，需要和返回的数据匹配，如果返回的是 int 数组，那么这里就是 int[]，务必和服务器侧定义的返回类型一致</typeparam>
            <param name="topic">主题信息，也是服务器的 RPC 接口信息</param>
            <param name="payload">传递的参数信息，示例："{\"address\": \"100\",\"length\": 10}" 本质是一个字符串。</param>
            <returns>服务器返回的数据信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRpc``1(System.String,System.Object)">
            <summary>
            读取MQTT服务器注册的RPC接口，忽略返回的Topic数据，直接将结果转换为泛型对象，如果JSON转换失败，将返回错误，参数传递主题和数据负载，
            数据负载示例：new { address = "", length = 0 } 本质是一个匿名对象。<br />
            Read the RPC interface registered by the MQTT server, ignore the returned Topic data, and directly convert the result into a generic object. 
            If the JSON conversion fails, an error will be returned. The parameter passes the topic and the data payload. 
            The data payload example: new { address = "", length = 0 } is essentially an anonymous object.
            </summary>
            <remarks>
            关于类型对象，需要和服务器返回的类型一致，如果服务器返回了 <see cref="T:System.String"/>, 这里也是 <see cref="T:System.String"/>, 如果是自定义对象，客户端没有该类型，可以使用 <see cref="T:Newtonsoft.Json.Linq.JObject"/>
            </remarks>
            <typeparam name="T">泛型对象，需要和返回的数据匹配，如果返回的是 int 数组，那么这里就是 int[]</typeparam>
            <param name="topic">主题信息，也是服务器的 RPC 接口信息</param>
            <param name="payload">传递的参数信息，示例：new { address = "", length = 0 } 本质是一个匿名对象。</param>
            <returns>服务器返回的数据信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcApis">
            <summary>
            读取服务器的已经注册的API信息列表，将返回API的主题路径，注释信息，示例的传入的数据信息。<br />
            Read the registered API information list of the server, and return the API subject path, annotation information, and sample incoming data information.
            </summary>
            <returns>包含是否成功的api信息的列表</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcApiLog(System.String)">
            <summary>
            读取服务器的指定的API接口的每天的调用次数，如果API接口不存在，或是还没有调用数据，则返回失败。<br />
            Read the number of calls per day of the designated API interface of the server. 
            If the API interface does not exist or the data has not been called yet, it returns a failure.
            </summary>
            <remarks>
            如果api的参数为空字符串，就是请求所有的接口的调用的统计信息。
            </remarks>
            <param name="api">等待请求的API的接口信息，如果为空，就是请求所有的接口的调用的统计信息。</param>
            <returns>最近几日的连续的调用情况，例如[1,2,3]，表示前提调用1次，昨天调用2次，今天3次</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRetainTopics">
            <summary>
            读取服务器的已经驻留的所有消息的主题列表<br />
            Read the topic list of all messages that have resided on the server
            </summary>
            <returns>消息列表对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadTopicPayload(System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            读取服务器的已经驻留的指定主题的消息内容<br />
            Read the topic list of all messages that have resided on the server
            </summary>
            <param name="topic">指定的主题消息</param>
            <param name="receiveProgress">结果进度报告</param>
            <returns>消息列表对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadAsync(System.String,System.Byte[],System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.Read(System.String,System.Byte[],System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadStringAsync(System.String,System.String,System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadString(System.String,System.String,System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcAsync``1(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRpc``1(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcAsync``1(System.String,System.Object)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRpc``1(System.String,System.Object)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcApisAsync">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcApis"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcApiLogAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcApiLog(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadRetainTopicsAsync">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRetainTopics"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadTopicPayloadAsync(System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadTopicPayload(System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadFile(System.String,System.String,System.Action{System.Int64,System.Int64},System.String,HslCommunication.Core.HslCancelToken)">
            <summary>
            从远程服务器下载一个文件到本地，需要指定文件类别，文件名，进度报告，本地保存的文件名<br />
            To download a file from a remote server to the local, you need to specify the file category, file name, progress report, and file name saved locally
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分 </param>
            <param name="fileName">文件名称，例如 123.txt</param>
            <param name="processReport">进度报告，第一个参数是已完成字节数，第二个参数是总字节数，如果不需要，传入NULL即可</param>
            <param name="fileSaveName">本地保存的文件名</param>
            <param name="cancelToken">取消下载操作的令牌</param>
            <returns>是否下载成功</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadFile(System.String,System.String,System.Action{System.Int64,System.Int64},System.IO.Stream,HslCommunication.Core.HslCancelToken)">
            <summary>
            从远程服务器下载一个文件到流中，需要指定文件类别，文件名，进度报告，本地保存的文件名<br />
            To download a file from a remote server to the stream, you need to specify the file category, file name, progress report, and file name saved locally
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分 </param>
            <param name="fileName">文件名称，例如 123.txt</param>
            <param name="processReport">进度报告，第一个参数是已完成字节数，第二个参数是总字节数</param>
            <param name="stream">数据流</param>
            <param name="cancelToken">取消下载操作的令牌</param>
            <returns>是否下载成功</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadBitmap(System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <summary>
            从远程服务器下载一个文件，生成一个Bitmap图片对象，需要指定文件类别，文件名，进度报告，可用于用户头像的存储<br />
            Download a file from a remote server and generate a Bitmap image object. You need to specify the file category, file name, and progress report, which can be used to store the user's avatar
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <param name="fileName">文件名称，例如 123.txt</param>
            <param name="processReport">进度报告，第一个参数是已完成字节数，第二个参数是总字节数</param>
            <param name="cancelToken">取消下载操作的令牌</param>
            <returns>如果下载成功，则携带图片资源对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.UploadFile(System.Drawing.Bitmap,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <summary>
            上传一个Bitmap图片对象到服务器指定的分类下面，需要指定分类信息，服务器保存的文件名，描述信息，支持进度报告<br />
            Upload a Bitmap image object to the category specified by the server, you need to specify the category information, 
            the file name saved by the server, description information, and support for progress reports
            </summary>
            <param name="bitmap">图片对象</param>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <param name="serverName">在服务器保存的文件名称</param>
            <param name="fileTag">文件的额外的描述信息</param>
            <param name="processReport">进度报告，第一个参数是已完成字节数，第二个参数是总字节数</param>
            <param name="cancelToken">取消上传操作的令牌</param>
            <returns>是否上传成功</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.UploadFileBase(System.Object,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <summary>
            上传文件给服务器，需要指定上传的数据内容，上传到服务器的分类信息，支持进度汇报功能。<br />
            To upload files to the server, you need to specify the content of the uploaded data, 
            the classification information uploaded to the server, and support the progress report function.
            </summary>
            <param name="source">数据源，可以是文件名，也可以是数据流</param>
            <param name="serverName">在服务器保存的文件名，不包含驱动器路径</param>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <param name="fileTag">文件的额外的描述信息</param>
            <param name="processReport">进度报告，第一个参数是已完成字节数，第二个参数是总字节数</param>
            <param name="cancelToken">用户取消的令牌信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.UploadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <summary>
            上传文件给服务器，需要指定上传文件的路径信息，服务器保存的名字，以及上传到服务器的分类信息，支持进度汇报功能。<br />
            To upload a file to the server, you need to specify the path information of the uploaded file, the name saved by the server, 
            and the classification information uploaded to the server to support the progress report function.
            </summary>
            <param name="fileName">文件名，需要指定完整的路径信息，文件必须存在，否则发送失败</param>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <param name="serverName">服务器端保存的文件名</param>
            <param name="fileTag">文件的额外的描述信息</param>
            <param name="processReport">进度报告，第一个参数是已完成字节数，第二个参数是总字节数</param>
            <param name="cancelToken">取消上传操作的令牌</param>
            <returns>是否上传成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.UploadFile(System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <summary>
            上传文件给服务器，需要指定上传文件的路径信息(服务器保存的名称就是文件名)，以及上传到服务器的分类信息，支持进度汇报功能。<br />
            To upload a file to the server, you need to specify the path information of the uploaded file (the name saved by the server is the file name), 
            as well as the classification information uploaded to the server, to support the progress report function.
            </summary>
            <param name="fileName">文件名，需要指定完整的路径信息，文件必须存在，否则发送失败</param>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <param name="fileTag">文件的额外的描述信息</param>
            <param name="processReport">进度报告，第一个参数是已完成字节数，第二个参数是总字节数</param>
            <param name="cancelToken">取消上传操作的令牌</param>
            <returns>是否上传成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadPathFileNames(System.String)">
            <summary>
            下载指定分类信息的所有的文件描述信息，需要指定分类信息，例如：Files/Personal/Admin<br />
            To download all the file description information of the specified classification information, 
            you need to specify the classification information, for example: Files/Personal/Admin
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <returns>当前分类下所有的文件描述信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadPathFolders(System.String)">
            <summary>
            下载指定分类信息的全部子分类信息<br />
            Download all sub-category information of the specified category information
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <returns>当前分类下所有的子分类信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.IsFileExists(System.String,System.String)">
            <summary>
            请求服务器指定分类是否存在指定的文件名，需要指定分类信息，文件名<br />
            Request the server to specify whether the specified file name exists in the specified category, need to specify the category information, file name
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <param name="fileName">文件名信息，例如 123.txt</param>
            <returns>Content为True表示存在，否则为不存在</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DeleteFile(System.String,System.String)">
            <summary>
            删除服务器的指定的文件名，需要指定分类信息，文件名<br />
            Delete the specified file name of the server, need to specify the classification information, file name
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <param name="fileName">文件名信息</param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DeleteFile(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DeleteFile(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DeleteFolderFiles(System.String)">
            <summary>
            删除服务器上指定的分类信息及管理的所有的文件，包含所有的子分类信息，不可逆操作，谨慎操作。<br />
            Delete the specified classification information and all files managed on the server, 
            including all sub-classification information, irreversible operation, and careful operation.
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.GetGroupFileInfo(System.String)">
            <summary>
            获取服务器文件夹的指定目录的文件统计信息，包括文件数量，总大小，最后更新时间<br />
            Get the file statistics of the specified directory of the server folder, including the number of files, the total size, and the last update time
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <returns>服务器文件大小的结果对象，单位：字节数</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.GetSubGroupFileInfos(System.String,System.Boolean)">
            <summary>
            获取服务器文件夹的指定目录的所有子目录的文件信息，包括每个子目录的文件数量，总大小，最后更新时间<br />
            Get the file information of all subdirectories of the specified directory of the server folder, including the number of files in each subdirectory, the total size, and the last update time
            </summary>
            <param name="groups">文件的类别，例如 Files/Personal/Admin 按照斜杠来区分</param>
            <param name="withLastFileInfo">是否让服务器携带最新的文件信息返回</param>
            <returns>服务器文件大小的结果对象，单位：字节数</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadFileAsync(System.String,System.String,System.Action{System.Int64,System.Int64},System.String,HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DownloadFile(System.String,System.String,System.Action{System.Int64,System.Int64},System.String,HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadFileAsync(System.String,System.String,System.Action{System.Int64,System.Int64},System.IO.Stream,HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DownloadFile(System.String,System.String,System.Action{System.Int64,System.Int64},System.IO.Stream,HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadBitmapAsync(System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DownloadBitmap(System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.UploadFileAsync(System.Drawing.Bitmap,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.UploadFile(System.Drawing.Bitmap,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.UploadFileBaseAsync(System.Object,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.UploadFileBase(System.Object,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.UploadFileAsync(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.UploadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.UploadFileAsync(System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.UploadFile(System.String,System.String,System.String,System.Action{System.Int64,System.Int64},HslCommunication.Core.HslCancelToken)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadPathFileNamesAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DownloadPathFileNames(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DownloadPathFoldersAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DownloadPathFolders(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.IsFileExistsAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.IsFileExists(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DeleteFileAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DeleteFile(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DeleteFileAsync(System.String,System.String[])">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DeleteFile(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.DeleteFolderFilesAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.DeleteFolderFiles(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.GetGroupFileInfoAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.GetGroupFileInfo(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.GetSubGroupFileInfosAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.GetSubGroupFileInfos(System.String,System.Boolean)"/>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSyncClient.ConnectionOptions">
            <summary>
            获取或设置当前的连接信息，客户端将根据这个连接配置进行连接服务器，在连接之前需要设置相关的信息才有效。<br />
            To obtain or set the current connection information, the client will connect to the server according to this connection configuration. 
            Before connecting, the relevant information needs to be set to be effective.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSyncClient.StringEncoding">
            <summary>
            获取或设置使用字符串访问的时候，使用的编码信息，默认为UT8编码<br />
            Get or set the encoding information used when accessing with a string, the default is UT8 encoding
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttSyncClientPool">
            <summary>
            <b>[商业授权]</b> MqttSyncClient客户端的连接池类对象，用于共享当前的连接池，合理的动态调整连接对象，然后进行高效通信的操作，默认连接数无限大。<br />
            <b>[Authorization]</b> The connection pool class object of the MqttSyncClient is used to share the current connection pool, 
            reasonably dynamically adjust the connection object, and then perform efficient communication operations, 
            The default number of connections is unlimited
            </summary>
            <remarks>
            本连接池用于提供高并发的读写性能，仅对商业授权用户开放。使用起来和<see cref="T:HslCommunication.MQTT.MqttSyncClient"/>一致，但是更加的高性能，在密集型数据交互时，优势尤为明显。
            </remarks>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.#ctor(HslCommunication.MQTT.MqttConnectionOptions)">
            <summary>
            通过MQTT连接参数实例化一个对象<br />
            Instantiate an object through MQTT connection parameters
            </summary>
            <param name="options">MQTT的连接参数信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.#ctor(HslCommunication.MQTT.MqttConnectionOptions,System.Action{HslCommunication.MQTT.MqttSyncClient})">
            <summary>
            通过MQTT连接参数以及自定义的初始化方法来实例化一个对象<br />
            Instantiate an object through MQTT connection parameters and custom initialization methods
            </summary>
            <param name="options">MQTT的连接参数信息</param>
            <param name="initialize">自定义的初始化方法</param>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSyncClientPool.GetMqttSyncConnectPool">
            <summary>
            获取当前的连接池管理对象信息<br />
            Get current connection pool management object information
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSyncClientPool.MaxConnector">
            <inheritdoc cref="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.MaxConnector"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.Read(System.String,System.Byte[],System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.Read(System.String,System.Byte[],System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadString(System.String,System.String,System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadString(System.String,System.String,System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpc``1(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRpc``1(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpc``1(System.String,System.Object)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRpc``1(System.String,System.Object)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpcApis">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcApis"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpcApiLog(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRpcApiLog(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRetainTopics">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRetainTopics"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadTopicPayload(System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadTopicPayload(System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadAsync(System.String,System.Byte[],System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClientPool.Read(System.String,System.Byte[],System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadStringAsync(System.String,System.String,System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClientPool.ReadString(System.String,System.String,System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpcAsync``1(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpc``1(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpcAsync``1(System.String,System.Object)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpc``1(System.String,System.Object)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpcApisAsync">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpcApis"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpcApiLogAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRpcApiLog(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadRetainTopicsAsync">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadRetainTopics"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ReadTopicPayloadAsync(System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttSyncClient.ReadTopicPayload(System.String,System.Action{System.Int64,System.Int64})"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClientPool.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttRpcApiInfo">
            <summary>
            Mqtt的同步网络服务的单Api信息描述类<br />
            Single Api information description class of Mqtt's synchronous network service
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.ApiTopic">
            <summary>
            当前的Api的路由信息，对于注册服务来说，是类名/方法名
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.Description">
            <summary>
            当前的Api的路由说明
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.MethodSignature">
            <summary>
            当前方法的签名
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.CalledCount">
            <summary>
            当前Api的调用次数
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.ExamplePayload">
            <summary>
            示例的
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.SpendTotalTime">
            <summary>
            当前Api的调用总耗时，单位是秒
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.IsMethodApi">
            <summary>
            当前Api是否为方法，如果是方法，就为true，否则为false
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.HttpMethod">
            <summary>
            如果当前的API接口是支持Http的请求方式，当前属性有效，例如GET,POST
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.IsOperateResultApi">
            <summary>
            当前的Api的方法是否是异步的Task类型
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.Method">
            <summary>
            当前的Api关联的方法反射，本属性在JSON中将会忽略
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.Property">
            <summary>
            当前的Api关联的方法反射，本属性在JSON中将会忽略
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.PermissionAttribute">
            <summary>
            当前Api的方法的权限访问反射，本属性在JSON中将会忽略
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttRpcApiInfo.SourceObject">
            <summary>
            当前Api绑定的对象的，实际的接口请求，将会从对象进行调用，本属性在JSON中将会忽略
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttRpcApiInfo.CalledCountAddOne(System.Int64)">
            <summary>
            使用原子的操作增加一次调用次数的数据信息，需要传入当前的消耗的时间，单位为100倍毫秒
            </summary>
            <param name="timeSpend">当前调用花费的时间，单位为100倍毫秒</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttRpcApiInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.NamespaceDoc">
            <summary>
            一个工业物联网的底层架构框架，专注于底层的技术通信及跨平台，跨语言通信功能，实现各种主流的PLC数据读写，实现modbus，机器人的各种协议读写等等，
            支持快速搭建工业上位机软件，组态软件，SCADA软件，工厂MES系统，助力企业工业4.0腾飞，实现智能制造，智慧工厂的目标。
            <br /><br />
            本组件付费开源，使用之前请认真的阅读本API文档，对于本文档中警告部分的内容务必理解，部署生产之前请详细测试，如果在测试的过程中，
            发现了BUG，或是有问题的地方，欢迎联系作者进行修改，或是直接在github上进行提问。未经测试，直接部署，对设备，工厂造成了损失，作者概不负责。
            <br /><br />
            官方网站：<a href="http://www.hslcommunication.cn/">http://www.hslcommunication.cn/</a>，包含组件的在线API地址以及一个MES DEMO的项目展示。
            <br /><br />
            <note type="important">
            本组件的目标是集成一个框架，统一所有的设备读写方法，抽象成统一的接口<see cref="T:HslCommunication.Core.IReadWriteNet"/>，对于上层操作只需要关注地址，读取类型即可，另一个目标是使用本框架轻松实现C#后台+C#客户端+web浏览器+android手机的全方位功能实现。
            </note>
            本库提供了C#版本和java版本和python版本，java，python版本的使用和C#几乎是一模一样的，都是可以相互通讯的。
            <br />
            在使用本通讯库之前，需要学会如何使用nuget来安装当前的通讯库，可以参考如下的博文：<a href="http://www.cnblogs.com/dathlin/p/7705014.html">http://www.cnblogs.com/dathlin/p/7705014.html</a>
            <br /><br />
            先整体介绍下如何使用本组件库的基本思路，基本上是引用库，从nuget安装的库会自动添加引用到项目中的，就可以直接进行using操作了，当然了在使用之前，需要先激活一下，激活的方式如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Active.cs" region="Sample1" title="激活示例" />
            在你的应用程序刚开起来的时候，激活一次即可，后续都不需要再重复激活了。接下来就可以开始写代码了。任何的设备的操作基本是相同的，实例化，配置参数（有些plc默认的参数即可），连接设备，读写操作，关闭
            <br />
            关于Hsl的日志功能，贯穿整个hslcommunication的项目，所有的网络类，都包含了<see cref="T:HslCommunication.LogNet.ILogNet"/>日志功能，当然你也可以继承接口实现你自己的日志，在hsl里提供了三种常见的简单实用的日志
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example1" title="单文件实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="日志基本的使用" />
            <br />
            再开始讲解基本的代码通讯之前，先来了解两个基本的概念，长连接，短连接。为了更好的说明当前的通信情况，我把所有的通信拆分为四个部分，连接，发，收，断开。<br />
            短连接：连接，发，收，断开，连接，发，收，断开，连接，发，收，断开，连接，发，收，断开...无限循环<br />
            长连接：连接，发，收，发，收，发，收，发，收，发，收，发，收，发，收，发，收，发，收....断开<br />
            然后我们来看看异常的情况，短连接的异常比较好处理，反正每次请求都是先连接，关键来看长连接的异常<br />
            长连接：连接，发，收，发，收...异常，连接，发，收，发，收，异常，连接，连接，连接...收，发，收，发，收，发，收，发，收....断开<br />
            这里第一个异常发生后，第二次读写立即连接上去并且成功，第二个异常触发后，一直读写失败，说明就是一直连接不上去。<br />
            对于HSL组件来说，不需要重复连接服务器或是plc，无论是短连接还是长连接，都只需要一直读写就OK了，对读写的结果进行判定，即使发生异常了，读写失败了，也要一直坚持，网络好的时候，读写会恢复成功的。<br /><br />
            我们以三菱的PLC为示例，其他的plc调用方式基本是一模一样的，就是调用的类不一样，参数配置不一样而已。以下的逻辑都是适用的。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage2" title="简单的长连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample1" title="基本的读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample2" title="批量读取示例" />
            需要注意的事，在实际的开发中，我们的一个窗体程序（或是控制台，原理都是一样的），会定时或是不定时的去读写PLC的操作（调用Read或是Write方法），这个本身是没有任何问题的，
            但是总会有这样的需求，我们需要在界面上，或是系统里实时体现当前的PLC的在线情况，我相信不少小伙伴会有这样的问题的。所以就出现了下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Check Netstatus" title="检查连接状态" />
            实际这种操作是非常不可取的，为什么这么说，下面说说原因：<br />
            <note type="warning">
            首先说明下<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer"/>方法里发生了什么？这个方法首先会关闭连接，然后重新连接，连接成功，就发送初始化指令（有些PLC就需要握手确认），初始化握手成功，才返回真正的成功！<br />
            那么这里为什么不行呢？因为Read和Write方法是有混合锁实现互斥操作的，这样的好处就是多线程调用互不影响，但是<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer"/>方法，并没有互斥锁，如果调用的时候同时在读写，那就会导致异常，
            那么为什么没有加互斥锁呢？因为为了实现读写方法的时候，支持自动重连操作，所以连接方法已经在互斥锁了。如果再加互斥锁，会发生死锁，所以综合考虑，就设计成了现在的样子。
            </note>
            既然上面的代码不能使用，那么怎么来看当前的连接状态呢？这里有一点需要注意，<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer"/>只需要调用0次或1次即可。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Check Netstatus2" title="检查连接状态" />
            如果你本来就在每秒读取PLC的数据信息了，那么连检测的定时器都不用写了，你每次读取数据的时候顺便判定下，结果就出来了。<br /><br />
            其他相关的代码示例需要到各自的目录里查找，下面只列举了一些常见的代码示例
            <list type="bullet">
                <item>Hsl组件日志相关示例参考<see cref="T:HslCommunication.LogNet.ILogNet"/></item>
                <item>三菱mc协议示例参考<see cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet"/></item>
                <item>西门子S7协议示例参考<see cref="T:HslCommunication.Profinet.Siemens.SiemensS7Net"/></item>
                <item>欧姆龙协议示例参考<see cref="T:HslCommunication.Profinet.Omron.OmronFinsNet"/></item>
                <item>罗克韦尔协议示例参考<see cref="T:HslCommunication.Profinet.AllenBradley.AllenBradleyNet"/></item>
                <item>Modbus协议示例参考<see cref="T:HslCommunication.ModBus.ModbusTcpNet"/></item>
                <item>MQTT服务器示例参考<see cref="T:HslCommunication.MQTT.MqttServer"/></item>
                <item>MQTT客户端示例参考<see cref="T:HslCommunication.MQTT.MqttClient"/></item>
                <item>WebSocket服务器示例参考<see cref="T:HslCommunication.WebSocket.WebSocketServer"/></item>
                <item>WebSocket客户端示例参考<see cref="T:HslCommunication.WebSocket.WebSocketClient"/>。</item>
                <item>WebApi示例参考<see cref="T:HslCommunication.Enthernet.HttpServer"/>。</item>
                <item>Redis示例参考<see cref="T:HslCommunication.Enthernet.Redis.RedisClient"/></item>
                <item>身份证阅读器串口版<see cref="T:HslCommunication.Profinet.IDCard.SAMSerial"/></item>
                <item>身份证阅读器网口版<see cref="T:HslCommunication.Profinet.IDCard.SAMTcpNet"/></item>
                <item>文件传送服务器<see cref="T:HslCommunication.Enthernet.UltimateFileServer"/></item>
            </list>
            <note type="important">
            相关的代码示例，可以翻阅左侧的命名空间，基本是按照功能来区分的，只要点进去多看看即可
            </note>
            </summary>
            <remarks>
            本软件著作权归Richard.Hu所有。
            <br />
            博客地址：<a href="https://www.cnblogs.com/dathlin/p/7703805.html">https://www.cnblogs.com/dathlin/p/7703805.html</a>
            <br />
            授权付费模式：Hslcommunication企业商业授权，一次付费，终身授权，终身开放源码，终身支持后续更新，支持的设备列表请参考最新的DEMO界面，凡是DEMO列举都是统一打包授权的。不限制电脑，项目，plc，开发人员数量。
            <br />
            <list type="bullet">
                <item>企业授权提供专业版通讯库的所有更新版的 HslCommunication 源代码。包含 .Net Java Python 三大平台。</item>
                <item>企业授权支持对特殊需求而进行修改，更新源代码的服务，配合企业客户修复源代码错误的服务。</item>
                <item>企业授权用户拥有对通讯库商用的权利，拥有自己修改源代码并商业使用的权利，组件版权仍归属原作者。</item>
                <item>企业授权用户需要对源代码保密。禁止公开源代码，禁止对源代码的商业用途。</item>
                <item>企业授权用户可以免费获得官网的 MES DEMO源代码。</item>
                <item>企业商业授权 费用请联系QQ200962190咨询，公司即可拥有商用版权，支持任意的开发人员数量，项目数量，支持源代码更新，长期支持，商用软件必须冠名公司标识，官网显示合作伙伴logo。</item>
                <item>支持专业的一对一培训业务，一小时1000 rmb，一天8小时为5000 rmb</item>
            </list>
            
            个人赞助二维码：<br />
            <img src="https://raw.githubusercontent.com/dathlin/HslCommunication/master/imgs/support.png" />
            </remarks>
            <revisionHistory>
                <revision date="2017-10-21" version="3.7.10" author="Richard.Hu">
                    <list type="bullet">
                        <item>正式发布库到互联网上去。</item>
                    </list>
                </revision>
                <revision date="2017-10-21" version="3.7.11" author="Richard.Hu">
                    <list type="bullet">
                        <item>添加xml文档</item>
                    </list>
                </revision>
                <revision date="2017-10-31" version="3.7.12" author="Richard.Hu">
                    <list type="bullet">
                        <item>重新设计西门子的数据读取机制，提供一个更改类型的方法。</item>
                    </list>
                </revision>
                <revision date="2017-11-06" version="3.7.13" author="Richard.Hu">
                    <list type="bullet">
                        <item>提供一个ModBus的服务端引擎。</item>
                    </list>
                </revision>
                <revision date="2017-11-07" version="3.7.14" author="Richard.Hu">
                    <list type="bullet">
                        <item>紧急修复了西门子批量访问时出现的BUG。</item>
                    </list>
                </revision>
                <revision date="2017-11-12" version="3.7.15" author="Richard.Hu">
                    <list type="bullet">
                        <item>完善CRC16校验码功能，完善数据库辅助类方法。</item>
                    </list>
                </revision>
                <revision date="2017-11-13" version="3.7.16" author="Richard.Hu">
                    <list type="bullet">
                        <item>西门子访问类，提供一个批量bool数据写入，但该写入存在安全隐患，具体见博客。</item>
                    </list>
                </revision>
                <revision date="2017-11-21" version="4.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>与3.X版本不兼容，谨慎升级。如果要升级，主要涉及的代码包含PLC的数据访问和同步数据通信。</item>
                        <item>删除了2个类，OperateResultBytes和OperateResultString类，提供了更加强大方便的泛型继承类，多达10个泛型参数。地址见http://www.cnblogs.com/dathlin/p/7865682.html</item>
                        <item>将部分类从HslCommunication命名空间下移动到HslCommunication.Core下面。</item>
                        <item>提供了一个通用的ModBus TCP的客户端类，方便和服务器交互。</item>
                        <item>完善了HslCommunication.BasicFramework.SoftBaisc下面的辅助用的静态方法，提供了一些方便的数据转化，在上面进行公开。</item>
                    </list>
                </revision>
                <revision date="2017-11-24" version="4.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>更新了三菱的读取接口，提供了一个额外的字符串表示的方式，OperateResult&lt;byte[]&gt; read =  melsecNet.ReadFromPLC("M100", 5);</item>
                        <item>更新了西门子的数据访问类和modbus tcp类提供双模式运行，按照之前版本的写法是默认模式，每次请求重新创建网络连接，新增模式二，在代码里先进行连接服务器方法，自动切换到模式二，每次请求都共用一个网络连接，内部已经同步处理，加速数据访问，如果访问失败，自动在下次请求是重新连接，如果调用关闭连接服务器，自动切换到模式一。</item>
                    </list>
                </revision>
                <revision date="2017-11-25" version="4.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复Modbus tcp批量写入寄存器时，数据解析异常的BUG。</item>
                        <item>三菱访问器新增长连接模式。</item>
                        <item>三菱访问器支持单个M写入，在数组中指定一个就行。</item>
                        <item>三菱访问器提供了float[]数组写入的API。</item>
                        <item>三菱访问器支持F报警器，B链接继电器，S步进继电器，V边沿继电器，R文件寄存器读写，不过还需要大面积测试。</item>
                        <item>三菱访问器的读写地址支持字符串形式传入。</item>
                        <item>其他的细节优化。</item>
                        <item>感谢 hwdq0012 网友的测试和建议。</item>
                        <item>感谢 吃饱睡好 好朋友的测试</item>
                    </list>
                </revision>
                <revision date="2017-11-27" version="4.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>三菱，西门子，Modbus tcp客户端内核优化重构。</item>
                        <item>三菱，西门子，Modbus tcp客户端提供统一的报文测试方法，该方法也是通信核心，所有API都是基于此扩展起来的。</item>
                        <item>三菱，西门子，Modbus tcp客户端提供了一些便捷的读写API，详细参见对应博客。</item>
                        <item>三菱的地址区分十进制和十六进制。</item>
                        <item>优化三菱的位读写操作。</item>
                    </list>
                </revision>
                <revision date="2017-11-28" version="4.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复西门子读取的地址偏大会出现异常的BUG。</item>
                        <item>完善统一了所有三菱，西门子，modbus客户端类的读写方法，已经更新到博客。</item>
                    </list>
                </revision>
                <revision date="2017-12-02" version="4.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>完善日志记录，提供关键字记录操作。</item>
                        <item>三菱，西门子，modbus tcp客户端提供自定义数据读写。</item>
                        <item>modbus tcp服务端提供数据池功能，并支持数据订阅操作。</item>
                        <item>提供一个纵向的进度控件。</item>
                    </list>
                </revision>
                <revision date="2017-12-04" version="4.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>完善Modbus tcp服务器端的数据订阅功能。</item>
                        <item>进度条控件支持水平方向和垂直方向两个模式。</item>
                    </list>
                </revision>
                <revision date="2017-12-05" version="4.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>进度条控件修复初始颜色为空的BUG。</item>
                        <item>进度条控件文本锯齿修复。</item>
                        <item>按钮控件无法使用灰色按钮精灵破解。</item>
                    </list>
                </revision>
                <revision date="2017-12-13" version="4.1.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>modbus tcp提供读取short数组的和ushort数组方法。</item>
                    </list>
                </revision>
                <revision date="2017-12-13" version="4.1.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复流水号生成器无法生成不带日期格式的流水号BUG。</item>
                    </list>
                </revision>
                <revision date="2017-12-18" version="4.1.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>OperateResult成功时，消息为成功。</item>
                        <item>数据库辅助类API添加，方便的读取聚合函数。</item>
                        <item>日志类分析工具界面，显示文本微调。</item>
                    </list>
                </revision>
                <revision date="2017-12-25" version="4.1.7" author="Richard.Hu">
                    <list type="bullet">
                        <item>进度条控件新增一个新的属性对象，是否使用动画。</item>
                    </list>
                </revision>
                <revision date="2017-12-27" version="4.1.8" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增一个饼图控件。</item>
                    </list>
                </revision>
                <revision date="2017-12-28" version="4.1.9" author="Richard.Hu">
                    <list type="bullet">
                        <item>饼图显示优化，新增是否显示百分比的选择。</item>
                    </list>
                </revision>
                <revision date="2017-12-31" version="4.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增一个仪表盘控件。</item>
                    </list>
                </revision>
                <revision date="2018-01-03" version="4.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>饼图控件新增一个是否显示占比很小的信息文本。</item>
                        <item>新增一个旋转开关控件。</item>
                        <item>新增一个信号灯控件。</item>
                    </list>
                </revision>
                <revision date="2018-01-05" version="4.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复modbus tcp客户端读取 float, int, long,的BUG。</item>
                    </list>
                </revision>
                <revision date="2018-01-08" version="4.2.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复modbus tcp客户端读取某些特殊设备会读取不到数据的BUG。</item>
                    </list>
                </revision>
                <revision date="2018-01-15" version="4.2.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>双模式的网络基类中新增一个读取超时的时间设置，如果为负数，那么就不验证返回。</item>
                    </list>
                </revision>
                <revision date="2018-01-24" version="4.3.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>信号灯控件显示优化。</item>
                        <item>Modbus Tcp服务端类修复内存暴涨问题。</item>
                        <item>winfrom客户端提供一个曲线控件，方便显示实时数据，多曲线数据。</item>
                    </list>
                </revision>
                <revision date="2018-02-05" version="4.3.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>优化modbus tcp客户端的访问类，支持服务器返回错误信息。</item>
                        <item>优化曲线控件，支持横轴文本显示，支持辅助线标记，详细见对应博客。</item>
                    </list>
                </revision>
                <revision date="2018-02-22" version="4.3.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>曲线控件最新时间显示BUG修复。</item>
                        <item>Modbus tcp错误码BUG修复。</item>
                        <item>三菱访问类完善long类型读写。</item>
                        <item>西门子访问类支持1500系列，支持读取订货号。</item>
                    </list>
                </revision>
                <revision date="2018-03-05" version="4.3.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>曲线控件增加一个新的属性，图标标题。</item>
                        <item>Modbus tcp服务器端的读写BUG修复。</item>
                        <item>西门子访问类重新支持200smart。</item>
                    </list>
                </revision>
                <revision date="2018-03-07" version="4.3.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Json组件更新至11.0.1版本。</item>
                        <item>紧急修复日志类的BeforeSaveToFile事件在特殊情况的触发BUG。</item>
                    </list>
                </revision>
                <revision date="2018-03-19" version="4.3.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复Modbus-tcp服务器接收异常的BUG。</item>
                        <item>修复SoftBasic.ByteTo[U]ShortArray两个方法异常。</item>
                    </list>
                </revision>
                <revision date="2018-04-05" version="5.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>网络核心层重新开发，完全的基于异步IO实现。</item>
                        <item>所有双模式客户端类进行代码重构，接口统一。</item>
                        <item>完善并扩充OperateResult对象的类型支持。</item>
                        <item>提炼一些基础的更加通用的接口方法，在SoftBasic里面。</item>
                        <item>支持欧姆龙PLC的数据交互。</item>
                        <item>支持三菱的1E帧数据格式。</item>
                        <item>不兼容升级，谨慎操作。</item>
                    </list>
                </revision>
                <revision date="2018-04-10" version="5.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>OperateResult静态方法扩充。</item>
                        <item>文件引擎提升缓存空间到100K，加速文件传输。</item>
                        <item>三菱添加读取单个bool数据。</item>
                        <item>Modbus-tcp客户端支持配置起始地址不是0的服务器。</item>
                        <item>其他代码优化。</item>
                    </list>
                </revision>
                <revision date="2018-04-14" version="5.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>ComplexNet服务器代码精简优化，移除客户端的在线信息维护代码。</item>
                        <item>西门子访问类第一次握手信号18字节改为0x02。</item>
                        <item>更新JSON组件到11.0.2版本。</item>
                        <item>日志存储类优化，支持过滤存储特殊关键字的日志。</item>
                        <item>Demo项目新增控件介绍信息。</item>
                    </list>
                </revision>
                <revision date="2018-04-20" version="5.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复Modbus-Tcp服务器的空异常。</item>
                        <item>修复西门子类写入float，double，long数据异常。</item>
                        <item>修复modbus-tcp客户端读写字符串颠倒异常。</item>
                        <item>修复三菱多读取数据字节的问题。</item>
                        <item>双模式客户端新增异形客户端模式，变成了三模式客户端。</item>
                        <item>提供异形modbus服务器和客户端Demo方便测试。</item>
                    </list>
                </revision>
                <revision date="2018-04-25" version="5.0.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus-tcp服务器同时支持RTU数据交互。</item>
                        <item>异形客户端新增在线监测，自动剔除访问异常设备。</item>
                        <item>modbus-tcp支持读取输入点。</item>
                        <item>所有客户端设备的连接超时判断增加休眠，降低CPU负载。</item>
                        <item>西门子批量读取上限为19个数组。</item>
                        <item>其他小幅度的代码优化。</item>
                    </list>
                </revision>
                <revision date="2018-04-30" version="5.0.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus相关的代码优化。</item>
                        <item>新增Modbus-Rtu客户端模式，配合服务器的串口支持，已经可以实现电脑本机的通讯测试了。</item>
                    </list>
                </revision>
                <revision date="2018-05-04" version="5.0.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>提炼数据转换基类，优化代码，修复WordReverse类对字符串的BUG，相当于修复modbus和omron读写字符串的异常。</item>
                        <item>新增一个全新的功能类，数据的推送类，轻量级的高效的订阅发布数据信息。具体参照Demo。</item>
                    </list>
                </revision>
                <revision date="2018-05-07" version="5.0.7" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus服务器提供在线客户端数量属性。</item>
                        <item>所有服务器基类添加端口缓存。</item>
                        <item>双模式客户端完善连接失败，请求超时的消息提示。</item>
                        <item>修复双模式客户端某些特殊情况下的头子节NULL异常。</item>
                        <item>修复三菱交互类的ASCII协议下的写入数据异常。</item>
                    </list>
                </revision>
                <revision date="2018-05-12" version="5.0.8" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增一个埃夫特机器人的数据访问类。</item>
                        <item>双模式客户端的长连接支持延迟连接操作，通过一个新方法完成。</item>
                    </list>
                </revision>
                <revision date="2018-05-21" version="5.0.9" author="Richard.Hu">
                    <list type="bullet">
                        <item>优化ComplexNet客户端的代码。</item>
                        <item>更新埃夫特机器人的读取机制到最新版。</item>
                        <item>Modbus Rtu及串口基类支持接收超时时间设置，不会一直卡死。</item>
                        <item>Modbus Tcp及Rtu都支持带功能码输入，比如读取100地址，等同于03X100。（注意：该多功能地址仅仅适用于Read及相关的方法</item>
                    </list>
                </revision>
                <revision date="2018-05-22" version="5.0.10" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus Tcp及Rtu支持手动更改站号。也就是支持动态站号调整。</item>
                        <item>修复上个版本遗留的Modbus在地址偏移情况下会多减1的BUG。</item>
                    </list>
                </revision>
                <revision date="2018-06-05" version="5.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus服务器支持串口发送数据时也会触发消息接收。</item>
                        <item>IReadWriteNet接口新增Read(string address,ushort length)方法。</item>
                        <item>提炼统一的设备基类，支持Read方法及其扩展的子方法。</item>
                        <item>修复埃夫特机器人的读取BUG。</item>
                        <item>三菱PLC支持读取定时器，计数器的值，地址格式为"T100"，"C100"。</item>
                        <item>新增快速离散的傅立叶频谱变换算法，并在Demo中测试三种周期信号。</item>
                    </list>
                </revision>
                <revision date="2018-06-16" version="5.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复西门子fetch/write协议对db块，定时器，计数器读写的BUG。</item>
                        <item>埃夫特机器人修复tostring()的方法。</item>
                        <item>modbus客户端新增两个属性，指示是否字节颠倒和字符串颠倒，根据不同的服务器配置。</item>
                        <item>IReadWriteNet接口补充几个数组读取的方法。</item>
                        <item>新增一个全新的连接池功能类，详细请参见 https://www.cnblogs.com/dathlin/p/9191211.html </item>
                        <item>其他的小bug修复，细节优化。</item>
                    </list>
                </revision>
                <revision date="2018-06-27" version="5.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>IByteTransform接口新增bool[]数组转换的2个方法。</item>
                        <item>Modbus Server类新增离散输入数据池和输入寄存器数据池，可以在服务器端读写，在客户端读。</item>
                        <item>Modbus Tcp及Modbus Rtu及java的modbus tcp支持富地址表示，比如"s=2;100"为站号2的地址100信息。</item>
                        <item>Modbus Server修复一个偶尔出现多次异常下线的BUG。</item>
                        <item>其他注释修正。</item>
                    </list>
                </revision>
                <revision date="2018-07-13" version="5.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus服务器新增数据大小端配置。</item>
                        <item>Modbus服务器支持数据存储本地及从本地加载。</item>
                        <item>修复modbus服务器边界读写bug。</item>
                        <item>ByteTransformBase的double转换bug修复。</item>
                        <item>修复ReverseWordTransform批量字节转换时隐藏的一些bug。</item>
                        <item>SoftBasic移除2个数据转换的方法。</item>
                        <item>修复modbus写入单个寄存器的高地位倒置的bug。</item>
                        <item>修复串口通信过程中字节接收不完整的异常。包含modbus服务器和modbus-rtu。</item>
                        <item>添加了.net 4.5项目，并且其他项目源代码引用该项目。添加了单元测试，逐步新增测试方法。</item>
                    </list>
                </revision>
                <revision date="2018-07-27" version="5.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>项目新增api文档，提供离线版和在线版，文档提供了一些示例代码。</item>
                        <item>modbus-rtu新增批量的数组读取方法。</item>
                        <item>modbus-rtu公开ByteTransform属性，方便的进行数据转换。</item>
                        <item>SoftMail删除发送失败10次不能继续发送的机制。</item>
                        <item>modbus server新增站号属性，站号不对的话，不响应rtu反馈。</item>
                        <item>modbus server修复读取65524和65535地址提示越界的bug。</item>
                        <item>Demo项目提供了tcp/ip的调试工具。</item>
                    </list>
                </revision>
                <revision date="2018-08-08" version="5.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>API文档中西门子FW协议示例代码修复。</item>
                        <item>modbus-rtu修复读取线圈和输入线圈的值错误的bug。</item>
                    </list>
                </revision>
                <revision date="2018-08-23" version="5.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>Demo中三菱A-1E帧，修复bool读取显示失败的BUG。</item>
                        <item>数据订阅类客户端连接上服务器后，服务器立即推送一次。</item>
                        <item>串口设备基类代码提炼，提供了多种数据类型的读写支持。</item>
                        <item>仪表盘新增属性IsBigSemiCircle，设置为true之后，仪表盘可显示大于半圆的视图。</item>
                        <item>提供了一个新的三菱串口类，用于采集FX系列的PLC，MelsecFxSerial</item>
                    </list>
                </revision>
                <revision date="2018-08-24" version="5.2.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复双模式基类的一个bug，支持不接受反馈数据。</item>
                        <item>修复三菱串口类的读写bug，包括写入位，和读取字和位。</item>
                        <item>相关代码重构优化。</item>
                    </list>
                </revision>
                <revision date="2018-09-08" version="5.3.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>串口基类接收数据优化，保证接收一次完整的数据内容。</item>
                        <item>新增一个容器罐子的控件，可以调整背景颜色。</item>
                        <item>OperateResult成功时的错误码调整为0。</item>
                        <item>修复modbus-tcp及modbus-rtu读取coil及discrete的1个位时解析异常的bug。</item>
                        <item>授权类公开一个属性，终极秘钥的属性，感谢 洛阳-LYG 的建议。</item>
                        <item>修复transbool方法在特殊情况下的bug</item>
                        <item>NetworkDeviceBase 写入的方法设置为了虚方法，允许子类进行重写。</item>
                        <item>SoftBasic: 新增三个字节处理的方法，移除前端字节，移除后端字节，移除两端字节。</item>
                        <item>新增串口应用的LRC校验方法。还未实际测试。</item>
                        <item>Siemens的s7协议支持V区自动转换，方便数据读取。</item>
                        <item>新增ab plc的类AllenBradleyNet，已测试读写，bool写入仍存在一点问题。</item>
                        <item>新增modbus-Ascii类，该类库还未仔细测试。</item>
                        <item>埃夫特机器人更新，适配最新版本数据采集。</item>
                        <item>其他的代码优化，重构精简</item>
                    </list>
                </revision>
                <revision date="2018-09-10" version="5.3.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复埃夫特机器人读取数据的bug，已测试通过。</item>
                        <item>ByteTransform数据转换层新增一个DataFormat属性，可选ABCD,BADC,CDAB,DCBA</item>
                        <item>三个modbus协议均适配了ByteTransform并提供了直接修改的属性，默认ABCD</item>
                        <item>注意：如果您的旧项目使用的Modbus类，请务必重新测试适配。给你带来的不便，敬请谅解。</item>
                    </list>
                </revision>
                <revision date="2018-09-21" version="5.3.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>所有显示字符串支持中英文，支持切换，默认为系统语言。</item>
                        <item>Json组件依赖设置为不依赖指定版本。</item>
                        <item>modbus-ascii类库测试通过。</item>
                        <item>新增松下的plc串口读写类，还未测试。</item>
                        <item>西门子s7类写入byte数组长度不受限制，原先大概250个字节左右。</item>
                        <item>demo界面进行了部分的中英文适配。</item>
                        <item>OperateResult类新增了一些额外的构造方法。</item>
                        <item>SoftBasic新增了几个字节数组操作相关的通用方法。</item>
                        <item>其他大量的细节的代码优化，重构。</item>
                    </list>
                </revision>
                <revision date="2018-09-27" version="5.3.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>DeviceNet层添加异步的API，支持async+await调用。</item>
                        <item>java修复西门子的写入成功却提示失败的bug。</item>
                        <item>java代码重构，和C#基本保持一致。</item>
                        <item>python版本发布，支持三菱，西门子，欧姆龙，modbus，数据订阅，同步访问。</item>
                        <item>其他的代码优化，重构精简。</item>
                    </list>
                </revision>
                <revision date="2018-10-20" version="5.4.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>python和java的代码优化，完善，添加三菱A-1E类。</item>
                        <item>修复仪表盘控件，最大值小于0会产生的特殊Bug。</item>
                        <item>NetSimplifyClient: 提供高级.net的异步版本方法。</item>
                        <item>serialBase: 新增初始化和结束的保护方法，允许重写实现额外的操作。</item>
                        <item>softBuffer: 添加一个线程安全的buffer内存读写。</item>
                        <item>添加西门子ppi协议类，针对s7-200，需要最终测试。</item>
                        <item>Panasonic: 修复松下plc的读取读取数据异常。</item>
                        <item>修复fx协议批量读取bool时意外的Bug。</item>
                        <item>NetSimplifyClient: 新增带用户int数据返回的读取接口。</item>
                    </list>
                </revision>
                <revision date="2018-10-24" version="5.4.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增一个温度采集模块的类，基于modbus-rtu实现，阿尔泰科技发展有限公司的DAM3601模块。</item>
                    </list>
                </revision>
                <revision date="2018-10-25" version="5.4.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>三菱的mc协议新增支持读取ZR文件寄存器功能。</item>
                    </list>
                </revision>
                <revision date="2018-10-30" version="5.4.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复AB PLC的bool和byte写入失败的bug，感谢 北京-XLang 提供的思路。</item>
                    </list>
                </revision>
                <revision date="2018-11-1" version="5.5.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增西门子PPI通讯类库，支持200，200smart等串口通信，感谢 合肥-加劲 和 江阴-  ∮溪风-⊙_⌒ 的测试</item>
                    </list>
                </revision>
                <revision date="2018-11-5" version="5.5.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增三菱计算机链接协议通讯库，支持485组网，有效距离达50米，感谢珠海-刀客的测试。</item>
                        <item>串口协议的基类提供了检测当前串口是否处于打开的方法接口。</item>
                        <item>西门子S7协议新增槽号为3的s7-400的PLC选项，等待测试。</item>
                    </list>
                </revision>
                <revision date="2018-11-9" version="5.5.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>西门子PPI写入bool方法名重载到了Write方法里。</item>
                        <item>松下写入bool方法名重载到了Write方法里。</item>
                        <item>修复CRC16验证码在某些特殊情况下的溢出bug。</item>
                        <item>西门子类添加槽号和机架号属性，只针对400PLC有效，初步测试可读写。</item>
                        <item>ab plc支持对数组的读写操作，支持数组长度为0-246，超过246即失败。</item>
                        <item>三菱的编程口协议修复某些特殊情况读取失败，却提示成功的bug。</item>
                        <item>串口基类提高缓存空间到4096，并在数据交互时捕获COM口的异常。</item>
                    </list>
                </revision>
                <revision date="2018-11-16" version="5.6.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复欧姆龙的数据格式错误，修改为CDAB。</item>
                        <item>新增一个瓶子的控件。</item>
                        <item>新增一个管道的控件。</item>
                        <item>初步新增一个redis的类，初步实现了读写关键字。</item>
                    </list>
                </revision>
                <revision date="2018-11-21" version="5.6.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>AB PLC读取数组过长时提示错误信息。</item>
                        <item>正式发布redis客户端，支持一些常用的操作，并提供一个浏览器。博客：https://www.cnblogs.com/dathlin/p/9998013.html </item>
                    </list>
                </revision>
                <revision date="2018-11-24" version="5.6.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>曲线控件的曲线支持隐藏其中的一条或是多条曲线，可以用来实现手动选择显示曲线的功能。</item>
                        <item>Redis功能块代码优化，支持通知服务器进行数据快照保存，包括同步异步。</item>
                        <item>Redis新增订阅客户端类，可以实现订阅一个或是多个频道数据。</item>
                    </list>
                </revision>
                <revision date="2018-11-30" version="5.6.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>串口数据接收的底层机制重新设计。</item>
                        <item>串口底层循环验证缓冲区是否有数据的间隔可更改，默认20ms。</item>
                        <item>串口底层新增一个清除缓冲区数据的方法。</item>
                        <item>串口底层新增一个属性，用于配置是否在每次读写前清除缓冲区的脏数据。</item>
                        <item>新增了一个SharpList类，用于超高性能的管理固定长度的数组。博客：https://www.cnblogs.com/dathlin/p/10042801.html </item>
                    </list>
                </revision>
                <revision date="2018-12-3" version="5.6.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Networkbase: 接收方法的一个多余对象删除。</item>
                        <item>修复UserDrum控件的默认的text生成，及复制问题。</item>
                        <item>UserDrum修复属性在设计界面没有注释的bug。</item>
                    </list>
                </revision>
                <revision date="2018-12-5" version="5.6.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复Demo程序在某些特殊情况下无法在线更新的bug。</item>
                        <item>修复曲线控件隐藏曲线时在某些特殊情况的不隐藏的bug。</item>
                        <item>modbus协议无论读写都支持富地址格式。</item>
                        <item>修复连接池清理资源的一个bug，感谢 泉州-邱蕃金</item>
                        <item>修复java的modbus代码读取线圈异常的操作。</item>
                        <item>Demo程序新增免责条款。</item>
                    </list>
                </revision>
                <revision date="2018-12-11" version="5.6.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复redis客户端对键值进行自增自减指令操作时的类型错误bug。</item>
                        <item>修复redis客户端对哈希值进行自增自减指令操作时的类型错误bug。</item>
                        <item>推送的客户端可选委托或是事件的方式，方便labview调用。</item>
                        <item>推送的客户端修复当服务器的关键字不存在时连接未关闭的Bug。</item>
                        <item>Demo程序里，欧姆龙测试界面新增数据格式功能。</item>
                    </list>
                </revision>
                <revision date="2018-12-19" version="5.6.7" author="Richard.Hu">
                    <list type="bullet">
                        <item>ByteTransfer数据转换类新增了一个重载的构造方法。</item>
                        <item>Redis客户提供了一个写键值并发布订阅的方法。</item>
                        <item>AB-PLC支持槽号选择，默认为0。</item>
                        <item>PushNet推送服务器新增一个配置，可用于设置是否在客户端刚上线的时候推送缓存数据。</item>
                        <item>PushNet推送服务器对客户端的上下限管理的小bug修复。</item>
                        <item>本版本开始，组件将使用强签名。</item>
                        <item>本版本开始，组件的控件库将不再维护更新，所有的控件在新的控件库重新实现和功能增强，VIP群将免费使用控件库。</item>
                        <item>VIP群的进入资格调整为赞助200Rmb，谢谢支持。</item>
                    </list>
                </revision>
                <revision date="2018-12-27" version="5.7.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复modbus服务器地址写入的bug，之前写入地址数据后无效，必须带x=3;100才可以。</item>
                        <item>修复极少数情况内核对象申请失败的bug，之前会引发资源耗尽的bug。</item>
                        <item>SoftBasic的ByteToBoolArray新增一个转换所有位的重载方法，不需要再传递位数。</item>
                        <item>埃夫特机器人新增旧版的访问类对象，达到兼容的目的。</item>
                        <item>Demo程序新增作者简介。</item>
                        <item>修复Demo程序的redis订阅界面在设置密码下无效的bug。</item>
                        <item>Demo程序的免责界面新增demo在全球的使用情况。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2018-12-31" version="5.7.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复modbus服务器地址读取的bug，之前读取地址数据后无效，必须带x=3;100才可以。</item>
                        <item>NetPush功能里，当客户端订阅关键字时，服务器即使没有该关键字，也成功。</item>
                        <item>三菱的通讯类支持所有的字读取。例如读取M100的short数据表示M100-M115。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-1-15" version="5.7.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复三菱A-1E协议的读取数据的BUG错误，给大家造成的不便，非常抱歉。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-2-7" version="5.7.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>欧姆龙读写机制更改，报警的异常不再视为失败，仍然可以解析数据。</item>
                        <item>Modbus地址优化，Modbus服务器的地址读写优化。</item>
                        <item>新增一个数据池类，SoftBuffer，主要用来缓存字节数组内存的，支持BCL数据类型读写。</item>
                        <item>Modbus服务器的数据池更新，使用了最新的数据池类SoftBuffer。</item>
                        <item>SoftBasic类新增一个GetEnumFromString方法，支持从字符串直接生成枚举值，已通过单元测试。</item>
                        <item>新增一个机器人的读取接口信息IRobotNet，统一化所有的机器人的数据读取。</item>
                        <item>Demo程序中增加modbus的服务器功能。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-2-13" version="5.7.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>日志存储的线程号格式化改为D3，也即三位有效数字。</item>
                        <item>日志存储事件BeforeSaveToFile里允许设置日志Cancel属性，强制当前的记录不存储。</item>
                        <item>JSON库更新到12.0.1版本。</item>
                        <item>SoftBasic新增一个GetTimeSpanDescription方法，用来将时间差转换成文本的方法。</item>
                        <item>调整日志分析控件不随字体变化而变化。</item>
                        <item>其他的代码精简优化。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-2-21" version="5.8.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>SoftBasic修复AddArrayData方法批量添加数据异常的bug，导致曲线控件显示异常。</item>
                        <item>提炼一个公共的欧姆龙辅助类，准备为串口协议做基础的通用支持。</item>
                        <item>RedisHelper类代码优化精简，提炼部分的公共逻辑到NetSupport。</item>
                        <item>SoftBuffer: 新增读写单个的位操作，通过位的与或非来实现。</item>
                        <item>SiemensS7Server：新增一个s7协议的服务器，可以模拟PLC，进行通讯测试或是虚拟开发。</item>
                        <item>其他的代码精简优化。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-3-4" version="6.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>西门子虚拟PLC的ToString()方法重新实现。</item>
                        <item>埃夫特机器人的json格式化修正换行符。</item>
                        <item>IReadWriteNet接口添加Write(address, bytes)的方法。</item>
                        <item>Modbus虚拟服务器修复写入位操作时影响后面3个位的bug。</item>
                        <item>SoftBuffer内存数据池类的SetValue(byte,index)的bug修复。</item>
                        <item>西门子虚拟PLC和Modbus服务器新增客户端管理，关闭时也即断开所有连接。</item>
                        <item>三菱编程口协议的读取结果添加错误说明，显示原始返回信号，便于分析。</item>
                        <item>三菱MC协议新增远程启动，停止，读取PLC型号的接口。</item>
                        <item>新增三菱MC协议的串口的A-3C协议支持，允许读写三菱PLC的数据。</item>
                        <item>新增欧姆龙HostLink协议支持，允许读写PLC数据。</item>
                        <item>新增基恩士PLC的MC协议支持，包括二进制和ASCII格式，支持读写PLC的数据。</item>
                        <item>所有PLC的地址说明重新规划，统一在API文档中查询。</item>
                        <item>注意：三菱PLC的地址升级，有一些地址格式进行了更改，比如定时器和计数器，谨慎更新，详细地址参考最新文档。</item>
                        <item>如果有公司使用了本库并愿意公开logo的，将在官网及git上进行统一显示，有意愿的联系作者。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-3-10" version="6.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复代码注释上的一些bug，三菱的注释修复。</item>
                        <item>调整三菱和基恩士D区数据和W区数据的地址范围，原来只支持到65535。</item>
                        <item>SoftIncrementCount: 修复不持久化的序号自增类的数据复原的bug，并添加totring方法。</item>
                        <item>IRobot接口更改。针对埃夫特机器人进行重新实现。</item>
                        <item>RedisClient: 修复redis类在带有密码的情况下锁死的bug。</item>
                        <item>初步添加Kuka机器人的通讯类，等待测试。</item>
                        <item>西门子的s7协议读写字符串重新实现，根据西门子的底层存储规则来操作。</item>
                        <item>Demo的绝大多的界面进行重构。更友好的支持英文版的显示风格。</item>
                        <item>如果有公司使用了本库并愿意公开logo的，将在官网及git上进行统一显示，有意愿的联系作者。</item>
                    </list>
                </revision>
                <revision date="2019-3-21" version="6.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复西门子s7协议读写200smart字符串的bug。</item>
                        <item>重构优化NetworkBase及NetwordDoubleBase网络类的代码。</item>
                        <item>新增欧姆龙的FinsUdp的实现，DA1【PLC节点号】在配置Ip地址的时候自动赋值，不需要额外配置。</item>
                        <item>FinsTcp类的DA1【PLC节点号】在配置Ip地址的时候自动赋值，不需要额外配置。</item>
                    </list>
                </revision>
                <revision date="2019-3-28" version="6.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>NetPushServer推送服务器修复某些情况下的推送卡死的bug。</item>
                        <item>SoftBuffer内存数据类修复Double转换时出现的错误bug。</item>
                        <item>修复Kuka机器人读写数据错误的bug，已通过测试。</item>
                        <item>修复三菱的MelsecMcAsciiNet类写入bool值及数组会导致异常的bug，已通过单元测试。</item>
                        <item>SoftBasic新增从字符串计算MD5码的方法。</item>
                    </list>
                </revision>
                <revision date="2019-4-4" version="6.0.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复java的NetPushClient掉线重复连接的bug。</item>
                        <item>发布java的全新测试Demo。</item>
                        <item>Kuka机器人Demo修改帮助链接。</item>
                        <item>西门子新增s200的以太网模块连接对象。</item>
                        <item>修复文件引擎在上传文件时意外失败，服务器仍然识别为成功的bug。</item>
                    </list>
                </revision>
                <revision date="2019-4-17" version="6.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复日志存储自身异常时，时间没有初始化的bug。</item>
                        <item>NetworkBase: 新增UseSynchronousNet属性，默认为true，通过同步的网络进行读写数据，异步手动设置为false。</item>
                        <item>修复西门子的读写字符串的bug。</item>
                        <item>添加KeyenceNanoSerial以支持基恩士Nano系列串口通信。</item>
                        <item>其他的代码优化。</item>
                        <item>发布一个基于xamarin的安卓测试demo。</item>
                        <item>发布官方论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-4-24" version="6.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复基恩士MC协议读取D区数据索引不能大于100000的bug。</item>
                        <item>修复基恩士串口协议读写bool数据的异常bug。</item>
                        <item>修复数据推送服务器在客户端异常断开时的奔溃bug，界面卡死bug。</item>
                        <item>SoftNumericalOrder类新增数据重置和，最大数限制 。</item>
                        <item>ModbusTcp客户端公开属性SoftIncrementCount，可以强制消息号不变，或是最大值。</item>
                        <item>NetworkBase: 异步的方法针对Net451及standard版本重写。</item>
                        <term>modbus服务器的方法ReadFromModbusCore( byte[] modbusCore )设置为虚方法，可以继承重写，实现自定义返回。</term>
                        <item>串口基类serialbase的初始化方法新增多个重载方法，方便VB和labview调用。</item>
                        <item>NetworkBase: 默认的机制任然使用异步实现，UseSynchronousNet=false。</item>
                        <item>发布官方论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-4-25" version="6.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>紧急修复在NET451和Core里的异步读取的bug。</item>
                        <item>紧急修复PushNetServer的发送回调bug。</item>
                        <item>发布官方论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-5-6" version="6.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>SoftBuffer缓存类支持bool数据的读写，bool数组的读写，并修复double读写的bug。</item>
                        <item>Modbus虚拟服务器代码重构实现，继承自NetworkDataServerBase类。</item>
                        <item>新增韩国品牌LS的Fast Enet协议</item>
                        <item>新增韩国品牌LS的Cnet协议</item>
                        <item>新增三菱mc协议的虚拟服务器，仅支持二进制格式的机制。</item>
                        <item>LogNet支持写入任意的字符串格式。</item>
                        <item>其他的注释添加及代码优化。</item>
                        <item>发布官方论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-5-9" version="6.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复三菱读写PLC位时的bug。</item>
                        <item>修复Modbus读写线圈及离散的变量bug。</item>
                        <item>强烈建议更新，不能使用6.2.0版本！或是回退更低的版本。</item>
                        <item>有问题先上论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-5-10" version="6.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复上个版本modbus的致命bug，已通过单元测试。</item>
                        <item>新增松下的mc协议，demo已经新增，等待测试。</item>
                        <item>github源代码里的支持的型号需要大家一起完善。</item>
                    </list>
                </revision>
                <revision date="2019-5-31" version="6.2.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>Ls的Fast Enet协议问题修复，感谢来自埃及朋友。</item>
                        <item>Ls的CEnet协议问题修复，感谢来自埃及朋友。</item>
                        <item>Ls新增虚拟的PLC服务器，感谢来自埃及朋友。</item>
                        <item>改进了机器码获取的方法，获取实际的硬盘串号。</item>
                        <item>日志的等级为None的情况，不再格式化字符串，原生写入日志。</item>
                        <item>IReadWriteNet接口测试西门子的写入，没有问题。</item>
                        <term>三菱及松下，基恩士的地址都调整为最大20亿长度，实际取决于PLC本身。</term>
                        <item>松下MC协议修复LD数据库的读写bug。</item>
                        <item>Redis的DEMO界面新增删除key功能。</item>
                    </list>
                </revision>
                <revision date="2019-6-3" version="6.2.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Redis新增读取服务器的时间接口，可用于客户端的时间同步。</item>
                    </list>
                </revision>
                <revision date="2019-6-6" version="6.2.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>西门子的SiemensS7Net类当读取PLC配置长度的DB块数据时，将提示错误信息。</item>
                    </list>
                </revision>
                <revision date="2019-6-22 " version="7.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增安川机器人通信类，未测试。</item>
                        <item>西门子的多地址读取的长度不再限制为19个，而是无限制个。</item>
                        <item>NetworkDoubleBase: 实现IDispose接口，方便手动释放资源。</item>
                        <item>SerialBase: 实现IDispose接口，方便手动释放资源。</item>
                        <item>NetSimplifyClient:新增一个async...await方法。</item>
                        <item>NetSimplifyClient:新增读取字符串数组。</item>
                        <item>ModbusServer:新增支持账户密码登录，用于构建安全的服务器，仅支持hsl组件的modbus安全访问。</item>
                        <item>NetSimplifyServer:新增支持账户密码登录。</item>
                        <item>新增永宏PLC的编程口协议。</item>
                        <item>新增富士PLC的串口通信，未测试。</item>
                        <item>新增欧姆龙PLC的CIP协议通讯。</item>
                        <item>初步添加OpenProtocol协议，还未完成，为测试。</item>
                        <item>MelsecMcNet:字单位的批量读取长度突破960长度的限制，支持读取任意长度。</item>
                        <item>MelsecMcAsciiNet:字单位的批量读取长度突破480长度的限制，支持读取任意长度。</item>
                        <item>AllenBradleyNet:读取地址优化，支持读取数组任意起始位置，任意长度，支持结构体嵌套读取。</item>
                        <item>其他大量的代码细节优化。</item>
                    </list>
                </revision>
                <revision date="2019-6-25" version="7.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>IReadWriteNet完善几个忘记添加的Write不同类型参数的重载方法。</item>
                        <item>IReadWriteNet新增ReadBool方法，Write(string address, bool value)方法，是否支持操作需要看plc是否支持，不支持返回操作不支持的错误。</item>
                        <item>OmronFinsNet:新增一个属性，IsChangeSA1AfterReadFailed，当设置为True时，通信失败后，就会自动修改SA1的值，这样就能快速链接上PLC了。</item>
                        <item>OmronFinsNet:新增读写E区的能力，地址示例E0.0，EF.100，E12.200。</item>
                        <item>新增HslDeviceAddress特性类，现在支持直接基于对象的读写操作，提供了一种更加便捷的读写数据的机制，详细的关注后续的论坛。</item>
                        <item>本组件的最后一个对个人免费的版本，企业使用一律需要授权，授权流程为签合同，付款，开票。</item>
                    </list>
                </revision>
                <revision date="2019-9-10" version="8.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>SimpleHybirdLock: 简单混合锁的性能优化，基元对象采用懒加载的机制实现，同时增加了高级混合锁的类，支持自旋，线程拥有权，在高竞争的情况下性能大幅增加。</item>
                        <item>NetSoftUpdateServer: 软件自动更新的服务器端支持传送指定目录下的文件及其子文件夹下的所有文件内容，都将更新到客户端的电脑上去。</item>
                        <item>AllenBradleyNet: 修复字符串的读写bug，支持读写任意长度的字符串信息。</item>
                        <item>MelsecFxSerial: 三菱编程口协议支持读写D1024以上地址的数据，感谢 厦门-Mr.T 的贡献。</item>
                        <item>PIDHelper: 新增一个Pid的辅助类，用于模拟pid的波形情况。</item>
                        <item>NetPushClient: 修改一个时间的注释，追加单位信息，时间的单位是毫秒。</item>
                        <item>XGBFastEnet: 感谢埃及的朋友，修复了一些bug信息。</item>
                        <item>MelsecFxSerialOverTcp: 新增基于网口透传的三菱的编程口通讯类。</item>
                        <item>MelsecFxLinksOverTcp: 新增基于网口透传的三菱的计算机链接协议的通讯类。</item>
                        <item>MelsecA3CNet1OverTcp: 新增基于网口透传的三菱的A-3C的协议的通讯类。</item>
                        <item>OmronHostLinkOverTcp: 新增基于网口透传的欧姆龙的hostLink协议的通讯类。</item>
                        <item>PanasonicMewtocolOverTcp: 新增基于网口透传的松下的Mewtocol协议的通讯类。</item>
                        <item>SiemensPPIOverTcp: 新增基于网口透传的西门子PPi协议的通讯类。</item>
                        <item>XGBCnetOverTcp: 新增基于网口透传的Lsis的XGBCnet协议的通讯类。</item>
                        <item>KeyenceNanoSerialOverTcp: 新增基于网口透传的基恩士的NanoSerial串口协议的通讯类。</item>
                        <item>FujiSPBOverTcp: 新增基于网口透传的富士的SPB串口协议的通讯类。</item>
                        <term>FatekProgramOverTcp: 新增基于网口透传的永宏plc的串口协议的通讯类。</term>
                        <item>ModbusRtuOverTcp: 新增基于网口透传的Modbus rtu协议的通讯类。</item>
                        <item>Modbus相关的功能类进行代码精简，重构，优化，api标准化为ReadBool,WriteBool,Read,Write，移除了一些特殊的方法api，本次升级不兼容。</item>
                        <item>FFTFilter: 新增一个基于FFT（快速离散傅立叶变换）的滤波功能，可以作为一个高级的曲线拟合方案，详细参照demo，感谢 北京-monk 网友的支持。</item>
                        <item>KnxUdp: 新增一个KnxUdp的数据通讯类，感谢上海-null的支持。</item>
                        <item>ABBWebApiClient: 新增ABB机器人的基于web api的访问机制的通讯类。</item>
                        <item>SickIcrTcpServer: 新增一个sick的条码读取类，支持被动连接，主动连接，经过测试，同时支持海康，基恩士，DATELOGIC扫码器。</item>
                        <item>Demo: Demo工具新增了一个基于tcp的服务器的测试界面。</item>
                        <item>本组件从v8.0.0开始进入付费模式，谨慎升级，未激活的将只能使用8小时，普通vip群发放激活码，仅支持个人用途使用，禁止破解，感谢对正版的支持。</item>
                        <item>今天是2019年9月10日，祝天下所有的教师节日快乐。</item>
                    </list>
                </revision>
                <revision date="2019-9-17" version="8.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>所有网口透传类对象完善实例化的方法，都新增一个指定ip及端口的实例方法。</item>
                        <item>ABBWebClient: 完善实例化方法，修改ToString的格式化内容，提炼了webapi的基类，开放ip地址和端口。</item>
                        <item>ABBWebClient: 新增提供了机器人自身IO，扩展IO，最新的报警日志的数据读取API。</item>
                        <item>NetSimplifyClient: 修复了当ReceiveTimeOut小于0，但是实际接收时会发生奔溃的bug。</item>
                        <item>NetPlainSocket: 新增一个基于socket的明文的网络发送和接收类，采用事件驱动的机制。</item>
                        <item>LogNet: 日志类对象新增一个特性，当日志的文件名设置为空的时候，将不会创建文件，仅仅触发 BeforSaveToFile 事件，方便日志显示。</item>
                        <item>XGBCnet: Lsis的plc的串口类修复一个bug，感谢埃及朋友的贡献。</item>
                        <item>SoftIncrementCount: 消息号自增类新增一个方法，重置当前的消息号。</item>
                        <item>PanasonicMewtocol: 修复松下的串口类读写单个bool时异常的bug，地址支持字+位的表示方式，R33=R2.1，方便大家输入测试。</item>
                        <item>MqttClient: 新增一个Mqtt协议的客户端类，支持用户名密码，支持发布，支持订阅，支持重连，欢迎一起测试。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-9-19" version="8.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>ABBWebClient: abb机器人的api读取日志的接口新增一个参数，读取最近的日志数量。默认为10条。</item>
                        <item>MQTTClient: 修复mqtt客户端类的消息重复bug，修复发送空订阅的bug。</item>
                        <item>SiemensS7Net: 西门子的s7协议的类新增一个api，支持时间的读写，支持异步，时间格式和s7net一致。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-9-26" version="8.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>Networkbase: 修复套接字网络授权失败时不关闭网络的bug。</item>
                        <item>SoftBasic: 新增一个数组数据格式化的方法信息。</item>
                        <item>MqttServer: 新增一个mqtt的服务器，初步支持订阅，发布订阅，强制发布订阅，在线客户端数量功能等等。</item>
                        <item>Demo: 所有的PLC的demo和modbus协议的demo，支持批量读取各种类型的数组数据。</item>
                        <item>Nuget: 新增本项目的图标，在nuget上搜索时会显示图标。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-10-7" version="8.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>ModbusUdp: 新增一个Modbus的基于udp的协议类，使用的tcp的报文的机制。</item>
                        <item>HttpServer: 新增一个http的服务器封装类，方便实现基于webapi的后台功能，集成GET，POST的接口操作。</item>
                        <item>Serial Ports: standard项目依赖官方串口库，实现所有的设备的串口支持，可应用于跨平台。</item>
                        <item>standard: 在nuget上提供.net standard2.1版本的库。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-10-11" version="8.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Lsis: 感谢埃及朋友的支持，修复了一些bug，支持了bool的操作。</item>
                        <item>Redis: 新增db块属性设置，修复短连接下切换db块无效的bug，因为db块是跟随连接的。</item>
                        <item>MQTT: 修复客户端和服务器的长度计算bug，支持和其他mqtt组件混合使用。</item>
                        <item>MQTT Demo: 优化demo功能，支持文本追加或是覆盖选择，文本格式化查看选择。</item>
                        <item>Http Server: 支持跨域属性选择，编码统一为utf-8，兼容浏览器和postman，demo中增加返回类型示例。</item>
                        <item>Modbus server及Lsis Server: 针对.net standard版本，开放串口。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-10-16" version="8.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>Lsis: 感谢埃及朋友的支持，demo增加了bool操作。</item>
                        <item>Knx驱动：增加测试demo，完善驱动，测试通过，有需要的朋友可以查看信息。</item>
                        <item>IntegrationFileClient: 完善文件的收发类，新增重载的构造方法，传入ip地址及端口即可。</item>
                        <item>melsec: 三菱的MC协议部分错误代码关联了文本信息，在测试的时候即可弹出错误信息，方便排查，常见了已经绑定。</item>
                        <item>melsec: 新增3e协议的随机字批量读取操作，支持跨地址，跨数据类型混合交叉读取，一次即可读完。</item>
                        <item>fileserver: 修复linux下的bug，新增上传文件后的触发事件，将文件的信息都传递给调用者。</item>
                        <item>SiemensMpi: 添加MPI协议，并完善demo，等待测试。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-10-24" version="8.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>Lsis: 感谢埃及朋友的支持，demo完善了cpu类型的选择。</item>
                        <item>LogNet:新增移除关键字的接口方法，修复linux运行路径解析的bug，完善api文档的示例代码。</item>
                        <item>大量的细节优化，变量名称单次拼写错误的修复。</item>
                        <item>Modbus: 当地址为x=3;100时，读正常，写入异常的问题修复，功能码自动替换为0x10。</item>
                        <item>FileNet: 修复高并发下载时的下载异常的问题，调整指令头的超时时间。</item>
                        <item>AB plc: 公开一个新的api接口，运行配置一些比较高级的数据。</item>
                        <item>接下来计划：1.完善hsl的demo，api文档，准备基础的入门视频；2.开始完善java版本的代码，java版本只对超级VIP群开放。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-12-3" version="8.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>三菱的MC协议支持读取SM和SD，特殊连接继电器，特殊寄存器。</item>
                        <item>PushNet优化相关代码。</item>
                        <item>MelsecMcUdp: 新增三菱的MC协议的UDP通讯类。</item>
                        <item>MelsecMcAsciiUdp: 新增三菱的MC协议的ASCII格式的UDP通讯类。</item>
                        <item>MelsecMcServer: 三菱的虚拟服务器修复数据存储加载的bug。</item>
                        <item>Serial: 串口的基类公开了一个Rts属性，用于某些串口无法读取的设备的情况。</item>
                        <item>OmronFinsServer: 新增欧姆龙的虚拟plc，支持和hsl自身的通讯，支持cio，h区，ar区，d区的通信，不支持E区。</item>
                        <item>AllenBradleyServer: 新增ab plc的虚拟plc，支持和hsl的自身的通讯，在demo里预设了4个变量值。不支持结构体和二维及以上数组读写。</item>
                        <item>Aline: 异形的服务器对象新增一个设置属性，是否反馈注册结果，默认为True。</item>
                        <item>SoftBasic: 数组格式化操作新增格式化的字符串说明。</item>
                        <item>Modbus: 调整Write( string address, bool value )采用05功能码写入，而参数为bool[]的话，采用0F功能码。</item>
                        <item>Modbus: 提供WriteOneRegister方法，写入单个的寄存器，使用06功能码。</item>
                        <item>LogNet: 日志在实例化的时候，添加对当前设置的目录的是否存在的检查，如果不存在，则自动创建目录。</item>
                        <item>Python: 大量代码更新，新增了一个欧姆龙的fins-tcp通信。</item>
                        <item>Java: 大量代码更新，新增了一个AB plc的读写类。</item>
                    </list>
                </revision>
                <revision date="2019-12-11" version="8.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Cip协议：cip协议开放Eip指令自定义输入，优化指令生成算法。</item>
                        <item>Cip协议：Write(string address, byte[] data)方法提示使用WriteTag信息。</item>
                        <item>NetworkDoubleBase: 修复bool异步读写提示不支持的bug，现在可以使用异步了。</item>
                        <item>SAMSerial：新增身份证阅读器的串口协议，支持读取身份证信息，头像信息还未解密。</item>
                        <item>SAMTcpNet：新增身份证阅读器的串口透传协议，支持读取身份证信息，头像信息还未解密。</item>
                        <item>BeckhoffAdsNet：新增倍福plc的协议，还未通过测试。</item>
                    </list>
                </revision>
                <revision date="2020-1-3" version="8.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>lsis的plc优化，感谢埃及朋友的提供的技术支持。</item>
                        <item>Panasonic: 松下的Mewtocol协议增加SR区的支持，解析地址的方法修改为Public，方便外面调用。</item>
                        <item>Panasonic: 松下的Mewtocol协议批量读取bool方法是按字为单位，读取长度按照位为单位，地址写Y0，Y1，不能写Y0.4。</item>
                        <item>ab-plc: 虚拟服务器修复上个版本造成的bug，导致读写数据成功，但是数据实际没有更改。</item>
                        <item>ab-plc: 支持超长的数组读取，可以一次性读取任意长度的数组内容，不再需要手动切片。</item>
                        <item>ab-plc: 新增一个api接口，可以遍历所有的ab-plc的变量名称。</item>
                        <item>beckoff: 倍福的plc通信通过测试，需要设置正确各种网络号才可以，优化了标签缓存。</item>
                        <item>java: java版本的ab-plc类优化，支持超长的数组读取。</item>
                        <item>python: python版本的代码新增ab-plc的读取类。</item>
                        <item>demo: 安卓的demo增加lsis，mqtt协议的界面。</item>
                        <item>Melsec: 三菱PLC的多块批量读取目前只支持字地址，后续继续优化。</item>
                        <item>其他的代码优化和重构。</item>
                        <item>java版本的源代码及demo，python版本的源代码及demo仅对商业授权用户开放，谢谢支持。</item>
                        <item>作者于2020年1月5日和王女士结婚，地址是浙江省金华市兰溪市马涧镇，欢迎有空的老铁们来坐坐，带红包就行。</item>
                    </list>
                </revision>
                <revision date="2020-2-13" version="9.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>宣布V9版本脱胎换骨，浴火重生，C#版本的组件库底层网络大幅重构，删除一直以来的伪异步，原先的通过改为纯同步，并从底层提供完整的异步方法。</item>
                        <item>注意：不兼容升级，影响范围，MQTT协议的事件，网络的同步设置，西门子的PPI协议取消WriteByte方法，改为和其他一样的Write(string address,byte value)重载了，升级请谨慎测试。</item>
                        <item>所有的PLC通讯类，机器人类通讯类，Modbus通讯类，身份证类，包括 IReadWriteNet 接口都实现了异步的操作，针对NET45以上及Standard平台。</item>
                        <item>MQTT协议修改触发的消息事件，返回session信息，支持自定义返回数据信息，支持当前消息的发布拦截操作，服务器主送发布的消息支持是否驻留，默认主题驻留。</item>
                        <item>新增websocket协议的服务器，客户端，问答客户端。支持直接从C#的后台发送数据到网页前端，支持订阅操作。详细见demo的操作。</item>
                        <item>ComplexNet,SimplifyNet,PushNet,FileNet这几个网络引擎代码优化，初步测试OK。</item>
                        <item>SoftBasic: 新增方法SpliceStringArray，用来合并字符串信息。增加了ByteToHexString的空校验。</item>
                        <item>HttpServer: 异步优化，修复读取数据时可能长度不足的bug。</item>
                        <item>YRC1000: 安川机器人修改无法读取的bug，目前已经测试通过，感谢网友的支持。</item>
                        <item>Java: 修复ab-plc读取失败的错误信息，原因来自一个强制转换失败的错误。</item>
                        <item>本版本改动较多，尽管我已经仔细测试过，但是仍然不可避免存在一些bug，欢迎大家使用，测试，有问题可以报告给我，相信hsl组件会变的更加强大。</item>
                        <item>本版本依然是商业授权的，如果需要测试，可以付费240rmb，加入vip群，可以将hsl用于测试环境和研究学术用途，欢迎大家加我的支付宝好友，hsl200909@163.com </item>
                        <item>加油，武汉！加油，中国！疫情之后，无人自动化工厂将会获得更大的关注和发展，我辈当自强。</item>
                    </list>
                </revision>
                <revision date="2020-2-19" version="9.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>底层的网络在对方关闭连接后，不再等待接收，直接返回对方已关闭的错误信息，提供通信的性能。</item>
                        <item>四个服务器类，complexserver, simplifyserver,mqttserver,websocketserver开发关闭客户端连接的方法，调用者可以手动操作关闭。</item>
                        <item>MQTT服务器新增一个客户端上线事件，包含客户端的会话参数，方便实现一些特殊的场景需求，在api文档中增加调用示例。</item>
                        <item>Websocket服务器新增一个客户端上线事件，包含客户端的会话参数，方便实现一些特殊的场景需求。</item>
                        <item>Websocket服务器添加0x0A的心跳返回，用于有些客户端的心跳验证操作。</item>
                        <item>RedisClient: redis相关的代码优化，调整，添加了异步api接口，本机性能测试不如同步，有待优化。</item>
                        <item>RedisClient: 新增基于特性的读写，自动组合键批量读取，组合哈希键批量读取操作，提升性能，详细参考api文档。写入操作不支持列表相关的特性。</item>
                        <item>Demo的写入byte操作的反射代码获取失败的bug修复。</item>
                    </list>
                </revision>
                <revision date="2020-2-25" version="9.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复websocket对某些浏览器的请求验证失败的bug，改为正则表达式验证，适用的范围更加广阔。</item>
                        <item>三菱的mc协议的错误信息更加明确化，将提供更加确切的错误描述，方便大家查找错误。</item>
                        <item>websocket客户端新增连接服务器成功的事件，方便实现类似订阅的功能。</item>
                        <item>Websocket服务器添加心跳检测功能，将会定期（可以自定义）发送心跳包给客户端，在检测客户端是否在线。</item>
                        <item>文件的服务器和客户端开放文件缓存大小的属性，默认100K，越大的话，性能越高，越占内存。</item>
                        <item>Modbus协议功能调整，Write(string,short)和Write(string,ushort)功能码调整为06，如果需要0x10功能码，使用Write(string,short[])和Write(string,ushort[])</item>
                        <item>新增汇川PLC的通讯类，基于modbus协议，但是实现了地址的自动解析，输入D100即可自动转为modbus的地址，包含AM系列，H3U系列，H5U系列等</item>
                        <item>在示例文档中，新增大量的代码说明，完善注释，如果有任何的问题，优先参考api文档。</item>
                        <item>官网新增一个来自上海亦仕智能科技有限公司 MES DEMO： http://111.229.255.209 账号SF  密码 123 </item>
                    </list>
                </revision>
                <revision date="2020-3-3" version="9.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复汇川PLC的地址示例文档写错的bug。</item>
                        <item>IReadWriteNet标准化字符串读写操作，新增定制编码的字符串读写。netDeviceBase移除之前的writeunicode的方法。这点如果有使用，谨慎更新。</item>
                        <item>串口基类和UDP基类的数据交互方法新增日志记录，对发送的数据和接收的数据写入debug等级的日志。</item>
                        <item>数据服务器（主要是三菱虚拟plc，西门子虚拟plc，modbus服务器等）实现IReadWriteNet接口。</item>
                        <item>关于ab-plc，新增MicroCip协议，适用于Micro800系列读写操作。</item>
                        <item>关于序号生成器类SoftIncrement，重置最大值的方法名称更新，添加了重置当前值，重置初始值，支持反向序列，跳跃序列的功能，详细参考api文档。</item>
                        <item>文件的服务器类，新增一些日志记录，关于文件何时被读取，何时读取结束的日志信息，等级为debug。</item>
                        <item>NuGet组件更新，json组件更新到12.0.3版本，IO.port更新到4.7.0版本。单元测试框架更新。</item>
                        <item>Demo的redis示例，支持不同的db块选择，当你选择数据后自动切换，键值类数据增加格式化显示。</item>
                        <item>NetworkBase: 网络基类的连接服务器改为如果连接立即失败(500ms内)，将会休眠100ms后，立即再尝试一次，提高连接的成功率。影响范围为所有客户端类。</item>
                        <item>三菱二进制MC协议：地址里面新增标签访问，缓冲存储器访问，扩展的地址访问的方式，目前开放二进制的mc协议，欢迎测试，顺利的话，完善写入和ascii格式的。</item>
                        <item>大量的代码注释添加，主流的常用的代码添加中英文注释，后续逐步全都改为中英文，方便国外客户阅读。</item>
                        <item>240元的普通vip群的激活码时间调整，改为20年，中间软件重启一次，就又是20年，感谢大家的理解和支持。</item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                    </list>
                </revision>
                <revision date="2020-3-15" version="9.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>MQTT: 服务器增加定时检测客户端在线情况，超过设置的时间不活跃，强制下线，开放OnlineSession属性，获取在线客户端，查看ip，端口，在线时间等信息。</item>
                        <item>WebSocket: 服务器开放OnlineSession属性，获取在线客户端，查看ip，端口，在线时间等信息。</item>
                        <item>Language: 组件的语言系统修复设置英文后，无法切换回中文的bug。</item>
                        <item>SoftBasic: 添加SpliceByteArray(params byte[][] bytes)方法，用来将任意个byte[]进行拼接成一个byte[]。</item>
                        <item>SoftBasic: 添加BoolOnByteIndex方法，用来获取byte数据的指定位的bool值。</item>
                        <item>Panasonic: 松下的mc地址和串口地址统一表示方式：R101=R10.1=[10*16+1]，R10.F=R10.15(这两种表示方式都可以)</item>
                        <item>发布基于HSL扩展组件HslCppExtension，将写入的重载方法名按照类型重写一遍，方便C++调用。</item>
                        <item>VC++的demo示例，新增写入数据的例子，基于扩展组件HslCppExtension实现，详细参照demo源代码。</item>
                        <item>SoftBasic: 针对byte数组的切割，选择头，尾，中间，移除头，尾的方法全部更改成泛型版本，方法名字已经变更，如果有调用，谨慎更新。</item>
                        <item>FanucInterfaceNet: 新增读取fanuc机器人的通讯类，支持读写任意地址数据的功能，详细参考api文档，写入操作谨慎测试。</item>
                        <item>FanucRobotServer: 新增fanuc机器人的虚拟服务器，方便进行测试，初始数据来自真实机器人，支持D,I,Q,AI,AQ,M数据区。</item>
                        <item>Fanuc: 目前测试通过的型号为R-30iB mate plus，其他型号暂时不清楚支持范围。</item>
                        <item>代码注释优化，api文档大量的更新，添加一些示例代码，包含如果检测状态，长短连接，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>三年磨一剑，直插工业互联网的心脏。软件开发之艰辛，如人饮水冷暖自知。感谢所有支持的朋友。</item>
                    </list>
                </revision>
                <revision date="2020-3-22" version="9.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>feat(SAM): 身份证阅读器修复在某些状态下接受数据不完整的bug，将校验数据的完整性。</item>
                        <item>feat(ab-plc): 虚拟服务器的地址支持小数点的形式，支持单个的bool读写，支持string的读写操作，和客户端的体验一致。</item>
                        <item>feat(softbasic): 方法针对数组切割的方法，增加扩展方法支持，byte[] a; byte[] b= a.RemoveBegin(2);意思就是移除最前面的2个元素。</item>
                        <item>feat(softbasic): Hex字符串和byte[]的转化也支持扩展方法。byte[] a.ToHexString()。</item>
                        <item>feat(melsec): 三菱的a-1e协议之前的，x,y地址采用8进制，先修改为自定义，如果要八进制，地址前面加0，例如X017，如果不加就是十六进制，例如X17，默认十六进制，升级需注意。</item>
                        <item>feat(melsec): 三菱的a-1e协议增加了F报警继电器，B链接继电器，W链接寄存器，定时器和计数器的线圈，触点，当前值的读取，地址参见api文档说明。</item>
                        <item>feat(melsec): 添加a-1e协议的ASCII版本，地址格式和二进制版本是一致的，支持的地址类型也是一致的，还未仔细测试，欢迎老铁们测试。</item>
                        <item>feat(melsec): 三菱的mc虚拟服务器支持二进制和ascii，实例化的时候选择，支持和HSL组件自身的通讯。</item>
                        <item>lsis: cnet和fenet地址的解析bug修复，感谢埃及朋友的支持。</item>
                        <item>代码注释优化，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-3-29" version="9.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>ModbusAscii: 修复和rtu指令转换时的bug，之前会发生读写失败，目前已经在台达PLC上测试通过。</item>
                        <item>MelsecA1EAscii：修复三菱的A1E协议的ascii格式类写入单个bool异常的bug。</item>
                        <item>NetworkUdpServerBase：新增基于UDP协议的服务器基类，后台线程循环接收数据实现。</item>
                        <item>CipServer: 虚拟的ab-plc服务器新增字符串数组对象的读写操作，demo相关的完善。</item>
                        <item>HyundaiUdpNet: 新增现代机器人的姿态跟踪网络通讯类，</item>
                        <item>代码注释优化，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-4-6" version="9.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>HslExtension: 完善一些转化的api，方便数组和字符串转化，完善对象转JSON字符串。</item>
                        <item>LogNet：消息格式化文本的消息等级追随HSL的语言设定，如果是中文，就显示调试，信息，警告，错误，致命。</item>
                        <item>Redis: 修复ExpireKey，生存时间参数丢失的bug，完善了说明文档。</item>
                        <item>OmronCip: 欧姆龙的CIP协议的类库，修复数组读取的bug，修复字符串写入bug，字符串写入还需要测试。</item>
                        <item>Toledo：新增托利多电子秤的串口类及网口服务器类，方便接收标准的数据流，等待测试。</item>
                        <item>Java：增加了单元测试的内容，对一些已经完成的类添加单元测试。</item>
                        <item>Python：实现了python版本的HslCommunication程序，基于pyqt实现，初步添加了一些PLC的调试界面。</item>
                        <item>代码注释优化，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-4-20" version="9.1.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>ServerBase: 服务器对象基类完善客户端下线逻辑，精简相关的代码。</item>
                        <item>LogNet：设备网络通讯类及串口类在数据收发的时候增加日志的记录，可以设置PLC类的LogNet属性抓取相关的报文信息。</item>
                        <item>ModbusServer: Modbus服务器同时支持TCP,RTU,ASCII，其中RTU和ASCII共用一个串口，根据报文头是否为冒号区分。</item>
                        <item>ModbusAscii: 修复通讯的bug，已通过单元测试，支持和ModbusServer完美通讯，欢迎网友继续测试。</item>
                        <item>MelsecMcNet：三菱MC协议的数据地址新增对SB，SW，特殊链接继电器，寄存器的支持。</item>
                        <item>SiemensServer: 西门子S7虚拟服务器的DB块支持DB1.X，DB2.X，DB3.X，3以上的db块都是使用同一个的DB块。</item>
                        <item>HttpServer：自定义轻量级的WebApi服务器支持反射对象的方法名，简化定义API时定义大量的if...else...。</item>
                        <item>UdpNet：添加ConnectionId属性，使用的<seealso cref="M:HslCommunication.BasicFramework.SoftBasic.GetUniqueStringByGuidAndRandom"/>方法获取信息。</item>
                        <item>MelsecMcRNet：添加三菱R系列的MC协议二进制的实现，和标准的有一点区别，地址支持也不一样，欢迎测试Demo。</item>
                        <item>OmronCip：欧姆龙的读写数组已经测试通过，修改了读写字符串的逻辑实现，等待测试。</item>
                        <item>代码注释优化，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-4-28" version="9.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>HttpServer: 当客户端发起request请求的时候，在日志记录的时候记录当前的请求的方式，GET,POST,OPTION等等。</item>
                        <item>MQTT: mqtt的消息等级追加一个新的等级，为OnlyTransfer等级，用来表示只发送服务器，不触发发布操作。</item>
                        <item>MqttServer: 配合Qos等级为OnlyTransfer时，进行相关的适配操作，并触发消息接收的事件。</item>
                        <item>MqttSyncClient: 新增MQTT的同步访问的客户端，协议头标记为HUSL，向HSL的mqtt服务器进行数据请求并等待反馈。尚未添加心跳程序。</item>
                        <item>MqttServer: 适配同步客户端实现功能，当客户端为同步客户端的时候，调试心跳验证。</item>
                        <item>至此，HSL的MQTT协议已经是兼容几大网络功能了，在线客户端管理，消息发布订阅，消息普通收发，同步网络访问。</item>
                        <item>IByteTransform接口属性新增IsStringReverseByteWord，相当于从ReverseByWord挪过来了，默认为false，如果为true，在解析字符串的时候将两两字节颠倒。</item>
                        <item>Omron: 欧姆的fins-tcp及fins-udp及hostlink的IByteTransform接口IsStringReverseByteWord调整为true默认颠倒。</item>
                        <item>SerialBase: 串口基类的打开串口方法调整返回类型OperateResult，在串口数据读取之前增加打开串口的Open方法，串口类也只需要一直读就可以了。</item>
                        <item>NetworkDoubleBase, SerialDeviceBase, NetworkUdpDeviceBase及相关的继承类，对所有的泛型进行了擦除，一律采用接口实现，之后将统一java,python代码。</item>
                        <item>FreedomTcp,FreedomUdp,FreeSerial: 添加基于自由协议的tcp，udp，串口协议，可以自由配置IByteTransform接口，可用来读取一些不常见的协议。</item>
                        <item>Omron-cip: 读写字符串仍然没有测试通过，请暂时不要调用。</item>
                        <item>SiemensS7: 单次读取之前是按照200字节进行拆分的，现在根据s7协议返回的报文来自动调整，1200系列是220字节，1500系列是920字节，其他等待测试。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-5-6" version="9.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Toledo: 托利多电子秤的字节触发的时候，传递出来携带原始的字节数组，方便自行处理，Demo界面优化，显示信息更加完善。</item>
                        <item>Lsis: Lsis的PLC通信类修复一些bug，感谢埃及朋友的提供的技术支持。</item>
                        <item>MqttSyncClient: 新增ReadString方法，以字符串的形式来和服务器交互，默认编码UTF8，当然也可以自己指定编码，本质还是读取字节数据。</item>
                        <item>WebsocketClient: websocket的客户端类，重新设计异常重连，网络异常时触发 OnNetworkError 事件，用户应该捕获事件，然后在事件里重连服务器，直到成功为止。</item>
                        <item>MqttClient: Mqtt客户端类，重新设计异常重连，网络异常时触发 OnNetworkError 事件，用户应该捕获事件，然后在事件里重连服务器，直到成功为止。</item>
                        <item>MqttSyncClient: 支持读取数据的进度回调功能，支持三种进度报告，数据上传到服务器的进度报告，服务器处理进度报告，数据返回到客户端的进度报告。</item>
                        <item>PanasonicMewtocol: 修复注释错误，L区的数据也可以进行L100F，L2.3访问。</item>
                        <item>DLT645: 初步添加电力规约协议的串口实现，目前只实现了读取数据，还未测试，等待后续的测试完善。</item>
                        <item>Omron-cip: 读写字符串仍然没有测试通过，请暂时不要调用。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-5-11" version="9.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>MqttClient: 上个版本开放的网络错误事件，如果不进行事件绑定，增加默认实现，每隔10秒去连接服务器，直到成功为止。</item>
                        <item>WebsocketClient: 上个版本开放的网络错误事件，如果不进行事件绑定，增加默认实现，每隔10秒去连接服务器，直到成功为止。</item>
                        <item>DLT645: 电力规约协议完善，等待后续的测试完善。</item>
                        <item>SerialBase: ReadBase提供一个重载的方法，ReadBase( byte[] send, bool sendOnly )支持单向发送，不接收数据返回。</item>
                        <item>SoftBasic: HexStringToBytes算法优化，性能提升，移除了转大写字母的步骤。</item>
                        <item>SiemensS7: 开放获取 pdu 数据长度属性，属性名称：PDULength</item>
                        <item>HslExtension: 增加IncreaseBy方法，但是测试发现不适用byte类型。</item>
                        <item>Omron-cip: 读写字符串仍然没有测试通过，请暂时不要调用。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-5-21" version="9.2.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>IReadWriteNet接口新增一个属性，ConnectionId，用来表示设备的唯一ID。</item>
                        <item>ModbusTcpServer: Modbus的虚拟服务器支持0x16功能码，支持掩码写入操作，适用Tcp,Rtu,Ascii。</item>
                        <item>Modbus客户端(tcp+rtu+ascii+rtuovertcp) 新增掩码写入方法，WriteMask，bool写入时，假如Write("100.1", true)就使用掩码写入寄存器100的第1位为真。</item>
                        <item>RedisClient: redis的客户端新增Ping方法，DBSize方法获取key数量，FlushDB方法清除数据库所有key。</item>
                        <item>DTUServer: 新增一个DTU服务器，可以用来实现对plc的反向连接操作，根据设备的唯一号来识别。</item>
                        <item>Omron-cip: 读写字符串不成功的bug修复，已经测试通过。</item>
                        <item>WebsocketClient: 实例化时新增url的额外参数传递，("127.0.0.1", 1883, "/A/B?C=123456")，也可以使用"ws://127.0.0.1:1883/A/B?C=123456"。</item>
                        <item>WebsocketClient: 修复未连接服务器的时候，调用关闭方法将会引发发送异常的bug。</item>
                        <item>MqttServer: 修复NET35版本不支持同步访问的bug，新增一个客户端断开连接的事件，OnClientDisConnected事件。</item>
                        <item>VibrationSensor: 新增一个震动传感器的类，型号为苏州捷杰震动传感器VB31，支持获取速度，加速度，位移，温度信息。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-5-29" version="9.2.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Mewtocol: 松下的串口协议修复LD寄存器无法访问的bug，输入LD100，如果只输入L100，就是线圈。</item>
                        <item>Modbus: 修复写入寄存器指定位bool失败的bug，写入true的掩码改为 FF FE，00 01</item>
                        <item>Modbus：在ModbusRtuOverTcp里填写掩码写入的api方法。</item>
                        <item>ab-plc：CIP协议解析标签地址的编码从ASCII编码修改为UTF-8编码，支持中文的标签名访问。</item>
                        <item>omron-plc：CIP协议解析标签地址的编码从ASCII编码修改为UTF-8编码，支持中文的标签名访问。</item>
                        <item>Websocket: 连接的请求标头修改为GET ws://127.0.0.1:8800/ HTTP/1.1  就是带IP地址及端口信息</item>
                        <item>Redis：Redis的客户端添加对集合和有序集合操作的相关API方法，基本支持了所有需要的操作信息，单元测试通过。</item>
                        <item>Demo: 所有DEMO写入数据操作，新增Hex写入，输入1A 1B等十六进制数据，然后底层调用Write(string, byte[])方法。</item>
                        <item>Demo：Redis的功能菜单新增一个测试界面，用来同步两个不同的redis的数据，也可以同一个redis不同的db块数据。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-6-10" version="9.2.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>CipServer: Cip的虚拟服务器的数据节点编码修改为UTF8编码，增加了一些可读性比较强的增加节点的api，支持赋值初始化数据。</item>
                        <item>Demo: Kuka机器人的连接问题，请参考下面地址：http://blog.davidrobot.com/2019/03/hsl_for_kuka.html?tdsourcetag=s_pctim_aiomsg </item>
                        <item>Redis: 增加读取TTL的api方法，方便的获取剩余的生存时间。</item>
                        <item>HttpServer: 修复Response为空时进行AppendHeader时发生的bug，进行二次校验。</item>
                        <item>VibrationSensorClient: 修复deme站号设置失效的bug，站号根据接收的数据动态调整，增加检测长时间未接收传感器数据，就选择重连的功能。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-6-28" version="9.2.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>NetworkBase: 同步网络通信的超时检查不再开新的线程检查，使用socket自带的ReceiveTimeout来检查。</item>
                        <item>NetworkBase: 发送数据时，增加对发送数据的空检查，如果为空，就认为成功。</item>
                        <item>RedisClient: 新增修改密码的API接口，可以进行对redis的密码重置操作。</item>
                        <item>MqttServer: 当同步客户端 MqttSyncClient连接上来时，不进行触发上下线事件。</item>
                        <item>MqttServer：原先支持获取所有的在线客户端，现在新增获取异步客户端列表，获取同步客户端列表。</item>
                        <item>MqttSubscribeMessage: 类型拼写错误修复，如果使用这个类，请谨慎升级。</item>
                        <item>Keyence: 基恩士的MC协议，支持CC，TC的数据类型读取。</item>
                        <item>FanucSeries0i: 新增一个fanuc机床的数据通讯类，支持读取一些简单的数据，目前在Series0i-F上测试通过。</item>
                        <item>Cip: 修复ab-plc的标签地址解析为UTF-8编码，但是长度确实字符串的bug，现在支持中文编码。</item>
                        <item>其他的注释优化</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-7-8" version="9.2.7" author="Richard.Hu">
                    <list type="bullet">
                        <item>MqttServer: 修复MQTT服务器开启时，当用其他的mqtt客户端订阅时，会发生异常的bug，原因在于订阅质量没有回传。</item>
                        <item>WebsocketServer: websocket的服务器端新增一个客户端下线的事件，无论是正常关闭还是异常关闭，都会触发事件。</item>
                        <item>MqttClient: Mqtt的客户端新增一个连接成功的事件OnClientConnected，重连成功后也会触发。在该事件的订阅topic会在网络恢复后重新订阅。</item>
                        <item>NetworkDoubleBase: 当校验指令头失败的时候，返回的错误信息里追加，收发的报文，方便查找问题。</item>
                        <item>MelsecA1EAsciiNet: 修复读取bool时，长度为奇数时，会出现交替失败的bug，原因出自数据粘包。</item>
                        <item>WebsocketClient: 添加一个IsClosed属性，修复服务器强制断线导致客户端无限重连的bug。</item>
                        <item>OmronConnectedCipNet: 添加一个基于连接的CIP的读写类，等待测试。</item>
                        <item>其他的注释优化</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-7-20" version="9.2.8" author="Richard.Hu">
                    <list type="bullet">
                        <item>KeyenceNanoSerial: 基恩士的串口协议重新实现，实现IReadWrite接口，增加了单元测试。支持的地址需要查阅API文档信息。</item>
                        <item>OmronHostLinkCMode: 支持了欧姆龙的HOSTLINK协议的Cmode模式的实现，初步单元测试通过，等待测试。</item>
                        <item>MC协议：三菱MC协议的ZR区的地址进制从16进制改为10进制。</item>
                        <item>NetworkDoubleBase: 添加一个PING的方法IpAddressPing( ), 对设备当前的IP地址进行PING操作。</item>
                        <item>NetworkUdpBase: 添加一个PING的方法IpAddressPing( ), 对设备当前的IP地址进行PING操作。</item>
                        <item>yamaha: 添加一个雅马哈机器人协议的实现，初步实现了几个api，等待测试，测试通过继续完善。</item>
                        <item>DEMO: 主界面增加一个全国使用情况的分布图，统计DEMO的使用次数实现。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-8-3" version="9.3.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>Networkbase：核心网络底层的错误码调整，当读写操作因为网络问题失败时，返回错误码为负数-1，如果连续读写失败，就一直递减。</item>
                        <item>OmronConnectedCipNet: 地址解析修改为全部上29 00 报文。</item>
                        <item>FileNet: 两种文件服务器支持删除多个文件和删除文件夹的所有文件功能，客户端同步适配，初步测试通过。</item>
                        <item>NetSimplifyClient: 新增一个构造方法，可以传入IPAddress类型的ip地址。</item>
                        <item>MqttSyncClient: 新增一个构造方法，可以传入IPAddress类型的ip地址。</item>
                        <item>MqttClient: 修复一个连接反馈信号，解析判断服务器状态错误的bug，该bug导致MqttClient连接不是中国移动的OneNet物联网框架。</item>
                        <item>FFT: 傅立叶变换FFTValue方法添加一个可选参数，是否二次开放，波形中的毛刺频段会更加明显。</item>
                        <item>HttpServer: webapi的服务器完善注释，添加一个端口号的属性，获取当前配置端口号信息。</item>
                        <item>Active: 当前库激活失效的时候，返回的错误消息，携带当前的通信对象的实例化个数，方便查找授权失败的原因。</item>
                        <item>Abb机器人：abb机器人支持读取程序执行状态，任务列表功能，伺服状态，机器人位置数据。</item>
                        <item>ABB虚拟机器人：新增一个abb机器人的虚拟webapi的服务器，可以用来测试和ABB客户端的通信。</item>
                        <item>Demo: 数据转换的界面，新增一个显示指定的文件的二进制的内容的功能。当demo激活成功时，不显示时间及授权信息。</item>
                        <item>新增一篇全新的博文，介绍基于HSL的大一统网络架构实现，满足发布订阅，一对多通信，webapi等：https://www.cnblogs.com/dathlin/p/13416030.html。</item>
                        <item>官网备案成功了，地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-8-28" version="9.3.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Beckhoff: 倍福PLC新增读取设备信息和设备状态的api接口。在demo界面添加测试按钮，状态码检查优化，错误时返回报文信息。</item>
                        <item>FanucSeries0i: 修复fanuc机床的读取宏变量解析double数据时，为0的时候解析异常的bug。</item>
                        <item>ABBWebApiServer：ABB机器人的虚拟服务器支持用户名和密码设置，在客户端请求数据的时间，支持账户验证。</item>
                        <item>Demoserver: 优化根据IP地址获取物理地址的方法，获取不到或是奇怪字符将切换线路重新获取。</item>
                        <item>KukaTcpNet: 新增KukaTcp通讯类，支持多变量写入的api，在demo界面增加启动，复位，停止程序的操作。</item>
                        <item>.Net Framwork 2.0 支持2.0的框架的dll发布，通过nuget安装即可。</item>
                        <item>SimpleHybirdLock: 简单混合锁添加一个当前进入锁的次数的静态属性，可以查看当前共有多少锁，等待多少锁。</item>
                        <item>NetworkDeviceBase: 核心交互方便增加错误捕获，异常释放锁，再throw, YamahaRCX类完善异步方法</item>
                        <item>NetworkBase: 增加一个线程检查超时的次数统计功能。</item>
                        <item>InovanceH3U: 修复汇川的3U的PLC地址类型为SM,SD时解析异常的bug。</item>
                        <item>Demo: HslCommunication Test Demo支持PLC及一些连接对象的参数保存功能，使用英文冒号可以分类管理。</item>
                        <item>WebSocketSession: 新增url属性，如果客户端请求包含url信息，例如：ws://127.0.0.1:1883/A/B?C=123, 那么url就是这个值。</item>
                        <item>Demo: 测试的DEMO程序，支持连接参数存储，不用再每次打开程序重新输入IP地址，端口，站号等等信息，可以存储起来，还支持分类存储。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
                <revision date="2020-9-27" version="9.3.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>KeyenceNanoSerial: 修复读写R寄存器时，提示地址格式异常的BUG，已经测试通过。</item>
                        <item>MelsecMcUdpServer: 新增三菱MC协议的UDP虚拟PLC，支持数据读写，支持二进制和ASCII格式。</item>
                        <item>OmronFinsUdpServer: 新增欧姆龙Fins协议的UDP的虚拟PLC，支持数据读写操作。</item>
                        <item>MqttServer: 修复MQTT服务器在客户端发送批量订阅的时候，服务器会触发BUG的问题。</item>
                        <item>ConnectPool&lt;TConnector&gt;类代码注释优化，新增连接次数峰值属性。</item>
                        <item>RedisSubscribe: 订阅服务器重新设计，订阅实现事件触发，支持手动订阅，取消订阅操作。</item>
                        <item>RedisClient: 支持了订阅的操作，当订阅的时候，创建订阅的实例化对象，应该在连接参数设置之后再进行订阅。</item>
                        <item>RedisClientPool：新增Redis连接池类，默认不限制连接数量，使用起来和普通的RedisClient一样，适合一个项目实例化一个对象。</item>
                        <item>MqttSyncClientPool: 新增MqttSyncClient的连接池版本类，默认不限制连接数量，用起来和普通的MqttSyncClient一样。</item>
                        <item>LogNetFileSize: 根据文件大小的日志类，实例化时支持设置允许存在的文件上限，如果设置为10，只保留最新的10个日志文件。</item>
                        <item>LogNetDateTime: 根据日期的日志类，实例化时支持设置允许存在的文件上限，如果设置为按天存储，上限为10，就是保留10天的日志。</item>
                        <item>AllenBradleySLCNet: 新增AB PLC的数据访问类，适合比较老的AB PLC，测试通过的是1747系列。地址格式为A9:0</item>
                        <item>AllenBradleyNet: 读写bool值的时候，不带下标访问单bool数据，如果需要访问bool数组，就需要带下标访问，例如：A[0]。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2020-10-23" version="9.5.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>AllenBradleyNet: ReadBool方法默认读取单bool类型变量，如果要读取int类型的bool数组，采用"i="开头表示，例如"i=A[10]"</item>
                        <item>NetworkDataServerBase: 新增一个属性ActiveTimeSpan，可以设置激活时间间隔，默认24小时，锁优化，其他的继承实现的服务器都进行了设置。</item>
                        <item>NetworkDeviceBase: Read&lt;T&gt;修改为虚方法，支持继承进行重写，基于特性的类注释完善。</item>
                        <item>Siemenss7net: ReadString(string address, ushort length)读取字符串时，如果长度为0，就读取西门子格式的字符串。</item>
                        <item>OperateResult: 扩充泛型方法，Check, Convert, Then，实现了结果链，简化代码。参考：https://www.cnblogs.com/dathlin/p/13863115.html </item>
                        <item>FanucSeries0i: 修复数控机床在读取0i-mf状态时导致长度不够的bug。</item>
                        <item>IReadWriteNet: 新增wait方法接口，用于等待一些信号到达指定的值，支持扫描频率设置，超时设置。例如 Wait("M100.0", true, 500, 10000)等待这个信号为true为止。</item>
                        <item>MqttServer: 支持调用ReportOperateResult返回错误信息及错误码给客户端，MqttSyncClient会自动识别报文，然后IsSuccess自动适应，网络不会断开。</item>
                        <item>MqttSyncClient: 支持设置接收超时时间，默认是60秒，之前是5秒，而且不能更改。</item>
                        <item>MqttServer: 支持注册远程RPC的API接口，自动解析json参数，自动调用已经注册的接口自动返回是否成功，MqttSyncClient也支持遍历服务器的接口列表。详细：https://www.cnblogs.com/dathlin/p/13864866.html </item>
                        <item>SiemensS7Net: 通信类实现ReadBool("M100", 10); 批量读bool方法，通过读Byte间接实现。</item>
                        <item>OmronHostLinkCModeOverTcp: 新增欧姆龙的通讯类，Cmode模式的以太网透传实现。</item>
                        <item>PLC: 所以的PLC实现了HslMqttApi特性支持，从而在MqttServer里可以直接注册，然后对外开放读写接口操作。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2020-11-2" version="9.5.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>MQTTServer: 服务器端在注册M-RPC远程调用接口服务的时候，如果你的接口实现了参数默认值，那么就提取到示例参数里。</item>
                        <item>KeyenceSR2000SeriesTcp: 新增基恩士的SR2000系列的扫码器的驱动，目前是TCP版本，支持读码，读取记录，停止复位等，支持自定义的命令。</item>
                        <item>XGKFastEnet: 新增Lsis的XGK系列的FastEnet实现。</item>
                        <item>XGKCnet: 新增Lsis的XGK的cnet的实现。</item>
                        <item>Demo: Demo的TCP调试的服务器端优化，错误获取优化，发送数据失败的问题修复。</item>
                        <item>NetworkBase: 底层异步的数据接收的超时优化，优化超时线程池实现，更加节省线程调度。</item>
                        <item>MqttSyncClient: 客户端支持读取MQTT服务器的驻留主题列表，读取该主题的相关的数据信息。详细见demo。</item>
                        <item>MqttServer: 修改ClientVerification事件，增加会话句柄传递，支持动态修改client id，支持设置当前客户端禁止发布任何数据。</item>
                        <item>MqttServer上的MRPC的权限控制仅对商业授权用户开放，MqttSyncClientPool连接池以及RedisClientPool连接池仅对商业授权用户开放。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2020-11-11" version="9.5.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>XGKFastEnet修复了一点小问题，感谢埃及朋友提供的技术支持。</item>
                        <item>KeyenceSR2000Serial: 新增基恩士的SR2000系列的扫码器的串口版驱动，支持读码，读取记录，停止复位等，支持自定义的命令。</item>
                        <item>IKeyenceSR2000Series: 新增基恩士的SR2000系列的扫码器接口，优化读码功能，如果读码失败，则发送LOFF命令。</item>
                        <item>LogStatistics: 新增统计次数的辅助类，可以实现关于时间的一些统计信息，比如统计每小时，每天，每周，每月等的登录量，使用量信息。</item>
                        <item>LogValueLimit: 新增数据极值类，用于统计一个数的开始值，结束值，最大值，最小值，平均值，然后可以按小时，天，周，月等统计。</item>
                        <item>OmronHostLink: 修复解析错误码时，如果错误码不为数字的时候会导致奔溃的bug，错误提供内容更加详细。</item>
                        <item>ILogNet: 日志记录的方法实现MqttApi特性，可以在MQTTServe里面注册为RPC服务，从而实现远程调用日志写入的方法。</item>
                        <item>ILogNet: 日志类方法新增属性LogStatistics，只要实例化就可以统计当前的日志记录情况，可以每分钟，每小时，每天，每周，每月，每季度，每年。</item>
                        <item>MqttClient: 新增一个订阅的api接口，支持直接传递MqttSubscribeMessage对象，可以指定消息质量。</item>
                        <item>XinJEXCSerial: 新增信捷的XC系列的串口通讯类，底层是modbus-rtu，地址做了封装，按照信捷的地址输入即可，比如X1,Y7,M1000,D100,F100,E100。</item>
                        <item>MelsecFxSerial: 三菱编程口类新增 IsNewVersion 属性，如果为false，就是老版本的协议，修复T,C线圈读写的地址不对BUG。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2020-12-2" version="9.5.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>ModbusRtuOverTcp: 更改继承，直接从NetworkDeviceBase进行继承，通过单元测试</item>
                        <item>YokogawaLinkTcp: 新增横河PLC的二进制通讯类，支持X,Y,I,E,M,T,C,L,D,B,F,R,V,Z,W,TN,CN读写，部分高级API商业授权用户才能使用，例如读取PLC信息。</item>
                        <item>YokogawaLinkServer: 新增横河PLC的二进制格式的虚拟PLC，模拟的真实的PLC的通信机制，实现了读写长度的限制，以及错误信号的返回。</item>
                        <item>Networkdoublebase: ReadFromCoreServer( byte[] send, bool hasResponseData ) 新增是否等待数据返回的属性，可以用于某些不需要数据返回的命令。</item>
                        <item>Networkbase： 修复异步接收数据时，某些情况下长度为0导致连接关闭的bug。</item>
                        <item>FetchWriteServer: 新增西门子fetch/Write协议的虚拟PLC，支持虚拟数据的读写，通信。</item>
                        <item>MelsecFxSerialOverTcp: 修改继承体系，从NetworkDeviceBase继承，和MelsecFxSerial的IsStringReverseByteWord调整为true;</item>
                        <item>文件引擎服务器修复路径大小写导致的bug问题，文件客户端支持检查文件是否存在的方法，检查文件是否存在。</item>
                        <item>MqttServer: 远程调用的MRPC的参数支持自定义类型，通过JSON转换，将字符串转换为实体类。还有其他的优化。</item>
                        <item>DeltaDvpSerial, DeltaDvpSerialAscii, DeltaDvpTcpNet: 添加台达的通信类，输入台达的地址即可，会自动转换实际的modbus地址。</item>
                        <item>所有的虚拟PLC的服务器均调整为商业授权用户专享，还有一些高级的API，具体看api注释是否带有[商业授权]字样，基本的数据读写功能将一直对个人用户开放。</item>
                        <item>Demo: 数据读写示例的界面，写入现在支持批量写入，数据写[1,2,3]，然后写入short，就是写入short数组了。</item>
                        <item>普通VIP的个人使用不再限制100个PLC对象，连续运行时间调整为10年，高级的一些API限制商用，参考注释是否带[商业授权]字样。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2020-12-22" version="9.6.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>YokogawaLink: 异步的方法添加和完善，虚拟PLC侧支持Special:100开头的地址，表示特殊模块寄存器，从而支持各种类型的读写。</item>
                        <item>LogStatistics, LogValueLimit: 两个数据日志分析类支持获取指定时间段的数据，数据存储文件格式重新设计，为不兼容更新。</item>
                        <item>LogStatisticsDict, LogValueLimitDict: 新增数据日志分析的词典类，用来统计多个数据的不同时间段的使用情况。</item>
                        <item>所有的基于tcp的plc，机器人，redis, mqtt, websocket等通讯类的ip地址支持直接输入域名，会自动调用Dns.GetIpAddress来解析。 </item>
                        <item>MqttRpcApi: MRpc的API特性支持应用在属性上，不需要传递参数，直接获取属性的值，在demo上显示的小图标不一样。PLC的通讯类的基本属性在MRPC公开。</item>
                        <item>MelsecFxLinks: 支持读取PLC的型号，读写数据的地址支持了站号指定，地址可以写成[s=2;D100]，方便多站号读取。</item>
                        <item>AllenBradleyNet: 地址支持slot参数，例如：slot=2;AAA ，也可以不携带，这个是可选的。</item>
                        <item>FatekProgram, FujiSPB, XGBCnet, MelsecA3CNet1, OmronHostLink, OmronHostLinkCMode, PanasonicMewtocol, SiemensPPI，信捷，汇川类及其透传类支持地址携带站号，例如 s=2;D100</item>
                        <item>FujiSPBServer: 新增富士PLC的虚拟服务器，支持串口和网口，原先的富士PLC存在bug，不能读取，欢迎网友对富士PLC测试。</item>
                        <item>HttpServer: 删除原先的HttpGet和HttpPost特性，改用MRPC的特性，支持注册webapi服务，使用方式和MRPC类似，demo增加httpsclient可浏览接口，https://www.cnblogs.com/dathlin/p/14170802.html</item>
                        <item>HttpServer, MqttServer: 服务器端支持接口调用的次数统计，支持客户端查询接口调用情况，demo客户端实现mqttclient,方便服务器管理在线客户端信息。</item>
                        <item>其他优化改进，如果有网友发现bug，配合作者测试并修复bug，将根据实际情况给与现金红包奖励。</item>
                        <item>普通VIP的个人使用不再限制100个PLC对象，连续运行时间调整为10年，高级的一些API限制商用，参考注释是否带[商业授权]字样。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-1-12" version="9.6.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Lsis XGK: 修复部分的问题，感谢埃及朋友提供的支持。</item>
                        <item>FujiSPB: 修复未在net20, net35, net standard项目里添加的bug。</item>
                        <item>MqttServer和HttpServer: 注册API的方法支持对静态方法的注册，注册时传入类型对象即可。</item>
                        <item>Modbus: tcp, rtu, ascii, rtu over tcp在读写int,uint,float,double,long,ulong时支持动态指定dataformat，地址示例：format=BADC;100</item>
                        <item>MqttServer: 扩展MQTT的子协议FILE，支持文件的上传，下载，删除，查看信息，权限控制操作，支持获取上传下载网速监控。</item>
                        <item>MqttSyncClient: 扩展文件的方法接口，支持上传，下载，删除，遍历文件操作，每个操作都是短连接的，使用的全新的socket对象。</item>
                        <item>SiemensS7Net: 修复西门子s7协议某些情况数据批量写入失败的bug，原因来自PDU长度信息不对。</item>
                        <item>DLT645: 修复一些问题，已经测试通过，新增 DLT645OverTcp，感谢 QQ：542023033 提供的技术支持。</item>
                        <item>FanucInterface: 机器人的解析数据时，当shift_jis编码不存在时，将会引发异常，现在自动替换UTF8</item>
                        <item>HslCommunication: 所有的异步通信代码优化，优化超时检测机制，现在大大提升了服务器的高并发的能力，异步通信的性能。</item>
                        <item>AllenBradleyNet及OmronCipNet协议支持 UINT, UDINT, ULING类型的写入，对应的C#的类型是 ushort, uint, ulong</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-1-26" version="9.6.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>OmronConnectedCipNet: 新增欧姆龙的基于连接的CIP实现，测试读写欧姆龙PLC成功，支持数组读写，详细参考API文档，欧姆龙的CIP请使用本类。</item>
                        <item>AllenBradleyNet: 修复当自动重连时，连接的ID 还是上次的 ID 导致读写失败的bug。</item>
                        <item>DLT645: 点对点模式下，在读取地址域的时候，新增读取成功后即修改当前的地址域信息，也即是在打开串口后，读取地址域即可通信。</item>
                        <item>DLT645: 修复有些数据格式不一致导致读取数据不正常的bug，已经测试可以读取功率，能耗，电压电流，电表基本信息，还支持自定义的解析格式。</item>
                        <item>NetworkAlienClient: DTU客户端增加对连接客户端的注册包的数据校验，修复数据意外的情况导致程序奔溃的bug。</item>
                        <item>Demo: 在 演示程序里，Modbus的DTU的示例界面，修复 ID 设置时，结果设置到 IP 导致异常的bug。另外增加西门子的DTU演示界面。</item>
                        <item>LSisServer: 修复同一地址，数据读写不对的bug，和 XGKFastEnet 客户端读写测试通过，包括bool类型地址，字地址</item>
                        <item>GeSRTPNet: 新增 GE-PLC（通用电气） 的SRTP协议实现的客户端，支持I,Q,M,T,SA,SB,SC,S,G 的位和字节读写，支持 AI,AQ,R 的字读写操作。</item>
                        <item>GeSRTPServer: 新增 GE 的 SRTP 协议的虚拟PLC，支持和 GeSRTPNet 通信测试。支持类型和客户端支持的一致。</item>
                        <item>MqttServer: 在启动文件服务功能时，增加对分类路径，以及文件名的合法性进行校验，防止注入特殊字符攻击及意外bug。</item>
                        <item>MqttSession: 新增一个方法，GetTopics() 用于获取当前的会话对象所订阅的主题的副本数据。</item>
                        <item>PanasonicMewtocol: 修复 Mewtocol及串口转网口类，在批量读取 bool 数组地址解析不准确的bug。</item>
                        <item>MelsecCipNet: 新增三菱的CIP协议功能，PLC使用了 QJ71EIP71 模块时就需要使用本类来访问。</item>
                        <item>SickIcrTcpServer: 修复当关闭服务器的时候，现有的连接没有关闭的bug，没有关闭的话，仍然会接收到来自设备发来的条码信息。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-2-15" version="9.6.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>SickIcrTcpServer: 修复手动连接扫码设备的网络在关闭服务器后仍然会自动重连的bug。</item>
                        <item>SoftBasic: 删除SpliceTwoByteArray及SpliceByteArray方法，改为泛型支持的SpliceArray方法，支持任意类型拼接，添加了扩展方法支持。</item>
                        <item>Modbus: 支持 0x16 功能码，用于掩码操作，支持对寄存器地址的位操作，需要设备方支持，该功能仅支持商业授权使用。</item>
                        <item>Modbus: 读取线圈和输入线圈的长度支持任意，内部按照2000长度自动切割，读取寄存器和输入寄存器按照120自动切割，该功能商业授权特权，普通的VIP用户存在长度限制。</item>
                        <item>MqttSyncClient: 新增ReadRpc&lt;T>(string topic, string payload )方法，专门用来读取注册的RPC接口的，自动json转换类型。</item>
                        <item>MqttSyncClientPool: 连接池优化，注释优化，添加了一些缺失的方法。该功能商业授权特权。</item>
                        <item>RedisClientPool: 连接池优化，注释优化。该功能商业授权特权。</item>
                        <item>LogNet: 日志部分新增一个 ConsoleOutput 属性，如果设置为 true，那么日志就会在控制台进行输出，等级不一样的日志，文字颜色不一样。</item>
                        <item>LogNet: 日志部分的记录优化调整，取消了一些底层的重复记录的日志内容，针对 MQTT, Websocket, HTTP 及虚拟PLC相关的日志记录根据信息进行优化。</item>
                        <item>祝大家新年生意滚滚，身体健康，牛年大吉。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-3-11" version="9.6.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>ILogNet: 当ConsoleOutput为true时，修复在空字符串的存储路径时，不进行控制台输出的bug。</item>
                        <item>SiemensS7Server: 优化握手报文的信息，现在支持sharp7进行数据通信了。</item>
                        <item>SiemensS7Net: 开放了 ConnectionType 和 LocalTSAP 属性，方便按照自己的需求修改，具体看属性注释。</item>
                        <item>SiemensS7Net: 西门子的PLC读取支持0x0A和0x06的错误码，当读取DB块不存在时，提示错误消息。</item>
                        <item>SiemensS7Net: 支持了 WString 类型的读写，使用ReadWString和WriteWString方法，支持中文的读写</item>
                        <item>SiemensS7Net: 西门子S7协议的地址解析，DB块地址优化，DB1.DBW1 的 DBX,DBB,DBW,DBD都会自动屏蔽。</item>
                        <item>SiemensS7Net: 在核心的报文交互上，自动忽略只有7字节的TPKT和ISO的报文的情况。</item>
                        <item>MqttServer, HttpServer:RPC注册的方法，原先只支持一个泛型的结果类 OperateResult&lt;T>， 现在支持任意个泛型的结果类对象。</item>
                        <item>FanucSeries0i: 所有的方法实现异步接口，并增加了 RPC 的特性支持，方便直接注册就可以调用。</item>
                        <item>SimensFetchWriteServer: 修复在standard项目里没有添加的bug。</item>
                        <item>MelsecMcNet: 修复ReadMemory的报文错误，增加读取智能模块的ReadSmartModule方法。</item>
                        <item>NetworkDataServerBase: 所有的虚拟PLC的基类，添加获取所在在线客户端信息的属性 GetOnlineSessions</item>
                        <item>Demo: 所有读写PLC的界面在读写的时候，增加提示耗时的信息，包括最大值，最小值。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-3-15" version="9.6.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>SiemensS7Net: 修复上个版本的DB块位地址解析的bug，写入DB1.0.5为True的时候，却写入了DB1.0.0为True。</item>
                        <item>AllenBradleyDF1Serial: 初步添加AB-PLC的DF1协议，支持了简单的读写，等待测试，地址示例：N7:0。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-3-25" version="9.6.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>SoftCRC16: 计算CRC16的辅助方法，开放预置值的设定，可以自由的指定。</item>
                        <item>FanucSeries0i: 新增一个读取机床系统语言的api，读取之后将会自动切换语言，暂不支持根据消息自动匹配编码解析。</item>
                        <item>SiemensS7Net: OperateResult&lt;byte[]> Read( string[] address, ushort[] length )接口添加RPC支持</item>
                        <item>NetworkDataServerBase: OnDataReceived事件签名修改为DataReceivedDelegate( object sender, object source, byte[] data )，追加一个source参数，可用来获取客户端IP地址，具体看api文档</item>
                        <item>NetworkDoubleBase: 增加LocalBinding属性，如果需要绑定本地ip或是端口的，可以设置，所有的网络类PLC都支持绑定本地的ip端口操作了。</item>
                        <item>NetworkUdpBase: 增加LocalBinding属性，如果需要绑定本地ip或是端口的，可以设置，所有的网络类PLC都支持绑定本地的ip端口操作了。</item>
                        <item>SiemensS7Net: 完善异步的PDU自动长度信息，新增AI,AQ地址的读写，地址格式：AI0,AQ0，欢迎大家测试。</item>
                        <item>OmronFinsNet: 欧姆龙FINSTCP协议的SA1机制调整为自动获取，不需要在手动设置，修复错误信息文本和错误码不匹配的bug。</item>
                        <item>MqttClient: 修复在网络异常导致正在重连服务器的时候，调用ConnectClose方法后，后台仍然不停的重连服务器的BUG。</item>
                        <item>NetworkDeviceSoloBase: 删除这个文件，并优化相关的串口透传类。全部改为继承自：NetworkDeviceBase</item>
                        <item>NetworkDataServerBase: 所有派生类的虚拟服务器，包括modbus，s7, mc, fins等服务器全部支持设置是否允许远程写入操作，modbus的demo界面添加是否允许的选项。</item>
                        <item>WebSocketClient: 修复客户量的Request报文少一个换行信号在某些服务器会连接失败的bug，新增两个发送数据的api，发送数据更加的灵活。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-4-15" version="9.7.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>OmronFinsNet, OmronFinsUdp, HostLink: 地址的解析优化，在读取的API方法里，自动按照500长度进行切割，可以由 ReadSplits 更改。</item>
                        <item>FanucSeriesOi: Fanuc数控机床支持R数据的读取，参考API： ReadRData(int start, int end)</item>
                        <item>HslExtension: 新增从字节数组获取位值的扩展方法: GetBoolValue( this byte[] bytes, int bytIndex, int boolIndex )</item>
                        <item>FatekProgram: 地址解析优化，修复 RT,RC地址解析不正确的bug，读取的字及位长度自动切割，调用不受长度限制。</item>
                        <item>SoftBasic: 添加设置byte数据的某个位的方法SetBoolOnByteIndex，也可以调用byte的扩展方法，byte.SetBoolByIndex(2, true) 就是设置第二位为true</item>
                        <item>FujiSPHNet: 新增支持富士的SPH以太网协议，支持M1.0, M3.0, M10.0, I0, Q0地址的读写操作，支持位的读写操作。写位需要谨慎，先读字，修改位，再写入。</item>
                        <item>net20, net35, net451三个框架版本的项目引用 http.web 组件，用来修复 HttpServer 里url携带中文时，会导致解析乱码的情况，现在支持了中文的api接口注册，中文参数。</item>
                        <item>HttpServer: 使用了注册RPC接口时，返回调用方的数据内容格式调整为json格式，方便postman等测试工具识别内容。</item>
                        <item>FujiSPHServer: 新增富士SPH协议的虚拟服务器，支持和FujiSPHNet进行测试通信。支持的地址是一致的。</item>
                        <item>KeyenceNanoSerial: 基恩士的上位链路协议优化，支持了B，VB的bool读写，W，VM的字读写，新增bool数组写入功能。</item>
                        <item>KeyenceNanoSerial: 支持了plc型号读取，状态读取，注释读取，扩展缓存器的读写，错误代码提示携带更详细文本，适用于 KeyenceNanoSerialOverTcp</item>
                        <item>KeyenceNanoServer: 新增基恩士上位链路协议的虚拟服务器，可以和 KeyenceNanoSerialOverTcp 进行通信测试。</item>
                        <item>KeyenceSR2000: 基恩士扫描的协议的错误提示信息新增了英文模式下的注释，原来的只有中文的提示。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-5-13" version="9.8.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>MqttSyncClient: ReadRpc&lt;T>方法提示JSON转换错误消息更加友好，注释完善。</item>
                        <item>MelsecMcServer: 三菱的虚拟plc新增对B，R，ZR的地址支持。</item>
                        <item>FujiSPHNet: 富士PLC实现按照240长度自动切割，支持无限长的数据读取。</item>
                        <item>MqttClient(不兼容更新): 接收服务器数据的事件签名修改，MqttMessageReceiveDelegate( MqttClient client, string topic, byte[] payload );</item>
                        <item>WebSocketServer: 优化数据发送部分的功能逻辑代码，将数据发送从锁中解脱出来。</item>
                        <item>MqttClient: 新增属性 ConnectionOptions 用来获取当前连接参数信息。</item>
                        <item>Omron: Hostlink协议的读取字数据时，长度进行切割，按照260字切割，可通过ReadSplits属性修改。</item>
                        <item>PanasonicMewtocolServer: 初步添加mewtocol的虚拟plc，初步测试R地址成功。</item>
                        <item>设备通信核心: tcp, udp, 串口三大通信内核添加，封包和解包的虚方法，可以重写实现自定义需求。</item>
                        <item>IModbus: 新增IModbus的设备接口，用来描述Modbus相关的设备，包含站号，DataFormat属性等。</item>
                        <item>Modbus: 包含TCP,RTU,ASCII,RTU-over-tcp，UDP全部结构优化，重写，完善，最终一套代码实现覆盖以上类，接口无变化。
                        但是如果用调用了ReadFromCoreServer则不兼容，现在都只需要传核心报文，01 03 00 00 00 01，无论rtu,tcp,ascii</item>
                        <item>Modbus: 支持对寄存器，输入寄存器的位数据读取，ReadBool("100.1") 就是读取寄存器地址100的第一个位的bool值。</item>
                        <item>MqttSubscribeMessage: Identifier默认设置为1，这样可以修复在某些服务器（mosquitto）订阅异常的bug。</item>
                        <item>SerialBase(不兼容更新): ReadBase串口基本的交互方法重命名为ReadFromCoreServer，这样与TCP，及UDP的方法标准一致。</item>
                        <item>FanucInterfaceNet: 支持 R 地址的读写，支持R1-R10，其中R1-R5为int数据，R6-R10为float数据。SR1-SR6进行字符串读写。</item>
                        <item>BeckhoffAdsServer: 新增ADS的虚拟PLC，支持M100, I100, Q100地址格式。暂不支持内存地址，变量名。</item>
                        <item>SiemensS7Net: 修复9.6.4版本添加的ConnectionType, LocalTSAP属性对 200，200smart型号的影响。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-5-23" version="10.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>V10版本：本来上个版本就应该定为V10版本，因为已经内核优化，出现不兼容更新，所以这个版本果断设定为V10版本。</item>
                        <item>SerialBase: 修复在串口异常的情况下，会抛出异常的bug，是上个版本的问题，现在会返回失败的OperateResult对象。</item>
                        <item>ShineInLightSourceController: 新增昱行智造科技（深圳）有限公司的光源控制器的通信对象，主要用于视觉的打光操作。</item>
                        <item>MqttSession：Mqtt的会话信息增加一个object Tag属性，用来自己绑定一些自定义的数据。</item>
                        <item>SerialBase: 串口初始化的方法修改为虚方法，允许在继承类里进行重写，修改一些默认参数信息。</item>
                        <item>NetworkBase: 修复ReceiveAsync异步方法在length=-1时，对方关闭时返回仍然为成功的bug，只有在极少数情况下会触发。</item>
                        <item>ModbusTcpServer: 新增一个属性UseModbusRtuOverTcp，只要设置为True，就可以创建ModbusRtuOverTcp的对应的服务器，使用TCP传送RTU报文。</item>
                        <item>HttpServer: 新增SetLoginAccessControl( MqttCredential[] credentials )方法，用于增加默认的账户控制，如果传入null，则不启动账户控制。</item>
                        <item>IReadWriteDevice: 新增设备读写接口，继承自IReadWriteNet，然后所有设备实现IReadWriteDevice接口，相关继承关系优化，接口增加ReadFromCoreServer。</item>
                        <item>All: 统一所有的设备核心层打包报文方法名为:PackCommandWithHeader 解包的方法名为UnpackResponseContent，允许重写实现自定义操作。</item>
                        <item>Omron: 对OmronFinsTcp和OmronFinsUdp的通信层大幅度优化，统一代码规则，新增run，stop，读取cpu数据，cpu状态的高级方法。</item>
                        <item>DTSU6606Serial: 新增德力西电表的采集类，基于modbusrtu实现，ReadElectricalParameters方法可以直接获取电表相关参数。</item>
                        <item>HslExtension: 有两个获取byte的位的方法，功能重复，删除GetBoolOnIndex方法，使用GetBoolByIndex方法。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-6-11" version="10.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>FatekProgram: 串口类和串口转网口透传类优化，统一一套代码来读写设备。</item>
                        <item>IDisposable: NetworkAlienClient, NetworkAlienClient, LogNetBase, MqttClient, MqttServer, WebSocketClient, WebSocketServer实现释放接口。</item>
                        <item>SiemensS7net: 新增DestTSAP属性，优化了LocalTSAP和DestTSAP属性对不同系列plc的值设置，当plc为s200系列时，支持设置自定义的值来访问plc。</item>
                        <item>UltimateFileServer: 文件服务器删除目录所有文件调整为直接删除整个目录，新增支持删除指定目录下所有空的子目录的功能。文件客户端新增匹配操作的方法。</item>
                        <item>PanasonicMcNet: 地址新增支持SD数据类型，示例SD0，返回的错误代码修改为松下的专用信息，和三菱的不一致。</item>
                        <item>IModbus: Modbus接口新增TranlateToModbusAddress( string, byte) 接口，只要继承重写该方法，即可轻松实现自定义地址解析转modbus地址。</item>
                        <item>Delta: 台达相关的类根据modbus最新的优化，全部进行优化，每个类只有一点点代码了。</item>
                        <item>FujiSPB: 富士的串口协议代码和串口透传代码优化，修复串口类调用异步写bool失败的bug。</item>
                        <item>XinJE: XinJEXCSerial重命名为 XinJESerial类，根据modbus的优化进行精简，支持了信捷系列选择，可选XC,XJ,XD，地址支持根据所选型号自动解析。</item>
                        <item>XinJE: 新增基于串口透传的XinJESerialOverTcp类，以及modbustcp协议的XinJETcpNet类，DEMO上支持测试。</item>
                        <item>Inovance: 汇川的类优化，删除原来的AM,H3U,H5U类，改用InovanceSeries枚举来区分系列，然后解析不同的地址。同时添加InovanceSerialOverTcp串口转网口类。</item>
                        <item>OmronFinsServer: 欧姆龙的FinsTCP虚拟服务器端支持E数据块，E0.0-E31.0 都是指同一个数据块。</item>
                        <item>IByteTransform: 新增二维数组的解析方法接口，主要是short,ushort,int,uint,long,ulong,float,double类型。</item>
                        <item>Demo: MelsecSerialOverTcp的demo界面添加是否新版的选择。</item>
                        <item>如果有用到汇川，信捷的类库，请注意升级时出现不兼容，需要修改下类型，指定PLC的系列，感谢支持。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-6-22" version="10.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>OmronFinsServer: 修复服务器的内存数据保存本地文件及加载文件时，不支持em区数据的bug。</item>
                        <item>ISessionContext: 新增会话信息接口，在MqttServer和Httpserver中，在注册RPC时可以在方法参数里追加ISessionContext接口的上下文信息，用来控制当前api的对不同账户的权限。</item>
                        <item>Modbus: TranslateToModbusAddress 单词拼写错误的修复。</item>
                        <item>FujiSPBAddress: 地址类的继承改成 DeviceAddressDataBase</item>
                        <item>ModbusHelper: 在所有modbus及派生类里，当实现地址转换后，修复写bool,bool[]时地址仍然不转换的bug。</item>
                        <item>KeyenceNano: 新增 UseStation 属性，用来设定是否开启使用站号的报文功能，有些特殊的情况需要站号。</item>
                        <item>KeyenceNano: 串口类和串口转网口透传类优化，统一一套代码来读写设备。</item>
                        <item>其他的注释优化，代码优化</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-7-14" version="10.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>Melsec: 三菱的MC协议TCP，UDP，二进制，ASCII代码优化，一套代码实现，新增IReadWriteMc接口，针对MC协议的设备通用读写类</item>
                        <item>NetworkUdpBase: 新增LogMsgFormatBinary属性，可以指示当前的数据交互报文记录时按照ASCII编码显示，或是二进制显示。</item>
                        <item>DTSU6606Serial: 德力西的电表的读取方法ReadElectricalParameters支持HslMqttApi特性，方便MRPC及WEBAPI接口服务注册。</item>
                        <item>Demo: Modbus rtu的demo界面的报文读取取消crc封装，因为内部已经集成封装。</item>
                        <item>Melsec: 统一 MelsecMcNet, MelsecMcUdp, MelsecMcAsciiNet, MelsecMcAsciiUdp, MelsecMcRNet的代码逻辑结构，修复了ASCII格式类的一些bug。</item>
                        <item>MelsecMcServer: 三菱的虚拟服务器限制了bool读取长度7168限制字读取长度960，三菱MC客户端的bool读取支持自动切割。</item>
                        <item>OmronHostLink: OmronHostLink及OmronHostLinkOverTcp代码优化，完善错误代码文本提示，增加返回命令和发送命令校验的操作。</item>
                        <item>HslExtension: ToStringArray的扩展方法支持对GUID的解析功能，不支持.net20, .net35</item>
                        <item>NetworkDataServerBase: 修复数据类服务器在主动关闭引擎时，在线客户端的数量未及时复原的bug，影响范围，所有的虚拟PLC服务器。</item>
                        <item>OmronHostLinkServer: 新增欧姆龙HostLink协议的虚拟PLC，支持网口和串口的进行读写操作。优化hostlink协议的客户端错误代码含义展示，优化数据接收机制。</item>
                        <item>Demo: httpclient界面支持对https接口测试，在内容请求的header支持添加content-type信息，提供了一些选项。</item>
                        <item>SimensWebApi: 新增NetworkWebApiDevice设备类，实现IReadWritteNet接口，新增SimensWebApi类，用于西门子1500的webapi接口，可实现读写标签变量信息。</item>
                        <item>FanucSeries0i: fanuc的通信类支持NC程序文件的上传和下载，删除，设置主程序号，启动加工操作。修复刀具信息读取时，某个刀具信息失败导致读取失败的bug。</item>
                        <item>AllenBradleyServer: ab-plc的虚拟服务器支持会话id的生成，支持对客户端校验会话id是否一致。</item>
                        <item>Melsec: MC协议的类支持对字地址按照位读取，例如读取D100.5 开始的3个位，使用ReadBool("D100.5", 3)即可</item>
                        <item>NetworkBase: 优化ReceiveByMessage及异步版本的性能，减少一次内容数据的拷贝操作，提升内存利用效率，提升读写的性能。</item>
                        <item>SiemensS7Net: 西门子s7协议的地址支持 VB100, VW100, VD100的写法。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-7-18" version="10.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>UltimateFileServer: 支持获取指定目录的所有文件大小，客户端IntegrationFileClient实现相应的调用方法GetTotalFileSize</item>
                        <item>MqttServer: 支持获取指定目录的所有文件大小，客户端MqttSyncClient实现相应的调用方法GetTotalFileSize</item>
                        <item>MelsecA3CNet1重命名为MelsecA3CNet，MelsecA3CNet1OverTcp重命名为MelsecA3CNetOverTcp，所有引用这两个类的话无法兼容更新。</item>
                        <item>MelsecA3CNet,MelsecA3CNetOverTcp修复和校验bug，支持是否和校验，支持格式1,2,3,4四种通信机制，已经通过单元测试。</item>
                        <item>MelsecA3CServer: 新增三菱的A3C虚拟plc，支持是否和校验，格式1，2，3，4，支持和MelsecA3CNet,MelsecA3CNetOverTcp通信测试。</item>
                        <item>FanucSeries0i: fanuc机床客户端新增ReadCutterNumber读取当前刀具号的API信息。</item>
                        <item>MqttClient: 新增属性UseTimerCheckDropped是否启动定时器检测，其他优化。</item>
                        <item>SoftBasic: 新增一个静态辅助方法string GetAsciiStringRender( byte[] content ); 用来获取ASCII显示的，如果遇见不可见字符，则用十六进制替代。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-8-3" version="10.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>feat(UltimateFileServer): 获取文件服务器的指定目录的大小的方法改为获取大小，文件数量，最后一个文件修改时间的方法，客户端同步更新GetGroupFileInfo。</item>
                        <item>feat(MqttServer): 获取文件服务器的指定目录的大小的方法改为获取大小，文件数量，最后一个文件修改时间的方法，客户端同步更新GetGroupFileInfo。</item>
                        <item>feat(UltimateFileServer): 新增一个获取指定目录所有子目录的基本信息，包含总大小，文件数量，最后一个文件修改时间，GetSubGroupFileInfos</item>
                        <item>feat(MqttServer): 文件服务器新增一个获取指定目录所有子目录的基本信息，包含总大小，文件数量，最后一个文件修改时间，GetSubGroupFileInfos</item>
                        <item>SiemensWebApi: 修复在.net standard2.0及2.1中未添加SiemensWebApi类的bug。</item>
                        <item>MelsecA3CNetHelper: 优化数据解析时，对错误异常的处理，增加错误捕获。</item>
                        <item>LSisServer: 重写串口Cnet协议的数据接收，处理，和返回，支持了单变量数据，和连续数据的读写操作。</item>
                        <item>XGBCnet, XGBCnetOverTcp: 重新实现了类，统一了代码，重新解析的数据内容，支持了对错误码的提取和错误消息的解析。</item>
                        <item>memobus: 新增memobus通信协议，初步实现了读取的操作，具体还需要测试，如有网友有测试条件，可以联系我测试。</item>
                        <item>Yamatake: 新增山武的数字示波器的CPL协议的通信对象和虚拟服务器，分别是DigitronCPL,DigitronCPLServer</item>
                        <item>MqttServer, HttpServer: 使用HslMqttApi特性注册远程RPC接口时，支持对异步方法(async...await)进行注册，并进行异步调用，返回相关数据。仅支持NET451及以上。 </item>
                        <item>HslMqttApi: 在注册RPC接口时，增加了对方法签名的解析过程，客户端可以浏览服务器接口的方法签名，清楚的看到返回类型，参数类型信息。</item>
                        <item>Delta: DeltaDvp系列的网口，串口协议，修复在跨区域读写M1536及D4096时，地址偏移不正确的bug。现在会自动跳转。</item>
                        <item>MqttServer: 修复Mqtt客户端在取消订阅时，传入多个的Topic时导致服务器解析异常的bug。</item>
                        <item>XGBCnet: 支持Read(string[]); 读取多个地址的数据信息，自动按照每16进行拆分访问。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision> <revision date="2021-8-23" version="10.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>JSON: .NET framework的dll对newtonsoft.Json不依赖特定的版本。</item>
                        <item>XGBFastEnet: 修复读取单个的bool时报文不正确的bug.</item>
                        <item>MqttServer: 新增GetMqttSessionsByTopic方法，用来获取订阅某个主题的所有客户端列表。</item>
                        <item>HttpServer: 修复httpserver中文编码问题，在谷歌，微软浏览器下显示中文乱码的bug。因为Content-Type传值不正确</item>
                        <item>HttpServer: 修复在账户验证模式下，使用ajax跨域请求OPTIONS导致401错误的bug。</item>
                        <item>FujiCommandSettingType: 新增富士的CommandSettingType通信协议的实现，基于TCP访问，支持地址见API文档.</item>
                        <item>FujiCommandSettingTypeServer: 新增富士的CommandSettingType协议的虚拟PLC，支持B,M,K,D,W9,BD,F,A,WL,W21地址</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-9-3" version="10.1.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>NetworkAlienClient: DTU(异形)服务器增加对报文的固定头的检查。</item>
                        <item>NetworkServerBase: 连接异形DTU(异形)的server的方法ConnectHslAlientClient支持密码输入。</item>
                        <item>NetworkDoubleBase: 当设置DTU会话时，修复恰好正在读取导致报文错乱的bug，初始化成功才成功切换DTU。</item>
                        <item>McServer: 修复三菱的MC虚拟服务器在ASCII模式下，远程客户端读写B继电器时，地址解析异常的bug。</item>
                        <item>LSisServer: 修复LSisServer在客户端读写位时，PX20之类的地址时，写入true不成功的bug。</item>
                        <item>TemperatureController: 新增RKC的数字式温度控制器的读写类，地址支持M1,M2,M3,等等</item>
                        <item>TemperatureControllerOverTcp: 新增RKC的数字式温度控制器的网口透传读写类，地址支持M1,M2,M3,等等</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-9-12" version="10.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>NetSoftUpdateServer: 代码优化，新增一个OnlineSessionss属性，用来获取当前正在更新的客户端的数量。</item>
                        <item>RSAHelper: 提供了从PEM格式的私钥和公钥创建RSA对象的辅助方法，还提供了RSA对象导出PEM格式的私钥公钥方法。支持加密解密超长数据</item>
                        <item>RSACryptoServiceProvider: 增加RSA对象的扩展方法GetPEMPrivateKey及GetPEMPublicKey方便快捷的获取PEM格式的公钥和私钥，扩展加密解密超长数据。</item>
                        <item>SerialBase: 串口基类新增虚方法CheckReceiveDataComplete用于检查报文是否接收完成，一旦接收完成，立即返回，增加通信性能。</item>
                        <item>ModbusRtu: 重写了CheckReceiveDataComplete方法，根据功能码的不同来判断当前的数据长度是否完整，以此判断报文是否完整。</item>
                        <item>ModbusAscii: 重写了CheckReceiveDataComplete方法，根据开头及结尾的固定字符来是否指定值，以此判断报文是否完整。</item>
                        <item>ModbusTcpServer: 优化服务器的串口接收功能，现在回复报文很快。1. 先接收串口数据，再Sleep。2. 增加数据完整性校验，一旦成功，立即返回报文。</item>
                        <item>ModbusTcpServer: 新增属性RequestDelayTime，设置非0时用来防止有客户端疯狂进行请求而导致服务器的CPU占用率上升问题。</item>
                        <item>MelsecA1EServer: 新增MC-A1E协议的虚拟服务器，支持了二进制和ASCII格式，已经配合客户端通过单元测试。</item>
                        <item>AesCryptography, DesCryptography: 新增AES及DES加密解密对象，使用密钥实例化即可加密解密操作。</item>
                        <item>MQTTServer: 在原有的基础上增加了加密的功能，如果MQTTClient，MQTTSyncClient启用加密功能，那么数据的传输就是加密的，无法抓包破解账户名密码及交互数据。</item>
                        <item>AllenBradleyNet: cip协议支持了日期，日期时间的读写操作，这样omron的plc的cip协议也支持了日期时间的读写，在omroncip的demo上添加测试操作。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-9-19" version="10.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>SiemensS7Net: 修复读写WString字符串时，乱码的情况。</item>
                        <item>NetSoftUpdateServer: 修复在某些情况下在线客户端数量新增后不会减少的bug。</item>
                        <item>demo: 字节转换工具界面增加字节数组和base64字符串的转换功能。</item>
                        <item>MqttServer: 当MQTTClient在加密模式下，订阅一个主题后，修复服务器仍然返回没有加密的bug，导致客户端解密失败。</item>
                        <item>MqttSyncClient: 修复加密模式下，使用SetPersistentConnection设置长连接，不进行ConnectServer直接第一次请求失败的bug。</item>
                        <item>AllenBradleyNet: 优化读取bool的功能方法，新增读取bool数组的实现。</item>
                        <item>NetworkDataServerBase: 所有串口类的服务器（从机），功能代码优化调整，部分的类实现报文完整性判断，实现数据瞬间回复客户端（主机）。</item>
                        <item>Serial: 大量的串口类的设备进行了优化，对接收结果是否结束进行判断，提高了串口通信的性能。</item>
                        <item>NetSoftUpdateServer: 新增另一种更新机制，更新软件在收到文件信息后，先比对MD5信息来确定是否下载更新，从而提高升级速度，仍然兼容旧的更新模式。</item>
                        <item>NetSoftUpdateServer配套的更新客户端，软件自动更新重新命名为 AutoUpdate, 针对差异化更新做了优化。</item>
                        <item>DEMO里面所有的读写PLC界面的读写字符串功能支持了可选编码，支持ASCII,UTF8,UNICODE,UNICODE-BIG,GB2312,ANSI</item>
                        <item>其他一些细节的优化，和注释的完善。DEMO界面的大量优化，显示调整，DEMO使用了新的更新软件，AutoUpdate.exe</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-9-30" version="10.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>NetworkDoubleBase: 在异步的网络通信方法中，原来的同步锁会在特殊的情况下导致UI线程卡死，所以改为异步锁，相关继承类也修改。</item>
                        <item>HslReflectionHelper: 通过HslDeviceAddressAttribute反射Read，Write的读写自定义对象的功能支持对byte类型的读写操作，需要通信对象本身支持才能成功读写。</item>
                        <item>SerialBase: 新增protect级别的AtLeastReceiveLength变量，用来表示从串口中至少接收的字节长度信息，一般为1。</item>
                        <item>IReadWriteNet: 新增api支持ReadCustomer( string address, T obj )，允许传入实例对象，对属性进行赋值，方便wpf进行数据绑定操作。</item>
                        <item>NetworkWebApiBase: 新增属性UseEncodingISO，在访问某些特殊的API的时候，会发生异常"The character set provided in ContentType is invalid...."，这时候本属性设置为true即可。</item>
                        <item>Cip: 欧姆龙cip及rockwell的cip支持读取plc型号的方法ReadPlcType()，omron的cip重新设计了WriteTag，对于0xD1类型数据，支持偶数个写入操作。</item>
                        <item>SiemensPPI: 修复writebyte方法的api接口名称还未注册的问题, 和串口透传类的相关代码优化，精简。</item>
                        <item>MelsecFxSerial: AtLeastReceiveLength变量设置为2，和串口透传类的相关代码优化，精简。</item>
                        <item>MqttServer: 新增属性：TopicWildcard，当设置为true时，支持主题订阅通配符，使用#,+来订阅多个主题的功能。具体参考该属性的API文档。</item>
                        <item>demo: 修复demo的HTTPClient界面浏览在linux创建的Webapi服务器的api列表功能失败的bug，使用HttpWebRequest来实现。</item>
                        <item>demo: rsa加密解密算法测试界面实现签名和验签操作。签名算法可选SHA1，SHA256, SHA512, MD5等等。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-11-19" version="10.3.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>allenbrandlyNet: ExtraOnDisconnect方法增加socket的空检测操作，因为在极少数特殊情况会发生空的异常的bug。</item>
                        <item>OmronCipNet: 修复Write数据类型为short[]时长度不是1的bug。同步方法调用Write(string,short[])时会发生写入失败。</item>
                        <item>Demo: OmronHostLinkCModeOverTcp的Demo测试界面添加读取型号的功能，可以更加便捷的测试。</item>
                        <item>AllenBradleyNet: 重写读取字符串方法ReadString( string address, ushort length )，编码修改为UTF8</item>
                        <item>ReverseWordTransform: 字节变换的对象代码优化精简，ReverseWordTransform新增IsInteger16Reverse属性指示short,ushort是否发生翻转，默认翻转。适用极个别特殊的Modbus格式</item>
                        <item>YRC1000TcpNet: 安川的机器人的API功能大量添加，支持读取机器人坐标，各种变量信息，启动程序，停止，复位，读报警等待。</item>
                        <item>SiemensS7Net: 写入bool数组的方法优化，修改为先读取byte[], 修改中间的位，然后再写回去操作，可以写入一个字节的中间几个位，单元测试通过，仍然有风险，谨慎调用。</item>
                        <item>OmronHostLinkCMode: 修复OmronHostLinkCMode读写字节顺序颠倒的问题，新增了读取plc型号，plc状态，修改状态的功能，增加错误码文本解释。</item>
                        <item>OmronHostLinkCModeServer: 新增CMode协议对应的虚拟PLC服务器，初步实现了和客户端通信功能，包括串口和网口的支持，单元测试通过。</item>
                        <item>添加在NET2.0，NET3.5及Standard项目缺失的SiemensFetchWriteServer, MelsecA3CServer, MelsecA1EServer, 以及安川的 memobusTcpNet</item>
                        <item>SiemensS7Net: 在读取单个的bool的值的时候，增加对结果数据的合法性检测，当遇到错误码时，提示错误信息。修复写入bool在某些特殊的情况下，实际成功但是提示失败的bug。</item>
                        <item>YRCHighEthernet: 安川机器人添加高速以太网通信，基于UDP实现，在DEMO界面可以直接原生命令测试，支持读取报警，字节，整型，字符串等变量。</item>
                        <item>PipeSerial, PipeSocket: 新增串口管道和网口管道，串口基类和网口基类优化重构，允许多个串口设备对象共享一个串口通道，多个网口的设备对象共享一个网口通道。</item>
                        <item>ModbusTcpNet:新增属性IsCheckMessageId，用于配置modbustcp协议是否检查设备返回的消息ID是否一致，默认检查，设置为False，也即是不检查ID一致。</item>
                        <item>MemobusTcpNet: 安川PLC的memobus协议的修复报文错误的bug，增加了线圈读写，寄存器读写，扩展寄存器的读写功能，例如扩展保持寄存器地址：x=9;100</item>
                        <item>Demo：测试界面添加了一个TCP转TCP的界面，可以用于两个网络连接中捕捉通信的数据报文。还有其他的一些细节优化。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-12-2" version="10.4.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>Delta:台达系列的PLC类重命名，新增PLC系列，可选DVP系列和AS系列，相当于新增了对AS300的支持，如果用到，谨慎更新。</item>
                        <item>WebSocketServer: 原先订阅的操作使用header来完成，新增客户端从url添加订阅主题，例如：ws://127.0.0.1:1883/HslSubscribes=A,B</item>
                        <item>AllenBradleyPcccNet:新增AB的CIP协议PCCC格式的通信，测试适用ab1400，地址格式为 N7:5, I:0/2, F2:0 等</item>
                        <item>AllenBradleyPcccServer: 新增PCCC的虚拟服务器功能，可以配合客户端进行通信的测试，支持基本的地址。</item>
                        <item>MC-A3C: 修复A3C的服务器在格式4的情况下，返回写入操作的控制代码错误的bug，应该为06，写成了02。</item>
                        <item>三菱的A3C协议的读取字数据及位数据长度自动切割，可以输入理论最大长度，修复校验是否写入成功确提示失败的bug。</item>
                        <item>NetworkDataServerBase:串口接收增加最小接收时间，默认是20，表示20毫秒，如果重写了报文结束检查，则可以设置大一点。</item>
                        <item>NetworkServerBase: 基础服务器对象新增属性EnableIPv6，当设置为true的时候，则使用IPv6协议进行数据通信和访问。</item>
                        <item>所有的TCP及UDP的相关的客户端通信类的 IP 地址设置，都支持了 IPv6 地址，所以目前IP地址支持 IPv4 和 IPv6 及 网址。</item>
                        <item>Demo:fanuc机器人的测试界面写入数据操作进行提示相关的确认，防止手抖不小心写入导致机器人运行不正常。</item>
                        <item>Demo，所有的设备通信类，新增一个支持的设备列表功能，大家可以手动添加支持的列表，方便别人查看支持的型号，请大家务必真实填写。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-12-17" version="10.4.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Delta: 台达的DVP系列，当地址带站号时，并且出现了跨地址切割时，修复站号丢失的bug。跨地址指跨越M1536,D4096地址。</item>
                        <item>Delta: 台达AS系列的地址 SR 地址支持输入 SR0 以及 sr0 </item>
                        <item>针对FinsTcp协议及ADS协议的剩余字节解析，本来是int类型，现在加了最大长度10000的限制，防止异常攻击时导致申请内存过大而奔溃。</item>
                        <item>Inovance: 汇川相关的PLC的数据排列规则调整为 CDAB，DEMO上的选择也默认改为这个。</item>
                        <item>MelsecFxSerial: 移除三菱编程口协议最小接收回复报文2字节的限制，实际测试有时候只需要一个字节就可以了，否则会一直处于接收超时。</item>
                        <item>ByteTransform: TransBool的方法的偏移和长度均修改为以位为单位，具体调用API时查看注释说明，长度为10就表示10个长度的bool。</item>
                        <item>AllenBradleySLCNet,AllenBradleyPcccNet: 地址支持ST10:2这种字符串地址，并在AllenBradleyPcccNet上实现动态读取字符串，长度为0或没有，则自动长度。</item>
                        <item>AllenBradleySLCNet,AllenBradleyPcccNet: 以及SLC的协议地址支持了 L17:0 的地址，长整型类型</item>
                        <item>VigorSerial,VigorSerialOverTcp: 新增丰炜PLC的编程口协议及透传类，支持VS系列，地址支持动态站号信息，例如 s=2;D100</item>
                        <item>VigorServer: 新增丰炜的虚拟PLC，模拟了VS系列的通信，可以和对应的客户端进行数据读写测试，位地址支持 X,Y,M,S，字地址支持 D,R,SD</item>
                        <item>MelsecFxSerial: 三菱的编程口协议及其透传类添加一个激活PLC的API方法ActivePlc，在某些特殊的PLC读写数据之前，需要先调用一下。</item>
                        <item>Modbus:Modbus所有协议的ReadFromCoreServe(byte[])增加特别的注释，只需要传递modbus核心报文即可，不管tcp,还是rtu,还是ascii，都是一样的。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2021-12-22" version="10.4.2" author="Richard.Hu">
                    <list type="bullet">
                       <item>NetworkBase: 新增Receive原始字节数据时，也就是申请byte[]缓存时，对可能存在的异常捕获操作，返回失败的结果对象。</item>
                       <item>AllenBradleyPcccNet: 修复对于ReadAsync也注册了API接口，导致重复注册的bug。</item>
                       <item>WebSocketClient: 修复因为掉线重连服务器的时候，重新携带订阅的主题。</item>
                       <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                       <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2022-1-1" version="10.4.3" author="Richard.Hu">
                    <list type="bullet">
                       <item>SerialBase: SetPipSerial重，命名为SetPipeSerial，如果有使用串口管道，则需要更改相关的名称。</item>
                       <item>MelsecMcDataType: 修复三菱累计定时器当前的值的地址进制转换应该为10进制，结果写成100导致转换失败的bug。</item>
                       <item>Keyence: 上位链路协议的串口及网口的通信类，ByteTransform的IsStringReverseByteWord调整为true，读写字符串时将两两颠倒。</item>
                       <item>IByteTransform: 转换接口类的注释进行完善，提示更加详细完整，中英文并行提示。</item>
                       <item>Vigor: 丰炜PLC的读取位和读取字的功能方法，对读取长度进行内置切割，相当于支持了无限长度的数据读取。</item>
                       <item>EstunTcpNet: 新增埃斯顿机器人通信类，内置定时器保持心跳，支持读取机器人的基本信息，详细见DEMO界面。</item>
                       <item>FanucInterfaceNet: 修复fanuc机器人的中文编码异常的bug，使用标准的GB编码解析，如果编码获取异常，需要自行nuget安装System.Text.Encoding.CodePages组件，并注册编码。</item>
                       <item>Device: 设备类增加ReadStruct{T}方法，根据特性从原始字节里解析出实际的数据对象。影响范围所有的设备类对象。</item>
                       <item>Demo: Demo程序支持了手动设置版本更新忽略提醒，忽略之后再菜单栏进行提示新版，以及增加添加激活操作功能，本地保存加密的激活码。</item>
                       <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                       <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2022-1-17" version="10.5.0" author="Richard.Hu">
                    <list type="bullet">
                       <item>ABBWebApiClient: GetRobotTarget方法，返回的数据信息，增加q4数据信息。</item>
                       <item>Modbus: 在modbus的派生类协议中，重写了modbus的地址转换的情况中，修复读写bool操作，因为地址中带小数点导致地址转换异常的bug。例如汇川AM系列读写QX3000.0 的bool值</item>
                       <item>MelsecFxSerialHelper: 三菱编程口协议的检查和校验的方法，增加try...catch，在某些特殊的情况下，会导致异常，直接奔溃。</item>
                       <item>NetSoftUpdateServer: 针对之前旧版的软件升级功能，增加30分钟的超时时间限制，如果30分钟后仍然没有更新完成，则自动移除会话。</item>
                       <item>SiemensS7: S7的地址支持大小写，且都支持带X,B,D,W的地址，比如MD100, MW100, MX100.2</item>
                       <item>OmronConnectedCipNet: 注册报文里的不通信超时修改为42分钟，读取short，及ushort数组时，按照994长度进行切割</item>
                       <item>AllenBradleyPcccNet: 支持使用0F-AB的掩码写入功能，写入一个bool值到PLC中，PCCC虚拟服务器实现了这个AB功能码，可以虚拟测试。</item>
                       <item>FanucInterfaceNet: 修复demo上读取WO数据时，地址偏移不正确的bug。</item>
                       <item>Freedom: 串口，网口的自由通信协议增加委托CheckResponseStatus，可以自定义对报文结果进行校验，完善注释。</item>
                       <item>DLT645: 优化数据接收部分的代码，如果数据完整，立即返回，数据前面兼容无用的字符数据。</item>
                       <item>INetMessage: 消息类新增方法PependedUselesByteLength( byte[] headByte )并在DLT645OverTcp消息类重写，支持前置无效的字符。</item>
                       <item>AllenBradleyNet：支持添加消息路由功能，默认不开启，实例化属性MessageRouter, 例如：1.15.2.18.1.1，支持在demo界面进行配置操作。</item>
                       <item>AllenBradleyNet: 支持遍历全局变量和局部变量。新增StructTagEnumerator( AbTagItem structTag )方法遍历结构体的成员变量信息。</item>
                       <item>Demo:AllenBradleyNet节点浏览的界面支持了查找数据，显示数据，结构体嵌套遍历，还支持显示当前的数据信息。</item>
                       <item>ModbusTcpServer的RTU接收时间调整为500ms，如果报文完整立即接收结束。</item>
                       <item>本版本可能是春节前的最后一个版本了，提前祝大家新春快乐。</item>
                       <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                       <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2022-2-28" version="10.5.1" author="Richard.Hu">
                    <list type="bullet">
                       <item>AllenBradleyNet: Write( string address, bool value )写入bool方法优化，如果是类型代号0xD3的，地址前面需要增加 "i=" 标记。</item>
                       <item>PanasonicMewtocolServer: 松下虚拟PLC地址类型支持完善线圈支持X,Y,R,L, 字单位的整型支持 X,Y,R,L,D,LD,F，支持RCP及WCP指令离散读写线圈。</item>
                       <item>PanasonicMewtocol：松下协议及其网口类的代码优化提炼共同代码，新增加离散bool地址的读写，传入多个地址，返回一个bool数组。</item>
                       <item>AsciiControl: 在命名空间slCommunication.Core下面增加一个AsciiControl类，包含控制类ASCII常量定义，例如ENQ,NAK,STX,ETX等。</item>
                       <item>MelsecFxLinksServer: 新增三菱的FxLinks计算机链接协议的虚拟PLC，支持串口和网口透传访问，支持格式1，4切换，支持是否和校验。</item>
                       <item>MelsecFxLinks: 1. 同时支持了格式1，格式4，2. 支持了地址大于10000的时候使用QR,QW命令，3. 修复报文创建时数据长度及站号不是16进制的bug。</item>
                       <item>KeyenceNanoServer: 修复启动串口时，和上位链路客户端通信时，一直返回通信校验错误的bug，现在针对CC指令和CQ指令都能正确的返回。</item>
                       <item>keyenceNano: 基恩士上位链路协议的串口类和网口透传类记录报文的格式调整为ASCII码，这样更加直观。</item>
                       <item>NetworDataServerBase: 添加GetNewNetMessage( )及ReadFromCoreServer方法，精简所有继承的子类虚拟PLC的服务器的代码。</item>
                       <item>MelsecA1EServer: 修复三菱A1E协议服务器报文接收异常的bug，导致客户端读写数据不正常。</item>
                       <item>FatekPrograme: 永宏编程口协议读取字按照64字长度自动切割，支持了RUN,STOP，读取状态接口方法，新增对应的虚拟服务器实现。</item>
                       <item>SpecifiedCharacterMessage: 新增基于指定字符结尾的消息类，通过ProtocolHeadBytesLength属性变种而来，NetworkBase的ReceiveByMessage功能适配了SpecifiedCharacterMessage消息。</item>
                       <item>Turck: 新增图尔克的Reader协议实现，支持对字节读写，bool读写，实现了虚拟服务器，通过了单元测试，主要用来和RFID进行通信。</item>
                       <item>IEC104: 初步添加IEC104协议实现和解析，增加demo测试，但是目前还清楚怎么设计API和使用场景，等待继续优化，欢迎相关需求的人联系测试优化。</item>
                       <item>DEMO: RSA加密解密的测试界面，支持对超长的数据进行加密解密操作。</item>
                       <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                       <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2022-4-1" version="10.6.0" author="Richard.Hu">
                    <list type="bullet">
                       <item>ModbusHelper: 修复ReadBoolHelper在Modbus继承类里进行了自定义地址转换，导致读字地址的位失败，例如汇川AM系列读取M240.1的bool数据失败</item>
                       <item>LSisServer: 修复基于Cnet串口协议的通讯时，客户端使用SB连续读取指令读取长度大于9时，服务器对长度解析失败导致读取失败的bug。</item>
                       <item>GroupFileContainer: 新增获取所有文件的下载次数总和的属性，名称为：TotalDownloadTimes。</item>
                       <item>SerialPort: 新增串口的扩展方法IniSerialByFormatString，支持格式化的初始串口信息，例如 COM3-9600-8-N-1，简单明了。ModbusServer界面支持串口参数配置，支持配置最短接收时间配置。</item>
                       <item>MelsecFxLinksServer: 三菱Fxlinks虚拟服务器，修复远程客户端在读取位地址（例如M100）的字数据时，返回错误失败的bug。</item>
                       <item>HslReflectionHelper: MRPC及Webapi注册的方法接口功能中，支持参数类型为自定义类型数组的参数，例如Student[]，不支持List{Student}。</item>
                       <item>MqttServer: 文件读写功能的引擎中，遍历所有子目录统计信息时，可选参数是否携带返回最新的一个文件的信息，客户端做了相关的适配，参数支持。</item>
                       <item>XGBFastEnet: 修复向PLC读取数据到时候，类型指定不正确的bug，之前无论是什么类型，都会设置为0，PLC从而值返回一个字节长度的数据。</item>
                       <item>Mewtocol: 松下Mewtocol协议，当读写字单位超出协议限制时，自动升级为扩展协议标识，标记字符为 &lt; (小于号), 服务器读写长度根据实际限制，支持扩展协议标识。</item>
                       <item>FanucSeries0i: 修复fanuc机床类读取虚拟机床系统时，显示运行时间为负数的bug。</item>
                       <item>NetworkDoubleBase: 新增受保护的属性UseServerActivePush，只要设置为True，就可以将当前的连接切换为既支持设备主动发送，又支持同步访问的客户端，使用信号同步器来支持问答通信。</item>
                       <item>SiemensPPIServer: 新增PPI Server类，支持TCP以及串口的通讯，PPI的串口和网口透传类客户端增加读取PLC类型的功能方法。</item>
                       <item>SiemensS7Server: 修复客户端读取数据时，返回客户端FF04的数据内容时，位长度信息赋值不正确的bug，这会导致某些客户端发生数据异常。</item>
                       <item>SiemensPPI: 西门子PPI协议优化，读取bool[]的功能方法调整为先读取字，再解析出位数据信息，以此来支持批量读取位。</item>
                       <item>XinJETcpNet: 信捷的modbustcp协议新增当某些地址超过临界范围时，自动升级modbus协议到信捷内部TCP协议，以此访问到更大范围的数据内容，并支持了临界地址的跨地址访问，自动切割重组。</item>
                       <item>XinJEInternalNet: 新增完全的信捷内部协议实现的TCP通信，可以读取更大范围的数据内容，比如D200000地址，支持的地址参考API文档。</item>
                       <item>DeltaDvp: 修复台达系列在进行读取D寄存器的位的时候，也即是时 ReadBool("D100.1") 方法时，地址无法识别的bug，现在可以正确的读到D100的位信息。</item>
                       <item>FanucSeries0i: 新增WriteRData的接口方法，新增读写PMC数据的方法，ReadPMCData及WritePMCData，与R数据的读写类似，都是字节操作的方法。</item>
                       <item>IReadWriteDevice: 扩充方法支持，支持ReadFromCoreServer(List{byte[]})的读取的方法支持，支持多个报文读取，结果打包返回。</item>
                       <item>BeckhoffAdsNet: 倍福通信类新增是否使用自动AMS属性，默认为false，设置为true时，网络初始化时从server端加载相关的NETID参数信息，目前在twincat3上成功测试。</item>
                       <item>BeckhoffAdsNet: 修复ReadBool数组时，返回的长度都是8的倍数的bug。属性UseServerActivePush调整为True，支持PLC方主动推送数据信息。</item>
                       <item>BeckhoffAdsNet: 修改读取bool时地址机制，地址支持小数点，例如M100.2 ，所以M800等于M100.0， 修复读取数组时值解析不正确的bug， 修复写入bool数组失败的bug。</item>
                       <item>BeckhoffAdsNet: 修复直接SetPersistentConnection设置长连接无法读取的bug，以及掉线后，继续读写一直失败的bug。</item>
                       <item>BeckhoffAdsNet: 修复倍福服务器重启后继续读写标签变量一直失败的bug，原因来自倍福重启导致标签内存地址变更，但是缓存还是一直使用旧的。</item>
                       <item>SecsHsms: 新增secs协议的hsms实现，初步实现了主动方，也即是客户端，支持了一个通用的接口和数据，ReadSecsMessage方法。</item>
                       <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                       <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2022-4-11" version="10.6.1" author="Richard.Hu">
                    <list type="bullet">
                       <item>MelsecMcRNet: 修复McType属性设置不正确的bug，导致依然使用普通的mc协议来进行通信，因为R系列MC协议地址不一样。</item>
                       <item>ModbusServer: ModbusServer增加属性StationCheck，默认为True，对请求的客户端的站号进行检查操作，也可以设置false，不检查站号一致。</item>
                       <item>BeckhoffAdsNet: 新增支持批量读取的方法Read( string[] address, ushort[] length )，完善了API文档说明，可以一次性读取多个标签信息，需要自行解析。</item>
                       <item>BeckhoffAdsNet： 修改默认的端口为851，主要用于TWINCAT3，当没有设置 NETID 时，直接连接PLC的话，自动升级为自动获取NETID信息。</item>
                       <item>BeckhoffAdsNet: 重写实现新的Read{T}(), 一次性读取所有的类型数据，然后自动解析赋值到对象的属性，在API文档上增加示例的代码。</item>
                       <item>SiemensPPI: 西门子PPI协议修复输入M5这种只有两个字符的地址的时候，地址解析报异常的bug，同样也适用于SiemensPPIOverTcp</item>
                       <item>KeyenceNano: 基恩士上位链路协议优化，地址重新设计，修复B,VB,W的十六进制地址解析异常的bug，FM地址不正确解析的bug。</item>
                       <item>KeyenceNano: 上位链路协议读取支持自动切割，根据不同的地址切割出不同的长度信息，一般都是256长度切割，虚拟服务器也进行了地址修复和长度限制适配。</item>
                       <item>OmronFinsUdp: 欧姆龙Finsudp协议的DA1（PLC节点号）调整为0x00，自动获取，在demo测试界面，增加GCT和SID的参数设置，一般默认就好。</item>
                       <item>FanucSeries0i: 读取R数据的接口重新设计，修改为ReadPMCData，地址支持G,F,Y,X,A,R,T,K,C,D,E 例如R1200，写入也是一样，具体看demo演示。</item>
                       <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                       <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2022-5-25" version="11.0.0" author="Richard.Hu">
                    <list type="bullet">
                       <item>TcpForward: 新增TCP转TCP的类，设置本地端口及远程端口，客户端连接之后立即连接远程服务器，进行数据转发，支持多个连接，每个客户端都创建一个远程连接对象，DEMO的转发测试使用这个类。</item>
                       <item>BeckhoffAdsServer: 倍福的虚拟PLC修复M100.1位地址读写数据不正确的bug，支持了符号地址，支持创建符号数据，自动生成唯一的句柄地址。支持客户端批量的地址读取，也即功能码为 0xF080。</item>
                       <item>AllenBradleyPcccServer: 修复PCCC虚拟PLC读写地址数据解析异常的bug，导致和客户端的地址数据不一致。提炼优化地址信息。</item>
                       <item>NetworkDataServerBase: 优化串口接收时候的数据检测的代码，修复modbus虚拟服务器接收串口数据时，功能码为0x10时，SerialReceiveAtleastTime属性设置无效的bug。</item>
                       <item>XinJE: 基于modbus协议的信捷类对象，当地址是位地址时(X,Y,M等)，支持了当使用Read（字单位）读取原始字节的方法，返回原始的字节信息。</item>
                       <item>FanucSeries0i: Fanuc数控机床通信类，新增读取机床型号信息的api，ReadSysInfo，信息在连接初始时获取生成，后续直接读取内存。</item>
                       <item>FanucSeries0i: 读取程序文件及下载程序到机床支持路径参数，例如操作PATH2时只需要输入 //CNC_MEM/USER/PATH2/ 即可，新增DeleteFile的API用于删除任意路径的程序文件。</item>
                       <item>FanucSeries0i: 新增ReadAllDirectoryAndFile方法，用来遍历指定路径下的所有的子路径和文件的信息，文件大小使用字节为单位。</item>
                       <item>ISessionContext: 在MRPC的接口及HttpWebapi注册接口的方法里，参数ISessionContext新增Tag对象，方便自定义捆绑一些数据信息。</item>
                       <item>MqttServer: 文件服务器相关的功能增加GetGroupFromFilePath方法，从路径信息里获取到文件列表管理容器，进而可以获取单个文件的对象，在权限控制时可以更加的细致。</item>
                       <item>Modbus: ModbusHelper针对modbus-rtu的返回接收报文检测，增加对站号一致性的检测，如果发现站号不一样，返回错误信息。</item>
                       <item>ICryptography: 添加直接对字符串进行加密解密的方法，并在AesCryptography类和DesCryptography实现方法，方便直接操作。</item>
                       <item>OmronConnectedCipNet: 优化批量读取数组的方法，自动根据类型来切割不同的读取长度，分批次读取所有的数据信息。修复握手报文丢失Timeout时间报文的bug，导致v10.5.0以来不能读取的问题</item>
                       <item>OmronConnectedCipNet: 优化和PLC持续几秒钟不读写就被PLC强制断线的问题，现在支持很长的时间，修复关闭立即重连（包括意外断线重连）连接不成功，一直报错重复打开会话的异常。</item>
                       <item>NetworkConnectedCip: 基于连接的CIP协议里，在OpenForward初始化里，自动获取连接ID，如果失败，并尝试五次自增连接ID重新Open。</item>
                       <item>AllenBradleyConnectedCipNet: 新增ab的connected cip协议的实现，继承自欧姆龙的connected cip协议，重写了部分的逻辑实现，缩小了单次读取的字节上限，初步测试通过。</item>
                       <item>NetworkServerBase,NetworkDoubleBase: 新增属性SocketKeepAliveTime，用来设置底层的socket的KeepAlive信号，单位毫秒，默认不开启，开启后将会自动间隔的发送KeepAlive信号。</item>
                       <item>AllenBradleyServer: cip的虚拟服务器同时支持了基于连接的CIP的访问。标签定义类AllenBradleyItemValue新增TypeCode属性，在返回客户端数据的时候，带类型数据返回。支持bool[]节点创建</item>
                       <item>SoftBasic: GetAsciiStringRender 不可见字符判断除了0x20以下，追加0x7e以上的字符。新增GetFromAsciiStringRender方法，把GetAsciiStringRender 结果反向转换回来。</item>
                       <item>AllenBradleyNet: 支持写入bool[]功能，支持写入byte[]数组功能（类型代号默认为0xD1），WriteTag方法支持地址携带类型信息，例如地址 type=0xD1;A[0]</item>
                       <item>MelsecFxSerial: 三菱的编程口协议在新版协议配置为True时，修复D8000地址以上读写不正确的bug，修复X,Y,M,S部分地址读写不正确的bug，都调整为新版的报文，支持的范围更大更准确。</item>
                       <item>MelsecFxSerialOverTcp: 新增加通过GOT连接的方式，。PanasonicMewtocol: 松下的Mewtocol协议支持了经过值及目标值。ILogNet: 日志的接口新增属性LogThreadID，用来配置是否记录线程ID的数据信息。</item>
                       <item>SecsHsmsServer: 新增Secs协议的虚拟服务器，支持事件自定义处理所有的消息。并添加示例的代码。Demo程序界面。</item>
                       <item>Mqtt: MqttClient及MqttServer支持了遗言消息，客户端A在连接参数里设置了遗言主题及数据，当客户端A非正常掉线的时候，服务器即发布该遗言主题信息。</item>
                       <item>MqttSyncClient: 新增HslCancelToken对象，在文件上传和下载的过程中支持取消操作，MqttServer适配相应的功能实现，取消示例代码增加。</item>
                       <item>HttpServer: 新增Action对象DealWithHttpListenerRequest，用来处理定义的Header数据到Session会话中，实现更加复杂自定义的操作。</item>
                       <item>Demo: DEMO写入各种PLC的数据功能里，写入的数据支持byte数组，例如数据输入[1,2,3], 点击写入byte，就自动写入new byte[]{ 0x01, 0x02, 0x03};</item>
                       <item>Demo: TCP调试界面优化，新增握手报文设置。新增一个测试正则表达式的界面，增加一些常用的正则表达式的内容。CIP浏览节点界面支持正则表达式筛选节点。</item>
                       <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                       <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
                <revision date="2022-6-9" version="11.0.1" author="Richard.Hu">
                    <list type="bullet">
                       <item>HslExtension: 新增了一些扩展方法，现在可以直接从short，int类型获取位及设置位的功能，例如 bool value = shortValue.GetBoolByIndex(10); 设置位也是同理。</item>
                       <item>DLT645: Demo界面优化，无论是串口的，还是网口的，都支持了密码及操作者ID的输入。修复了站号输入后，但是站号初始化不成功的bug。</item>
                       <item>LogStatisticsBase: 当传入的长度为-1时，表示不限制长度信息，会一直的新增。</item>
                       <item>Upgrade.exe: 用于自动升级更新的项目重新优化，支持了下载时候的网速显示，支持了下载百分比显示，删除了自动创建快捷方式的代码。</item>
                       <item>SerialBase: 初始化串口的方法SerialPortInni( string portName )支持格式化的输入，例如COM3-9600-8-N-1，COM5-19200-7-E-2。</item>
                       <item>MelsecFxSerialOverTcp: 当启动GOT透传时，修复报文封装不正确导致写入失败，读写值不正常的bug。</item>
                       <item>InovanceHelper): 汇川的PLC针对M地址的寄存器，支持使用 MX0.0 来对位进行读取操作。支持了MB100读取byte类型的数据。</item>
                       <item>Demo: 在Demo所有的设备通信测试界面，几乎所有的设备都支持了显示报文信息，想要查看通信的报文协议，菜单里点击 报文日志 。</item>
                       <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                       <item>本软件已经申请软件著作权，软著登记号：2020SR0340826，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                    </list>
                </revision>
            </revisionHistory>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AbStructHandle">
            <summary>
            结构体的句柄信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbStructHandle.#ctor">
            <summary>
            实例化一个默认的对象<br />
            instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbStructHandle.#ctor(System.Byte[],System.Int32)">
            <summary>
            使用原始字节的数据，索引信息来实例化一个对象<br />
            Instantiate an object with raw bytes of data, index information
            </summary>
            <param name="source">原始字节数据</param>
            <param name="index">起始的偏移索引</param>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.ReturnCount">
            <summary>
            返回项数
            </summary>
            <remarks>
            Count of Items returned
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.TemplateObjectDefinitionSize">
            <summary>
            结构体定义大小
            </summary>
            <remarks>
            This is the number of structure members
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.TemplateStructureSize">
            <summary>
            使用读取标记服务读取结构时在线路上传输的字节数
            </summary>
            <remarks>
            This is the number of bytes of the structure data
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.MemberCount">
            <summary>
            成员数量
            </summary>
            <remarks>
            This is the number of structure members
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.StructureHandle">
            <summary>
            结构体的handle
            </summary>
            <remarks>
            This is the Tag Type Parameter used in Read/Write Tag service
            </remarks>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AbTagItem">
            <summary>
            AB PLC的数据标签实体类<br />
            Data tag entity class of AB PLC
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.#ctor">
            <summary>
            实例化一个默认的对象<br />
            instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.InstanceID">
            <summary>
            实例ID<br />
            instance ID
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.Name">
            <summary>
            当前标签的名字<br />
            the name of the current label
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.SymbolType">
            <summary>
            当前标签的类型代号，例如 0x0C1 表示bool类型，如果当前的标签的<see cref="P:HslCommunication.Profinet.AllenBradley.AbTagItem.IsStruct"/>为 <c>True</c>，那么本属性表示结构体的实例ID<br />
            The type code of the current tag, for example 0x0C1 means bool type, if the current tag's <see cref="P:HslCommunication.Profinet.AllenBradley.AbTagItem.IsStruct"/> is <c>True</c>, 
            then this attribute indicates the instance ID of the structure
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.ArrayDimension">
            <summary>
            数据的维度信息，默认是0，标量数据，1表示一维数组，2表示二维数组<br />
            The dimension information of the data, the default is 0, scalar data, 1 means a one-dimensional array, 2 means a two-dimensional array
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.IsStruct">
            <summary>
            当前的标签是否结构体数据<br />
            Whether the current label is structured data
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.ArrayLength">
            <summary>
            当前如果是数组，表示数组的长度，仅在读取结构体的变量信息时有效，为-1则是无效。
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.Members">
            <summary>
            如果当前的标签是结构体的标签，则表示为结构体的成员信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.Tag">
            <summary>
            用户自定义的额外的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.ByteOffset">
            <summary>
            获取或设置本属性实际数据在结构体中的偏移位置信息<br />
            Get or set the offset position information of the actual data of this property in the structure
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.GetTypeText">
            <summary>
            获取类型的文本描述信息
            </summary>
            <returns>文本信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.CloneBy(HslCommunication.Profinet.AllenBradley.AbTagItem)">
            <summary>
            克隆单个的标签数据信息
            </summary>
            <param name="abTagItem">标签信息</param>
            <returns>新的实例的标签</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.CloneBy(HslCommunication.Profinet.AllenBradley.AbTagItem[])">
            <summary>
            克隆整个的标签数组信息
            </summary>
            <param name="abTagItems">标签数组信息</param>
            <returns>标签数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.PraseAbTagItem(System.Byte[],System.Int32@)">
            <summary>
            从指定的原始字节的数据中，解析出实际的节点信息
            </summary>
            <param name="source">原始字节数据</param>
            <param name="index">起始的索引</param>
            <returns>标签信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.PraseAbTagItems(System.Byte[],System.Int32,System.Boolean,System.UInt32@)">
            <summary>
            从指定的原始字节的数据中，解析出实际的标签数组，如果是系统保留的数组，或是__开头的，则自动忽略。
            </summary>
            <param name="source">原始字节数据</param>
            <param name="index">起始的索引</param>
            <param name="isGlobalVariable">是否局部变量</param>
            <param name="instance">输出最后一个标签的实例ID</param>
            <returns>标签信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.CalculatesSpecifiedCharacterLength(System.Byte[],System.Int32,System.Byte)">
            <summary>
            计算到达指定的字节的长度信息，可以用来计算固定分割符得字节长度
            </summary>
            <param name="source">原始字节数据</param>
            <param name="index">索引位置</param>
            <param name="value">等待判断的字节</param>
            <returns>字符串长度，如果不存在，返回-1</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AbTagItem.PraseAbTagItemsFromStruct(System.Byte[],System.Int32,HslCommunication.Profinet.AllenBradley.AbStructHandle)">
            <summary>
            从结构体的数据中解析出实际的子标签信息
            </summary>
            <param name="source">原始字节</param>
            <param name="index">偏移索引</param>
            <param name="structHandle">结构体句柄</param>
            <returns>结果内容</returns>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet">
            <summary>
            基于连接的对象访问的CIP协议的实现，用于对罗克韦尔 PLC进行标签的数据读写，对数组，多维数组进行读写操作，支持的数据类型请参照API文档手册。<br />
            The implementation of the CIP protocol based on connected object access is used to read and write tag data to Rockwell PLC, 
            and read and write arrays and multidimensional arrays. For the supported data types, please refer to the API documentation manual.
            </summary>
            <remarks>
            支持普通标签的读写，类型要和标签对应上。如果标签是数组，例如 A 是 INT[0...9] 那么Read("A", 1)，返回的是10个short所有字节数组。
            如果需要返回10个长度的short数组，请调用 ReadInt16("A[0], 10"); 地址必须写 "A[0]"，不能写 "A" , 如需要读取结构体，参考 <see cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadStruct``1(System.String)"/>
            </remarks>
            <example>
            首先说明支持的类型地址，在PLC里支持了大量的类型，有些甚至在C#里是不存在的。现在做个统一的声明
            <list type="table">
              <listheader>
                <term>PLC类型</term>
                <term>含义</term>
                <term>代号</term>
                <term>C# 类型</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>bool</term>
                <term>位类型数据</term>
                <term>0xC1</term>
                <term>bool</term>
                <term></term>
              </item>
              <item>
                <term>SINT</term>
                <term>8位的整型</term>
                <term>0xC2</term>
                <term>sbyte</term>
                <term>有符号8位很少用，HSL直接用byte</term>
              </item>
              <item>
                <term>USINT</term>
                <term>无符号8位的整型</term>
                <term>0xC6</term>
                <term>byte</term>
                <term>如需要，使用<see cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/>实现</term>
              </item>
              <item>
                <term>BYTE</term>
                <term>8位字符数据</term>
                <term>0xD1</term>
                <term>byte</term>
                <term>如需要，使用<see cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/>实现</term>
              </item>
              <item>
                <term>INT</term>
                <term>16位的整型</term>
                <term>0xC3</term>
                <term>short</term>
                <term></term>
              </item>
              <item>
                <term>UINT</term>
                <term>无符号的16位整型</term>
                <term>0xC7</term>
                <term>ushort</term>
                <term></term>
              </item>
              <item>
                <term>DINT</term>
                <term>32位的整型</term>
                <term>0xC4</term>
                <term>int</term>
                <term></term>
              </item>
              <item>
                <term>UDINT</term>
                <term>无符号的32位整型</term>
                <term>0xC8</term>
                <term>uint</term>
                <term></term>
              </item>
              <item>
                <term>LINT</term>
                <term>64位的整型</term>
                <term>0xC5</term>
                <term>long</term>
                <term></term>
              </item>
              <item>
                <term>ULINT</term>
                <term>无符号的64位的整型</term>
                <term>0xC9</term>
                <term>ulong</term>
                <term></term>
              </item>
              <item>
                <term>REAL</term>
                <term>单精度浮点数</term>
                <term>0xCA</term>
                <term>float</term>
                <term></term>
              </item>
              <item>
                <term>DOUBLE</term>
                <term>双精度浮点数</term>
                <term>0xCB</term>
                <term>double</term>
                <term></term>
              </item>
              <item>
                <term>STRING</term>
                <term>字符串数据</term>
                <term>0xD0</term>
                <term>string</term>
                <term>前两个字节为字符长度</term>
              </item>
              <item>
                <term>8bit string BYTE</term>
                <term>8位的字符串</term>
                <term>0xD1</term>
                <term></term>
                <term>本质是BYTE数组</term>
              </item>
              <item>
                <term>16bit string WORD</term>
                <term>16位的字符串</term>
                <term>0xD2</term>
                <term></term>
                <term>本质是WORD数组，可存放中文</term>
              </item>
              <item>
                <term>32bit string DWORD</term>
                <term>32位的字符串</term>
                <term>0xD2</term>
                <term></term>
                <term>本质是DWORD数组，可存放中文</term>
              </item>
            </list>
            在读写操作之前，先看看怎么实例化和连接PLC<br />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage" title="实例化及连接示例" />
            现在来说明以下具体的操作细节。我们假设有如下的变量：<br />
            CESHI_A       SINT<br />
            CESHI_B       BYTE<br />
            CESHI_C       INT<br />
            CESHI_D       UINT<br />
            CESHI_E       SINT[0..9]<br />
            CESHI_F       BYTE[0..9]<br />
            CESHI_G       INT[0..9]<br />
            CESHI_H       UINT[0..9]<br />
            CESHI_I       INT[0..511]<br />
            CESHI_J       STRING[12]<br />
            ToPc_ID1      ARRAY[0..99] OF STRING[20]<br />
            CESHI_O       BOOL<br />
            CESHI_P       BOOL[0..31]<br />
            对 CESHI_A 来说，读写这么操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage2" title="读写示例" />
            对于 CESHI_B 来说，写入的操作有点特殊
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage3" title="读写示例" />
            对于 CESHI_C, CESHI_D 来说，就是 ReadInt16(string address) , Write( string address, short value ) 和 ReadUInt16(string address) 和 Write( string address, ushort value ) 差别不大。
            所以我们着重来看看数组的情况，以 CESHI_G 标签为例子:<br />
            情况一，我想一次读取这个标签所有的字节数组（当长度满足的情况下，会一次性返回数据）
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage4" title="读写示例" />
            情况二，我想读取第3个数，或是第6个数开始，一共5个数
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage5" title="读写示例" />
            其他的数组情况都是类似的，我们来看看字符串 CESHI_J 变量
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage6" title="读写示例" />
            对于 bool 变量来说，就是 ReadBool("CESHI_O") 和 Write("CESHI_O", true) 操作，如果是bool数组，就不一样了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage7" title="读写示例" />
            最后我们来看看结构体的操作，假设我们有个结构体<br />
            MyData.Code     STRING(12)<br />
            MyData.Value1   INT<br />
            MyData.Value2   INT<br />
            MyData.Value3   REAL<br />
            MyData.Value4   INT<br />
            MyData.Value5   INT<br />
            MyData.Value6   INT[0..3]<br />
            因为bool比较复杂，暂时不考虑。要读取上述的结构体，我们需要定义结构一样的数据
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage8" title="结构体" />
            定义好后，我们再来读取就很简单了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\AllenBradleyConnectedCipNetSample.cs" region="Usage9" title="读写示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet.#ctor(System.String,System.Int32)">
            <summary>
            根据指定的IP及端口来实例化这个连接对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet.GetMaxTransferBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyConnectedCipNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial">
            <summary>
            AB-PLC的DF1通信协议，基于串口实现，通信机制为半双工，目前适用于 Micro-Logix1000,SLC500,SLC 5/03,SLC 5/04，地址示例：N7:1
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.#ctor">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.Station">
            <summary>
            站号信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.DstNode">
            <summary>
            目标节点号
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.SrcNode">
            <summary>
            源节点号
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.CheckType">
            <summary>
            校验方式
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.Read(System.String,System.UInt16)">
            <summary>
            读取PLC的原始数据信息，地址示例：N7:0  可以携带站号 s=2;N7:0, 携带 dst 和 src 信息，例如 dst=1;src=2;N7:0
            </summary>
            <param name="address">PLC的地址信息，支持的类型见类型注释说明</param>
            <param name="length">读取的长度，单位，字节</param>
            <returns>是否读取成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.Write(System.String,System.Byte[])">
            <summary>
            写入PLC的原始数据信息，地址示例：N7:0  可以携带站号 s=2;N7:0, 携带 dst 和 src 信息，例如 dst=1;src=2;N7:0
            </summary>
            <param name="address">PLC的地址信息，支持的类型见类型注释说明</param>
            <param name="value">原始的数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.PackCommand(System.Byte,System.Byte[])">
            <summary>
            打包命令的操作，加站号进行打包成完整的数据内容，命令内容为原始命令，打包后会自动补充0x10的值
            </summary>
            <param name="station">站号信息</param>
            <param name="command">等待发送的命令</param>
            <returns>打包之后的数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.BuildProtectedTypedLogicalReadWithThreeAddressFields(System.Int32,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.BuildProtectedTypedLogicalReadWithThreeAddressFields(System.Byte,System.Byte,System.Int32,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.BuildProtectedTypedLogicalReadWithThreeAddressFields(System.Byte,System.Byte,System.Int32,System.String,System.UInt16)">
            <summary>
            构建0F-A2命令码的报文读取指令，用来读取文件数据。适用 Micro-Logix1000,SLC500,SLC 5/03,SLC 5/04, PLC-5，地址示例：N7:1<br />
            Construct a message read instruction of 0F-A2 command code to read file data. Applicable to Micro-Logix1000, SLC500, SLC 5/03, SLC 5/04, PLC-5, address example: N7:1
            </summary>
            <param name="dstNode">目标节点号</param>
            <param name="srcNode">原节点号</param>
            <param name="tns">消息号</param>
            <param name="address">PLC的地址信息</param>
            <param name="length">读取的数据长度</param>
            <returns>初步的报文信息</returns>
            <remarks>
            对于SLC 5/01或SLC 5/02而言，一次最多读取82个字节。对于 03 或是 04 为225，236字节取决于是否应用DF1驱动
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.BuildProtectedTypedLogicalWriteWithThreeAddressFields(System.Int32,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.BuildProtectedTypedLogicalWriteWithThreeAddressFields(System.Byte,System.Byte,System.Int32,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.BuildProtectedTypedLogicalWriteWithThreeAddressFields(System.Byte,System.Byte,System.Int32,System.String,System.Byte[])">
            <summary>
            构建0F-AA命令码的写入读取指令，用来写入文件数据。适用 Micro-Logix1000,SLC500,SLC 5/03,SLC 5/04, PLC-5，地址示例：N7:1<br />
            Construct a write and read command of 0F-AA command code to write file data. Applicable to Micro-Logix1000, SLC500, SLC 5/03, SLC 5/04, PLC-5, address example: N7:1
            </summary>
            <param name="dstNode">目标节点号</param>
            <param name="srcNode">原节点号</param>
            <param name="tns">消息号</param>
            <param name="address">PLC的地址信息</param>
            <param name="data">写入的数据内容</param>
            <returns>初步的报文信息</returns>
            <remarks>
            对于SLC 5/01或SLC 5/02而言，一次最多读取82个字节。对于 03 或是 04 为225，236字节取决于是否应用DF1驱动
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.BuildProtectedTypedLogicalMaskWithThreeAddressFields(System.Int32,System.String,System.Int32,System.Boolean)">
            <summary>
            构建0F-AB的掩码写入的功能
            </summary>
            <param name="tns">消息号</param>
            <param name="address">PLC的地址信息</param>
            <param name="bitIndex">位索引信息</param>
            <param name="value">通断值</param>
            <returns>命令报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.ExtractActualData(System.Byte[])">
            <summary>
            提取返回报文的数据内容，将其转换成实际的数据内容，如果PLC返回了错误信息，则结果对象为失败。<br />
            Extract the data content of the returned message and convert it into the actual data content. If the PLC returns an error message, the result object is a failure.
            </summary>
            <param name="content">PLC返回的报文信息</param>
            <returns>结果对象内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.GetStatusDescription(System.Byte)">
            <summary>
            根据错误代码，来获取错误的具体描述文本
            </summary>
            <param name="code">错误的代码，非0</param>
            <returns>错误的描述文本信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.GetExtStatusDescription(System.Byte)">
            <summary>
            根据错误代码，来获取错误的具体描述文本
            </summary>
            <param name="code">错误的代码，非0</param>
            <returns>错误的描述文本信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyDF1Serial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper">
            <summary>
            AB PLC的辅助类，用来辅助生成基本的指令信息
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Execute_PCCC">
            <summary>
            CIP命令中PCCC命令相关的信息
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_DATA">
            <summary>
            CIP命令中的读取数据的服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_WRITE_DATA">
            <summary>
            CIP命令中的写数据的服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_WRITE_DATA">
            <summary>
            CIP命令中的读并写的数据服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_FRAGMENT">
            <summary>
            CIP命令中的读片段的数据服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_WRITE_FRAGMENT">
            <summary>
            CIP命令中的写片段的数据服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_LIST">
            <summary>
            CIP指令中读取数据的列表
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_MULTIREAD_DATA">
            <summary>
            CIP命令中的对数据读取服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_DATE">
            <summary>
            日期的格式
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_TIME">
            <summary>
            时间的格式
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_TimeAndDate">
            <summary>
            日期时间格式，最完整的时间格式
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_TimeOfDate">
            <summary>
            一天中的时间格式
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Bool">
            <summary>
            bool型数据，一个字节长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Byte">
            <summary>
            byte型数据，一个字节长度，SINT
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Word">
            <summary>
            整型，两个字节长度，INT
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_DWord">
            <summary>
            长整型，四个字节长度，DINT
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_LInt">
            <summary>
            特长整型，8个字节，LINT
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_USInt">
            <summary>
            Unsigned 8-bit integer, USINT
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_UInt">
            <summary>
            Unsigned 16-bit integer, UINT
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_UDint">
            <summary>
             Unsigned 32-bit integer, UDINT
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_ULint">
            <summary>
             Unsigned 64-bit integer, ULINT
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Real">
            <summary>
            实数数据，四个字节长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Double">
            <summary>
            实数数据，八个字节的长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Struct">
            <summary>
            结构体数据，不定长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_String">
            <summary>
            字符串数据内容
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_D1">
            <summary>
             Bit string, 8 bits, BYTE,
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_D2">
            <summary>
            Bit string, 16-bits, WORD
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_D3">
            <summary>
            Bit string, 32 bits, DWORD
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_D4">
            <summary>
            Bit string, 64 bits LWORD
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_BitArray">
            <summary>
            二进制数据内容
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.OriginatorVendorID">
            <summary>
            连接方的厂商标识
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.OriginatorSerialNumber">
            <summary>
            连接方的序列号
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ParseRequestPathCommand(System.Byte[])">
            <summary>
            从生成的报文里面反解出实际的数据地址，不支持结构体嵌套，仅支持数据，一维数组，不支持多维数据
            </summary>
            <param name="pathCommand">地址路径报文</param>
            <returns>实际的地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.BuildEnumeratorCommand(System.UInt32)">
            <summary>
            获取枚举PLC数据信息的指令
            </summary>
            <param name="startInstance">实例的起始地址</param>
            <returns>结果数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.BuildEnumeratorProgrameMainCommand(System.UInt32)">
            <summary>
            获取枚举PLC的局部变量的数据信息的指令
            </summary>
            <param name="startInstance">实例的起始地址</param>
            <returns>结果命令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.GetStructHandleCommand(System.UInt16)">
            <summary>
            获取获得结构体句柄的命令
            </summary>
            <param name="symbolType">包含地址的信息</param>
            <returns>命令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.GetStructItemNameType(System.UInt16,HslCommunication.Profinet.AllenBradley.AbStructHandle,System.Int32)">
            <summary>
            获取结构体内部数据结构的方法
            </summary>
            <param name="symbolType">地址</param>
            <param name="structHandle">句柄</param>
            <param name="offset">偏移量地址</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestHeader(System.UInt16,System.UInt32,System.Byte[],System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestHeader(System.UInt16,System.UInt32,System.UInt32,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestHeader(System.UInt16,System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            将CommandSpecificData的命令，打包成可发送的数据指令
            </summary>
            <param name="command">实际的命令暗号</param>
            <param name="error">错误号信息</param>
            <param name="session">当前会话的id</param>
            <param name="commandSpecificData">CommandSpecificData命令</param>
            <returns>最终可发送的数据命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackExecutePCCCRead(System.Int32,System.String,System.UInt16)">
            <summary>
            打包一个PCCC的读取的命令报文
            </summary>
            <param name="tns">请求序号信息</param>
            <param name="address">请求的文件地址，地址示例：N7:1</param>
            <param name="length">请求的字节长度</param>
            <returns>PCCC的读取报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackExecutePCCCWrite(System.Int32,System.String,System.Byte[])">
            <summary>
            打包一个PCCC的写入的命令报文
            </summary>
            <param name="tns">请求序号信息</param>
            <param name="address">请求的文件地址，地址示例：N7:1</param>
            <param name="value">写入的原始数据信息</param>
            <returns>PCCC的写入报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequsetRead(System.String,System.Int32,System.Boolean)">
            <summary>
            打包生成一个请求读取数据的节点信息，CIP指令信息
            </summary>
            <param name="address">地址</param>
            <param name="length">指代数组的长度</param>
            <param name="isConnectedAddress">是否是连接模式下的地址，默认为false</param>
            <returns>CIP的指令信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestReadSegment(System.String,System.Int32,System.Int32)">
            <summary>
            打包生成一个请求读取数据片段的节点信息，CIP指令信息
            </summary>
            <param name="address">节点的名称 -> Tag Name</param>
            <param name="startIndex">起始的索引位置，以字节为单位 -> The initial index position, in bytes</param>
            <param name="length">读取的数据长度，一次通讯总计490个字节 -> Length of read data, a total of 490 bytes of communication</param>
            <returns>CIP的指令信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestWrite(System.String,System.UInt16,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            根据指定的数据和类型，生成对应的数据
            </summary>
            <param name="address">地址信息</param>
            <param name="typeCode">数据类型</param>
            <param name="value">字节值</param>
            <param name="length">如果节点为数组，就是数组长度</param>
            <param name="isConnectedAddress">是否为连接模式的地址</param>
            <returns>CIP的指令信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.AnalysisArrayIndex(System.String,System.Int32@)">
            <summary>
            分析地址数据信息里的位索引的信息，例如a[10]  返回 a 和 10 索引，如果没有指定索引，就默认为0
            </summary>
            <param name="address">数据地址</param>
            <param name="arrayIndex">位索引</param>
            <returns>地址信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestWrite(System.String,System.Boolean)">
            <summary>
            写入Bool数据的基本指令信息
            </summary>
            <param name="address">地址</param>
            <param name="value">值</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandService(System.Byte[],System.Byte[][])">
            <summary>
            将所有的cip指定进行打包操作。
            </summary>
            <param name="portSlot">PLC所在的面板槽号</param>
            <param name="cips">所有的cip打包指令信息</param>
            <returns>包含服务的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCleanCommandService(System.Byte[],System.Byte[][])">
            <summary>
            将所有的cip指定进行打包操作。
            </summary>
            <param name="portSlot">PLC所在的面板槽号</param>
            <param name="cips">所有的cip打包指令信息</param>
            <returns>包含服务的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandGetAttributesAll(System.Byte[],System.UInt32)">
            <summary>
            打包一个读取所有特性数据的报文信息，需要传入slot
            </summary>
            <param name="portSlot">站号信息</param>
            <param name="sessionHandle">会话的ID信息</param>
            <returns>最终发送的报文数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandResponse(System.Byte[],System.Boolean)">
            <summary>
            根据数据创建反馈的数据信息
            </summary>
            <param name="data">反馈的数据信息</param>
            <param name="isRead">是否是读取</param>
            <returns>数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandSpecificData(System.Byte[][])">
            <summary>
            生成读取直接节点数据信息的内容
            </summary>
            <param name="service">cip指令内容</param>
            <returns>最终的指令值</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandSingleService(System.Byte[],System.UInt16,System.Boolean)">
            <summary>
            将所有的cip指定进行打包操作。
            </summary>
            <param name="command">指令信息</param>
            <param name="code">服务器的代号信息</param>
            <param name="isConnected">是否基于连接的服务</param>
            <returns>包含服务的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.RegisterSessionHandle(System.Byte[])">
            <summary>
            向PLC注册会话ID的报文<br />
            Register a message with the PLC for the session ID
            </summary>
            <param name="senderContext">发送的上下文信息</param>
            <returns>报文信息 -> Message information </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.UnRegisterSessionHandle(System.UInt32)">
            <summary>
            获取卸载一个已注册的会话的报文<br />
            Get a message to uninstall a registered session
            </summary>
            <param name="sessionHandle">当前会话的ID信息</param>
            <returns>字节报文信息 -> BYTE message information </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CheckResponse(System.Byte[])">
            <summary>
            初步检查返回的CIP协议的报文是否正确<br />
            Initially check whether the returned CIP protocol message is correct
            </summary>
            <param name="response">CIP的报文信息</param>
            <returns>是否正确的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据解析，返回解析后的数据内容，数据类型（在多项数据返回中无效），以及是否有更多的数据
            </summary>
            <param name="response">PLC的反馈数据</param>
            <param name="isRead">是否是返回的操作</param>
            <returns>带有结果标识的最终数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice)">
            <summary>
            从PLC里读取当前PLC的型号信息<br />
            Read the current PLC model information from the PLC
            </summary>
            <param name="plc">PLC对象</param>
            <returns>型号数据信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ReadPlcTypeAsync(HslCommunication.Core.IReadWriteDevice)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue">
            <summary>
            AB PLC的数据
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue.Buffer">
            <summary>
            真实的数组缓存
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue.IsArray">
            <summary>
            是否是数组的数据
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue.TypeLength">
            <summary>
            单个单位的数据长度信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue.TypeCode">
            <summary>
            数据类型信息
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip">
            <summary>
            AB PLC的cip通信实现类，适用Micro800系列控制系统<br />
            AB PLC's cip communication implementation class, suitable for Micro800 series control system
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip.PackCommandService(System.Byte[],System.Byte[][])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyNet">
            <summary>
            AB PLC的数据通信类，使用CIP协议实现，适用1756，1769等型号，支持使用标签的形式进行读写操作，支持标量数据，一维数组，二维数组，三维数组等等。如果是局部变量，那么使用 Program:MainProgram.[变量名]。<br />
            The data communication class of AB PLC is implemented using the CIP protocol. It is suitable for 1756, 1769 and other models. 
            It supports reading and writing in the form of tags, scalar data, one-dimensional array, two-dimensional array, 
            three-dimensional array, and so on. If it is a local variable, use the Program:MainProgram.[Variable name].
            </summary>
            <remarks>
            thanks 江阴-  ∮溪风-⊙_⌒ help test the dll
            <br />
            thanks 上海-null 测试了这个dll
            <br />
            <br />
            默认的地址就是PLC里的TAG名字，比如A，B，C；如果你需要读取的数据是一个数组，那么A就是默认的A[0]，如果想要读取偏移量为10的数据，那么地址为A[10]，
            多维数组同理，使用A[10,10,10]的操作。
            <br />
            <br />
            假设你读取的是局部变量，那么使用 Program:MainProgram.变量名<br />
            目前适用的系列为1756 ControlLogix, 1756 GuardLogix, 1769 CompactLogix, 1769 Compact GuardLogix, 1789SoftLogix, 5069 CompactLogix, 5069 Compact GuardLogix, Studio 5000 Logix Emulate
            <br />
            <br />
            如果你有个Bool数组要读取，变量名为 A, 那么读第0个位，可以通过 ReadBool("A")，但是第二个位需要使用<br />
            ReadBoolArray("A[0]")   // 返回32个bool长度，0-31的索引，如果我想读取32-63的位索引，就需要 ReadBoolArray("A[1]") ，以此类推。
            <br />
            <br />
            地址可以携带站号信息，只要在前面加上slot=2;即可，这就是访问站号2的数据了，例如 slot=2;AAA，如果使用了自定义的消息路由，例如：[IP or Hostname],1,[Optional Routing Path],CPU Slot 172.20.1.109,1,[15,2,18,1],12<br />
            在实例化之后，连接PLC之前，需要调用如下代码 plc.MessageRouter = new MessageRouter( "1.15.2.18.1.12" )
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
            <param name="ipAddress">PLC IpAddress</param>
            <param name="port">PLC Port</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.SessionHandle">
            <summary>
            The current session handle, which is determined by the PLC when communicating with the PLC handshake
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Slot">
            <summary>
            Gets or sets the slot number information for the current plc, which should be set before connections
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.PortSlot">
            <summary>
            port and slot information
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.CipCommand">
            <summary>
            获取或设置整个交互指令的控制码，默认为0x6F，通常不需要修改<br />
            Gets or sets the control code of the entire interactive instruction. The default is 0x6F, and usually does not need to be modified.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.MessageRouter">
            <summary>
            获取或设置当前的通信的消息路由信息，可以实现一些复杂情况的通信，数据包含背板号，路由参数，slot，例如：1.15.2.18.1.1<br />
            Get or set the message routing information of the current communication, which can realize some complicated communication. 
            The data includes the backplane number, routing parameters, and slot, for example: 1.15.2.18.1.1
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ExtraOnDisconnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.BuildReadCommand(System.String[],System.Int32[])">
            <summary>
            创建一个读取标签的报文指定，标签地址可以手动动态指定slot编号，例如 slot=2;AAA<br />
            Build a read command bytes, The label address can manually specify the slot number dynamically, for example slot=2;AAA
            </summary>
            <param name="address">the address of the tag name</param>
            <param name="length">Array information, if not arrays, is 1 </param>
            <returns>Message information that contains the result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.BuildReadCommand(System.String[])">
            <summary>
            创建一个读取多标签的报文<br />
            Build a read command bytes
            </summary>
            <param name="address">The address of the tag name </param>
            <returns>Message information that contains the result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.BuildWriteCommand(System.String,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Create a written message instruction
            </summary>
            <param name="address">The address of the tag name </param>
            <param name="typeCode">Data type</param>
            <param name="data">Source Data </param>
            <param name="length">In the case of arrays, the length of the array </param>
            <returns>Message information that contains the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.BuildWriteCommand(System.String,System.Boolean)">
            <summary>
            Create a written message instruction
            </summary>
            <param name="address">The address of the tag name </param>
            <param name="data">Bool Data </param>
            <returns>Message information that contains the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String,System.UInt16)">
            <summary>
            Read data information, data length for read array length information
            </summary>
            <param name="address">Address format of the node</param>
            <param name="length">In the case of arrays, the length of the array </param>
            <returns>Result data with result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[])">
            <summary>
            <b>[商业授权]</b> 批量读取多地址的数据信息，例如我可以读取两个标签的数据 "A","B[0]"，每个地址的数据长度为1，表示一个数据，最终读取返回的是一整个的字节数组，需要自行解析<br />
            <b>[Authorization]</b> Batch read data information of multiple addresses, for example, I can read the data of two tags "A", "B[0]", the data length of each address is 1, 
            which means one data, and the final read returns a The entire byte array, which needs to be parsed by itself
            </summary>
            <param name="address">Name of the node </param>
            <returns>Result data with result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[],System.Int32[])">
            <summary>
            <b>[商业授权]</b> 批量读取多地址的数据信息，例如我可以读取两个标签的数据 "A","B[0]"， 长度为 [1, 5]，返回的是一整个的字节数组，需要自行解析<br />
            <b>[Authorization]</b> Read the data information of multiple addresses in batches. For example, I can read the data "A", "B[0]" of two tags, 
            the length is [1, 5], and the return is an entire byte array, and I need to do it myself Parsing
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">如果是数组，就为数组长度 -> In the case of arrays, the length of the array </param>
            <returns>带有结果对象的结果数据 -> Result data with result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadSegment(System.String,System.Int32,System.Int32)">
            <summary>
            Read Segment Data Array form plc, use address tag name
            </summary>
            <param name="address">Tag name in plc</param>
            <param name="startIndex">array start index, uint byte index</param>
            <param name="length">array length, data item length</param>
            <returns>Results Bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadCipFromServer(System.Byte[][])">
            <summary>
            使用CIP报文和服务器进行核心的数据交换
            </summary>
            <param name="cips">Cip commands</param>
            <returns>Results Bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadEipFromServer(System.Byte[][])">
            <summary>
            使用EIP报文和服务器进行核心的数据交换
            </summary>
            <param name="eip">eip commands</param>
            <returns>Results Bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBool(System.String)">
            <summary>
            读取单个的bool数据信息，如果读取的是单bool变量，就直接写变量名，如果是由int组成的bool数组的一个值，一律带"i="开头访问，例如"i=A[0]" <br />
            Read a single bool data information, if it is a single bool variable, write the variable name directly, 
            if it is a value of a bool array composed of int, it is always accessed with "i=" at the beginning, for example, "i=A[0]"
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBoolArray(System.String)">
            <summary>
            批量读取的bool数组信息，如果你有个Bool数组变量名为 A, 那么读第0个位，可以通过 ReadBool("A")，但是第二个位需要使用 
            ReadBoolArray("A[0]")   // 返回32个bool长度，0-31的索引，如果我想读取32-63的位索引，就需要 ReadBoolArray("A[1]") ，以此类推。<br />
            For batch read bool array information, if you have a Bool array variable named A, then you can read the 0th bit through ReadBool("A"), 
            but the second bit needs to use ReadBoolArray("A[0]" ) // Returns the length of 32 bools, the index is 0-31, 
            if I want to read the bit index of 32-63, I need ReadBoolArray("A[1]"), and so on.
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadByte(System.String)">
            <summary>
            读取PLC的byte类型的数据<br />
            Read the byte type of PLC data
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadTag(System.String,System.Int32)">
            <summary>
            从PLC里读取一个指定标签名的原始数据信息及其数据类型信息<br />
            Read the original data information of a specified tag name and its data type information from the PLC
            </summary>
            <remarks>
            数据类型的定义，可以参考 <see cref="T:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper"/> 的常量资源信息。
            </remarks>
            <param name="address">PLC的标签地址信息</param>
            <param name="length">读取的数据长度</param>
            <returns>包含原始数据信息及数据类型的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadAsync(System.String[],System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[],System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadSegmentAsync(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadSegment(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadCipFromServerAsync(System.Byte[][])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadCipFromServer(System.Byte[][])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadEipFromServerAsync(System.Byte[][])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadEipFromServer(System.Byte[][])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBoolArrayAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBoolArray(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadTagAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadTag(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.TagEnumerator">
            <summary>
            枚举当前的所有的变量名字，包含结构体信息，除去系统自带的名称数据信息<br />
            Enumerate all the current variable names, including structure information, except the name data information that comes with the system
            </summary>
            <returns>结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.TagEnumeratorAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.TagEnumerator"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.StructTagEnumerator(HslCommunication.Profinet.AllenBradley.AbTagItem)">
            <summary>
            枚举结构体的方法，传入结构体的标签对象，返回结构体子属性标签列表信息，子属性有可能是标量数据，也可能是另一个结构体。<br />
            The method of enumerating the structure, passing in the tag object of the structure, 
            and returning the tag list information of the sub-attributes of the structure. The sub-attributes may be scalar data or another structure.
            </summary>
            <param name="structTag">结构体的标签</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadFloat(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadString(System.String,System.UInt16)">
            <summary>
            读取字符串数据，默认为<see cref="P:System.Text.Encoding.UTF8"/>编码<br />
            Read string data, default is the <see cref="P:System.Text.Encoding.UTF8"/> encoding
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的string数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadStringAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadPlcTypeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte[])">
            <summary>
            当前写入字节数组使用数据类型 0xD1 写入，如果其他的字节类型需要调用 <see cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/> 方法来实现。<br />
            The currently written byte array is written using the data type 0xD1. If other byte types need to be called <see cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/> Method to achieve. <br />
            </summary>
            <param name="address">地址</param>
            <param name="value">值</param>
            <returns>写入结果值</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            使用指定的类型写入指定的节点数据，类型信息参考API文档，地址支持协议类型代号信息，例如 "type=0xD1;A"<br />
            Use the specified type to write the specified node data. For type information, refer to the API documentation. The address supports protocol type code information, such as "type=0xD1;A"
            </summary>
            <remarks>
            关于参数 length 的含义，表示的是地址长度，一般的标量数据都是 1，如果PLC有个标签是 A，数据类型为 byte[10]，那我们写入 3 个byte就是 WriteTag( "A[5]", 0xD1, new byte[]{1,2,3}, 3 );<br />
            Regarding the meaning of the parameter length, it represents the address length. The general scalar data is 1. If the PLC has a tag of A and the data type is byte[10], then we write 3 bytes as WriteTag( "A[5 ]", 0xD1, new byte[]{1,2,3}, 3 );
            </remarks>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="typeCode">类型代码，详细参见<see cref="T:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper"/>上的常用字段 ->  Type code, see the commonly used Fields section on the <see cref= "T:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper"/> in detail</param>
            <param name="value">实际的数据值 -> The actual data value </param>
            <param name="length">如果节点是数组，就是数组长度 -> If the node is an array, it is the array length </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTagAsync(System.String,System.UInt16,System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int16[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt16[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt32[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Single[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int64[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt64[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Double[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Boolean)">
            <summary>
            写入单个Bool的数据信息。如果读取的是单bool变量，就直接写变量名，如果是bool数组的一个值，一律带下标访问，例如a[0]<br />
            Write the data information of a single Bool. If the read is a single bool variable, write the variable name directly, 
            if it is a value of the bool array, it will always be accessed with a subscript, such as a[0]
            </summary>
            <remarks>
            如果写入的是类型代号 0xC1 的bool变量或是数组，直接使用标签名即可，比如：A,A[10]，如果写入的是类型代号0xD3的bool数组的值，则需要使用地址"i="开头，例如：i=A[10]<br />
            If you write a bool variable or array of type code 0xC1, you can use the tag name directly, such as: A,A[10], 
            if you write the value of a bool array of type code 0xD3, you need to use the address" i=" at the beginning, for example: i=A[10]
            </remarks>
            <param name="address">标签的地址数据</param>
            <param name="value">bool数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte)">
            <summary>
            写入Byte数据，返回是否写入成功，默认使用类型 0xC2, 如果PLC的变量类型不一样，则需要指定实际的变量类型，例如PLC的变量 A 是0xD1类型，那么地址需要携带类型信息，type=0xD1;A <br />
            Write Byte data and return whether the writing is successful. The default type is 0xC2. If the variable types of the PLC are different, you need to specify the actual variable type. 
            For example, the variable A of the PLC is of type 0xD1, then the address needs to carry the type information, type= 0xD1;A
            </summary>
            <remarks>
            如何确认PLC的变量的类型呢？可以在HslCommunicationDemo程序上测试知道，也可以直接调用 <see cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadWithType(System.String[],System.Int32[])"/> 来知道类型信息。
            </remarks>
            <param name="address">标签的地址数据</param>
            <param name="value">Byte数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadDate(System.String)">
            <summary>
            读取指定地址的日期数据，最小日期为 1970年1月1日，当PLC的变量类型为 "Date" 和 "TimeAndDate" 时，都可以用本方法读取。<br />
            Read the date data of the specified address. The minimum date is January 1, 1970. When the PLC variable type is "Date" and "TimeAndDate", this method can be used to read.
            </summary>
            <param name="address">PLC里变量的地址</param>
            <returns>日期结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteDate(System.String,System.DateTime)">
            <summary>
            使用日期格式（Date）将指定的数据写入到指定的地址里，PLC的地址类型变量必须为 "Date"，否则写入失败。<br />
            Use the date format (Date) to write the specified data to the specified address. The PLC address type variable must be "Date", otherwise the writing will fail.
            </summary>
            <param name="address">PLC里变量的地址</param>
            <param name="date">时间信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTimeAndDate(System.String,System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteDate(System.String,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadTime(System.String)">
            <summary>
            读取指定地址的时间数据，最小时间为 0，如果获取秒，可以访问 <see cref="P:System.TimeSpan.TotalSeconds"/>，当PLC的变量类型为 "Time" 和 "TimeOfDate" 时，都可以用本方法读取。<br />
            Read the time data of the specified address. The minimum time is 0. If you get seconds, you can access <see cref="P:System.TimeSpan.TotalSeconds"/>. 
            When the PLC variable type is "Time" and "TimeOfDate", you can use this Method to read.
            </summary>
            <param name="address">PLC里变量的地址</param>
            <returns>时间的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTime(System.String,System.TimeSpan)">
            <summary>
            使用时间格式（TIME）将时间数据写入到PLC中指定的地址里去，PLC的地址类型变量必须为 "TIME"，否则写入失败。<br />
            Use the time format (TIME) to write the time data to the address specified in the PLC. The PLC address type variable must be "TIME", otherwise the writing will fail.
            </summary>
            <param name="address">PLC里变量的地址</param>
            <param name="time">时间参数变量</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTimeOfDate(System.String,System.TimeSpan)">
            <summary>
            使用时间格式（TimeOfDate）将时间数据写入到PLC中指定的地址里去，PLC的地址类型变量必须为 "TimeOfDate"，否则写入失败。<br />
            Use the time format (TimeOfDate) to write the time data to the address specified in the PLC. The PLC address type variable must be "TimeOfDate", otherwise the writing will fail.
            </summary>
            <param name="address">PLC里变量的地址</param>
            <param name="timeOfDate">时间参数变量</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadDateAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadDate(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteDateAsync(System.String,System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteDate(System.String,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTimeAndDateAsync(System.String,System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTimeAndDate(System.String,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadTimeAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadTime(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTimeAsync(System.String,System.TimeSpan)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTime(System.String,System.TimeSpan)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTimeOfDateAsync(System.String,System.TimeSpan)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTimeOfDate(System.String,System.TimeSpan)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.PackCommandService(System.Byte[],System.Byte[][])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandService(System.Byte[],System.Byte[][])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet">
            <summary>
            在CIP协议里，使用PCCC命令进行访问设备的原始数据文件的通信方法，
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.#ctor(System.String,System.Int32)">
            <summary>
            根据指定的IP及端口来实例化这个连接对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.GetLargeForwardOpen(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.GetLargeForwardClose">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            读取PLC的原始数据信息，地址示例：N7:0
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
            <remarks>
            写入PLC的原始数据信息，地址示例：N7:0
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadBool(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
            <remarks>
            读取PLC的地址信息，如果输入了 ST 的地址，例如 ST10:2, 当长度指定为 0 的时候，这时候就是动态的读取PLC来获取实际的字符串长度。<br />
            Read the PLC address information, if the ST address is entered, such as ST10:2, when the length is specified as 0, then the PLC is dynamically read to obtain the actual string length.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccServer">
            <summary>
            虚拟的PCCC服务器，模拟的AB 1400通信
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccServer.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyPcccServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyServer">
            <summary>
            <b>[商业授权]</b> AB PLC的虚拟服务器，仅支持和HSL组件的完美通信，可以手动添加一些节点。<br />
            <b>[Authorization]</b> AB PLC's virtual server only supports perfect communication with HSL components. You can manually add some nodes.
            </summary>
            <remarks>
            本AB的虚拟PLC仅限商业授权用户使用，感谢支持。
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.#ctor">
            <summary>
            实例化一个AB PLC协议的服务器<br />
            Instantiate an AB PLC protocol server
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.DataFormat">
            <summary>
            获取或设置当前的服务器的数据字节排序情况<br />
            Gets or sets the data byte ordering of the current server
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue)">
            <summary>
            向服务器新增一个新的Tag值<br />
            Add a new tag value to the server
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">标签值</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Boolean)">
            <summary>
            向服务器新增一个新的bool类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of type bool to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Boolean[])">
            <summary>
            向服务器新增一个新的bool数组类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of type bool array to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int16)">
            <summary>
            向服务器新增一个新的short类型的Tag值，并赋予初始化的值<br />
            Add a new short tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int16[])">
            <summary>
            向服务器新增一个新的short数组的Tag值，并赋予初始化的值<br />
            Add a new short array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt16)">
            <summary>
            向服务器新增一个新的ushort类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of ushort type to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt16[])">
            <summary>
            向服务器新增一个新的ushort数组的Tag值，并赋予初始化的值<br />
            Add a new ushort array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int32)">
            <summary>
            向服务器新增一个新的int类型的Tag值，并赋予初始化的值<br />
            Add a new Tag value of type int to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int32[])">
            <summary>
            向服务器新增一个新的int数组的Tag值，并赋予初始化的值<br />
            Add a new Tag value of the int array to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt32)">
            <summary>
            向服务器新增一个新的uint类型的Tag值，并赋予初始化的值<br />
            Add a new uint tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt32[])">
            <summary>
            向服务器新增一个新的uint数组的Tag值，并赋予初始化的值<br />
            Add a new uint array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int64)">
            <summary>
            向服务器新增一个新的long类型的Tag值，并赋予初始化的值<br />
            Add a new Tag value of type long to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int64[])">
            <summary>
            向服务器新增一个新的long数组的Tag值，并赋予初始化的值<br />
            Add a new Long array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt64)">
            <summary>
            向服务器新增一个新的ulong类型的Tag值，并赋予初始化的值<br />
            Add a new Ulong type Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt64[])">
            <summary>
            向服务器新增一个新的ulong数组的Tag值，并赋予初始化的值<br />
            Add a new Ulong array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Single)">
            <summary>
            向服务器新增一个新的float类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of type float to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Single[])">
            <summary>
            向服务器新增一个新的float数组的Tag值，并赋予初始化的值<br />
            Add a new Tag value of the float array to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Double)">
            <summary>
            向服务器新增一个新的double类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of type double to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Double[])">
            <summary>
            向服务器新增一个新的double数组的Tag值，并赋予初始化的值<br />
            Add a new double array Tag value to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.String,System.Int32)">
            <summary>
            向服务器新增一个新的string类型的Tag值，并赋予初始化的值<br />
            Add a new Tag value of string type to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
            <param name="maxLength">字符串的最长值</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.String[],System.Int32)">
            <summary>
            向服务器新增一个新的string数组的Tag值，并赋予初始化的值<br />
            Add a new String array Tag value to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
            <param name="maxLength">字符串的最长值</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadFromCipCore(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。
            </summary>
            <param name="session">当前客户端的会话信息</param>
            <param name="cipAll">CIP报文数据</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadFloat(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet">
            <summary>
            AllenBradley品牌的PLC，针对SLC系列的通信的实现，测试PLC为1747。<br />
            AllenBradley brand PLC, for the realization of SLC series communication, the test PLC is 1747.
            </summary>
            <remarks>
            地址支持的举例：A9:0, N9:0, B9:0, F9:0, S:0, C9:0, I:0/10, O:0/1, R9:0, T9:0
            </remarks>
            <example>
            地址格式如下：
            <list type="table">
              <listheader>
                <term>地址代号</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>A</term>
                <term>A9:0</term>
                <term>A9:0/1 或 A9:0.1</term>
                <term></term>
              </item>
              <item>
                <term>B</term>
                <term>B9:0</term>
                <term>B9:0/1 或 B9:0.1</term>
                <term></term>
              </item>
              <item>
                <term>N</term>
                <term>N9:0</term>
                <term>N9:0/1 或 N9:0.1</term>
                <term></term>
              </item>
              <item>
                <term>F</term>
                <term>F9:0</term>
                <term>F9:0/1 或 F9:0.1</term>
                <term></term>
              </item>
              <item>
                <term>S</term>
                <term>S:0</term>
                <term>S:0/1 或 S:0.1</term>
                <term>S:0 等同于 S2:0</term>
              </item>
              <item>
                <term>C</term>
                <term>C9:0</term>
                <term>C9:0/1 或 C9:0.1</term>
                <term></term>
              </item>
              <item>
                <term>I</term>
                <term>I:0</term>
                <term>I:0/1 或 I9:0.1</term>
                <term></term>
              </item>
              <item>
                <term>O</term>
                <term>O:0</term>
                <term>O:0/1 或 O9:0.1</term>
                <term></term>
              </item>
              <item>
                <term>R</term>
                <term>R9:0</term>
                <term>R9:0/1 或 R9:0.1</term>
                <term></term>
              </item>
              <item>
                <term>T</term>
                <term>T9:0</term>
                <term>T9:0/1 或 T9:0.1</term>
                <term></term>
              </item>
            </list>
            感谢 seedee 的测试支持。
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.#ctor">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
            <param name="ipAddress">PLC IpAddress</param>
            <param name="port">PLC Port</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.SessionHandle">
            <summary>
            The current session handle, which is determined by the PLC when communicating with the PLC handshake
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.Read(System.String,System.UInt16)">
            <summary>
            Read data information, data length for read array length information
            </summary>
            <param name="address">Address format of the node</param>
            <param name="length">In the case of arrays, the length of the array </param>
            <returns>Result data with result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.ReadBool(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.ReadBoolAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.AnalysisBitIndex(System.String,System.Int32@)">
            <summary>
            分析地址数据信息里的位索引的信息
            </summary>
            <param name="address">数据地址</param>
            <param name="bitIndex">位索引</param>
            <returns>地址信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            构建读取的指令信息
            </summary>
            <param name="address">地址信息，举例：A9:0</param>
            <param name="length">读取的长度信息</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.BuildWriteCommand(System.String,System.Byte[])">
            <summary>
            构建写入的报文内容，变成实际的数据
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.BuildWriteCommand(System.String,System.Boolean)">
            <summary>
            构建写入的报文内容，变成实际的数据
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleySLCNet.ExtraActualContent(System.Byte[])">
            <summary>
            解析当前的实际报文内容，变成数据内容
            </summary>
            <param name="content">报文内容</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.MessageRouter">
            <summary>
            自定义的消息路由
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.MessageRouter.#ctor">
            <summary>
            实例化一个默认的实例对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.MessageRouter.#ctor(System.String)">
            <summary>
            指定路由来实例化一个对象
            </summary>
            <param name="router">路由信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.MessageRouter.GetRouter">
            <summary>
            获取路由信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.MessageRouter.Backplane">
            <summary>
            背板信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.MessageRouter.RoutingPath">
            <summary>
            路由信息，例如：15.2.18.1
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.MessageRouter.Slot">
            <summary>
            槽号信息
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo">
            <summary>
            Ads设备的相关信息，主要是版本号，设备名称<br />
            Information about Ads devices, primarily version numbers, device names.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.#ctor(System.Byte[])">
            <summary>
            根据原始的数据内容来实例化一个对象<br />
            Instantiate an object based on the original data content
            </summary>
            <param name="data">原始的数据内容</param>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.Major">
            <summary>
            主版本号<br />
            Main Version
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.Minor">
            <summary>
            次版本号<br />
            Minor Version
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.Build">
            <summary>
            构建版本号<br />
            Build version
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.DeviceName">
            <summary>
            设备的名字<br />
            Device Name
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Beckhoff.AmsTcpHeaderFlags">
            <summary>
            AMS消息的命令号
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.AmsTcpHeaderFlags.Command">
            <summary>
            AmsCommand (AMS_TCP_PORT_AMS_CMD, 0x0000)
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.AmsTcpHeaderFlags.PortClose">
            <summary>
            Port Close command (AMS_TCP_PORT_CLOSE, 0x0001)
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.AmsTcpHeaderFlags.PortConnect">
            <summary>
            Port connect command (AMS_TCP_PORT_CONNECT, 0x1000)
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.AmsTcpHeaderFlags.RouterNotification">
            <summary>
            Router Notification (AMS_TCP_PORT_ROUTER_NOTE, 0x1001)
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.AmsTcpHeaderFlags.GetLocalNetId">
            <summary>
            Get LocalNetId header
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet">
            <summary>
            倍福的ADS协议，支持读取倍福的地址数据，关于端口号的选择，TwinCAT2，端口号801；TwinCAT3，端口号为851，NETID可以选择手动输入，自动输入方式，具体参考API文档的示例代码<br />
            Beckhoff's ADS protocol supports reading Beckhoff address data. Regarding the choice of port number, TwinCAT2, port number is 801; TwinCAT3, port number is 851, NETID can be input manually or automatically. 
            For details, please refer to the example of API documentation code
            </summary>
            <remarks>
            支持的地址格式分四种，第一种是绝对的地址表示，比如M100，I100，Q100；第二种是字符串地址，采用s=aaaa;的表示方式；第三种是绝对内存地址采用i=1000000;的表示方式，第四种是自定义的index group, IG=0xF020;0 的地址<br />
            There are four supported address formats, the first is absolute address representation, such as M100, I100, Q100; the second is string address, using s=aaaa; representation; 
            the third is absolute memory address using i =1000000; representation, the fourth is the custom index group, the address of IG=0xF020;0
            <br />
            <note type="important">
            在实际的测试中，由于打开了VS软件对倍福PLC进行编程操作，会导致HslCommunicationDemo读取PLC发生间歇性读写失败的问题，此时需要关闭Visual Studio软件对倍福的连接，之后HslCommunicationDemo就会读写成功，感谢QQ：1813782515 提供的解决思路。
            </note>
            </remarks>
            <example>
            地址既支持 M100, I100，Q100 ，读取bool时，支持输入 M100.0,  也支持符号的地址，s=MAIN.a  ,也支持绝对地址的形式， i=1235467;<br />
            下面是实例化的例子，可选两种方式
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\BeckhoffAdsNetSample.cs" region="Sample1" title="实例化" />
            实例化之后，就可以连接操作了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\BeckhoffAdsNetSample.cs" region="Sample2" title="连接" />
            连接成功之后，就可以进行读写操作了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\BeckhoffAdsNetSample.cs" region="Sample3" title="读写示例" />
            也可以高级的批量读取，需要自己手动解析下数据
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\BeckhoffAdsNetSample.cs" region="Sample4" title="批量读取" />
            当然，还可以进一步，既实现了批量的高性能读取，又自动解析。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\BeckhoffAdsNetSample.cs" region="Sample5" title="类型读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的ip地址以及端口号实例化一个默认的对象<br />
            Instantiate a default object with the specified IP address and port number
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.IpAddress">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.UseTagCache">
            <summary>
            是否使用标签的名称缓存功能，默认为 <c>False</c><br />
            Whether to use tag name caching. The default is <c>False</c>
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.UseAutoAmsNetID">
            <summary>
            是否使用服务器自动的NETID信息，默认手动设置<br />
            Whether to use the server's automatic NETID information, manually set by default
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.AmsPort">
            <summary>
            获取或设置Ams的端口号信息，TwinCAT2，端口号801,811,821,831；TwinCAT3，端口号为851,852,853<br />
            Get or set the port number information of Ams, TwinCAT2, the port number is 801, 811, 821, 831; TwinCAT3, the port number is 851, 852, 853
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.SetTargetAMSNetId(System.String)">
            <summary>
            目标的地址，举例 192.168.0.1.1.1；也可以是带端口号 192.168.0.1.1.1:801<br />
            The address of the destination, for example 192.168.0.1.1.1; it can also be the port number 192.168.0.1.1.1: 801
            </summary>
            <remarks>
            Port：1: AMS Router; 2: AMS Debugger; 800: Ring 0 TC2 PLC; 801: TC2 PLC Runtime System 1; 811: TC2 PLC Runtime System 2; <br />
            821: TC2 PLC Runtime System 3; 831: TC2 PLC Runtime System 4; 850: Ring 0 TC3 PLC; 851: TC3 PLC Runtime System 1<br />
            852: TC3 PLC Runtime System 2; 853: TC3 PLC Runtime System 3; 854: TC3 PLC Runtime System 4; ...
            </remarks>
            <param name="amsNetId">AMSNet Id地址</param>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.SetSenderAMSNetId(System.String)">
            <summary>
            设置原目标地址 举例 192.168.0.100.1.1；也可以是带端口号 192.168.0.100.1.1:34567<br />
            Set the original destination address Example: 192.168.0.100.1.1; it can also be the port number 192.168.0.100.1.1: 34567
            </summary>
            <param name="amsNetId">原地址</param>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.GetSenderAMSNetId">
            <summary>
            获取当前发送的AMS的网络ID信息
            </summary>
            <returns>AMS发送信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.GetTargetAMSNetId">
            <summary>
            获取当前目标的AMS网络的ID信息
            </summary>
            <returns>AMS目标信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ExtraAfterReadFromCoreServer(HslCommunication.OperateResult)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.DecideWhetherQAMessage(System.Net.Sockets.Socket,HslCommunication.OperateResult{System.Byte[]})">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadValueHandle(System.String)">
            <summary>
            根据当前标签的地址获取到内存偏移地址<br />
            Get the memory offset address based on the address of the current label
            </summary>
            <param name="address">带标签的地址信息，例如s=A,那么标签就是A</param>
            <returns>内存偏移地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.TransValueHandle(System.String)">
            <summary>
            将字符串的地址转换为内存的地址，其他地址则不操作<br />
            Converts the address of a string to the address of a memory, other addresses do not operate
            </summary>
            <param name="address">地址信息，s=A的地址转换为i=100000的形式</param>
            <returns>地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAdsDeviceInfo">
            <summary>
            读取Ads设备的设备信息。主要是版本号，设备名称<br />
            Read the device information of the Ads device. Mainly version number, device name
            </summary>
            <returns>设备信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAdsState">
            <summary>
            读取Ads设备的状态信息，其中<see cref="P:HslCommunication.OperateResult`2.Content1"/>是Ads State，<see cref="P:HslCommunication.OperateResult`2.Content2"/>是Device State<br />
            Read the status information of the Ads device, where <see cref="P:HslCommunication.OperateResult`2.Content1"/> is the Ads State, and <see cref="P:HslCommunication.OperateResult`2.Content2"/> is the Device State
            </summary>
            <returns>设备状态信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.WriteAdsState(System.Int16,System.Int16,System.Byte[])">
            <summary>
            写入Ads的状态，可以携带数据信息，数据可以为空<br />
            Write the status of Ads, can carry data information, and the data can be empty
            </summary>
            <param name="state">ads state</param>
            <param name="deviceState">device state</param>
            <param name="data">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReleaseSystemHandle(System.UInt32)">
            <summary>
            释放当前的系统句柄，该句柄是通过<see cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadValueHandle(System.String)"/>获取的
            </summary>
            <param name="handle">句柄</param>
            <returns>是否释放成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadValueHandleAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadValueHandle(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.TransValueHandleAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.TransValueHandle(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAdsDeviceInfoAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAdsDeviceInfo"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAdsStateAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAdsState"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.WriteAdsStateAsync(System.Int16,System.Int16,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.WriteAdsState(System.Int16,System.Int16,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReleaseSystemHandleAsync(System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReleaseSystemHandle(System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Read(System.String,System.UInt16)">
            <summary>
            读取PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            Read PLC data, there are three formats of address, one: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A</param>
            <param name="length">长度</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Read``1">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Read(System.String[],System.UInt16[])">
            <summary>
            批量读取PLC的数据，需要传入地址数组，以及读取的长度数组信息，长度单位为字节单位，如果是读取bool变量的，则以bool为单位，统一返回一串字节数据信息，需要进行二次解析的操作。<br />
            To read PLC data in batches, you need to pass in the address array and the read length array information. The unit of length is in bytes. If you read a bool variable, 
            it will return a string of byte data information in units of bool. , which requires a secondary parsing operation.
            </summary>
            <remarks>
            关于二次解析的参考信息，可以参考API文档，地址：http://api.hslcommunication.cn<br />
            For reference information about secondary parsing, you can refer to the API documentation, address: http://api.hslcommunication.cn
            </remarks>
            <param name="address">地址数组信息</param>
            <param name="length">读取的长度数组信息</param>
            <returns>原始字节数组的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Byte[])">
            <summary>
            写入PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            There are three formats for the data written into the PLC. One: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadBool(System.String,System.UInt16)">
            <summary>
            读取PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            Read PLC data, there are three formats of address, one: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">PLC的地址信息，例如 M10</param>
            <param name="length">数据长度</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Boolean[])">
            <summary>
            写入PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            There are three formats for the data written into the PLC. One: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadByte(System.String)">
            <summary>
            读取PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            Read PLC data, there are three formats of address, one: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Byte)">
            <summary>
            写入PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            There are three formats for the data written into the PLC. One: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAsync``1">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAsync(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Read(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer">
            <summary>
            倍福Ads协议的虚拟服务器
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.#ctor">
            <summary>
            实例化一个基于ADS协议的虚拟的倍福PLC对象，可以用来和<see cref="T:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet"/>进行通信测试。
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,HslCommunication.Profinet.Beckhoff.Helper.AdsTagItem)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.AddTagValue(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId">
            <summary>
            倍福PLC的命令码<br />
            Command Id: https://infosys.beckhoff.com/english.php?content=../content/1033/tc3_ads_intro/index.html
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.ReadDeviceInfo">
            <summary>
            读取PLC的名字和版本号等信息<br />
            Reads the name and the version number of the ADS device.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.Read">
            <summary>
            可以读ADS的设备读取数据<br />
            With ADS Read data can be read from an ADS device
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.Write">
            <summary>
            将ADS数据写入到ADS的设备里去<br />
            With ADS Write data can be written to an ADS device
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.ReadState">
            <summary>
            读取ADS设备里的设备状态信息和ADS状态<br />
            Reads the ADS status and the device status of an ADS device.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.WriteControl">
            <summary>
            更改ADS设备的设备状态信息和ADS状态<br />
            Changes the ADS status and the device status of an ADS device.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.AddDeviceNotification">
            <summary>
            在ADS设备里面创建一个通知对象<br />
            A notification is created in an ADS device
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.DeleteDeviceNotification">
            <summary>
            删除ADS设备里的一个通知对象<br />
            One before defined notification is deleted in an ADS device.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.DeviceNotification">
            <summary>
            从ADS设备订阅一个数据的通知，将会发送到客户端<br />
            Data will carry forward independently from an ADS device to a Client
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.ReadWrite">
            <summary>
            在写入的时候进行同时的读取<br />
            With ADS ReadWrite data will be written to an ADS device. Additionally, data can be read from the ADS device.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildAmsHeaderCommand(System.UInt16,System.Byte[])">
            <summary>
            根据命令码ID，消息ID，数据信息组成AMS的命令码
            </summary>
            <param name="commandId">命令码ID</param>
            <param name="data">数据内容</param>
            <returns>打包之后的数据信息，没有填写AMSNetId的Target和Source内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildReadDeviceInfoCommand">
            <summary>
            构建读取设备信息的命令报文
            </summary>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildReadStateCommand">
            <summary>
            构建读取状态的命令报文
            </summary>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildWriteControlCommand(System.Int16,System.Int16,System.Byte[])">
            <summary>
            构建写入状态的命令报文
            </summary>
            <param name="state">Ads state</param>
            <param name="deviceState">Device state</param>
            <param name="data">Data</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildReadCommand(System.String,System.Int32,System.Boolean)">
            <summary>
            构建写入的指令信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBit">是否是位信息</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildReadCommand(System.String[],System.UInt16[])">
            <summary>
            构建批量读取的指令信息，不能传入读取符号数据，只能传入读取M,I,Q,i=0x0001信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildReadWriteCommand(System.String,System.Int32,System.Boolean,System.Byte[])">
            <summary>
            构建写入的指令信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBit">是否是位信息</param>
            <param name="value">写入的数值</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildWriteCommand(System.String[],System.Collections.Generic.List{System.Byte[]})">
            <summary>
            构建批量写入的指令代码，不能传入读取符号数据，只能传入读取M,I,Q,i=0x0001信息
            </summary>
            <remarks>
            实际没有调试通
            </remarks>
            <param name="address">地址列表信息</param>
            <param name="value">写入的数据值信息</param>
            <returns>命令报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildWriteCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            构建写入的指令信息
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据</param>
            <param name="isBit">是否是位信息</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildWriteCommand(System.String,System.Boolean[],System.Boolean)">
            <summary>
            构建写入的指令信息
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据</param>
            <param name="isBit">是否是位信息</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.BuildReleaseSystemHandle(System.UInt32)">
            <summary>
            构建释放句柄的报文信息，当获取了变量的句柄后，这个句柄就被释放
            </summary>
            <param name="handle">句柄信息</param>
            <returns>报文的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.CheckResponse(System.Byte[])">
            <summary>
            检查从PLC的反馈的数据报文是否正确
            </summary>
            <param name="response">反馈报文</param>
            <returns>检查结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.PackAmsTcpHelper(HslCommunication.Profinet.Beckhoff.AmsTcpHeaderFlags,System.Byte[])">
            <summary>
            将实际的包含AMS头报文和数据报文的命令，打包成实际可发送的命令
            </summary>
            <param name="headerFlags">命令头信息</param>
            <param name="command">命令信息</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.AnalysisAddress(System.String,System.Boolean)">
            <summary>
            分析当前的地址信息，根据结果信息进行解析出真实的偏移地址
            </summary>
            <param name="address">地址</param>
            <param name="isBit">是否位访问</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.StrToAdsBytes(System.String)">
            <summary>
            将字符串名称转变为ADS协议可识别的字节数组
            </summary>
            <param name="value">值</param>
            <returns>字节数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.StrToAMSNetId(System.String)">
            <summary>
            将字符串的信息转换为AMS目标的地址
            </summary>
            <param name="amsNetId">目标信息</param>
            <returns>字节数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.GetAmsNetIdString(System.Byte[],System.Int32)">
            <summary>
            根据byte数组信息提取出字符串格式的AMSNetId数据信息，方便日志查看
            </summary>
            <param name="data">原始的报文数据信息</param>
            <param name="index">起始的节点信息</param>
            <returns>Ams节点号信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsHelper.GetErrorCodeText(System.Int32)">
            <summary>
            根据AMS的错误号，获取到错误信息，错误信息来源于 wirshake 源代码文件 "..\wireshark\plugins\epan\ethercat\packet-ams.c"
            </summary>
            <param name="error">错误号</param>
            <returns>错误的描述信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Beckhoff.Helper.AdsTagItem">
            <summary>
            Ads标签信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.Helper.AdsTagItem.#ctor(System.String,System.Byte[])">
            <summary>
            实例化一个默认的对象
            </summary>
            <param name="name">标签名</param>
            <param name="buffer">缓存的数据对象</param>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.Helper.AdsTagItem.TagName">
            <summary>
            标签的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.Helper.AdsTagItem.Buffer">
            <summary>
            标签的数据缓存信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.Helper.AdsTagItem.Location">
            <summary>
            绝对地址信息
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.DeltaSerialAscii">
            <summary>
            台达PLC的串口通讯类，基于Modbus-Ascii协议开发，按照台达的地址进行实现。<br />
            The serial communication class of Delta PLC is developed based on the Modbus-Ascii protocol and implemented according to Delta's address.
            </summary>
            <remarks>
            适用于DVP-ES/EX/EC/SS型号，DVP-SA/SC/SX/EH型号以及AS300型号，地址参考API文档，同时地址可以携带站号信息，举例：[s=2;D100],[s=3;M100]，可以动态修改当前报文的站号信息。<br />
            Suitable for DVP-ES/EX/EC/SS models, DVP-SA/SC/SX/EH models and AS300 model, the address refers to the API document, and the address can carry station number information,
            for example: [s=2;D100],[s= 3;M100], you can dynamically modify the station number information of the current message.
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Delta.DeltaSerial" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialAscii.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaSerial.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialAscii.#ctor(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaSerial.#ctor(System.Byte)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Delta.DeltaSerialAscii.Series">
            <inheritdoc cref="P:HslCommunication.Profinet.Delta.IDelta.Series"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialAscii.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialAscii.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialAscii.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialAscii.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialAscii.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialAscii.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.Helper.DeltaASHelper">
            <summary>
            台达AS300的辅助帮助类信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaASHelper.ParseDeltaASAddress(System.String,System.Byte)">
            <summary>
            根据台达AS300的PLC的地址，解析出转换后的modbus协议信息，适用AS300系列，当前的地址仍然支持站号指定，例如s=2;D100<br />
            According to the PLC address of Delta AS300, the converted modbus protocol information is parsed, 
            and it is applicable to AS300 series. The current address still supports station number designation, for example, s=2;D100
            </summary>
            <param name="address">台达plc的地址信息</param>
            <param name="modbusCode">原始的对应的modbus信息</param>
            <returns>还原后的modbus地址</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper">
            <summary>
            台达PLC的相关的帮助类，公共的地址解析的方法。<br />
            Delta PLC related help classes, public address resolution methods.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.ParseDeltaDvpAddress(System.String,System.Byte)">
            <summary>
            根据台达PLC的地址，解析出转换后的modbus协议信息，适用DVP系列，当前的地址仍然支持站号指定，例如s=2;D100<br />
            According to the address of Delta PLC, the converted modbus protocol information is parsed out, applicable to DVP series, 
            the current address still supports station number designation, such as s=2;D100
            </summary>
            <param name="address">台达plc的地址信息</param>
            <param name="modbusCode">原始的对应的modbus信息</param>
            <returns>还原后的modbus地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.ReadBool(System.Func{System.String,System.UInt16,HslCommunication.OperateResult{System.Boolean[]}},System.String,System.UInt16)">
            <summary>
            读取台达PLC的bool变量，重写了读M地址时，跨区域读1536地址时，将会分割多次读取
            </summary>
            <param name="readBoolFunc">底层基础的读取方法</param>
            <param name="address">PLC的地址信息</param>
            <param name="length">读取的长度信息</param>
            <returns>读取的结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.Write(System.Func{System.String,System.Boolean[],HslCommunication.OperateResult},System.String,System.Boolean[])">
            <summary>
            写入台达PLC的bool数据，当发现是M类型的数据，并且地址出现跨1536时，进行切割写入操作
            </summary>
            <param name="writeBoolFunc">底层的写入操作方法</param>
            <param name="address">PLC的起始地址信息</param>
            <param name="value">等待写入的数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.Read(System.Func{System.String,System.UInt16,HslCommunication.OperateResult{System.Byte[]}},System.String,System.UInt16)">
            <summary>
            读取台达PLC的原始字节变量，重写了读D地址时，跨区域读4096地址时，将会分割多次读取
            </summary>
            <param name="readFunc">底层基础的读取方法</param>
            <param name="address">PLC的地址信息</param>
            <param name="length">读取的长度信息</param>
            <returns>读取的结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.Write(System.Func{System.String,System.Byte[],HslCommunication.OperateResult},System.String,System.Byte[])">
            <summary>
            写入台达PLC的原始字节数据，当发现是D类型的数据，并且地址出现跨4096时，进行切割写入操作
            </summary>
            <param name="writeFunc">底层的写入操作方法</param>
            <param name="address">PLC的起始地址信息</param>
            <param name="value">等待写入的数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.ReadBoolAsync(System.Func{System.String,System.UInt16,System.Threading.Tasks.Task{HslCommunication.OperateResult{System.Boolean[]}}},System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.ReadBool(System.Func{System.String,System.UInt16,HslCommunication.OperateResult{System.Boolean[]}},System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.WriteAsync(System.Func{System.String,System.Boolean[],System.Threading.Tasks.Task{HslCommunication.OperateResult}},System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.Write(System.Func{System.String,System.Boolean[],HslCommunication.OperateResult},System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.ReadAsync(System.Func{System.String,System.UInt16,System.Threading.Tasks.Task{HslCommunication.OperateResult{System.Byte[]}}},System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.Read(System.Func{System.String,System.UInt16,HslCommunication.OperateResult{System.Byte[]}},System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.WriteAsync(System.Func{System.String,System.Byte[],System.Threading.Tasks.Task{HslCommunication.OperateResult}},System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.Helper.DeltaDvpHelper.Write(System.Func{System.String,System.Byte[],HslCommunication.OperateResult},System.String,System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.Helper.DeltaHelper">
            <summary>
            台达的想关的辅助类
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.DeltaSerial">
            <summary>
            台达PLC的串口通讯类，基于Modbus-Rtu协议开发，按照台达的地址进行实现。<br />
            The serial communication class of Delta PLC is developed based on the Modbus-Rtu protocol and implemented according to Delta's address.
            </summary>
            <remarks>
            适用于DVP-ES/EX/EC/SS型号，DVP-SA/SC/SX/EH型号以及AS300型号，地址参考API文档，同时地址可以携带站号信息，举例：[s=2;D100],[s=3;M100]，可以动态修改当前报文的站号信息。<br />
            Suitable for DVP-ES/EX/EC/SS models, DVP-SA/SC/SX/EH models and AS300 model, the address refers to the API document, and the address can carry station number information,
            for example: [s=2;D100],[s= 3;M100], you can dynamically modify the station number information of the current message.
            </remarks>
            <example>
            对于DVP系列的地址的格式如下(适用于DVP-ES/EX/EC/SS型号，DVP-SA/SC/SX/EH型号，)：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>ES/EX/SS</term>
                <term>SA/SX/SC</term>
                <term>EH</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S127</term>
                <term>S0-S1023</term>
                <term>S0-S1023</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X0-X177</term>
                <term>X0-X177</term>
                <term>X0-X377</term>
                <term>8</term>
                <term>×</term>
                <term>√</term>
                <term>只读</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y0-Y177</term>
                <term>Y0-Y177</term>
                <term>Y0-Y377</term>
                <term>8</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T127</term>
                <term>T0-T255</term>
                <term>T0-T255</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>如果是读位，就是通断继电器，如果是读字，就是当前值</term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C127 C232-C255</term>
                <term>C0-C199 C200-C255</term>
                <term>C0-C199 C200-C255</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>如果是读位，就是通断继电器，如果是读字，就是当前值</term>
              </item>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M0-M1279</term>
                <term>M0-M4095</term>
                <term>M0-M4095</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D1311</term>
                <term>D0-D4999</term>
                <term>D0-D9999</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            对于AS300型号的地址及范围如下：<br />
            对于位操作的地址如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>AS300</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term></term>
                <term>X</term>
                <term>X0.0~X63.15</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>只读</term>
              </item>
              <item>
                <term></term>
                <term>Y</term>
                <term>Y0.0~Y63.15</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>M</term>
                <term>M0~M8191</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SM</term>
                <term>SM0~SM4095</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0~S2047</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>T</term>
                <term>T0~T511</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>C</term>
                <term>C0~C511</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HC</term>
                <term>HC0~HC255</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            对于字操作的地址如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>AS300</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term></term>
                <term>X</term>
                <term>X0~X63</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>只读</term>
              </item>
              <item>
                <term></term>
                <term>Y</term>
                <term>Y0~Y63</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SR</term>
                <term>SR0~SR2047</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>D</term>
                <term>D0~D29999</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>T</term>
                <term>T0~T511</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>C</term>
                <term>C0~C511</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HC</term>
                <term>HC0~HC255</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>E</term>
                <term>E0~E9</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            除此之外，以上地址都可以携带站号信息，例如 s=2;D100，也是支持的。
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerial.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerial.#ctor(System.Byte)">
            <summary>
            指定客户端自己的站号来初始化<br />
            Specify the client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="P:HslCommunication.Profinet.Delta.DeltaSerial.Series">
            <inheritdoc cref="P:HslCommunication.Profinet.Delta.IDelta.Series"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerial.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerial.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerial.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerial.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.DeltaSerialOverTcp">
            <summary>
            台达PLC的串口转网口透传类，基于Modbus-Rtu协议开发，但是实际的通信管道使用的是网络，但是实际的地址是台达的地址进行读写操作。<br />
            Delta PLC's serial port to network port transparent transmission class is developed based on the Modbus-Rtu protocol, 
            but the actual communication channel uses the network, but the actual address is Delta's address for read and write operations.
            </summary>
            <remarks>
            适用于DVP-ES/EX/EC/SS型号，DVP-SA/SC/SX/EH型号以及AS300型号，地址参考API文档，同时地址可以携带站号信息，举例：[s=2;D100],[s=3;M100]，可以动态修改当前报文的站号信息。<br />
            Suitable for DVP-ES/EX/EC/SS models, DVP-SA/SC/SX/EH models and AS300 model, the address refers to the API document, and the address can carry station number information,
            for example: [s=2;D100],[s= 3;M100], you can dynamically modify the station number information of the current message.
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Delta.DeltaSerial" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaSerial.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.#ctor(System.String,System.Int32,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.Series">
            <inheritdoc cref="P:HslCommunication.Profinet.Delta.IDelta.Series"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaSerialOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.DeltaTcpNet">
            <summary>
            台达PLC的网口通讯类，基于Modbus-Rtu协议开发，按照台达的地址进行实现。<br />
            The tcp communication class of Delta PLC is developed based on the Modbus-Tcp protocol and implemented according to Delta's address.
            </summary>
            <remarks>
            适用于DVP-ES/EX/EC/SS型号，DVP-SA/SC/SX/EH型号以及AS300型号，地址参考API文档，同时地址可以携带站号信息，举例：[s=2;D100],[s=3;M100]，可以动态修改当前报文的站号信息。<br />
            Suitable for DVP-ES/EX/EC/SS models, DVP-SA/SC/SX/EH models and AS300 model, the address refers to the API document, and the address can carry station number information,
            for example: [s=2;D100],[s= 3;M100], you can dynamically modify the station number information of the current message.
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Delta.DeltaSerial" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaSerial.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.#ctor(System.String,System.Int32,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Delta.DeltaTcpNet.Series">
            <inheritdoc cref="P:HslCommunication.Profinet.Delta.IDelta.Series"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            地址支持X,Y,M,SM,S,T,C,HC，其中X和Y地址使用DD.DD格式，范围 X0.0~X63.15, Y0.0~Y63.15，其中X地址使用的是02功能码，其余的都是01功能码。<br />
            Address supports X, Y, M, SM, S, T, C, HC, where X and Y addresses use the DD.DD format, and the range is X0.0~X63.15, Y0.0~Y63.15, 
            where X addresses are used The one is 02 function code, and the rest are 01 function code.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
            <remarks>
            地址支持Y,M,SM,S,T,C,HC，其中Y地址使用DD.DD格式，Y0.0~Y63.15，不支持X地址的写入。<br />
            The address supports Y, M, SM, S, T, C, HC, where the Y address uses the DD.DD format, Y0.0~Y63.15, the writing of the X address is not supported.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Boolean)">
            <inheritdoc/>
            <remarks>
            地址支持Y,M,SM,S,T,C,HC，其中Y地址使用DD.DD格式，Y0.0~Y63.15，不支持X地址的写入。<br />
            The address supports Y, M, SM, S, T, C, HC, where the Y address uses the DD.DD format, Y0.0~Y63.15, the writing of the X address is not supported.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
            <remarks>
            字地址支持X,Y,SR,D,T,C,HC,E, 所有的地址都是十进制的方式，地址范围参照API文档事例，举例：X1,Y10,SR100,D10,T20,C20,HC200,E2<br />
            Word address supports X, Y, SR, D, T, C, HC, E, all addresses are in decimal format, and the address range refers to the API document example, 
            for example: X1, Y10, SR100, D10, T20, C20, HC200 ,E2
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
            <remarks>
            字地址支持Y,SR,D,T,C,HC,E, 所有的地址都是十进制的方式，地址范围参照API文档事例，举例：Y10,SR100,D10,T20,C20,HC200,E2<br />
            Word address supports Y, SR, D, T, C, HC, E, all addresses are in decimal format, and the address range refers to the API document example, 
            for example: Y10, SR100, D10, T20, C20, HC200 ,E2
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Delta.DeltaTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Delta.DeltaTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.DeltaSeries">
            <summary>
            台达的系列信息
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Delta.DeltaSeries.Dvp">
            <summary>
            台达的Dvp系列，适用DVP-ES/EX/EC/SS型号，DVP-SA/SC/SX/EH型号
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Delta.DeltaSeries.AS">
            <summary>
            适用于AS300系列
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Delta.IDelta">
            <summary>
            台达PLC的相关的接口信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Delta.IDelta.Series">
            <summary>
            获取或设置当前的台达PLC的系列信息，默认为 DVP 系列<br />
            Get or set the current series information of Delta PLC, the default is DVP series
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.FATEK.FatekProgram">
            <summary>
            台湾永宏公司的编程口协议，具体的地址信息请查阅api文档信息，地址允许携带站号信息，例如：s=2;D100<br />
            The programming port protocol of Taiwan Yonghong company, 
            please refer to the api document for specific address information, The address can carry station number information, such as s=2;D100
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.FATEK.FatekProgramOverTcp" path="remarks"/>
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.FATEK.FatekProgramOverTcp" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.FATEK.FatekProgram.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Run(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Run(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Run">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgram.Run(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Stop(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Stop(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Stop">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgram.Stop(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.ReadStatus(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadStatus(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.ReadStatus">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgram.ReadStatus(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper">
            <summary>
            FatekProgram相关的辅助方法，例如报文构建，核心读写支持
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.CalculateAcc(System.String)">
            <summary>
            计算指令的和校验码
            </summary>
            <param name="data">指令</param>
            <returns>校验之后的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <summary>
            检查当前的串口的数据接收是否完整
            </summary>
            <param name="ms">数据流</param>
            <returns>是否数据接收完成</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.PackFatekCommand(System.Byte,System.String)">
            <summary>
            将Fatek的基本命令打包成可以发送PLC的电文消息
            </summary>
            <param name="station">PLC的站号信息</param>
            <param name="cmd">基本命令信息</param>
            <returns>发送PLC的电文消息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.BuildReadWordCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.BuildReadBoolCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ExtraResponse(System.Byte[],System.UInt16)">
            <summary>
            提取当前的结果数据信息，针对的是字单位的方式
            </summary>
            <param name="response">PLC返回的数据信息</param>
            <param name="length">读取的长度内容</param>
            <returns>结果数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.BuildWriteBoolCommand(System.Byte,System.String,System.Boolean[])">
            <summary>
            创建一条别入bool数据的指令信息，需要指定一些参数
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.BuildWriteByteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            创建一条别入byte数据的指令信息，需要指定一些参数，按照字单位
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.CheckResponse(System.Byte[])">
            <summary>
            检查PLC反馈的报文是否正确，如果不正确，返回错误消息
            </summary>
            <param name="content">PLC反馈的报文信息</param>
            <returns>反馈的报文是否正确</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.GetErrorDescriptionFromCode(System.Char)">
            <summary>
            根据错误码获取到真实的文本信息
            </summary>
            <param name="code">错误码</param>
            <returns>错误的文本描述</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <summary>
            批量读取PLC的字节数据，以字为单位，支持读取X,Y,M,S,D,T,C,R,RT,RC具体的地址范围需要根据PLC型号来确认，地址可以携带站号信息，例如 s=2;D100<br />
            Read PLC byte data in batches, in word units. Supports reading X, Y, M, S, D, T, C, R, RT, RC. 
            The specific address range needs to be confirmed according to the PLC model, The address can carry station number information, such as s=2;D100
            </summary>
            <param name="device">PLC通信的对象</param>
            <param name="station">设备的站点信息</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C,R,RT,RC具体的地址范围需要根据PLC型号来确认，地址可以携带站号信息，例如 s=2;D100<br />
            The data written to the PLC in batches, in units of words, that is, at least 2 bytes of information, 
            supporting X, Y, M, S, D, T, C, R, RT, and RC. The specific address range needs to be based on the PLC model To confirm, The address can carry station number information, such as s=2;D100
            </summary>
            <param name="device">PLC通信的对象</param>
            <param name="station">设备的站号信息</param>
            <param name="address">地址信息，举例，D100，R200，RC100，RT200</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,M,S,T,C，具体的地址范围取决于PLC的类型，地址可以携带站号信息，例如 s=2;M100<br />
            Read bool data in batches. The supported types are X, Y, M, S, T, C. The specific address range depends on the type of PLC, 
            The address can carry station number information, such as s=2;M100
            </summary>
            <param name="device">PLC通信对象</param>
            <param name="station">设备的站号信息</param>
            <param name="address">地址信息，比如X10，Y17，M100</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,M,S,T,C，具体的地址范围取决于PLC的类型，地址可以携带站号信息，例如 s=2;M100<br />
            Write arrays of type bool in batches. The supported types are X, Y, M, S, T, C. The specific address range depends on the type of PLC, 
            The address can carry station number information, such as s=2;M100
            </summary>
            <param name="device">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Run(HslCommunication.Core.IReadWriteDevice,System.Byte)">
            <summary>
            使PLC处于RUN的状态
            </summary>
            <param name="device">PLC通信对象</param>
            <param name="station">站号信息</param>
            <returns>是否操作成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.RunAsync(HslCommunication.Core.IReadWriteDevice,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Run(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Stop(HslCommunication.Core.IReadWriteDevice,System.Byte)">
            <summary>
            使PLC处于STOP状态
            </summary>
            <param name="device">PLC通信对象</param>
            <param name="station">站号信息</param>
            <returns>是否操作成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.StopAsync(HslCommunication.Core.IReadWriteDevice,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Stop(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadStatus(HslCommunication.Core.IReadWriteDevice,System.Byte)">
            <summary>
            读取当前PLC的状态信息，返回一个bool数组，同时包含了几种电量信息，分别为 0: RUN/STOP, 1: BAT LOW/正常, 2: Ladder checksum error/正常, 3: 使用ROM PACK/未使用, 
            4: WDT Timeout/正常, 5: 设定ID/未设ID， 6： 紧急停机/正常<br />
            Read the status information of the current PLC and return a bool array, which also contains several power information, 0: RUN/STOP, 1: BAT LOW/normal, 
            2: Ladder checksum error/normal, 3: Use ROM PACK/ Not used, 4: WDT Timeout/Normal, 5: ID set/ID not set, 6: Emergency stop/Normal
            </summary>
            <param name="device">PLC通信对象</param>
            <param name="station">站号信息</param>
            <returns>状态结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadStatusAsync(HslCommunication.Core.IReadWriteDevice,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Stop(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="T:HslCommunication.Profinet.FATEK.FatekProgramOverTcp">
            <summary>
            台湾永宏公司的编程口协议，此处是基于tcp的实现，地址信息请查阅api文档信息，地址可以携带站号信息，例如 s=2;D100<br />
            The programming port protocol of Taiwan Yonghong company, here is the implementation based on TCP, 
            please refer to the API information for the address information, The address can carry station number information, such as s=2;D100
            </summary>
            <remarks>
            支持位访问：M,X,Y,S,T(触点),C(触点)，字访问：RT(当前值),RC(当前值)，D，R；具体参照API文档
            </remarks>
            <example>
            其所支持的地址形式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>RT</term>
                <term>RT100,RT200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前</term>
                <term>RC</term>
                <term>RC100,RC200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.#ctor">
            <summary>
            实例化默认的构造方法<br />
            Instantiate the default constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口来实例化一个对象<br />
            Instantiate an object with the specified IP address and port
            </summary>
            <param name="ipAddress">设备的Ip地址</param>
            <param name="port">设备的端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Station">
            <summary>
            PLC的站号信息，需要和实际的设置值一致，默认为1<br />
            The station number information of the PLC needs to be consistent with the actual setting value. The default is 1.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Run(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Run(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Run">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Run(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Stop(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Stop(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Stop">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Stop(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadStatus(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadStatus(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadStatus">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadStatus(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.RunAsync(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Run(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.RunAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.RunAsync(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.StopAsync(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.Stop(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.StopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.StopAsync(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadStatusAsync(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.Helper.FatekProgramHelper.ReadStatus(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadStatusAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadStatus(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.FATEK.FatekProgramServer">
            <summary>
            永宏编程口协议的虚拟PLC，可以用来和<see cref="T:HslCommunication.Profinet.FATEK.FatekProgram"/>及<see cref="T:HslCommunication.Profinet.FATEK.FatekProgramOverTcp"/>类做通信测试，支持简单数据的读写操作。
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.#ctor">
            <summary>
            实例化一个基于Programe协议的虚拟的永宏PLC对象，可以用来和<see cref="T:HslCommunication.Profinet.FATEK.FatekProgram"/>进行通信测试。
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.FATEK.FatekProgramServer.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.FATEK.FatekProgram.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Freedom.FreedomSerial">
            <summary>
            基于串口的自由协议，需要在地址里传入报文信息，也可以传入数据偏移信息，<see cref="P:HslCommunication.Serial.SerialDeviceBase.ByteTransform"/>默认为<see cref="T:HslCommunication.Core.RegularByteTransform"/>
            </summary>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample5" title="实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample6" title="读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Freedom.FreedomSerial.CheckResponseStatus">
            <inheritdoc cref="P:HslCommunication.Profinet.Freedom.FreedomTcpNet.CheckResponseStatus"/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomSerial.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomSerial.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Freedom.FreedomTcpNet">
            <summary>
            基于TCP/IP协议的自由协议，需要在地址里传入报文信息，也可以传入数据偏移信息，<see cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>默认为<see cref="T:HslCommunication.Core.RegularByteTransform"/>
            </summary>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample1" title="实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample2" title="连接及读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址及端口号来实例化自由的TCP协议
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Freedom.FreedomTcpNet.CheckResponseStatus">
            <summary>
            一个对返回数据合法检查的委托实例，默认为空，不进行合法性检查，可以实例化实现任意的报文检测，返回是否合法结果。<br />
            A delegate instance that checks the legality of the returned data. It is empty by default and does not perform legality checking. 
            It can be instantiated to implement any packet inspection and return whether the result is legal or not.
            </summary>
            <remarks>
            例如返回的第一个字节为0表示正常报文，否则是异常返回，可以简写：CheckResponseStatus = ( send, receive ) => receive[2] == 0 ? OperateResult.CreateSuccessResult( ) : new OperateResult( receive[2], "error" );<br />
            For example, if the first byte returned is 0, it means a normal message, otherwise it is an abnormal return, 
            which can be abbreviated as: CheckResponseStatus = ( send, receive ) => receive[2] == 0 ? OperateResult.CreateSuccessResult( ) : new OperateResult( receive[2], "error" );
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Freedom.FreedomTcpNet.NetMessage">
            <summary>
            如果当前的报文使用了固定报文头加剩余报文长度来描述完整报文的情况下，可以自定义实例化报文消息对象，可以更快更完整的接收全部报文的数据。<br />
            If the current message uses a fixed header and the remaining message length to describe the complete message, 
            you can customize the instantiated message object to receive the data of all messages faster and more completely.
            </summary>
            <remarks>
            例如当前的报文是modbustcp协议的话，NetMessage = new HslCommunication.Core.IMessage.ModbusTcpMessage( );<br />
            For example, if the current message is modbustcp protocol, NetMessage = new HslCommunication.Core.IMessage.ModbusTcpMessage( );
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            length没有任何意义，需要传入原始的字节报文，例如：stx=9;00 00 00 00 00 06 01 03 00 64 00 01，stx得值用于获取数据移除的前置报文头，可以不填写<br />
            length has no meaning, you need to pass in the original byte message, for example: stx=9;00 00 00 00 00 06 01 03 00 64 00 01, 
            the value of stx is used to obtain the preamble header for data removal, can be left blank
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Freedom.FreedomUdpNet">
            <summary>
            基于UDP/IP协议的自由协议，需要在地址里传入报文信息，也可以传入数据偏移信息，<see cref="P:HslCommunication.Core.Net.NetworkUdpDeviceBase.ByteTransform"/>默认为<see cref="T:HslCommunication.Core.RegularByteTransform"/>
            </summary>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample3" title="实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample4" title="读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址及端口号来实例化自由的TCP协议
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口</param>
        </member>
        <member name="P:HslCommunication.Profinet.Freedom.FreedomUdpNet.CheckResponseStatus">
            <inheritdoc cref="P:HslCommunication.Profinet.Freedom.FreedomTcpNet.CheckResponseStatus"/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiCommandSettingType">
            <summary>
            基于Command-Setting-Type通信模式的协议实现，地址格式参数API文档
            </summary>
            <remarks>
            本类实例化对象之后，还需要设置<see cref="P:HslCommunication.Profinet.Fuji.FujiCommandSettingType.DataSwap"/>属性，根据实际情况来设置。
            </remarks>
            <example>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>I/O Relay</term>
                <term>B</term>
                <term>B100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits</term>
              </item>
              <item>
                <term>Auxiliary Relay</term>
                <term>M</term>
                <term>M100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits</term>
              </item>
              <item>
                <term>Keep Relay</term>
                <term>K</term>
                <term>K100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits</term>
              </item>
              <item>
                <term>Special Relay</term>
                <term>F</term>
                <term>F100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits</term>
              </item>
              <item>
                <term>Announce Relay</term>
                <term>A</term>
                <term>A100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits</term>
              </item>
              <item>
                <term>Differential Relay</term>
                <term>D</term>
                <term>D100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits</term>
              </item>
              <item>
                <term>Step Relay</term>
                <term>S</term>
                <term>S100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>8 bits</term>
              </item>
              <item>
                <term>Current value of 0.1-sec timer</term>
                <term>W9</term>
                <term>W9.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>32 bits</term>
              </item>
              <item>
                <term>Set value of timer</term>
                <term>TS</term>
                <term>TS100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>32 bits: 定时设置值</term>
              </item>
              <item>
                <term>Current value of timer</term>
                <term>TR</term>
                <term>TR100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>32 bits: 定时当前值</term>
              </item>
              <item>
                <term>set value of counter</term>
                <term>CS</term>
                <term>CS100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>32 bits: 计数器设定值</term>
              </item>
              <item>
                <term>Current value of counter</term>
                <term>CR</term>
                <term>CR100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>32 bits: 计数器当前值</term>
              </item>
              <item>
                <term>Data Memory(BCD)</term>
                <term>BD</term>
                <term>BD100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>32 bits:</term>
              </item>
              <item>
                <term>No.1 block</term>
                <term>WL</term>
                <term>WL100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits:</term>
              </item>
              <item>
                <term>No.2 block</term>
                <term>W21</term>
                <term>W21.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits:</term>
              </item>
              <item>
                <term>No.3 block</term>
                <term>W22</term>
                <term>W22.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits:</term>
              </item>
              <item>
                <term>No.4 block</term>
                <term>W23</term>
                <term>W23.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits:</term>
              </item>
              <item>
                <term>Direct I/O</term>
                <term>W24</term>
                <term>W24.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits:</term>
              </item>
              <item>
                <term>Analog work area</term>
                <term>W25</term>
                <term>W25.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>32 bits:</term>
              </item>
              <item>
                <term>Last value differential relay</term>
                <term>W26</term>
                <term>W26.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits:</term>
              </item>
              <item>
                <term>File memory</term>
                <term>W30-W109</term>
                <term>W30.100, W109.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>32 bits or 16 bis depends by plc</term>
              </item>
              <item>
                <term></term>
                <term>W120-W123</term>
                <term>W120.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits:</term>
              </item>
              <item>
                <term>Calendar</term>
                <term>W125</term>
                <term>W125.100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>16 bits:</term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的IP地址和端口号来实例化一个对象
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.Read(System.String,System.UInt16)">
            <summary>
            从PLC读取原始的字节报文数据
            </summary>
            <param name="address">PLC地址信息</param>
            <param name="length">长度信息</param>
            <returns>结果报文数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.Write(System.String,System.Byte[])">
            <summary>
            写入原始数据到PLC指定的地址里，返回是否写入成功
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">原始数据内容</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.ReadByte(System.String)">
            <summary>
            读取指定地址的byte数据，地址格式 S100 <br />
            Reads the byte data of the specified address, the address format S100
            </summary>
            <param name="address">起始地址，格式为S100 </param>
            <returns>是否读取成功的结果对象</returns>
            <example>参考<see cref="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.Read(System.String,System.UInt16)"/>的注释</example>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回值说明<br />
            Write byte data to the PLC, return value description
            </summary>
            <param name="address">起始地址，格式为 S100</param>
            <param name="value">byte数据</param>
            <returns>是否写入成功的结果对象 </returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.Write(System.String,System.Byte[])"/>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiCommandSettingType.DataSwap">
            <summary>
            获取或设置当前的对象是否进行数据交换操作，将根据PLC的实际值来设定。<br />
            Get or set whether the current object performs data exchange operation or not, it will be set according to the actual value of the PLC.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            构建读取的报文指令
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="length">读取的长度信息</param>
            <returns>报文构建的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.BuildWriteCommand(System.String,System.Byte[])">
            <summary>
            构建写入原始报文数据的请求信息
            </summary>
            <param name="address">地址数据</param>
            <param name="value">原始报文的数据</param>
            <returns>原始的写入报文数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.GetErrorText(System.Int32)">
            <summary>
            根据错误信息获取相关数据信息
            </summary>
            <param name="error">错误代号</param>
            <returns>实际的错误描述信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingType.UnpackResponseContentHelper(System.Byte[],System.Byte[])">
            <summary>
            根据PLC返回的数据，解析出实际的数据内容
            </summary>
            <param name="send">发送给PLC的数据</param>
            <param name="response">PLC返回的数据</param>
            <returns>结果数据信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer">
            <summary>
            富士Command-Setting-type协议实现的虚拟服务器，支持的地址为 B,M,K,D,W9,BD,F,A,WL,W21
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.#ctor">
            <summary>
            实例化一个富士的服务器<br />
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.DataSwap">
            <inheritdoc cref="P:HslCommunication.Profinet.Fuji.FujiCommandSettingType.DataSwap"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.ReadByte(System.String)">
            <summary>
            从PLC读取byte类型的数据信息，通常针对步进寄存器，也就是 S100 的地址
            </summary>
            <param name="address">PLC地址数据，例如 S100</param>
            <returns>是否读取成功结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.Write(System.String,System.Byte)">
            <summary>
            将Byte输入写入到PLC之中，通常针对步进寄存器，也就是 S100 的地址
            </summary>
            <param name="address">PLC地址数据，例如 S100</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.ReadBool(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiCommandSettingTypeServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiSPB">
            <summary>
            富士PLC的SPB协议，详细的地址信息见api文档说明，地址可以携带站号信息，例如：s=2;D100，PLC侧需要配置无BCC计算，包含0D0A结束码<br />
            Fuji PLC's SPB protocol. For detailed address information, see the api documentation, 
            The address can carry station number information, for example: s=2;D100, PLC side needs to be configured with no BCC calculation, including 0D0A end code
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Fuji.FujiSPBOverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiSPB.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPB.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiSPBHelper">
            <summary>
            富士SPB的辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.AnalysisIntegerAddress(System.Int32)">
            <summary>
            将int数据转换成SPB可识别的标准的数据内容，例如 2转换为0200 , 200转换为0002
            </summary>
            <param name="address">等待转换的数据内容</param>
            <returns>转换之后的数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.CalculateAcc(System.String)">
            <summary>
            计算指令的和校验码
            </summary>
            <param name="data">指令</param>
            <returns>校验之后的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.BuildReadCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数，单次读取最大105个字
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.BuildReadCommand(System.Byte,HslCommunication.Core.Address.FujiSPBAddress,System.UInt16)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数，单次读取最大105个字
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.BuildReadCommand(System.Byte,System.String[],System.UInt16[],System.Boolean)">
            <summary>
            创建一条读取多个地址的指令信息，需要指定一些参数，单次读取最大105个字
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBool">是否位读取</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.BuildWriteByteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            创建一条别入byte数据的指令信息，需要指定一些参数，按照字单位，单次写入最大103个字
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.BuildWriteBoolCommand(System.Byte,System.String,System.Boolean)">
            <summary>
            创建一条别入byte数据的指令信息，需要指定一些参数，按照字单位，单次写入最大103个字
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.CheckResponseData(System.Byte[])">
            <summary>
            检查反馈的数据信息，是否包含了错误码，如果没有包含，则返回成功
            </summary>
            <param name="content">原始的报文返回</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.GetErrorDescriptionFromCode(System.String)">
            <summary>
            根据错误码获取到真实的文本信息
            </summary>
            <param name="code">错误码</param>
            <returns>错误的文本描述</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,L,M,D,TN,CN,TC,CC,R,W具体的地址范围需要根据PLC型号来确认，地址可以携带站号信息，例如：s=2;D100<br />
            Read PLC data in batches, in units of words. Supports reading X, Y, L, M, D, TN, CN, TC, CC, R, W. 
            The specific address range needs to be confirmed according to the PLC model, The address can carry station number information, for example: s=2;D100
            </summary>
            <param name="device">PLC设备通信对象</param>
            <param name="station">当前的站号信息</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
            <remarks>
            单次读取的最大的字数为105，如果读取的字数超过这个值，请分批次读取。
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持读取X,Y,L,M,D,TN,CN,TC,CC,R具体的地址范围需要根据PLC型号来确认，地址可以携带站号信息，例如：s=2;D100<br />
            The data written to the PLC in batches, in units of words, that is, a minimum of 2 bytes of information. It supports reading X, Y, L, M, D, TN, CN, TC, CC, and R. 
            The specific address range needs to be based on PLC model to confirm, The address can carry station number information, for example: s=2;D100
            </summary>
            <param name="device">PLC设备通信对象</param>
            <param name="station">当前的站号信息</param>
            <param name="address">地址信息，举例，D100，R200，TN100，CN200</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
            <remarks>
            单次写入的最大的字数为103个字，如果写入的数据超过这个长度，请分批次写入
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <summary>
            批量读取PLC的Bool数据，以位为单位，支持读取X,Y,L,M,D,TN,CN,TC,CC,R,W，例如 M100, 如果是寄存器地址，可以使用D10.12来访问第10个字的12位，地址可以携带站号信息，例如：s=2;M100<br />
            Read PLC's Bool data in batches, in units of bits, support reading X, Y, L, M, D, TN, CN, TC, CC, R, W, such as M100, if it is a register address, 
            you can use D10. 12 to access the 12 bits of the 10th word, the address can carry station number information, for example: s=2;M100
            </summary>
            <param name="device">PLC设备通信对象</param>
            <param name="station">当前的站号信息</param>
            <param name="address">地址信息，举例：M100, D10.12</param>
            <param name="length">读取的bool长度信息</param>
            <returns>Bool[]的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean)">
            <summary>
            写入一个Bool值到一个地址里，地址可以是线圈地址，也可以是寄存器地址，例如：M100, D10.12，地址可以携带站号信息，例如：s=2;D10.12<br />
            Write a Bool value to an address. The address can be a coil address or a register address, for example: M100, D10.12. 
            The address can carry station number information, for example: s=2;D10.12
            </summary>
            <param name="device">PLC设备通信对象</param>
            <param name="station">当前的站号信息</param>
            <param name="address">地址信息，举例：M100, D10.12</param>
            <param name="value">写入的bool值</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean)"/>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiSPHNet">
            <summary>
            富士PLC的SPH通信协议，可以和富士PLC进行通信，<see cref="P:HslCommunication.Profinet.Fuji.FujiSPHNet.ConnectionID"/>默认CPU0，需要根据实际进行调整。
            </summary>
            <remarks>
            地址支持 M1.0, M3.0, M10.0 以及I0, Q0
            </remarks>
            <example>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term></term>
                <term>M</term>
                <term>M1.0,M1.100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>M</term>
                <term>M3.0,M3.100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>M</term>
                <term>M10.0,M10.100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>I</term>
                <term>I0,I100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Q</term>
                <term>Q0,Q100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址和端口号来实例化一个对象<br />
            Specify the IP address and port number to instantiate an object
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiSPHNet.ConnectionID">
            <summary>
            对于 CPU0-CPU7来说是CPU的站号，分为对应 0xFE-0xF7，对于P/PE link, FL-net是模块站号，分别对应0xF6-0xEF<br />
            CPU0 to CPU7: SX bus station No. of destination CPU (FEh to F7h); P/PE link, FL-net: SX bus station No. of destination module (F6H to EFH)
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的地址数据，长度单位为字。地址支持M1.1000，M3.1000，M10.1000，返回读取的原始字节数组。<br />
            Read PLC address data in batches, the length unit is words. The address supports M1.1000, M3.1000, M10.1000, 
            and returns the original byte array read.
            </summary>
            <param name="address">PLC的地址，支持M1.1000，M3.1000，M10.1000</param>
            <param name="length">读取的长度信息，按照字为单位</param>
            <returns>包含byte[]的原始字节数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.Write(System.String,System.Byte[])">
            <summary>
            批量写入字节数组到PLC的地址里，地址支持M1.1000，M3.1000，M10.1000，返回是否写入成功。<br />
            Batch write byte array to PLC address, the address supports M1.1000, M3.1000, M10.1000, 
            and return whether the writing is successful.
            </summary>
            <param name="address">PLC的地址，支持M1.1000，M3.1000，M10.1000</param>
            <param name="value">写入的原始字节数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取位数据的方法，需要传入位地址，读取的位长度，地址示例：M1.100.5，M3.1000.12，M10.1000.0<br />
            To read the bit data in batches, you need to pass in the bit address, the length of the read bit, address examples: M1.100.5, M3.1000.12, M10.1000.0
            </summary>
            <param name="address">PLC的地址，示例：M1.100.5，M3.1000.12，M10.1000.0</param>
            <param name="length">读取的bool长度信息</param>
            <returns>包含bool[]的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.Write(System.String,System.Boolean[])">
            <summary>
            批量写入位数据的方法，需要传入位地址，等待写入的boo[]数据，地址示例：M1.100.5，M3.1000.12，M10.1000.0<br />
            To write bit data in batches, you need to pass in the bit address and wait for the boo[] data to be written. Examples of addresses: M1.100.5, M3.1000.12, M10.1000.0
            </summary>
            <remarks>
            [警告] 由于协议没有提供位写入的命令，所有通过字写入间接实现，先读取字数据，修改中间的位，然后写入字数据，所以本质上不是安全的，确保相关的地址只有上位机可以写入。<br />
            [Warning] Since the protocol does not provide commands for bit writing, all are implemented indirectly through word writing. First read the word data, 
            modify the bits in the middle, and then write the word data, so it is inherently not safe. Make sure that the relevant address is only The host computer can write.
            </remarks>
            <param name="address">PLC的地址，示例：M1.100.5，M3.1000.12，M10.1000.0</param>
            <param name="value">等待写入的bool数组</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchStart">
            <summary>
            <b>[Authorization]</b> This command is used to start all the CPUs that exist in a configuration in a batch. 
            Each CPU is cold-started or warm-started,depending on its condition. If a CPU is already started up, 
            or if the key switch is set at "RUN" position, the CPU does not perform processing for startup, 
            which, however, does not result in an error, and a response is returned normally
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchInitializeAndStart">
            <summary>
            <b>[Authorization]</b> This command is used to initialize and start all the CPUs that exist in a configuration in a batch. Each CPU is cold-started.
            If a CPU is already started up, or if the key switch is set at "RUN" position, the CPU does not perform processing for initialization 
            and startup, which, however, does not result in an error, and a response is returned normally.
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchStop">
            <summary>
            <b>[Authorization]</b> This command is used to stop all the CPUs that exist in a configuration in a batch.
            If a CPU is already stopped, or if the key switch is set at "RUN" position, the CPU does not perform processing for stop, which,
            however, does not result in an error, and a response is returned normally.
            </summary>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchReset">
            <summary>
            <b>[Authorization]</b> This command is used to stop all the CPUs that exist in a configuration in a batch.
            If a CPU is already stopped, or if the key switch is set at "RUN" position, the CPU does not perform processing for stop, which,
            however, does not result in an error, and a response is returned normally.
            </summary>
            <returns>是否复位成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualStart">
            <summary>
            <b>[Authorization]</b> This command is used to start an arbitrary CPU existing in a configuration by specifying it. The CPU may be cold-started or
            warm-started, depending on its condition. An error occurs if the CPU is already started. A target CPU is specified by a connection
            mode and connection ID.
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualInitializeAndStart">
            <summary>
            <b>[Authorization]</b> This command is used to initialize and start an arbitrary CPU existing in a configuration by specifying it. The CPU is cold-started.
            An error occurs if the CPU is already started or if the key switch is set at "RUN" or "STOP" position. A target CPU is specified by
            a connection mode and connection ID.
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualStop">
            <summary>
            <b>[Authorization]</b> This command is used to stop an arbitrary CPU existing in a configuration by specifying it. An error occurs if the CPU is already
            stopped or if the key switch is set at "RUN" or "STOP" position. A target CPU is specified by a connection mode and connection ID.
            </summary>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualReset">
            <summary>
            <b>[Authorization]</b> This command is used to reset an arbitrary CPU existing in a configuration by specifying it. An error occurs if the key switch is
            set at "RUN" or "STOP" position. A target CPU is specified by a connection mode and connection ID.
            </summary>
            <returns>是否复位成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchStartAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchStart"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchInitializeAndStartAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchInitializeAndStart"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchStopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchResetAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuBatchReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualStartAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualStart"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualInitializeAndStartAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualInitializeAndStartAsync"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualStopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualResetAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.CpuIndividualReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.GetErrorDescription(System.Byte)">
            <summary>
            根据错误代号获取详细的错误描述信息
            </summary>
            <param name="code">错误码</param>
            <returns>错误的描述文本</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.BuildReadCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            构建读取数据的命令报文
            </summary>
            <param name="connectionId">连接ID</param>
            <param name="address">读取的PLC的地址</param>
            <param name="length">读取的长度信息，按照字为单位</param>
            <returns>构建成功的读取报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.BuildReadCommand(System.Byte,HslCommunication.Core.Address.FujiSPHAddress,System.UInt16)">
            <summary>
            构建读取数据的命令报文
            </summary>
            <param name="connectionId">连接ID</param>
            <param name="address">读取的PLC的地址</param>
            <param name="length">读取的长度信息，按照字为单位</param>
            <returns>构建成功的读取报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            构建写入数据的命令报文
            </summary>
            <param name="connectionId">连接ID</param>
            <param name="address">写入的PLC的地址</param>
            <param name="data">原始数据内容</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHNet.ExtractActualData(System.Byte[])">
            <summary>
            从PLC返回的报文里解析出实际的数据内容，如果发送了错误，则返回失败信息
            </summary>
            <param name="response">PLC返回的报文信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiSPBOverTcp">
            <summary>
            富士PLC的SPB协议，详细的地址信息见api文档说明，地址可以携带站号信息，例如：s=2;D100，PLC侧需要配置无BCC计算，包含0D0A结束码<br />
            Fuji PLC's SPB protocol. For detailed address information, see the api documentation, 
            The address can carry station number information, for example: s=2;D100, PLC side needs to be configured with no BCC calculation, including 0D0A end code
            </summary>
            <remarks>
            其所支持的地址形式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>读写字单位的时候，M2代表位的M32</term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>读取字单位的时候，X2代表位的X32</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>读写字单位的时候，Y2代表位的Y32</term>
              </item>
              <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>读位的时候，D10.15代表第10个字的第15位</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>读位的时候，R10.15代表第10个字的第15位</term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>读位的时候，W10.15代表第10个字的第15位</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.#ctor">
            <summary>
            使用默认的构造方法实例化对象<br />
            Instantiate the object using the default constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口来实例化一个对象<br />
            Instantiate an object with the specified IP address and port
            </summary>
            <param name="ipAddress">设备的Ip地址</param>
            <param name="port">设备的端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Station">
            <summary>
            PLC的站号信息<br />
            PLC station number information
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiSPBServer">
            <summary>
            <b>[商业授权]</b> 富士的SPB虚拟的PLC，线圈支持X,Y,M的读写，其中X只能远程读，寄存器支持D,R,W的读写操作。<br />
            <b>[Authorization]</b> Fuji's SPB virtual PLC, the coil supports X, Y, M read and write, 
            X can only be read remotely, and the register supports D, R, W read and write operations.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.#ctor">
            <summary>
            实例化一个富士SPB的网口和串口服务器，支持数据读写操作
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiSPBServer.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiSPBServer.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiSPBServer.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiSPHServer">
            <summary>
            <b>[商业授权]</b> 富士的SPH虚拟的PLC，支持M1.0，M3.0，M10.0，I0，Q0的位与字的读写操作。<br />
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.#ctor">
            <summary>
            实例化一个基于SPH协议的虚拟的富士PLC对象，可以用来和<see cref="T:HslCommunication.Profinet.Fuji.FujiSPHNet"/>进行通信测试。
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPHNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPHServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue">
            <summary>
            振动传感器的加速度值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue.AcceleratedSpeedX">
            <summary>
            X轴的实时加速度
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue.AcceleratedSpeedY">
            <summary>
            Y轴的实时加速度
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue.AcceleratedSpeedZ">
            <summary>
            Z轴的实时加速度
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorClient">
            <summary>
            Geniitek-VB31 型号的智能无线振动传感器，来自苏州捷杰传感器技术有限公司
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip，端口来实例化一个默认的对象
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ConnectServer">
            <summary>
            连接服务器，实例化客户端之后，至少要调用成功一次，如果返回失败，那些请过一段时间后重新调用本方法连接。<br />
            After connecting to the server, the client must be called at least once after instantiating the client.
            If the return fails, please call this method to connect again after a period of time.
            </summary>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ConnectClose">
            <summary>
            关闭Mqtt服务器的连接。<br />
            Close the connection to the Mqtt server.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ConnectServerAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ConnectServer"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.SetReadStatus">
            <summary>
            设置读取震动传感器的状态数据<br />
            Set to read the status data of the shock sensor
            </summary>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.SetReadActual">
            <summary>
            设置读取震动传感器的实时加速度<br />
            Set the real-time acceleration of the vibration sensor
            </summary>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.SetReadStatusInterval(System.Int32)">
            <summary>
            设置当前的震动传感器的数据发送间隔为指定的时间，单位为秒<br />
            Set the current vibration sensor data transmission interval to the specified time in seconds
            </summary>
            <param name="seconds">时间信息，单位为秒</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnPeekValueReceiveDelegate">
            <summary>
            震动传感器峰值数据事件委托<br />
            Shock sensor peak data event delegation
            </summary>
            <param name="peekValue">峰值信息</param>
        </member>
        <member name="E:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnPeekValueReceive">
             <summary>
             接收到震动传感器峰值数据时触发<br />
             Triggered when peak data of vibration sensor is received
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnActualValueReceiveDelegate">
            <summary>
            震动传感器实时数据事件委托<br />
            Vibration sensor real-time data event delegation
            </summary>
            <param name="actualValue">实际信息</param>
        </member>
        <member name="E:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnActualValueReceive">
             <summary>
             接收到震动传感器实时数据时触发<br />
             Triggered when real-time data from shock sensor is received
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnClientConnectedDelegate">
            <summary>
            连接服务器成功的委托<br />
            Connection server successfully delegated
            </summary>
        </member>
        <member name="E:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnClientConnected">
            <summary>
            当客户端连接成功触发事件，就算是重新连接服务器后，也是会触发的<br />
            The event is triggered when the client is connected successfully, even after reconnecting to the server.
            </summary>
        </member>
        <member name="E:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnNetworkError">
            <summary>
            当网络发生异常的时候触发的事件，用户应该在事件里进行重连服务器
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ConnectTimeOut">
            <summary>
            获取或设置当前客户端的连接超时时间，默认10,000毫秒，单位ms<br />
            Gets or sets the connection timeout of the current client. The default is 10,000 milliseconds. The unit is ms.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorClient.CheckSeconds">
            <summary>
            获取或设置当前的客户端假死超时检查时间，单位为秒，默认60秒，60秒内没有接收到传感器的数据，则强制重连。
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorClient.Address">
            <summary>
            当前设备的地址信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.BulidLongMessage(System.UInt16,System.Byte,System.Byte[])">
            <summary>
            根据地址，命令，数据，创建向传感器发送的数据信息
            </summary>
            <param name="address">设备地址</param>
            <param name="cmd">命令</param>
            <param name="data">数据信息</param>
            <returns>原始的数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.CheckXor(System.Byte[])">
            <summary>
            检查当前的数据是否XOR校验成功
            </summary>
            <param name="data">数据信息</param>
            <returns>校验结果</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage">
            <summary>
            完整的数据报文信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue">
            <summary>
            振动传感器的峰值数据类
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.AcceleratedSpeedX">
            <summary>
            X轴的加速度，单位 m/s2
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.AcceleratedSpeedY">
            <summary>
            Y轴的加速度，单位 m/s2
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.AcceleratedSpeedZ">
            <summary>
            Z轴的加速度，单位 m/s2
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.SpeedX">
            <summary>
            X轴的速度，单位 mm/s
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.SpeedY">
            <summary>
            Y轴的速度，单位 mm/s
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.SpeedZ">
            <summary>
            Z轴的速度，单位 mm/s
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.OffsetX">
            <summary>
            X轴的位置，单位 um
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.OffsetY">
            <summary>
            Y轴的位移，单位 um
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.OffsetZ">
            <summary>
            Z轴的位移，单位 um
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.Temperature">
            <summary>
            温度，单位 摄氏度
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.Voltage">
            <summary>
            电压，单位 伏特
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.SendingInterval">
            <summary>
            数据的发送间隔，单位秒
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage">
            <summary>
            短消息的报文内容
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="T:HslCommunication.Profinet.GE.GeHelper">
            <summary>
            GE plc相关的辅助类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.BuildReadCoreCommand(System.Int64,System.Byte,System.Byte[])">
            <summary>
            构建一个读取数据的报文信息，需要指定操作的数据代码，读取的参数信息<br />
            To construct a message information for reading data, you need to specify the data code of the operation and the parameter information to be read
            </summary>
            <param name="id">消息号</param>
            <param name="code">操作代码</param>
            <param name="data">数据参数</param>
            <returns>包含是否成功的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.BuildReadCommand(System.Int64,HslCommunication.Core.Address.GeSRTPAddress)">
            <summary>
            构建一个读取数据的报文命令，需要指定消息号，读取的 GE 地址信息<br />
            To construct a message command to read data, you need to specify the message number and read GE address information
            </summary>
            <param name="id">消息号</param>
            <param name="address">GE 的地址</param>
            <returns>包含是否成功的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.BuildReadCommand(System.Int64,System.String,System.UInt16,System.Boolean)">
            <summary>
            构建一个读取数据的报文命令，需要指定消息号，地址，长度，是否位读取，返回完整的报文信息。<br />
            To construct a message command to read data, you need to specify the message number, 
            address, length, whether to read in bits, and return the complete message information.
            </summary>
            <param name="id">消息号</param>
            <param name="address">地址</param>
            <param name="length">读取的长度</param>
            <param name="isBit"></param>
            <returns>包含是否成功的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.BuildWriteCommand(System.Int64,HslCommunication.Core.Address.GeSRTPAddress,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeHelper.BuildWriteCommand(System.Int64,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.BuildWriteCommand(System.Int64,System.String,System.Byte[])">
            <summary>
            构建一个批量写入 byte 数组变量的报文，需要指定消息号，写入的地址，地址参照 <see cref="T:HslCommunication.Profinet.GE.GeSRTPNet"/> 说明。<br />
            To construct a message to be written into byte array variables in batches, 
            you need to specify the message number and write address. For the address, refer to the description of <see cref="T:HslCommunication.Profinet.GE.GeSRTPNet"/>.
            </summary>
            <param name="id">消息的序号</param>
            <param name="address">地址信息</param>
            <param name="value">byte数组的原始数据</param>
            <returns>包含结果信息的报文内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.BuildWriteCommand(System.Int64,System.String,System.Boolean[])">
            <summary>
            构建一个批量写入 bool 数组变量的报文，需要指定消息号，写入的地址，地址参照 <see cref="T:HslCommunication.Profinet.GE.GeSRTPNet"/> 说明。<br />
            To construct a message to be written into bool array variables in batches, 
            you need to specify the message number and write address. For the address, refer to the description of <see cref="T:HslCommunication.Profinet.GE.GeSRTPNet"/>.
            </summary>
            <param name="id">消息的序号</param>
            <param name="address">地址信息</param>
            <param name="value">bool数组</param>
            <returns>包含结果信息的报文内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.ExtraResponseContent(System.Byte[])">
            <summary>
            从PLC返回的数据中，提取出实际的数据内容，最少6个字节的数据。超出实际的数据长度的部分没有任何意义。<br />
            From the data returned by the PLC, extract the actual data content, at least 6 bytes of data. The part beyond the actual data length has no meaning.
            </summary>
            <param name="content">PLC返回的数据信息</param>
            <returns>解析后的实际数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.ExtraDateTime(System.Byte[])">
            <summary>
            从实际的时间的字节数组里解析出C#格式的时间对象，这个时间可能是时区0的时间，需要自行转化本地时间。<br />
            Analyze the time object in C# format from the actual time byte array. 
            This time may be the time in time zone 0, and you need to convert the local time yourself.
            </summary>
            <param name="content">字节数组</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeHelper.ExtraProgramName(System.Byte[])">
            <summary>
            从实际的时间的字节数组里解析出PLC的程序的名称。<br />
            Parse the name of the PLC program from the actual time byte array
            </summary>
            <param name="content">字节数组</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.GE.GeSRTPNet">
            <summary>
            Ge(通用电气)集团的SRTP协议实现的客户端，支持 I,Q,M,T,SA,SB,SC,S,G 的位和字节读写，支持 AI,AQ,R 的字读写操作，支持读取PLC时间，程序名操作<br />
            The client implemented by Ge (General Electric) Group's SRTP protocol, supports I, Q, M, T, SA, SB, SC, S, G bit and byte read and write, 
            supports AI, AQ, R word read and write Operation, support reading PLC time, program name operation
            </summary>
            <remarks>
            PLC的端口号默认18245，其中读取R，AI，AQ寄存器的原始字节时，传入的长度参数为字节长度。<br />
            对其他寄存器而言，M1-M8的位读取，相当于 M1的字节读取。写入也是同理。
            </remarks>
            <example>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>位操作</term>
                <term>字节操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>Discrete Inputs</term>
                <term>I</term>
                <term>I1,I100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>Discrete Outputs</term>
                <term>Q</term>
                <term>Q1,Q100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>Discrete Internals</term>
                <term>M</term>
                <term>M1,M100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>Discrete Temporaries</term>
                <term>T</term>
                <term>T1,T100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>SA Discrete</term>
                <term>SA</term>
                <term>SA1,SA100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>SB Discrete</term>
                <term>SB</term>
                <term>SB1,SB100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>SC Discrete</term>
                <term>SC</term>
                <term>SC1,SC100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>S Discrete</term>
                <term>S</term>
                <term>S1,S100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>Genius Global Data</term>
                <term>G</term>
                <term>G1,G100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>注意：读位和字节，属于不同的地址</term>
              </item>
              <item>
                <term>Analog Inputs </term>
                <term>AI</term>
                <term>AI1,AI100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>虽然读取的时候，长度是字节，但是实际是字单位的，所以不支持 ReadByte</term>
              </item>
              <item>
                <term>Analog Outputs </term>
                <term>QI</term>
                <term>QI1,QI100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>虽然读取的时候，长度是字节，但是实际是字单位的，所以不支持 ReadByte</term>
              </item>
              <item>
                <term>Registers </term>
                <term>R</term>
                <term>R1,R100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>虽然读取的时候，长度是字节，但是实际是字单位的，所以不支持 ReadByte</term>
              </item>
            </list>
            <note type="important">对于 AI,AQ,R 类型的数据来说，底层是以字为单位的，但是调用 <see cref="M:HslCommunication.Profinet.GE.GeSRTPNet.Read(System.String,System.UInt16)"/> 来读取原始数据时，需要传入2被的字长度，对于其他方法不影响</note>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\GeSRTPNetSample.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\GeSRTPNetSample.cs" region="Usage2" title="简单的长连接使用" />
            
            假设起始地址为R1，R1存储了温度，100.6℃值为1006，R2存储了压力，1.23Mpa值为123，R3-R4存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\GeSRTPNetSample.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\GeSRTPNetSample.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址和端口号来实例化一个对象<br />
            Specify the IP address and port number to instantiate an object
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.Read(System.String,System.UInt16)">
            <summary>
            批量读取字节数组信息，需要指定地址和长度，返回原始的字节数组，支持 I,Q,M,T,SA,SB,SC,S,G 的位和字节读写，支持 AI,AQ,R 的字读写操作，地址示例：R1,M1<br />
            Batch read byte array information, need to specify the address and length, return the original byte array.
            Support I, Q, M, T, SA, SB, SC, S, G bit and byte read and write, support AI, AQ, R word read and write operations, address examples: R1, M1
            </summary>
            <remarks>
            其中读取R，AI，AQ寄存器的原始字节时，传入的长度参数为字节长度。长度为10，返回10个字节数组信息，如果返回长度不满6个字节的，一律返回6个字节的数据
            </remarks>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadByte(System.String)">
            <summary>
            根据指定的地址来读取一个字节的数据，按照字节为单位，例如 M1 字节，就是指 M1-M8 位组成的字节，M2 字节就是 M9-M16 组成的字节。不支持对 AI,AQ,R 寄存器的字节读取<br />
            A byte of data is read according to the specified address, and the unit is byte. For example, M1 byte refers to a byte composed of M1-M8 bits, 
            and M2 byte is a byte composed of M9-M16. Does not support byte reading of AI, AQ, R registers
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的 <see cref="T:System.Byte"/> 数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回是否写入成功<br />
            Write byte data to PLC and return whether the writing is successful
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 -> Starting address, formatted as I100,mM100,Q100,DB20.100</param>
            <param name="value">byte数据 -> Byte data</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadBool(System.String,System.UInt16)">
            <summary>
            按照位为单位，批量从指定的地址里读取 bool 数组数据，不支持 AI，AQ，R 地址类型，地址比如从1开始，例如 I1,Q1,M1,T1,SA1,SB1,SC1,S1,G1<br />
            In units of bits, read bool array data from the specified address in batches. AI, AQ, 
            R address types are not supported. For example, the address starts from 1, such as I1, Q1, M1, T1, SA1, SB1, SC1, S1, G1
            </summary>
            <param name="address">PLC的地址信息，例如 M1, G1</param>
            <param name="length">读取的长度信息，按照位为单位</param>
            <returns>包含是否读取成功的bool数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.Write(System.String,System.Boolean[])">
            <summary>
            按照位为单位，批量写入 bool 数组到指定的地址里，不支持 AI，AQ，R 地址类型，地址比如从1开始，例如 I1,Q1,M1,T1,SA1,SB1,SC1,S1,G1<br />
            In units of bits, write bool arrays in batches to the specified addresses. AI, AQ, and R address types are not supported. For example, 
            the address starts from 1, such as I1, Q1, M1, T1, SA1, SB1, SC1, S1, G1
            </summary>
            <param name="address">PLC的地址信息，例如 M1, G1</param>
            <param name="value">bool 数组</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadPLCTime">
            <summary>
            <b>[商业授权]</b> 读取PLC当前的时间，这个时间可能是不包含时区的，需要自己转换成本地的时间。<br />
            <b>[Authorization]</b> Read the current time of the PLC, this time may not include the time zone, you need to convert the local time yourself.
            </summary>
            <returns>包含是否成功的时间信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadProgramName">
            <summary>
            <b>[商业授权]</b> 读取PLC当前的程序的名称<br />
            <b>[Authorization]</b> Read the name of the current program of the PLC
            </summary>
            <returns>包含是否成的程序名称信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadPLCTimeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadPLCTime"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadProgramNameAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadProgramName"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.GE.GeSRTPServer">
            <summary>
            <b>[商业授权]</b> Ge的SRTP协议实现的虚拟PLC，支持I,Q,M,T,SA,SB,SC,S,G的位和字节读写，支持AI,AQ,R的字读写操作，支持读取当前时间及程序名称。<br />
            <b>[Authorization]</b> Virtual PLC implemented by Ge's SRTP protocol, supports bit and byte read and write of I, Q, M, T, SA, SB, SC, S, G, 
            supports word read and write operations of AI, AQ, R, and supports reading Current time and program name.
            </summary>
            <remarks>
            实例化之后，直接调用 <see cref="M:HslCommunication.Core.Net.NetworkServerBase.ServerStart(System.Int32)"/> 方法就可以通信及交互，所有的地址都是从1开始的，地址示例：M1,M100, R1，
            具体的用法参考 HslCommunicationDemo 相关界面的源代码。
            </remarks>
            <example>
            地址的示例，参考 <see cref="T:HslCommunication.Profinet.GE.GeSRTPNet"/> 相关的示例说明
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.GE.GeSRTPNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.GE.GeSRTPServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.IDCard.IdentityCard">
            <summary>
            身份证的信息类
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Name">
            <summary>
            名字
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Sex">
            <summary>
            性别
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Id">
            <summary>
            身份证号
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Nation">
            <summary>
            民族
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Birthday">
            <summary>
            生日
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Address">
            <summary>
            地址
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Organ">
            <summary>
            发证机关
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.ValidityStartDate">
            <summary>
            有效期日期的起始日期
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.ValidityEndDate">
            <summary>
            有效期日期的结束日期
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Portrait">
            <summary>
            头像信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.IdentityCard.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:HslCommunication.Profinet.IDCard.SAMSerial">
            <summary>
            基于SAM协议的串口通信类，支持读取身份证的数据信息，详细参见API文档<br />
            Network class implemented by Tcp based on the SAM protocol, which supports reading ID card data information, 
            see API documentation for details
            </summary>
            <example>
            在使用之前需要实例化当前的对象，然后根据实际的情况填写好串口的信息，否则连接不上去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample1" title="实例化操作" />
            在实际的读取，我们一般放在后台进行循环扫描的操作，参见下面的代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample2" title="基本的读取操作" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.SPReceived(System.IO.Ports.SerialPort,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ReadSafeModuleNumber">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadSafeModuleNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.CheckSafeModuleStatus">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.CheckSafeModuleStatus"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.SearchCard">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SearchCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.SelectCard">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SelectCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ReadCard">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.PackToSAMCommand(System.Byte[])">
            <summary>
            将指令进行打包成可以发送的数据对象
            </summary>
            <param name="command">命令信息</param>
            <returns>字节数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.BuildReadCommand(System.Byte,System.Byte,System.Byte[])">
            <summary>
            根据SAM的实际的指令，来生成实际的指令信息
            </summary>
            <param name="cmd">命令码</param>
            <param name="para">参数信息</param>
            <param name="data">数据内容</param>
            <returns>字符串的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.CheckADSCommandCompletion(System.Collections.Generic.List{System.Byte})">
            <summary>
            检查当前的接收数据信息是否一条完整的数据信息
            </summary>
            <param name="input">输入的信息</param>
            <returns>是否接收完成</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.CheckADSCommandAndSum(System.Byte[])">
            <summary>
            检查当前的指令是否是正确的
            </summary>
            <param name="input">输入的指令信息</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ExtractSafeModuleNumber(System.Byte[])">
            <summary>
            提炼安全的模块数据信息
            </summary>
            <param name="data">数据</param>
            <returns>结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ExtractIdentityCard(System.Byte[])">
            <summary>
            从数据中提取出真实的身份证信息
            </summary>
            <param name="data">原始数据内容</param>
            <returns>包含结果对象的身份证数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.GetNationText(System.Int32)">
            <summary>
            根据民族的代号来获取到民族的文本描述信息
            </summary>
            <param name="nation">民族代码</param>
            <returns>民族的文本信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.GetNationEnumerator">
            <summary>
            枚举当前的所有的民族信息，共计五十六个民族
            </summary>
            <returns>枚举信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.GetErrorDescription(System.Int32)">
            <summary>
            获取错误的文本信息
            </summary>
            <param name="err">错误号</param>
            <returns>错误信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.IDCard.SAMTcpNet">
            <summary>
            基于SAM协议的Tcp实现的网络类，支持读取身份证的数据信息，通过透传的形式实现，除了初始化和串口类不一致，调用方法是几乎一模一样的，详细参见API文档<br />
            The network class implemented by Tcp based on the SAM protocol supports reading ID card data information and is implemented in the form of transparent transmission. 
            Except for the inconsistency between the initialization and the serial port class, the calling method is almost the same. 
            See the API documentation for details
            </summary>
            <example>
            在使用之前需要实例化当前的对象，然后根据实际的情况填写好串口的信息，否则连接不上去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample3" title="实例化操作" />
            在实际的读取，我们一般放在后台进行循环扫描的操作，参见下面的代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample4" title="基本的读取操作" />
            当然也支持全异步的操作了，就是方法的名称改改
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample5" title="实例化操作" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample6" title="基本的读取操作" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的ip地址以及端口来实例化对象<br />
            Instantiate the object with the specified IP address and port
            </summary>
            <param name="ipAddress">ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadSafeModuleNumber">
            <summary>
            读取身份证设备的安全模块号<br />
            Read the security module number of the ID device
            </summary>
            <returns>结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.CheckSafeModuleStatus">
            <summary>
            检测安全模块状态<br />
            Detecting Security Module Status
            </summary>
            <returns>返回是否检测成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SearchCard">
            <summary>
            寻找卡片，并返回是否成功<br />
            Find cards and return success
            </summary>
            <returns>是否寻找成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SelectCard">
            <summary>
            选择卡片，并返回是否成功<br />
            Select card and return success
            </summary>
            <returns>是否寻找成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadCard">
            <summary>
            读取卡片，如果成功的话，就返回身份证的所有的信息<br />
            Read the card, if successful, return all the information of the ID cards
            </summary>
            <returns>是否寻找成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadSafeModuleNumberAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadSafeModuleNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.CheckSafeModuleStatusAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.CheckSafeModuleStatus"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SearchCardAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SearchCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SelectCardAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SelectCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadCardAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceHelper">
            <summary>
            汇川PLC的辅助类，提供一些地址解析的方法<br />
            Auxiliary class of Yaskawa robot, providing some methods of address resolution
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByte(HslCommunication.ModBus.IModbus,System.String)">
            <summary>
            按照字节读取汇川M地址的数据，地址示例： MB100，MB101，需要注意的是，MB100 及 MB101 的地址是 MW50 的数据。<br />
            Read the data of Inovance M address according to the byte, address example: MB100, MB101, it should be noted that the addresses of MB100 and MB101 are the data of MW50.
            </summary>
            <param name="modbus">汇川的PLC对象</param>
            <param name="address">地址信息</param>
            <returns>读取的结果数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByteAsync(HslCommunication.ModBus.IModbus,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByte(HslCommunication.ModBus.IModbus,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceAddress(HslCommunication.Profinet.Inovance.InovanceSeries,System.String,System.Byte)">
            <summary>
            根据汇川PLC的地址，解析出转换后的modbus协议信息，适用AM,H3U,H5U系列的PLC<br />
            According to the address of Inovance PLC, analyze the converted modbus protocol information, which is suitable for AM, H3U, H5U series PLC
            </summary>
            <param name="series">PLC的系列</param>
            <param name="address">汇川plc的地址信息</param>
            <param name="modbusCode">原始的对应的modbus信息</param>
            <returns>Modbus格式的地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceAMAddress(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceAddress(HslCommunication.Profinet.Inovance.InovanceSeries,System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceH3UAddress(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceAddress(HslCommunication.Profinet.Inovance.InovanceSeries,System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceH5UAddress(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceAddress(HslCommunication.Profinet.Inovance.InovanceSeries,System.String,System.Byte)"/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceSerial">
            <summary>
            汇川的串口通信协议，A适用于AM400、 AM400_800、 AC800、H3U, XP, H5U 等系列底层走的是MODBUS-RTU协议，地址说明参见标记<br />
            Huichuan's serial communication protocol is applicable to AM400, AM400_800, AC800 and other series. The bottom layer is MODBUS-RTU protocol. For the address description, please refer to the mark
            </summary>
            <remarks>
            AM400_800 的元件有 Q 区，I 区，M 区这三种，分别都可以按位，按字节，按字和按双字进行访问，在本组件的条件下，仅支持按照位，字访问。<br />
            位地址支持 Q, I, M 地址类型，字地址支持 SM, SD，支持对字地址的位访问，例如 ReadBool("SD0.5");
            H3U 系列控制器支持 M/SM/S/T/C/X/Y 等 bit 型变量（也称线圈） 的访问、 D/SD/R/T/C 等 word 型变量的访问；<br />
            H5U 系列控制器支持 M/B/S/X/Y 等 bit 型变量（也称线圈） 的访问、 D/R 等 word 型变量的访问；内部 W 元件，不支持通信访问。<br />
            </remarks>
            <example>
            对于AM400_800系列的地址表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>输出</term>
                <term>Q</term>
                <term>Q0.0-Q8191.7 或是 Q0-Q65535</term>
                <term>8 或是 10</term>
                <term>位读写</term>
              </item>
              <item>
                <term>输入</term>
                <term>I</term>
                <term>IX0.0-IX8191.7 或是 I0-I65535</term>
                <term>8 或是 10</term>
                <term>位读写</term>
              </item>
              <item>
                <term>M寄存器</term>
                <term>M</term>
                <term>MW0-MW65535</term>
                <term>10</term>
                <term>按照字访问的</term>
              </item>
              <item>
                <term>M寄存器</term>
                <term>M</term>
                <term>MX0.0-MX1000.10</term>
                <term>10</term>
                <term>按照位访问</term>
              </item>
            </list>
            针对AM600的TCP还支持下面的两种地址读写
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term></term>
                <term>SM</term>
                <term>SM0.0-SM8191.7 或是 SM0-SM65535</term>
                <term>10</term>
                <term>位读写</term>
              </item>
              <item>
                <term></term>
                <term>SD</term>
                <term>SDW0-SDW65535</term>
                <term>10</term>
                <term>字读写</term>
              </item>
            </list>
            我们再来看看H3U系列的线圈、 位元件、位变量地址定义
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄电器</term>
                <term>M</term>
                <term>M0-M7679，M8000-M8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SM</term>
                <term>SM0-SM1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X377 或者X0.0-X37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y377 或者Y0.0-Y37.7</term>
                <term>8</term>
                <term></term>
              </item>
            </list>
            寄存器、 字元件、字变量地址定义：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>SD</term>
                <term>SD0-SD1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>R</term>
                <term>R0-R32767</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C199,C200-C255</term>
                <term>10</term>
                <term>其实C200-C255的计数器是32位的</term>
              </item>
            </list>
            <c>我们再来看看XP系列，就是少了一点访问的数据类型，然后，地址范围也不一致</c><br />
            线圈、 位元件、位变量地址定义
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄电器</term>
                <term>M</term>
                <term>M0-M3071，M8000-M8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X377 或者X0.0-X37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y377 或者Y0.0-Y37.7</term>
                <term>8</term>
                <term></term>
              </item>
            </list>
            寄存器、 字元件、字变量地址定义：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C199,C200-C255</term>
                <term>10</term>
                <term>其实C200-C255的计数器是32位的</term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerial.#ctor(System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化<br />
            Specify the server address, port number, and client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerial.#ctor(HslCommunication.Profinet.Inovance.InovanceSeries,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化<br />
            Specify the server address, port number, and client's own station number to initialize
            </summary>
            <param name="series">PLC的系列选择</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="P:HslCommunication.Profinet.Inovance.InovanceSerial.Series">
            <summary>
            获取或设置汇川的系列，默认为AM系列
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerial.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByte(HslCommunication.ModBus.IModbus,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerial.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByte(HslCommunication.ModBus.IModbus,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerial.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp">
            <summary>
            汇川的串口转网口通信协议，A适用于AM400、 AM400_800、 AC800、H3U, XP, H5U 等系列底层走的是MODBUS-RTU协议，地址说明参见标记<br />
            Huichuan's serial communication protocol is applicable to AM400, AM400_800, AC800 and other series. The bottom layer is MODBUS-RTU protocol. For the address description, please refer to the mark
            </summary>
            <remarks>
            AM400_800 的元件有 Q 区，I 区，M 区这三种，分别都可以按位，按字节，按字和按双字进行访问，在本组件的条件下，仅支持按照位，字访问。<br />
            位地址支持 Q, I, M 地址类型，字地址支持 SM, SD，支持对字地址的位访问，例如 ReadBool("SD0.5");<br />
            H3U 系列控制器支持 M/SM/S/T/C/X/Y 等 bit 型变量（也称线圈） 的访问、 D/SD/R/T/C 等 word 型变量的访问；<br />
            H5U 系列控制器支持 M/B/S/X/Y 等 bit 型变量（也称线圈） 的访问、 D/R 等 word 型变量的访问；内部 W 元件，不支持通信访问。<br />
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Inovance.InovanceSerial" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            通过指定站号，ip地址，端口号来实例化一个新的对象
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="station">站号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp.#ctor(HslCommunication.Profinet.Inovance.InovanceSeries,System.String,System.Int32,System.Byte)">
            <summary>
            通过指定站号，IP地址，端口以及PLC的系列来实例化一个新的对象<br />
            Instantiate a new object by specifying the station number and PLC series
            </summary>
            <param name="series">PLC的系列</param>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="station">站号信息</param>
        </member>
        <member name="P:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp.Series">
            <summary>
            获取或设置汇川的系列，默认为AM系列
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByte(HslCommunication.ModBus.IModbus,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByte(HslCommunication.ModBus.IModbus,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceSerialOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceSeries">
            <summary>
            汇川的系列枚举信息
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Inovance.InovanceSeries.AM">
            <summary>
            适用于AM400、 AM400_800、 AC800 等系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Inovance.InovanceSeries.H3U">
            <summary>
            适用于H3U, XP 等系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Inovance.InovanceSeries.H5U">
            <summary>
            适用于H5U 系列
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceTcpNet">
            <summary>
            汇川的网口通信协议，A适用于AM400、 AM400_800、 AC800、H3U, XP, H5U 等系列底层走的是MODBUS-TCP协议，地址说明参见标记<br />
            Huichuan's serial communication protocol is applicable to AM400, AM400_800, AC800 and other series. The bottom layer is MODBUS-RTU protocol. For the address description, please refer to the mark
            </summary>
            <remarks>
            AM400_800 的元件有 Q 区，I 区，M 区这三种，分别都可以按位，按字节，按字和按双字进行访问，在本组件的条件下，仅支持按照位，字访问。<br />
            位地址支持 Q, I, M 地址类型，字地址支持 SM, SD，支持对字地址的位访问，例如 ReadBool("SD0.5");
            H3U 系列控制器支持 M/SM/S/T/C/X/Y 等 bit 型变量（也称线圈） 的访问、 D/SD/R/T/C 等 word 型变量的访问；<br />
            H5U 系列控制器支持 M/B/S/X/Y 等 bit 型变量（也称线圈） 的访问、 D/R 等 word 型变量的访问；内部 W 元件，不支持通信访问。<br />
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Inovance.InovanceSerial" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceTcpNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceTcpNet.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            通过指定站号，ip地址，端口号来实例化一个新的对象
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="station">站号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceTcpNet.#ctor(HslCommunication.Profinet.Inovance.InovanceSeries,System.String,System.Int32,System.Byte)">
            <summary>
            通过指定站号，IP地址，端口以及PLC的系列来实例化一个新的对象<br />
            Instantiate a new object by specifying the station number and PLC series
            </summary>
            <param name="series">PLC的系列</param>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="station">站号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceTcpNet.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByte(HslCommunication.ModBus.IModbus,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceTcpNet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceHelper.ReadByte(HslCommunication.ModBus.IModbus,System.String)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Inovance.InovanceTcpNet.Series">
            <summary>
            获取或设置汇川的系列，默认为AM系列
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceTcpNet.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series">
            <summary>
            基恩士SR2000系列扫码设备的通用接口
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.ReadBarcode">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadBarcode(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.Reset">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.Reset(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.OpenIndicator">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.OpenIndicator(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.CloseIndicator">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.CloseIndicator(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.ReadVersion">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadVersion(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.ReadCommandState">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadCommandState(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.ReadErrorState">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadErrorState(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.CheckInput(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.CheckInput(System.Int32,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.SetOutput(System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.SetOutput(System.Int32,System.Boolean,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.ReadRecord">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadRecord(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.Lock">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.Lock(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.UnLock">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.UnLock(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.IKeyenceSR2000Series.ReadCustomer(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadCustomer(System.String,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceDataType">
            <summary>
            Keyence PLC的数据类型，此处包含了几个常用的类型
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceDataType.#ctor(System.Byte,System.Byte,System.String,System.Int32)">
            <summary>
            如果您清楚类型代号，可以根据值进行扩展
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceDataType.DataCode">
            <summary>
            类型的代号值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.B">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.M">
            <summary>
            内部辅助继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.L">
            <summary>
            锁存继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.SM">
            <summary>
            控制继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.SD">
            <summary>
            控制存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.D">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.R">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.ZR">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.W">
            <summary>
            链路寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet">
            <summary>
            基恩士PLC的数据通信类，使用QnA兼容3E帧的通信协议实现，使用ASCII的格式，地址格式需要进行转换成三菱的格式，详细参照备注说明<br />
            Keyence PLC's data communication class is implemented using QnA compatible 3E frame communication protocol. 
            It uses ascii format. The address format needs to be converted to Mitsubishi format.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Keyence.KeyenceMcNet" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceMcNet">
            <summary>
            基恩士PLC的数据通信类，使用QnA兼容3E帧的通信协议实现，使用二进制的格式，地址格式需要进行转换成三菱的格式，详细参照备注说明<br />
            Keyence PLC's data communication class is implemented using QnA compatible 3E frame communication protocol. 
            It uses binary format. The address format needs to be converted to Mitsubishi format.
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>KV-7500/7300</term>
                <term>KV-5500/5000/3000</term>
                <term>KV Nano</term>
              </listheader>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>B0000~B7FFF</term>
                <term>B0000~B3FFF</term>
                <term>B0000~B1FFF</term>
              </item>
              <item>
                <term>内部辅助继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>MR00000~MR99915</term>
                <term>MR00000~MR99915</term>
                <term>MR00000～MR59915</term>
              </item>
              <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>LR00000~LR99915</term>
                <term>LR00000~LR99915</term>
                <term>LR00000～LR19915</term>
              </item>
              <item>
                <term>控制继电器</term>
                <term>SM</term>
                <term>SM100,SM200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>CR0000~CR7915</term>
                <term>CR0000~CR3915</term>
                <term>CR0000～CR8915</term>
              </item>
              <item>
                <term>控制存储器</term>
                <term>SD</term>
                <term>SD100,SD200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>CM0000~CM5999</term>
                <term>CM0000~CM5999</term>
                <term>CM0000～CM8999</term>
              </item>
              <item>
                <term>数据存储器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>DM00000~DM65534</term>
                <term>DM00000~DM65534</term>
                <term>DM00000～DM32767</term>
              </item>
              <item>
                <term>扩展数据存储器</term>
                <term>D</term>
                <term>D100000~D165534</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>EM00000~EM65534</term>
                <term>EM00000~EM65534</term>
                <term>×</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>FM00000~FM32767</term>
                <term>FM00000~FM32767</term>
                <term>×</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term>ZF000000~ZF524287</term>
                <term>ZF000000~ZF131071</term>
                <term>×</term>
              </item>
              <item>
                <term>链路寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term>W0000~7FFF</term>
                <term>W0000~3FFF</term>
                <term>W0000~3FFF</term>
              </item>
              <item>
                <term>定时器（当前值）</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>定时器（接点）</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>计数器（当前值）</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
              <item>
                <term>计数器（接点）</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.#ctor">
            <summary>
            实例化基恩士的Qna兼容3E帧协议的通讯对象<br />
            Instantiate Keyence Qna compatible 3E frame protocol communication object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址及端口号来实例化一个基恩士的Qna兼容3E帧协议的通讯对象<br />
            Specify an IP address and port number to instantiate a Keynes Qna compatible 3E frame protocol communication object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceNanoHelper">
            <summary>
            KeyenceNano的基本辅助方法
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.GetConnectCmd(System.Byte,System.Boolean)">
            <summary>
            连接PLC的命令报文<br />
            Command message to connect to PLC
            </summary>
            <param name="station">当前PLC的站号信息</param>
            <param name="useStation">是否启动站号命令</param>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.GetDisConnectCmd(System.Byte,System.Boolean)">
            <summary>
            断开PLC连接的命令报文<br />
            Command message to disconnect PLC
            </summary>
            <param name="station">当前PLC的站号信息</param>
            <param name="useStation">是否启动站号命令</param>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.GetWordAddressMultiple(System.String)">
            <summary>
            获取当前的地址类型是字数据的倍数关系
            </summary>
            <param name="type">地址的类型</param>
            <returns>倍数关系</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            建立读取PLC数据的指令，需要传入地址数据，以及读取的长度，地址示例参照类的说明文档<br />
            To create a command to read PLC data, you need to pass in the address data, and the length of the read. For an example of the address, refer to the class documentation
            </summary>
            <param name="address">软元件地址</param>
            <param name="length">读取长度</param>
            <returns>是否建立成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.BuildReadCommand(HslCommunication.Core.Address.KeyenceNanoAddress,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.BuildReadCommand(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.BuildWriteCommand(System.String,System.Byte[])">
            <summary>
            建立写入PLC数据的指令，需要传入地址数据，以及写入的数据信息，地址示例参照类的说明文档<br />
            To create a command to write PLC data, you need to pass in the address data and the written data information. For an example of the address, refer to the class documentation
            </summary>
            <param name="address">软元件地址</param>
            <param name="value">转换后的数据</param>
            <returns>是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.BuildWriteExpansionMemoryCommand(System.Byte,System.UInt16,System.Byte[])">
            <summary>
            构建写入扩展单元缓冲寄存器的报文命令，需要传入单元编号，地址，写入的数据，实际写入的数据格式才有无符号的方式<br />
            To construct a message command to write to the buffer register of the expansion unit, the unit number, address, 
            and data to be written need to be passed in, and the format of the actually written data is unsigned.
            </summary>
            <param name="unit">单元编号0~48</param>
            <param name="address">地址0~32767</param>
            <param name="value">写入的数据信息，单次交互最大256个字</param>
            <returns>包含是否成功的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.BuildWriteCommand(System.String,System.Boolean)">
            <summary>
            建立写入bool数据的指令，针对地址类型为 R,CR,MR,LR<br />
            Create instructions to write bool data, address type is R, CR, MR, LR
            </summary>
            <param name="address">软元件地址</param>
            <param name="value">转换后的数据</param>
            <returns>是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.BuildWriteCommand(System.String,System.Boolean[])">
            <summary>
            批量写入数据位到plc地址，针对地址格式为 R,B,CR,MR,LR,VB<br />
            Write data bits in batches to the plc address, and the address format is R, B, CR, MR, LR, VB
            </summary>
            <param name="address">PLC的地址</param>
            <param name="value">等待写入的bool数组</param>
            <returns>写入bool数组的命令报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.CheckPlcReadResponse(System.Byte[])">
            <summary>
            校验读取返回数据状态，主要返回的第一个字节是不是E<br />
            Check the status of the data returned from reading, whether the first byte returned is E
            </summary>
            <param name="ack">反馈信息</param>
            <returns>是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.CheckPlcWriteResponse(System.Byte[])">
            <summary>
            校验写入返回数据状态，检测返回的数据是不是OK<br />
            Verify the status of the returned data written and check whether the returned data is OK
            </summary>
            <param name="ack">反馈信息</param>
            <returns>是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ExtractActualBoolData(System.String,System.Byte[])">
            <summary>
            从PLC反馈的数据进行提炼Bool操作<br />
            Refine Bool operation from data fed back from PLC
            </summary>
            <param name="addressType">地址的数据类型</param>
            <param name="response">PLC反馈的真实数据</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ExtractActualData(System.String,System.Byte[])">
            <summary>
            从PLC反馈的数据进行提炼操作<br />
            Refining operation from data fed back from PLC
            </summary>
            <param name="addressType">地址的数据类型</param>
            <param name="response">PLC反馈的真实数据</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
            <remarks>
            地址支持读取扩展单元缓冲存储器的数据，例如读取扩展单元号1，地址100的数据，地址写为 unit=1;100<br />
            The address supports reading the data in the buffer memory of the expansion unit, such as reading the data of the expansion unit number 1, address 100, and the address is written as unit=1;100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice)">
            <summary>
            <c>[商业授权]</c> 查询PLC的型号信息<br />
            <b>[Authorization]</b> Query PLC model information
            </summary>
            <param name="keyence">PLC通信对象</param>
            <returns>包含型号的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcTypeAsync(HslCommunication.Core.IReadWriteDevice)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice)">
            <summary>
            <c>[商业授权]</c> 读取当前PLC的模式，如果是0，代表 PROG模式或者梯形图未登录，如果为1，代表RUN模式<br />
            <b>[Authorization]</b> Read the current PLC mode, if it is 0, it means PROG mode or the ladder diagram is not registered, if it is 1, it means RUN mode
            </summary>
            <param name="keyence">PLC通信对象</param>
            <returns>包含模式的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcModeAsync(HslCommunication.Core.IReadWriteDevice)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.SetPlcDateTime(HslCommunication.Core.IReadWriteDevice,System.DateTime)">
            <summary>
            <c>[商业授权]</c> 设置PLC的时间<br />
            <b>[Authorization]</b> Set PLC time
            </summary>
            <param name="keyence">PLC通信对象</param>
            <param name="dateTime">时间数据</param>
            <returns>是否设置成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.SetPlcDateTimeAsync(HslCommunication.Core.IReadWriteDevice,System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.SetPlcDateTime(HslCommunication.Core.IReadWriteDevice,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadAddressAnnotation(HslCommunication.Core.IReadWriteDevice,System.String)">
            <summary>
            <c>[商业授权]</c> 读取指定软元件的注释信息<br />
            <b>[Authorization]</b> Read the comment information of the specified device
            </summary>
            <param name="keyence">PLC通信对象</param>
            <param name="address">软元件的地址</param>
            <returns>软元件的注释信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadAddressAnnotationAsync(HslCommunication.Core.IReadWriteDevice,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadAddressAnnotation(HslCommunication.Core.IReadWriteDevice,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadExpansionMemory(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.UInt16)">
            <summary>
            <c>[商业授权]</c> 从扩展单元缓冲存储器连续读取指定个数的数据，单位为字<br />
            <b>[Authorization]</b> Continuously read the specified number of data from the expansion unit buffer memory, the unit is word
            </summary>
            <param name="keyence">PLC的通信对象</param>
            <param name="unit">单元编号</param>
            <param name="address">偏移地址</param>
            <param name="length">读取的长度，单位为字</param>
            <returns>包含是否成功的原始字节数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadExpansionMemoryAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadExpansionMemory(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.WriteExpansionMemory(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.Byte[])">
             <summary>
            <c>[商业授权]</c> 将原始字节数据写入到扩展的缓冲存储器，需要指定单元编号，偏移地址，写入的数据<br />
             <b>[Authorization]</b> To write the original byte data to the extended buffer memory, you need to specify the unit number, offset address, and write data
             </summary>
             <param name="keyence">PLC通信对象信息</param>
             <param name="unit">单元编号</param>
             <param name="address">偏移地址</param>
             <param name="value">等待写入的原始字节数据</param>
             <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.WriteExpansionMemoryAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.WriteExpansionMemory(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceNanoSerial">
            <summary>
            基恩士KV上位链路串口通信的对象,适用于Nano系列串口数据,KV1000以及L20V通信模块，地址格式参考api文档<br />
            Keyence KV upper link serial communication object, suitable for Nano series serial data, and L20V communication module, please refer to api document for address format
            </summary>
            <remarks>
            位读写的数据类型为 R,B,MR,LR,CR,VB,以及读定时器的计数器的触点，字读写的数据类型为 DM,EM,FM,ZF,W,TM,Z,AT,CM,VM 双字读写为T,C,TC,CC,TS,CS。如果想要读写扩展的缓存器，地址示例：unit=2;1000  前面的是单元编号，后面的是偏移地址<br />
            注意：在端口 2 以多分支连接 KV-L21V 时，请一定加上站号。在将端口 2 设定为使用 RS-422A、 RS-485 时， KV-L21V 即使接收本站以外的带站号的指令，也将变为无应答，不返回响应消息。
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.#ctor">
            <summary>
            实例化基恩士的串口协议的通讯对象<br />
            Instantiate the communication object of Keyence's serial protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.InitializationOnOpen(System.IO.Ports.SerialPort)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ExtraOnClose(System.IO.Ports.SerialPort)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Station"/>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.UseStation">
            <inheritdoc cref="P:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.UseStation"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ReadPlcMode">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.SetPlcDateTime(System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.SetPlcDateTime(HslCommunication.Core.IReadWriteDevice,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ReadAddressAnnotation(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadAddressAnnotation(HslCommunication.Core.IReadWriteDevice,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ReadExpansionMemory(System.Byte,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadExpansionMemory(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.WriteExpansionMemory(System.Byte,System.UInt16,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.WriteExpansionMemory(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp">
            <summary>
            基恩士KV上位链路协议的通信对象,适用于KV5000/5500/3000,KV1000,KV700,以及L20V通信模块，本类是基于tcp通信<br />
            The communication object of KEYENCE KV upper link protocol is suitable for KV5000/5500/3000, KV1000, KV700, and L20V communication modules. This type is based on tcp communication
            </summary>
            <remarks>
            位读写的数据类型为 R,B,MR,LR,CR,VB,以及读定时器的计数器的触点，字读写的数据类型为 DM,EM,FM,ZF,W,TM,Z,AT,CM,VM 双字读写为T,C,TC,CC,TS,CS。如果想要读写扩展的缓存器，地址示例：unit=2;1000  前面的是单元编号，后面的是偏移地址<br />
            注意：在端口 2 以多分支连接 KV-L21V 时，请一定加上站号。在将端口 2 设定为使用 RS-422A、 RS-485 时， KV-L21V 即使接收本站以外的带站号的指令，也将变为无应答，不返回响应消息。
            </remarks>
            <example>
            地址示例如下：
            当读取Bool的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>继电器</term>
                <term>R</term>
                <term>R0,R100</term>
                <term>0-59915</term>
                <term></term>
              </item>
              <item>
                <term>链路继电器</term>
                <term>B</term>
                <term>B0,B100</term>
                <term>0-3FFF</term>
                <term>KV5500/KV5000/KV3000</term>
              </item>
              <item>
                <term>控制继电器</term>
                <term>CR</term>
                <term>CR0,CR100</term>
                <term>0-3915</term>
                <term></term>
              </item>
              <item>
                <term>内部辅助继电器</term>
                <term>MR</term>
                <term>MR0,MR100</term>
                <term>0-99915</term>
                <term></term>
              </item>
              <item>
                <term>锁存继电器</term>
                <term>LR</term>
                <term>LR0,LR100</term>
                <term>0-99915</term>
                <term></term>
              </item>
              <item>
                <term>工作继电器</term>
                <term>VB</term>
                <term>VB0,VB100</term>
                <term>0-3FFF</term>
                <term>KV5500/KV5000/KV3000</term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0,T100</term>
                <term>0-3999</term>
                <term>通断</term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0,C100</term>
                <term>0-3999</term>
                <term>通断</term>
              </item>
              <item>
                <term>高速计数器</term>
                <term>CTH</term>
                <term>CTH0,CTH1</term>
                <term>0-1</term>
                <term>通断</term>
              </item>
              <item>
                <term>高速计数器比较器</term>
                <term>CTC</term>
                <term>CTC0,CTC1</term>
                <term>0-1</term>
                <term>通断</term>
              </item>
            </list>
            读取数据的地址如下：
            
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据存储器</term>
                <term>DM</term>
                <term>DM0,DM100</term>
                <term>0-65534</term>
                <term></term>
              </item>
              <item>
                <term>控制存储器</term>
                <term>CM</term>
                <term>CM0,CM100</term>
                <term>0-11998</term>
                <term></term>
              </item>
              <item>
                <term>临时数据存储器</term>
                <term>TM</term>
                <term>TM0,TM100</term>
                <term>0-511</term>
                <term></term>
              </item>
              <item>
                <term>扩展数据存储器</term>
                <term>EM</term>
                <term>EM0,EM100</term>
                <term>0-65534</term>
                <term></term>
              </item>
              <item>
                <term>扩展数据存储器</term>
                <term>FM</term>
                <term>FM0,FM100</term>
                <term>0-32766</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z1,Z5</term>
                <term>1-12</term>
                <term></term>
              </item>
              <item>
                <term>数字微调器</term>
                <term>AT</term>
                <term>AT0,AT5</term>
                <term>0-7</term>
                <term></term>
              </item>
              <item>
                <term>链路寄存器</term>
                <term>W</term>
                <term>W1,W5</term>
                <term>0-3FFF</term>
                <term>KV5500/KV5000/KV3000</term>
              </item>
              <item>
                <term>工作寄存器</term>
                <term>VM</term>
                <term>VM1,VM5</term>
                <term>0-59999</term>
                <term>KV5500/KV5000/KV3000</term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0,T100</term>
                <term>0-3999</term>
                <term>当前值(current value), 读int</term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0,C100</term>
                <term>0-3999</term>
                <term>当前值(current value), 读int</term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口号来初始化对象<br />
            Initialize the object with the specified IP address and port number
            </summary>
            <param name="ipAddress">Ip地址数据</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ExtraOnDisconnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Station">
            <summary>
            获取或设置当前的站号信息，在RS232连接模式下，设置为0，如果是RS485/RS422连接下，必须设置正确的站号<br />
            Get or set the current station number information. In RS232 connection mode, set it to 0. 
            If it is RS485/RS422 connection, you must set the correct station number.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.UseStation">
            <summary>
            获取或设置当前是否启用站号信息，当不启动站号时，在连接和断开的时候，将不使用站号报文。<br />
            Get or set whether the station number information is currently enabled or not. 
            When the station number is not activated, the station number message will not be used when connecting and disconnecting.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadPlcMode">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.SetPlcDateTime(System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.SetPlcDateTime(HslCommunication.Core.IReadWriteDevice,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadAddressAnnotation(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadAddressAnnotation(HslCommunication.Core.IReadWriteDevice,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadExpansionMemory(System.Byte,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.ReadExpansionMemory(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.WriteExpansionMemory(System.Byte,System.UInt16,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoHelper.WriteExpansionMemory(HslCommunication.Core.IReadWriteDevice,System.Byte,System.UInt16,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadPlcTypeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadPlcModeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadPlcMode"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.SetPlcDateTimeAsync(System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.SetPlcDateTime(System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadAddressAnnotationAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadAddressAnnotation(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadExpansionMemoryAsync(System.Byte,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadExpansionMemory(System.Byte,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.WriteExpansionMemoryAsync(System.Byte,System.UInt16,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.WriteExpansionMemory(System.Byte,System.UInt16,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceNanoServer">
            <summary>
            基恩士的上位链路协议的虚拟服务器
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.#ctor">
            <summary>
            实例化一个基于上位链路协议的虚拟的基恩士PLC对象，可以用来和<see cref="T:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp"/>进行通信测试。
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyencePLCS">
            <summary>
            基恩士PLC的各种系列选择
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyencePLCS.KV5500">
            <summary>
            KV5500系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyencePLCS.KV5000">
            <summary>
            KV5000系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyencePLCS.KV3000">
            <summary>
            KV3000系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyencePLCS.KV1000">
            <summary>
            KV1000系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyencePLCS.KV700">
            <summary>
            KV700系列
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper">
            <summary>
            当前SR2000的辅助函数
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadBarcode(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            读取条码信息，返回最终读取的条码数据<br />
            Read the barcode information and return the finally read barcode data
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>条码信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.Reset(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            复位命令，响应后，进行复位动作。<br />
            Reset command, after responding, reset action.
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.OpenIndicator(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            打开指示灯<br />
            Turn on the indicator
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.CloseIndicator(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            关闭指示灯<br />
            Turn off the indicator
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadVersion(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            读取基恩士的版本<br />
            Read Keyence's version
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>版本信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadCommandState(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            读取基恩士的命令状态，none:不处理；wait：等待设置反映；update：正在更新<br />
            Read the command status of Keyence, none: do not process; wait: wait for the setting to reflect; update: update
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadErrorState(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            读取基恩士的错误状态<br />
            Read the error status of Keyence
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.CheckInput(System.Int32,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            读取IN端子的状况，需要传入哪个IN端子，返回是否通断<br />
            Read the status of the IN terminal, which IN terminal needs to be passed in, and return whether it is on or off
            </summary>
            <param name="number">端子的信息</param>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.SetOutput(System.Int32,System.Boolean,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            设置OUT端子的使能，需要传入哪个OUT端子，返回是否设置成功！<br />
            Set the enable of the OUT terminal, which OUT terminal needs to be passed in, and return whether the setting is successful!
            </summary>
            <param name="number">端子的索引，1，2，3</param>
            <param name="value">是否通断</param>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadRecord(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            读取扫码器的扫码记录，返回数组数据，分别是成功次数，失败次数，ERROR次数，稳定次数，时机输入次数<br />
            Read the scan code record of the scanner and return the array data, which are the number of successes, failures, ERRORs, stable times, and timing input times.
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.Lock(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            锁定扫码设备<br />
            Lock scanning device
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.UnLock(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            解除锁定的扫码设备<br />
            Unlock Scanning Device
            </summary>
            <param name="readCore">核心交互的方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadCustomer(System.String,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            读取自定义的命令，例如LON，如果是包含其他参数的，比如打开OUT端子，OUTON,1<br />
            Read custom commands, such as LON, if it contains other parameters, such as open OUT terminal, OUTON,1
            </summary>
            <param name="command">自定义的命令</param>
            <param name="readCore">核心的数据交互方法</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.GetErrorDescription(System.String)">
            <summary>
            获取操作代码包含的错误文本信息<br />
            Get the error text information contained in the operation code
            </summary>
            <param name="error">错误代码</param>
            <returns>真是的错误信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial">
            <inheritdoc cref="T:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.ReadBarcode">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadBarcode(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.Reset">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.Reset(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.OpenIndicator">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.OpenIndicator(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.CloseIndicator">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.CloseIndicator(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.ReadVersion">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadVersion(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.ReadCommandState">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadCommandState(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.ReadErrorState">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadErrorState(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.CheckInput(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.CheckInput(System.Int32,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.SetOutput(System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.SetOutput(System.Int32,System.Boolean,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.ReadRecord">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadRecord(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.Lock">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.Lock(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.UnLock">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.UnLock(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.ReadCustomer(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadCustomer(System.String,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Serial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp">
            <summary>
            基恩士的SR2000的扫码设备，可以进行简单的交互
            </summary>
            <remarks>
            当使用 "LON","LOFF","PRON","PROFF" 命令时，在发送时和发生错误时，将不会收到扫码设备的回发命令，而是输出读取结果。
            如果也希望获取上述命令的响应时，请在以下位置进行设置。[设置列表]-[其他]-"指定基本命令的响应字符串"
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.#ctor">
            <summary>
            实例化基恩士的SR2000的扫码设备通讯对象<br />
            Instantiate keyence's SR2000 scan code device communication object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址及端口号来实例化一个基恩士的SR2000的扫码设备通讯对象<br />
            Specify the ip address and port number to instantiate a keyence SR2000 scan code device communication object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.ReadBarcode">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadBarcode(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.Reset">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.Reset(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.OpenIndicator">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.OpenIndicator(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.CloseIndicator">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.CloseIndicator(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.ReadVersion">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadVersion(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.ReadCommandState">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadCommandState(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.ReadErrorState">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadErrorState(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.CheckInput(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.CheckInput(System.Int32,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.SetOutput(System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.SetOutput(System.Int32,System.Boolean,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.ReadRecord">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadRecord(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.Lock">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.Lock(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.UnLock">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.UnLock(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.ReadCustomer(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceSR2000Helper.ReadCustomer(System.String,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceSR2000SeriesTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Knx.KnxCode">
            <summary>
            Knx协议
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Knx.KnxCode.ReturnData">
            <summary>
            返回数据的委托
            </summary>
            <param name="data"></param>
        </member>
        <member name="E:HslCommunication.Profinet.Knx.KnxCode.Return_data_msg">
            <summary>
            返回需要写入KNX总线的应答报文（应答数据）
            </summary>
        </member>
        <member name="E:HslCommunication.Profinet.Knx.KnxCode.Set_knx_data">
            <summary>
            返回需要写入的KNX系统的报文（写入数据）
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Knx.KnxCode.GetData">
            <summary>
            获取数据的委托
            </summary>
            <param name="addr"></param>
            <param name="len"></param>
            <param name="data"></param>
        </member>
        <member name="E:HslCommunication.Profinet.Knx.KnxCode.GetData_msg">
            <summary>
            返回从knx系统得到的数据
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxCode.SequenceCounter">
            <summary>
            序号计数
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxCode.Channel">
            <summary>
            通道
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxCode.IsConnect">
            <summary>
            连接状态
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Disconnect_knx(System.Byte,System.Net.IPEndPoint)">
            <summary>
            关闭KNX连接
            </summary>
            <param name="channel">通道号</param>
            <param name="IP_PROT">本机IP</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Handshake(System.Net.IPEndPoint)">
            <summary>
            返回握手报文
            </summary>
            <param name="IP_PROT">本机ip地址</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.KNX_check(System.Byte[])">
            <summary>
            KNX报文解析
            </summary>
            <param name="in_data"></param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Knx_Write(System.Int16,System.Byte,System.Byte[])">
            <summary>
            写入数据到KNX系统
            </summary>
            <param name="addr">地址</param>
            <param name="len">长度</param>
            <param name="data">数据</param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Knx_Resd_step1(System.Int16)">
            <summary>
            从KNX获取数据
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.knx_server_is_real(System.Net.IPEndPoint)">
            <summary>
            连接保持（每隔1s发送一次到设备）
            </summary>
            <param name="IP_PROT"></param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Get_knx_addr(System.String,System.Boolean@)">
            <summary>
            暂时没有注释
            </summary>
            <param name="addr"></param>
            <param name="is_ok"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Return_status">
            <summary>
            返回连接状态
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Extraction_of_Channel(System.Byte[])">
            <summary>
            从握手回复报文获取通道号
            </summary>
            <param name="in_data"></param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Read_com_CEMI(System.Byte[])">
            <summary>
            解析控制包头和CEMI
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Read_CEMI(System.Byte[])">
             <summary>
            具体解析CEMI 
             </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Knx.KnxUdp">
            <summary>
            Knx驱动，具体的用法参照demo
            </summary>
            <remarks>
            感谢上海NULL提供的技术支持
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.Channel">
            <summary>
            通道号（由设备发来）
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.RouEndpoint">
            <summary>
            远程ip地址
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.LocalEndpoint">
            <summary>
            本机IP地址
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.LogNet">
            <summary>
            系统的日志信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.IsConnect">
            <summary>
            当前的状态是否连接中
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.KnxCode">
            <summary>
            通信指令类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.ConnectKnx">
            <summary>
            和KNX网络进行握手并开始监听
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.KeepConnection">
            <summary>
            保持KNX连接
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.DisConnectKnx">
            <summary>
            关闭连接
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.SetKnxData(System.Int16,System.Byte,System.Byte[])">
            <summary>
            将报文写入KNX系统
            </summary>
            <param name="addr">地址</param>
            <param name="len">长度</param>
            <param name="data">数据</param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.ReadKnxData(System.Int16)">
            <summary>
            读取指定KNX组地址
            </summary>
            <param name="addr">地址</param>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper">
            <summary>
            Cnet的辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.GetErrorText(System.Int32)">
            <summary>
            根据错误号，获取到真实的错误描述信息<br />
            According to the error number, get the real error description information
            </summary>
            <param name="err">错误号</param>
            <returns>真实的错误描述信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.UnpackResponseContent(System.Byte[],System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.CalculateAddressStarted(System.String,System.Boolean)">
            <summary>
            AnalysisAddress IX0.0.0 QX0.0.0  MW1.0  MB1.0
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="QI">是否输入输出的情况</param>
            <returns>实际的偏移地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.IsHex(System.String)">
            <summary>
            NumberStyles HexNumber
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.AnalysisAddress(System.String)">
            <summary>
            AnalysisAddress
            </summary>
            <param name="address">start address</param>
            <returns>analysis result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.BuildReadByteCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            reading address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="length">read length</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.BuildReadIndividualCommand(System.Byte,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.BuildReadIndividualCommand(System.Byte,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.BuildReadIndividualCommand(System.Byte,System.String[])">
            <summary>
            Multi reading address Type of Read Individual
            </summary>
            <param name="station">plc station</param>
            <param name="addresses">address, for example: MX100, PX100</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.BuildReadCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            build read command. 
            </summary>
            <param name="station">station</param>
            <param name="address">start address</param>
            <param name="length">address length</param>
            <returns> command</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.BuildWriteByteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            write data to address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="value">source value</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.BuildWriteOneCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            write data to address  Type of One
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="value">source value</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            write data to address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="value">source value</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.UInt16)">
            <summary>
            从PLC的指定地址读取原始的字节数据信息，地址示例：MB100, MW100, MD100, 如果输入了M100等同于MB100<br />
            Read the original byte data information from the designated address of the PLC. 
            Examples of addresses: MB100, MW100, MD100, if the input M100 is equivalent to MB100
            </summary>
            <remarks>
            地址类型支持 P,M,L,K,F,T,C,D,R,I,Q,W, 支持携带站号的形式，例如 s=2;MW100
            </remarks>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">PLC的地址信息，例如 M100, MB100, MW100, MD100</param>
            <param name="length">读取的长度信息</param>
            <returns>返回是否读取成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String[])">
            <summary>
            从PLC设备读取多个地址的数据信息，返回连续的字节数组，需要按照实际情况进行按顺序解析。<br />
            Read the data information of multiple addresses from the PLC device and return a continuous byte array, which needs to be parsed in order according to the actual situation.
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">PLC的地址信息，例如 M100, MB100, MW100, MD100</param>
            <returns>结果对象数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Byte[])">
            <summary>
            将原始数据写入到PLC的指定的地址里，地址示例：MB100, MW100, MD100, 如果输入了M100等同于MB100<br />
            Write the original data to the designated address of the PLC. 
            Examples of addresses: MB100, MW100, MD100, if input M100 is equivalent to MB100
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">PLC的地址信息，例如 M100, MB100, MW100, MD100</param>
            <param name="value">等待写入的原始数据内容</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String)">
            <summary>
            从PLC的指定地址读取原始的位数据信息，地址示例：MX100, MX10A<br />
            Read the original bool data information from the designated address of the PLC. 
            Examples of addresses: MX100, MX10A
            </summary>
            <remarks>
            地址类型支持 P,M,L,K,F,T,C,D,R,I,Q,W, 支持携带站号的形式，例如 s=2;MX100
            </remarks>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">PLC的地址信息，例如 MX100, MX10A</param>
            <returns>返回是否读取成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Boolean)">
            <summary>
            将bool数据写入到PLC的指定的地址里，地址示例：MX100, MX10A<br />
            Write the bool data to the designated address of the PLC. Examples of addresses: MX100, MX10A
            </summary>
            <remarks>
            地址类型支持 P,M,L,K,F,T,C,D,R,I,Q,W, 支持携带站号的形式，例如 s=2;MX100
            </remarks>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">PLC的地址信息，例如 MX100, MX10A</param>
            <param name="value">bool值信息</param>
            <returns>返回是否读取成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Boolean)"/>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.LSCpuInfo">
            <summary>
            It is determined to be the XGK/I/R series through a reserved area
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.LSCpuStatus">
            <summary>
            Cpu status
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.LSCpuStatus.RUN">
            <summary>
            运行中
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.LSCpuStatus.STOP">
            <summary>
            运行停止
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.LSCpuStatus.ERROR">
            <summary>
            错误状态
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.LSCpuStatus.DEBUG">
            <summary>
            调试模式
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.FlagBit">
            <summary>
            using FlagBit in Marker for Byte<br />
            M0.0=1;M0.1=2;M0.2=4;M0.3=8;==========================>M0.7=128
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.IO">
            <summary>입출력(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.SubRelay">
            <summary>보조릴레이(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.LinkRelay">
            <summary>링크릴레이(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.KeepRelay">
            <summary>Keep릴레이(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.EtcRelay">
            <summary>특수릴레이(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.Timer">
            <summary>타이머(현재값)(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.Counter">
            <summary>카운터(현재값)(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.ComDataRegister">
            <summary>통신 데이터레지스터(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.FileDataRegister">
            <summary>파일 레지스터(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.StepRelay">
            <summary>파일 레지스터(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_MemoryType.SpecialRegister">
            <summary>파일 레지스터(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.IO">
            <summary>입출력(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.SubRelay">
            <summary>보조릴레이(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.LinkRelay">
            <summary>링크릴레이(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.KeepRelay">
            <summary>Keep릴레이(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.EtcRelay">
            <summary>특수릴레이(Bit)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.Timer">
            <summary>타이머(현재값)(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.Counter">
            <summary>카운터(현재값)(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.DataRegister">
            <summary>데이터레지스터(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.ComDataRegister">
            <summary>통신 데이터레지스터(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.FileDataRegister">
            <summary>파일 레지스터(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.StepRelay">
            <summary>파일 레지스터(Word)</summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGT_Memory_TypeClass.SpecialRegister">
            <summary>파일 레지스터(Word)</summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGTAddressData.AddressString">
            <summary>
            주소 문자열 표현, EX) %DW1100
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGTAddressData.AddressByteArray">
            <summary>
            AddressString 을 바이트 배열로 변환
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGTAddressData.LengthByteArray">
            <summary>
            AddressByteArray 바이트 배열의 수(2byte)
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.LSisServer">
            <summary>
            <b>[商业授权]</b> Lsis的虚拟服务器，其中TCP的端口支持Fnet协议，串口支持Cnet协议<br />
            <b>[Authorization]</b> LSisServer
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.#ctor(System.String)">
            <summary>
            LSisServer
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.LSisServer.SetCpuType">
            <summary>
            set plc
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.IsHex(System.String)">
            <summary>
            NumberStyles HexNumber
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.CheckAddress(System.String)">
            <summary>
            Check the intput string address
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.GetSerialMessageLogText(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.DealWithSerialReceivedData(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.AnalysisAddressToByteUnit(System.String,System.Boolean)">
            <summary>
            将带有数据类型的地址，转换成实际的byte数组的地址信息，例如 MW100 转成 M200
            </summary>
            <param name="address">带有类型的地址</param>
            <param name="isBit">是否是位操作</param>
            <returns>最终的按照字节为单位的地址信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.XGBCnet">
            <summary>
            XGB Cnet I/F module supports Serial Port. The address can carry station number information, for example: s=2;D100
            </summary>
            <remarks>
            XGB 主机的通道 0 仅支持 1:1 通信。 对于具有主从格式的 1:N 系统，在连接 XGL-C41A 模块的通道 1 或 XGB 主机中使用 RS-485 通信。 XGL-C41A 模块支持 RS-422/485 协议。
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.LSIS.XGBCnetOverTcp" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBCnet.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.WriteCoil(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.WriteCoil(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadCoilAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadCoilAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.WriteCoilAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.WriteCoil(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Read(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.Read(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.XGBCnetOverTcp">
            <summary>
            XGB Cnet I/F module supports Serial Port. On Tcp/ip implementation, The address can carry station number information, for example: s=2;D100
            </summary>
            <remarks>
            XGB 主机的通道 0 仅支持 1:1 通信。 对于具有主从格式的 1:N 系统，在连接 XGL-C41A 模块的通道 1 或 XGB 主机中使用 RS-485 通信。 XGL-C41A 模块支持 RS-422/485 协议。
            </remarks>
            <example>
            Address example likes the follow
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>*</term>
                <term>P</term>
                <term>PX100,PB100,PW100,PD100,PL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>M</term>
                <term>MX100,MB100,MW100,MD100,ML100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>L</term>
                <term>LX100,LB100,LW100,LD100,LL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>K</term>
                <term>KX100,KB100,KW100,KD100,KL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>F</term>
                <term>FX100,FB100,FW100,FD100,FL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>T</term>
                <term>TX100,TB100,TW100,TD100,TL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>C</term>
                <term>CX100,CB100,CW100,CD100,CL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>D</term>
                <term>DX100,DB100,DW100,DD100,DL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>SX100,SB100,SW100,SD100,SL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Q</term>
                <term>QX100,QB100,QW100,QD100,QL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>I</term>
                <term>IX100,IB100,IW100,ID100,IL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>N</term>
                <term>NX100,NB100,NW100,ND100,NL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>U</term>
                <term>UX100,UB100,UW100,UD100,UL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Z</term>
                <term>ZX100,ZB100,ZW100,ZD100,ZL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>R</term>
                <term>RX100,RB100,RW100,RD100,RL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a Default object
            </summary>
            <param name="ipAddress">Ip Address</param>
            <param name="port">Ip port</param>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Station">
            <summary>
            PLC Station No.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadByte(System.String)">
            <summary>
            Read single byte value from plc
            </summary>
            <param name="address">Start address</param>
            <returns>result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Byte)">
            <summary>
            Write single byte value to plc
            </summary>
            <param name="address">Start address</param>
            <param name="value">value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadByteAsync(System.String)">
            <summary>
            Read single byte value from plc
            </summary>
            <param name="address">Start address</param>
            <returns>read result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.WriteAsync(System.String,System.Byte)">
            <summary>
            Write single byte value to plc
            </summary>
            <param name="address">Start address</param>
            <param name="value">value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String)">
            <summary>
            ReadCoil, same as ReadBool
            </summary>
            <param name="address">address, for example: MX100, PX100</param>
            <returns>Result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String,System.UInt16)">
            <summary>
            ReadCoil, same as ReadBool
            </summary>
            <param name="address">address, for example: MX100, PX100</param>
            <param name="length">array length</param>
            <returns>result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.WriteCoil(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address">Start Address</param>
            <param name="value">value for write</param>
            <returns>whether write is success</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoilAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoilAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.WriteCoilAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.WriteCoil(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Read(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.Helper.XGBCnetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Int32,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Read(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.XGBFastEnet">
            <summary>
            XGB Fast Enet I/F module supports open Ethernet. It provides network configuration that is to connect LSIS and other company PLC, PC on network
            </summary>
            <remarks>
            Address example likes the follow
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>*</term>
                <term>P</term>
                <term>PX100,PB100,PW100,PD100,PL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>M</term>
                <term>MX100,MB100,MW100,MD100,ML100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>L</term>
                <term>LX100,LB100,LW100,LD100,LL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>K</term>
                <term>KX100,KB100,KW100,KD100,KL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>F</term>
                <term>FX100,FB100,FW100,FD100,FL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>T</term>
                <term>TX100,TB100,TW100,TD100,TL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>C</term>
                <term>CX100,CB100,CW100,CD100,CL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>D</term>
                <term>DX100,DB100,DW100,DD100,DL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>SX100,SB100,SW100,SD100,SL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Q</term>
                <term>QX100,QB100,QW100,QD100,QL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>I</term>
                <term>IX100,IB100,IW100,ID100,IL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>N</term>
                <term>NX100,NB100,NW100,ND100,NL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>U</term>
                <term>UX100,UB100,UW100,UD100,UL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Z</term>
                <term>ZX100,ZB100,ZW100,ZD100,ZL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>R</term>
                <term>RX100,RB100,RW100,RD100,RL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a object by ipaddress and port
            </summary>
            <param name="ipAddress">the ip address of the plc</param>
            <param name="port">the port of the plc, default is 2004</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.#ctor(System.String,System.String,System.Int32,System.Byte)">
            <summary>
            Instantiate a object by ipaddress, port, cpuType, slotNo
            </summary>
            <param name="CpuType">CpuType</param>
            <param name="ipAddress">the ip address of the plc</param>
            <param name="port">he port of the plc, default is 2004</param>
            <param name="slotNo">slot number</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.SetCpuType">
            <summary>
            set plc
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.CpuType">
            <summary>
            CPU TYPE
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.CpuError">
            <summary>
            Cpu is error
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.LSCpuStatus">
            <summary>
            RUN, STOP, ERROR, DEBUG
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.BaseNo">
            <summary>
            FEnet I/F module’s Base No.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.SlotNo">
            <summary>
            FEnet I/F module’s Slot No.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.CpuInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.CompanyID">
            <summary>
            
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadBool(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadCoil(System.String)">
            <summary>
            ReadCoil
            </summary>
            <param name="address">Start address</param>
            <returns>Whether to read the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadCoil(System.String,System.UInt16)">
            <summary>
            ReadCoil
            </summary>
            <param name="address">Start address</param>
            <param name="length">read address length</param>
            <returns>Whether to read the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadByte(System.String)">
            <summary>
            Read single byte value from plc
            </summary>
            <param name="address">Start address</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte)">
            <summary>
            Write single byte value to plc
            </summary>
            <param name="address">Start address</param>
            <param name="value">value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.WriteCoil(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address">Start address</param>
            <param name="value">bool value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address">Start address</param>
            <param name="value">bool value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadBoolAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadCoilAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadCoilAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.WriteCoilAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.WriteCoil(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.CalculateAddressStarted(System.String,System.Boolean)">
            <summary>
            需要传入 MX100.2 的 100.2 部分，返回的是
            AnalysisAddress IX0.0.0 QX0.0.0  MW1.0  MB1.0
            </summary>
            <param name="address">start address</param>
            <param name="QI">is Q or I data</param>
            <returns>int address</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.IsHex(System.String)">
            <summary>
            NumberStyles HexNumber
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.XGBFastEnet.AddressTypes">
            <summary>
            所有支持的地址信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.AnalysisAddress(System.String,System.Boolean)">
            <summary>
            AnalysisAddress
            </summary>
            <param name="address">start address</param>
            <param name="IsReadWrite">is read or write operate</param>
            <returns>analysis result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.GetDataTypeToAddress(System.String)">
            <summary>
            Get DataType to Address
            </summary>
            <param name="address">address</param>
            <returns>dataType</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.BuildReadIndividualCommand(System.Byte,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.BuildReadIndividualCommand(System.Byte,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.BuildReadIndividualCommand(System.Byte,System.String[])">
            <summary>
            Multi reading address Type of Read Individual
            </summary>
            <param name="dataType">dataType bit:0x04, byte:0x01, word:0x02, dword:0x03, lword:0x04, continuous:0x14</param>
            <param name="addresses">address, for example: MX100, PX100</param>
            <returns>Read Individual Command</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ExtractActualData(System.Byte[])">
            <summary>
            Returns true data content, supports read and write returns
            </summary>
            <param name="response">response data</param>
            <returns>real data</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.GetErrorDesciption(System.Byte)">
            <summary>
            get the description of the error code meanning
            </summary>
            <param name="code">code value</param>
            <returns>string information</returns>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.XGKCnet">
            <summary>
            XGk Cnet I/F module supports Serial Port.
            </summary>
            <remarks>
            XGB 主机的通道 0 仅支持 1:1 通信。 对于具有主从格式的 1:N 系统，在连接 XGL-C41A 模块的通道 1 或 XGB 主机中使用 RS-485 通信。 XGL-C41A 模块支持 RS-422/485 协议。
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKCnet.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.WriteCoil(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGKCnet.WriteCoil(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.Read(HslCommunication.Profinet.LSIS.XGT_DataType,System.Collections.Generic.List{HslCommunication.Profinet.LSIS.XGTAddressData},HslCommunication.Profinet.LSIS.XGT_MemoryType,System.Int32)">
            <summary>
            Read
            </summary>
            <param name="pDataType"></param>
            <param name="pAddress"></param>
            <param name="pMemtype"></param>
            <param name="pDataCount"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.Write(HslCommunication.Profinet.LSIS.XGT_DataType,System.Collections.Generic.List{HslCommunication.Profinet.LSIS.XGTAddressData},HslCommunication.Profinet.LSIS.XGT_MemoryType,System.Int32)">
            <summary>
            Write
            </summary>
            <param name="pDataType"></param>
            <param name="pAddressList"></param>
            <param name="pMemtype"></param>
            <param name="pDataCount"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            Extract actual data form plc response
            </summary>
            <param name="response">response data</param>
            <param name="isRead">read</param>
            <returns>result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKCnet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.XGKFastEnet">
            <summary>
            XGK Fast Enet I/F module supports open Ethernet. It provides network configuration that is to connect LSIS and other company PLC, PC on network
            </summary>
            <remarks>
            Address example likes the follow
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>*</term>
                <term>P</term>
                <term>PX100,PB100,PW100,PD100,PL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>M</term>
                <term>MX100,MB100,MW100,MD100,ML100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>L</term>
                <term>LX100,LB100,LW100,LD100,LL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>K</term>
                <term>KX100,KB100,KW100,KD100,KL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>F</term>
                <term>FX100,FB100,FW100,FD100,FL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>T</term>
                <term>TX100,TB100,TW100,TD100,TL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>C</term>
                <term>CX100,CB100,CW100,CD100,CL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>D</term>
                <term>DX100,DB100,DW100,DD100,DL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>SX100,SB100,SW100,SD100,SL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Q</term>
                <term>QX100,QB100,QW100,QD100,QL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>I</term>
                <term>IX100,IB100,IW100,ID100,IL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>N</term>
                <term>NX100,NB100,NW100,ND100,NL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>U</term>
                <term>UX100,UB100,UW100,UD100,UL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Z</term>
                <term>ZX100,ZB100,ZW100,ZD100,ZL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>R</term>
                <term>RX100,RB100,RW100,RD100,RL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a object by ipaddress and port
            </summary>
            <param name="ipAddress">the ip address of the plc</param>
            <param name="port">the port of the plc, default is 2004</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.#ctor(System.String,System.String,System.Int32,System.Byte)">
            <summary>
            Instantiate a object by ipaddress, port, cpuType, slotNo
            </summary>
            <param name="CpuType">CpuType</param>
            <param name="ipAddress">the ip address of the plc</param>
            <param name="port">he port of the plc, default is 2004</param>
            <param name="slotNo">slot number</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKFastEnet.SetCpuType">
            <summary>
            set plc
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKFastEnet.CpuType">
            <summary>
            CPU TYPE
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKFastEnet.CpuError">
            <summary>
            Cpu is error
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKFastEnet.LSCpuStatus">
            <summary>
            RUN, STOP, ERROR, DEBUG
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKFastEnet.BaseNo">
            <summary>
            FEnet I/F module’s Base No.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKFastEnet.SlotNo">
            <summary>
            FEnet I/F module’s Slot No.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKFastEnet.CpuInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGKFastEnet.CompanyID">
            <summary>
            
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadCoilAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadCoilAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGKFastEnet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.WriteCoilAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGKFastEnet.WriteCoil(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGKFastEnet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadCoil(System.String)">
            <summary>
            ReadCoil
            </summary>
            <param name="address">Start address</param>
            <returns>Whether to read the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadCoil(System.String,System.UInt16)">
            <summary>
            ReadCoil
            </summary>
            <param name="address">Start address</param>
            <param name="length">read address length</param>
            <returns>Whether to read the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ReadByte(System.String)">
            <summary>
            Read single byte value from plc
            </summary>
            <param name="address">Start address</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.Write(System.String,System.Byte)">
            <summary>
            Write single byte value to plc
            </summary>
            <param name="address">Start address</param>
            <param name="value">value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.WriteCoil(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address">Start address</param>
            <param name="value">bool value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.Write(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address">Start address</param>
            <param name="value">bool value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.Read(HslCommunication.Profinet.LSIS.XGT_DataType,System.Collections.Generic.List{HslCommunication.Profinet.LSIS.XGTAddressData},HslCommunication.Profinet.LSIS.XGT_MemoryType,System.Int32,System.Int32)">
            <summary>
            Read
            </summary>
            <param name="pDataType"></param>
            <param name="pAddress"></param>
            <param name="pMemtype"></param>
            <param name="pInvokeID"></param>
            <param name="pDataCount"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.Write(HslCommunication.Profinet.LSIS.XGT_DataType,System.Collections.Generic.List{HslCommunication.Profinet.LSIS.XGTAddressData},HslCommunication.Profinet.LSIS.XGT_MemoryType,System.Int32,System.Int32)">
            <summary>
            Write
            </summary>
            <param name="pDataType"></param>
            <param name="pAddressList"></param>
            <param name="pMemtype"></param>
            <param name="pInvokeID"></param>
            <param name="pDataCount"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.CreateHeader(System.Int32,System.Int32)">
            <summary>
            CreateHeader
            </summary>
            <param name="pInvokeID"></param>
            <param name="pDataByteLenth"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.CreateValueName(HslCommunication.Profinet.LSIS.XGT_DataType,HslCommunication.Profinet.LSIS.XGT_MemoryType,System.String)">
             <summary>
            Create a memory address variable name.
             </summary>
             <param name="dataType">데이터타입</param>
             <param name="memType">메모리타입</param>
             <param name="pAddress">주소번지</param>
             <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.GetTypeChar(HslCommunication.Profinet.LSIS.XGT_DataType)">
            <summary>
            Char return according to data type
            </summary>
            <param name="type">데이터타입</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.GetMemTypeChar(HslCommunication.Profinet.LSIS.XGT_MemoryType)">
            <summary>
            Char return according to memory type
            </summary>
            <param name="type">메모리타입</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.AddByte(System.Byte[],System.Int32@,System.Byte[]@)">
            <summary>
            바이트 합치기
            </summary>
            <param name="item">개별바이트</param>
            <param name="idx">전체바이트에 개별바이트를 합칠 인덱스</param>
            <param name="header">전체바이트</param>
            <returns>전체 바이트 </returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.AnalysisAddress(System.String)">
            <summary>
            AnalysisAddress XGT_MemoryType
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.GetDataTypeToAddress(System.String)">
            <summary>
            GetDataTypeToAddress
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ExtractActualData(System.Byte[])">
            <summary>
            Returns true data content, supports read and write returns
            </summary>
            <param name="response">response data</param>
            <returns>real data</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.GetCpuTypeToPLC(System.Byte[])">
            <summary>
            SetCpuType
            </summary>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ExtractActualDataBool(System.Byte[])">
            <summary>
            Returns true data content, supports read and write returns
            </summary>
            <param name="response">response data</param>
            <returns>real data</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ExtractActualDatabyte(System.Byte[])">
            <summary>
            Returns true data content, supports read and write returns
            </summary>
            <param name="response">response data</param>
            <returns>real data</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.GetErrorDesciption(System.Byte)">
            <summary>
            get the description of the error code meanning
            </summary>
            <param name="code">code value</param>
            <returns>string information</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGKFastEnet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C">
            <summary>
            三菱的A3C协议类接口对象，具有站号，是否和校验的属性<br />
            Mitsubishi's A3C protocol interface object, which has the attributes of station number, and checksum
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Station">
            <summary>
            当前A3C协议的站编号信息<br />
            Station number information of the current A3C protocol
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.SumCheck">
            <summary>
            当前的A3C协议是否使用和校验，默认使用<br />
            Whether the current A3C protocol uses sum check, it is used by default
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Format">
            <summary>
            当前的A3C协议的格式信息，可选格式1，2，3，4，默认格式1<br />
            Format information of the current A3C protocol, optional format 1, 2, 3, 4, default format 1
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks">
            <summary>
            三菱的FxLink协议接口的设备信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks.Station">
            <summary>
            PLC的当前的站号，需要根据实际的值来设定，默认是0<br />
            The current station number of the PLC needs to be set according to the actual value. The default is 0.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks.WaittingTime">
            <summary>
            报文等待时间，单位10ms，设置范围为0-15<br />
            Message waiting time, unit is 10ms, setting range is 0-15
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks.SumCheck">
            <summary>
            是否启动和校验<br />
            Whether to start and sum verify
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks.Format">
            <summary>
            当前的PLC的Fxlinks协议格式，通常是格式1，或是格式4，所以此处可以设置1，或者是4<br />
            The current PLC Fxlinks protocol format is usually format 1 or format 4, so it can be set to 1 or 4 here
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc">
            <summary>
            基于MC协议的标准的设备接口，适用任何基于MC协议的PLC设备，主要是三菱，基恩士，松下的PLC设备。<br />
            The standard equipment interface based on MC protocol is suitable for any PLC equipment based on MC protocol, 
            mainly PLC equipment from Mitsubishi, Keyence, and Panasonic.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.NetworkNumber">
            <summary>
            网络号，通常为0<br />
            Network number, usually 0
            </summary>
            <remarks>
            依据PLC的配置而配置，如果PLC配置了1，那么此处也填0，如果PLC配置了2，此处就填2，测试不通的话，继续测试0
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.NetworkStationNumber">
            <summary>
            网络站号，通常为0<br />
            Network station number, usually 0
            </summary>
            <remarks>
            依据PLC的配置而配置，如果PLC配置了1，那么此处也填0，如果PLC配置了2，此处就填2，测试不通的话，继续测试0
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McAnalysisAddress(System.String,System.UInt16)">
            <summary>
            当前MC协议的分析地址的方法，对传入的字符串格式的地址进行数据解析。<br />
            The current MC protocol's address analysis method performs data parsing on the address of the incoming string format.
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>解析后的数据信息</returns>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McType">
            <summary>
            当前的MC协议的格式类型<br />
            The format type of the current MC protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.McType">
            <summary>
            MC协议的类型
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.Helper.McType.McBinary">
            <summary>
            基于二进制的MC协议
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.Helper.McType.MCAscii">
            <summary>
            基于ASCII格式的MC协议
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.Helper.McType.McRBinary">
            <summary>
            基于R系列的二进制的MC协议
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.Helper.McType.McRAscii">
            <summary>
            基于R系列的ASCII格式的MC协议
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper">
            <summary>
            基于MC协议的ASCII格式的辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.PackMcCommand(System.Byte[],System.Byte,System.Byte)">
            <summary>
            将MC协议的核心报文打包成一个可以直接对PLC进行发送的原始报文
            </summary>
            <param name="mcCore">MC协议的核心报文</param>
            <param name="networkNumber">网络号</param>
            <param name="networkStationNumber">网络站号</param>
            <returns>原始报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.ExtractActualDataHelper(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.CheckResponseContent(System.Byte[])">
            <summary>
            检查反馈的内容是否正确的
            </summary>
            <param name="content">MC的反馈的内容</param>
            <returns>是否正确</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.BuildAsciiReadMcCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean)">
            <summary>
            从三菱地址，是否位读取进行创建读取Ascii格式的MC的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="isBit">是否进行了位读取操作</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.BuildAsciiReadMcCoreExtendCommand(HslCommunication.Core.Address.McAddressData,System.UInt16,System.Boolean)">
            <summary>
            从三菱扩展地址，是否位读取进行创建读取的MC的核心报文
            </summary>
            <param name="isBit">是否进行了位读取操作</param>
            <param name="extend">扩展指定</param>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.BuildAsciiWriteWordCoreCommand(HslCommunication.Core.Address.McAddressData,System.Byte[])">
            <summary>
            以字为单位，创建ASCII数据写入的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="value">实际的原始数据信息</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.BuildAsciiWriteBitCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean[])">
            <summary>
            以位为单位，创建ASCII数据写入的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="value">原始的bool数组数据</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.BuildAsciiReadRandomWordCommand(HslCommunication.Core.Address.McAddressData[])">
            <summary>
            按字为单位随机读取的指令创建
            </summary>
            <param name="address">地址数组</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.BuildAsciiReadRandomCommand(HslCommunication.Core.Address.McAddressData[])">
            <summary>
            随机读取的指令创建
            </summary>
            <param name="address">地址数组</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.BuildAsciiReadMemoryCommand(System.String,System.UInt16)">
            <inheritdoc  cref="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadMemoryCommand(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McAsciiHelper.BuildAsciiReadSmartModule(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadSmartModule(System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper">
            <summary>
            三菱PLC，二进制的辅助类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.PackMcCommand(System.Byte[],System.Byte,System.Byte)">
            <summary>
            将MC协议的核心报文打包成一个可以直接对PLC进行发送的原始报文
            </summary>
            <param name="mcCore">MC协议的核心报文</param>
            <param name="networkNumber">网络号</param>
            <param name="networkStationNumber">网络站号</param>
            <returns>原始报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.CheckResponseContentHelper(System.Byte[])">
            <summary>
            检查从MC返回的数据是否是合法的。
            </summary>
            <param name="content">数据内容</param>
            <returns>是否合法</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadMcCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean)">
            <summary>
            从三菱地址，是否位读取进行创建读取的MC的核心报文<br />
            From the Mitsubishi address, whether to read the core message of the MC for creating and reading
            </summary>
            <param name="isBit">是否进行了位读取操作</param>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildWriteWordCoreCommand(HslCommunication.Core.Address.McAddressData,System.Byte[])">
            <summary>
            以字为单位，创建数据写入的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="value">实际的原始数据信息</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildWriteBitCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean[])">
            <summary>
            以位为单位，创建数据写入的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="value">原始的bool数组数据</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadMcCoreExtendCommand(HslCommunication.Core.Address.McAddressData,System.UInt16,System.Boolean)">
            <summary>
            从三菱扩展地址，是否位读取进行创建读取的MC的核心报文
            </summary>
            <param name="isBit">是否进行了位读取操作</param>
            <param name="extend">扩展指定</param>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadRandomWordCommand(HslCommunication.Core.Address.McAddressData[])">
            <summary>
            按字为单位随机读取的指令创建
            </summary>
            <param name="address">地址数组</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadRandomCommand(HslCommunication.Core.Address.McAddressData[])">
            <summary>
            随机读取的指令创建
            </summary>
            <param name="address">地址数组</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadTag(System.String[],System.UInt16[])">
            <summary>
            创建批量读取标签的报文数据信息
            </summary>
            <param name="tags">标签名</param>
            <param name="lengths">长度信息</param>
            <returns>报文名称</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadMemoryCommand(System.String,System.UInt16)">
            <summary>
            读取本站缓冲寄存器的数据信息，需要指定寄存器的地址，和读取的长度
            </summary>
            <param name="address">寄存器的地址</param>
            <param name="length">数据长度</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.BuildReadSmartModule(System.UInt16,System.String,System.UInt16)">
            <summary>
            构建读取智能模块的命令，需要指定模块编号，起始地址，读取的长度，注意，该长度以字节为单位。
            </summary>
            <param name="module">模块编号</param>
            <param name="address">智能模块的起始地址</param>
            <param name="length">读取的字长度</param>
            <returns>报文的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.ExtraTagData(System.Byte[])">
            <summary>
            解析出标签读取的数据内容
            </summary>
            <param name="content">返回的数据信息</param>
            <returns>解析结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.ExtractActualDataHelper(System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.ExtractActualData(System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.ReadTags(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])">
            <summary>
            <b>[商业授权]</b> 读取PLC的标签信息，需要传入标签的名称，读取的字长度，标签举例：A; label[1]; bbb[10,10,10]<br />
            <b>[Authorization]</b> To read the label information of the PLC, you need to pass in the name of the label, 
            the length of the word read, and an example of the label: A; label [1]; bbb [10,10,10]
            </summary>
            <param name="mc">MC协议通信对象</param>
            <param name="tags">标签名</param>
            <param name="length">读取长度</param>
            <returns>是否成功</returns>
            <remarks>
             不可以访问局部标签。<br />
             不可以访问通过GX Works2设置的全局标签。<br />
             为了访问全局标签，需要通过GX Works3的全局标签设置编辑器将“来自于外部设备的访问”的设置项目置为有效。(默认为无效。)<br />
             以ASCII代码进行数据通信时，由于需要从UTF-16将标签名转换为ASCII代码，因此报文容量将增加
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.ReadTagsAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.ReadTags(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])"/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.McHelper">
            <summary>
            MC协议的辅助类对象，提供了MC协议的读写操作的基本支持
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.GetReadWordLength(HslCommunication.Profinet.Melsec.Helper.McType)">
            <summary>
            返回按照字单位读取的最低的长度信息
            </summary>
            <param name="type">MC协议的类型</param>
            <returns>长度信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.GetReadBoolLength(HslCommunication.Profinet.Melsec.Helper.McType)">
            <summary>
            返回按照位单位读取的最低的长度信息
            </summary>
            <param name="type">MC协议的类型</param>
            <returns>长度信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
            <remarks>
            初步支持普通的数据地址之外，还额外支持高级的地址写法，以下是示例（适用于MC协议为二进制和ASCII格式）：<br />
            [商业授权] 扩展的数据地址: 表示为 ext=1;W100  访问扩展区域为1的W100的地址信息<br />
            [商业授权] 缓冲存储器地址: 表示为 mem=32  访问地址为32的本站缓冲存储器地址<br />
            [商业授权] 智能模块地址：表示为 module=3;4106  访问模块号3，偏移地址是4106的数据，偏移地址需要根据模块的详细信息来确认。<br />
            [商业授权] 基于标签的地址: 表示位 s=AAA  假如标签的名称为AAA，但是标签的读取是有条件的，详细参照<see cref="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.ReadTags(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])"/><br />
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
            <remarks>
            对于X,Y类型的地址，有两种表示方式，十六进制和八进制，默认16进制，比如输入 X10 是16进制的，如果想要输入8进制的地址，地址补0操作，例如 X010
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
            <remarks>
            当读取的长度过大时，会自动进行切割，对于二进制格式，切割长度为7168，对于ASCII格式协议来说，切割长度则是3584<br />
            对于X,Y类型的地址，有两种表示方式，十六进制和八进制，默认16进制，比如输入 X10 是16进制的，如果想要输入8进制的地址，地址补0操作，例如 X010
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
            <remarks>
            当读取的长度过大时，会自动进行切割，对于二进制格式，切割长度为7168，对于ASCII格式协议来说，切割长度则是3584<br />
            对于X,Y类型的地址，有两种表示方式，十六进制和八进制，默认16进制，比如输入 X10 是16进制的，如果想要输入8进制的地址，地址补0操作，例如 X010
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.WriteAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBoolAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.WriteAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])">
            <summary>
            随机读取PLC的数据信息，可以跨地址，跨类型组合，但是每个地址只能读取一个word，也就是2个字节的内容。收到结果后，需要自行解析数据<br />
            Randomly read PLC data information, which can be combined across addresses and types, but each address can only read one word, 
            which is the content of 2 bytes. After receiving the results, you need to parse the data yourself
            </summary>
            <param name="mc">MC协议通信对象</param>
            <param name="address">所有的地址的集合</param>
            <remarks>
            访问安装有 Q 系列 C24/E71 的站 QCPU 上位站 经由 Q 系列兼容网络系统 MELSECNET/H MELSECNET/10 Ethernet 的 QCPU 其他站 时
            访问点数········1≦ 字访问点数 双字访问点数 ≦192
            <br />
            访问 QnACPU 其他站 经由 QnA 系列兼容网络系统 MELSECNET/10 Ethernet 的 Q/QnACPU 其他站 时访问点数········1≦ 字访问点数 双字访问点数 ≦96
            <br />
            访问上述以外的 PLC CPU 其他站 时访问点数········1≦字访问点数≦10
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample3" title="随机字读取示例" /></example>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])">
            <summary>
            随机读取PLC的数据信息，可以跨地址，跨类型组合，每个地址是任意的长度。收到结果后，需要自行解析数据，目前只支持字地址，比如D区，W区，R区，不支持X，Y，M，B，L等等<br />
            Read the data information of the PLC randomly. It can be combined across addresses and types. Each address is of any length. After receiving the results, 
            you need to parse the data yourself. Currently, only word addresses are supported, such as D area, W area, R area. X, Y, M, B, L, etc
            </summary>
            <param name="mc">MC协议通信对象</param>
            <param name="address">所有的地址的集合</param>
            <param name="length">每个地址的长度信息</param>
            <remarks>
            实际测试不一定所有的plc都可以读取成功，具体情况需要具体分析
            <br />
            1 块数按照下列要求指定 120 ≧ 字软元件块数 + 位软元件块数
            <br />
            2 各软元件点数按照下列要求指定 960 ≧ 字软元件各块的合计点数 + 位软元件各块的合计点数
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample4" title="随机批量字读取示例" />
            </example>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])">
            <summary>
            随机读取PLC的数据信息，可以跨地址，跨类型组合，但是每个地址只能读取一个word，也就是2个字节的内容。收到结果后，自动转换为了short类型的数组<br />
            Randomly read PLC data information, which can be combined across addresses and types, but each address can only read one word, 
            which is the content of 2 bytes. After receiving the result, it is automatically converted to an array of type short.
            </summary>
            <param name="mc">MC协议的通信对象</param>
            <param name="address">所有的地址的集合</param>
            <remarks>
            访问安装有 Q 系列 C24/E71 的站 QCPU 上位站 经由 Q 系列兼容网络系统 MELSECNET/H MELSECNET/10 Ethernet 的 QCPU 其他站 时
            访问点数········1≦ 字访问点数 双字访问点数 ≦192
            
            访问 QnACPU 其他站 经由 QnA 系列兼容网络系统 MELSECNET/10 Ethernet 的 Q/QnACPU 其他站 时访问点数········1≦ 字访问点数 双字访问点数 ≦96
            
            访问上述以外的 PLC CPU 其他站 时访问点数········1≦字访问点数≦10
            </remarks>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomUInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])">
            <summary>
            随机读取PLC的数据信息，可以跨地址，跨类型组合，但是每个地址只能读取一个word，也就是2个字节的内容。收到结果后，自动转换为了ushort类型的数组<br />
            Randomly read PLC data information, which can be combined across addresses and types, but each address can only read one word, 
            which is the content of 2 bytes. After receiving the result, it is automatically converted to an array of type ushort.
            </summary>
            <param name="mc">MC协议的通信对象</param>
            <param name="address">所有的地址的集合</param>
            <remarks>
            访问安装有 Q 系列 C24/E71 的站 QCPU 上位站 经由 Q 系列兼容网络系统 MELSECNET/H MELSECNET/10 Ethernet 的 QCPU 其他站 时
            访问点数········1≦ 字访问点数 双字访问点数 ≦192
            
            访问 QnACPU 其他站 经由 QnA 系列兼容网络系统 MELSECNET/10 Ethernet 的 Q/QnACPU 其他站 时访问点数········1≦ 字访问点数 双字访问点数 ≦96
            
            访问上述以外的 PLC CPU 其他站 时访问点数········1≦字访问点数≦10
            </remarks>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomInt16Async(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomUInt16Async(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomUInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadMemory(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)">
            <summary>
            <b>[商业授权]</b> 读取缓冲寄存器的数据信息，地址直接为偏移地址<br />
            <b>[Authorization]</b> Read the data information of the buffer register, the address is directly the offset address
            </summary>
            <remarks>
            本指令不可以访问下述缓冲存储器:<br />
            1. 本站(SLMP对应设备)上安装的智能功能模块<br />
            2. 其它站缓冲存储器<br />
            </remarks>
            <param name="mc">MC通信对象</param>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>读取的内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadMemoryAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadMemory(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadSmartModule(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)">
            <summary>
            <b>[商业授权]</b> 读取智能模块的数据信息，需要指定模块地址，偏移地址，读取的字节长度<br />
            <b>[Authorization]</b> To read the extended data information, you need to enter the extended value information in addition to the original address and length information
            </summary>
            <param name="mc">MC通信对象</param>
            <param name="module">模块地址</param>
            <param name="address">地址</param>
            <param name="length">数据长度</param>
            <returns>返回结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadSmartModuleAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadSmartModule(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadExtend(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)">
            <summary>
            <b>[商业授权]</b> 读取扩展的数据信息，需要在原有的地址，长度信息之外，输入扩展值信息<br />
            <b>[Authorization]</b> To read the extended data information, you need to enter the extended value information in addition to the original address and length information
            </summary>
            <param name="mc">MC通信对象</param>
            <param name="extend">扩展信息</param>
            <param name="address">地址</param>
            <param name="length">数据长度</param>
            <returns>返回结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadExtendAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadExtend(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <summary>
            远程Run操作<br />
            Remote Run Operation
            </summary>
            <param name="mc">MC协议通信对象</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <summary>
            远程Stop操作<br />
            Remote Stop operation
            </summary>
            <param name="mc">MC协议通信对象</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <summary>
            远程Reset操作<br />
            Remote Reset Operation
            </summary>
            <param name="mc">MC协议通信对象</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <summary>
            读取PLC的型号信息，例如 Q02HCPU<br />
            Read PLC model information, such as Q02HCPU
            </summary>
            <param name="mc">MC协议通信对象</param>
            <returns>返回型号的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ErrorStateReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <summary>
            LED 熄灭 出错代码初始化<br />
            LED off Error code initialization
            </summary>
            <param name="mc">MC协议通信对象</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteRunAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteStopAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteResetAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadPlcTypeAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ErrorStateResetAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ErrorStateReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper">
            <summary>
            MelsecA3CNet1协议通信的辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.PackCommand(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.Byte[],System.Byte)">
            <summary>
            将命令进行打包传送，可选站号及是否和校验机制
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <param name="mcCommand">mc协议的命令</param>
            <param name="station">PLC的站号</param>
            <returns>最终的原始报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ExtraReadActualResponse(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.Byte[])">
            <summary>
            根据PLC返回的数据信息，获取到实际的数据内容
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <param name="response">PLC返回的数据信息</param>
            <returns>带有是否成功的读取结果对象内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.WriteAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadBoolAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.WriteAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)">
            <summary>
            远程Run操作
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)">
            <summary>
            远程Stop操作
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)">
            <summary>
            读取PLC的型号信息
            </summary>
            <param name="plc">PLC设备通信对象</param>
            <returns>返回型号的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteRunAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteStopAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadPlcTypeAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper">
            <summary>
            三菱的FxLinks的辅助方法信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.PackCommandWithHeader(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.Byte[])">
            <summary>
            将当前的报文进行打包，根据和校验的方式以及格式信息来实现打包操作
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="command">原始的命令数据</param>
            <returns>打包后的命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean,System.Byte)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBool">是否位读取</param>
            <param name="waitTime">等待时间</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.BuildWriteBoolCommand(System.Byte,System.String,System.Boolean[],System.Byte)">
            <summary>
            创建一条别入bool数据的指令信息，需要指定一些参数
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.BuildWriteByteCommand(System.Byte,System.String,System.Byte[],System.Byte)">
            <summary>
            创建一条别入byte数据的指令信息，需要指定一些参数，按照字单位
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <param name="waitTime">等待时间</param>
            <returns>命令报文的结果内容对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.BuildStart(System.Byte,System.Byte)">
            <summary>
            创建启动PLC的报文信息
            </summary>
            <param name="station">站号信息</param>
            <param name="waitTime">等待时间</param>
            <returns>命令报文的结果内容对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.BuildStop(System.Byte,System.Byte)">
            <summary>
            创建启动PLC的报文信息
            </summary>
            <param name="station">站号信息</param>
            <param name="waitTime">等待时间</param>
            <returns>命令报文的结果内容对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.BuildReadPlcType(System.Byte,System.Byte)">
            <summary>
            创建读取PLC类型的命令报文
            </summary>
            <param name="station">站号信息</param>
            <param name="waitTime">等待实际</param>
            <returns>命令报文的结果内容对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.GetPlcTypeFromCode(System.String)">
            <summary>
            从编码中提取PLC的型号信息
            </summary>
            <param name="code">编码</param>
            <returns>PLC的型号信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.CheckPlcResponse(System.Byte[])">
            <summary>
            检查PLC的消息反馈是否合法，合法则提取当前的数据信息，当时写入的命令消息时，无任何的数据返回<br />
            Check whether the PLC's message feedback is legal. If it is legal, extract the current data information. When the command message is written at that time, no data is returned.
            </summary>
            <param name="response">从PLC反馈的数据消息</param>
            <returns>检查的结果消息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认，地址支持动态指定站号，例如：s=2;D100<br />
            Read PLC data in batches, in units of words, supports reading X, Y, M, S, D, T, C. 
            The specific address range needs to be confirmed according to the PLC model, 
            The address supports dynamically specifying the station number, for example: s=2;D100
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认，地址支持动态指定站号，例如：s=2;D100<br />
            The data written to the PLC in batches is in units of words, that is, at least 2 bytes of information. 
            It supports X, Y, M, S, D, T, and C. The specific address range needs to be confirmed according to the PLC model, 
            The address supports dynamically specifying the station number, for example: s=2;D100
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.WriteAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型，地址支持动态指定站号，例如：s=2;D100<br />
            Read bool data in batches. The supported types are X, Y, S, T, C. The specific address range depends on the type of PLC, 
            The address supports dynamically specifying the station number, for example: s=2;D100
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型，地址支持动态指定站号，例如：s=2;D100<br />
            Write arrays of type bool in batches. The supported types are X, Y, S, T, C. The specific address range depends on the type of PLC, 
            The address supports dynamically specifying the station number, for example: s=2;D100
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadBoolAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.WriteAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.StartPLC(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)">
            <summary>
            <b>[商业授权]</b> 启动PLC的操作，可以携带额外的参数信息，指定站号。举例：s=2; 注意：分号是必须的。<br />
            <b>[Authorization]</b> Start the PLC operation, you can carry additional parameter information and specify the station number. Example: s=2; Note: The semicolon is required.
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="parameter">允许携带的参数信息，例如s=2; 也可以为空</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.StopPLC(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)">
            <summary>
            <b>[商业授权]</b> 停止PLC的操作，可以携带额外的参数信息，指定站号。举例：s=2; 注意：分号是必须的。<br />
            <b>[Authorization]</b> Stop PLC operation, you can carry additional parameter information and specify the station number. Example: s=2; Note: The semicolon is required.
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="parameter">允许携带的参数信息，例如s=2; 也可以为空</param>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)">
            <summary>
            <b>[商业授权]</b> 读取PLC的型号信息，可以携带额外的参数信息，指定站号。举例：s=2; 注意：分号是必须的。<br />
            <b>[Authorization]</b> Read the PLC model information, you can carry additional parameter information, and specify the station number. Example: s=2; Note: The semicolon is required.
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="parameter">允许携带的参数信息，例如s=2; 也可以为空</param>
            <returns>带PLC型号的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.StartPLCAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.StartPLC(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.StopPLCAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.StopPLC(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadPlcTypeAsync(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)"/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper">
            <summary>
            三菱编程口协议的辅助方法，定义了如何读写bool数据，以及读写原始字节的数据。<br />
            The auxiliary method of Mitsubishi programming port protocol defines how to read and write bool data and read and write raw byte data.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Boolean)">
            <summary>
            根据指定的地址及长度信息从三菱PLC中读取原始的字节数据，根据PLC中实际定义的规则，可以解析出任何类的数据信息<br />
            Read the original byte data from the Mitsubishi PLC according to the specified address and length information. 
            According to the rules actually defined in the PLC, any type of data information can be parsed
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="address">读取地址，，支持的类型参考文档说明</param>
            <param name="length">读取的数据长度</param>
            <param name="isNewVersion">是否是新版的串口访问类</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Boolean)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果，该读取地址最好从0，16，32...等开始读取，这样可以读取比较长的数据数组<br />
            Read bit devices in batches from Mitsubishi PLC and return the read results. 
            The read address should preferably be read from 0, 16, 32... etc., so that a relatively long data array can be read
            </summary>
            <param name="plc">PLC的通信对象</param>
            <param name="address">起始地址</param>
            <param name="length">读取的长度</param>
            <param name="isNewVersion">是否是新版的串口访问类</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
             <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadBool" title="Bool类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[],System.Boolean)">
            <summary>
            根据指定的地址向PLC写入数据，数据格式为原始的字节类型<br />
            Write data to the PLC according to the specified address, the data format is the original byte type
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="address">初始地址，支持的类型参考文档说明</param>
            <param name="value">原始的字节数据</param>
            <param name="isNewVersion">是否是新版的串口访问类</param>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，写入如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="WriteExample2" title="Write示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="WriteExample1" title="Write示例" />
            </example>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean)">
            <summary>
            强制写入位数据的通断，支持的类型参考文档说明<br />
            The on-off of the forced write bit data, please refer to the document description for the supported types
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="address">地址信息</param>
            <param name="value">是否为通</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ActivePlc(HslCommunication.Core.IReadWriteDevice)">
            <summary>
            激活PLC的接收状态，需要再和PLC交互之前进行调用，之后就需要再调用了。<br />
            </summary>
            <param name="plc">PLC通信对象</param>
            <returns>是否激活成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ActivePlcAsync(HslCommunication.Core.IReadWriteDevice)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ActivePlc(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.CheckPlcReadResponse(System.Byte[])">
            <summary>
            检查PLC返回的读取数据是否是正常的
            </summary>
            <param name="ack">Plc反馈的数据信息</param>
            <returns>检查结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.CheckPlcWriteResponse(System.Byte[])">
            <summary>
            检查PLC返回的写入的数据是否是正常的
            </summary>
            <param name="ack">Plc反馈的数据信息</param>
            <returns>检查结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.BuildWriteBoolPacket(System.String,System.Boolean)">
            <summary>
            生成位写入的数据报文信息，该报文可直接用于发送串口给PLC
            </summary>
            <param name="address">地址信息，每个地址存在一定的范围，需要谨慎传入数据。举例：M10,S10,X5,Y10,C10,T10</param>
            <param name="value"><c>True</c>或是<c>False</c></param>
            <returns>带报文信息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.BuildReadWordCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isNewVersion">是否是新版的串口访问类</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.BuildReadBoolCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">bool数组长度</param>
            <param name="isNewVersion">是否是新版的串口访问类</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.BuildWriteWordCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">实际的数据信息</param>
            <param name="isNewVersion">是否是新版的串口访问类</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ExtractActualData(System.Byte[])">
            <summary>
            从PLC反馈的数据进行提炼操作
            </summary>
            <param name="response">PLC反馈的真实数据</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ExtractActualBoolData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从PLC反馈的数据进行提炼bool数组操作
            </summary>
            <param name="response">PLC反馈的真实数据</param>
            <param name="start">起始提取的点信息</param>
            <param name="length">bool数组的长度</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.FxAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的三菱地址类型
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.FxCalculateWordStartAddress(System.String,System.Boolean)">
            <summary>
            返回读取的地址及长度信息
            </summary>
            <param name="address">读取的地址信息</param>
            <param name="isNewVersion">是否是新版的串口访问类</param>
            <returns>带起始地址的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.FxCalculateBoolStartAddress(System.String,System.Boolean)">
            <summary>
            返回读取的地址及长度信息，以及当前的偏置信息
            </summary><param name="address">读取的地址信息</param>
            <param name="isNewVersion">是否是新版的串口访问类</param>
            <returns>带起始地址的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet">
            <summary>
            三菱PLC通讯协议，采用A兼容1E帧协议实现，使用ASCII码通讯，请根据实际型号来进行选取<br />
            Mitsubishi PLC communication protocol, implemented using A compatible 1E frame protocol, using ascii code communication, please choose according to the actual model
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecA1ENet" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口来来实例化一个默认的对象<br />
            Specify the IP address and port to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.PLCNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecA1ENet.PLCNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.BuildReadCommand(System.String,System.UInt16,System.Boolean,System.Byte)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isBit">指示是否按照位成批的读出</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.BuildWriteWordCommand(System.String,System.Byte[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.BuildWriteBoolCommand(System.String,System.Boolean[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.CheckResponseLegal(System.Byte[])">
            <summary>
            检测反馈的消息是否合法
            </summary>
            <param name="response">接收的报文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA1EDataType">
            <summary>
            三菱PLC的数据类型，此处包含了几个常用的类型
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EDataType.#ctor(System.UInt16,System.Byte,System.String,System.Int32)">
            <summary>
            如果您清楚类型代号，可以根据值进行扩展
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EDataType.DataCode">
            <summary>
            类型的代号值（软元件代码，用于区分软元件类型，如：D，R）
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.X">
            <summary>
            X输入寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.Y">
            <summary>
            Y输出寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.M">
            <summary>
            M中间寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.S">
            <summary>
            S状态寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.F">
            <summary>
            F报警器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.B">
            <summary>
            B连接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.TS">
            <summary>
            TS定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.TC">
            <summary>
            TC定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.TN">
            <summary>
            TN定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.CS">
            <summary>
            CS计数器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.CC">
            <summary>
            CC计数器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.CN">
            <summary>
            CN计数器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.D">
            <summary>
            D数据寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.W">
            <summary>
            W链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.R">
            <summary>
            R文件寄存器
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA1ENet">
            <summary>
            三菱PLC通讯协议，采用A兼容1E帧协议实现，使用二进制码通讯，请根据实际型号来进行选取<br />
            Mitsubishi PLC communication protocol, implemented using A compatible 1E frame protocol, using binary code communication, please choose according to the actual model
            </summary>
            <remarks>
            本类适用于的PLC列表
            <list type="number">
            <item>FX3U(C) PLC   测试人sandy_liao</item>
            </list>
            <note type="important">本通讯类由CKernal推送，感谢</note>
            </remarks>
            <example>
            数据地址支持的格式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>动态</term>
                <term>√</term>
                <term>√</term>
                <term>地址前面带0就是8进制比如X010，不带则是16进制，X40</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>动态</term>
                <term>√</term>
                <term>√</term>
                <term>地址前面带0就是8进制比如Y020，不带则是16进制，Y40</term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B1A0,B2A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器触点</term>
                <term>TS</term>
                <term>TS0,TS100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器线圈</term>
                <term>TC</term>
                <term>TC0,TC100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器当前值</term>
                <term>TN</term>
                <term>TN0,TN100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器器触点</term>
                <term>CS</term>
                <term>CS0,CS100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器线圈</term>
                <term>CC</term>
                <term>CC0,CC100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器当前值</term>
                <term>CN</term>
                <term>CN0,CN100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W0,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            <see cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String,System.UInt16)"/> 方法一次读取的最多点数是256点。
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口来来实例化一个默认的对象<br />
            Specify the IP address and port to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1ENet.PLCNumber">
            <summary>
            PLC编号，默认为0xFF<br />
            PLC number, default is 0xFF
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取<see cref="T:System.Boolean"/>数组信息，需要指定地址和长度，地址示例M100，S100，B1A，如果是X,Y, X017就是8进制地址，Y10就是16进制地址。<br />
            Batch read <see cref="T:System.Boolean"/> array information, need to specify the address and length, return <see cref="T:System.Boolean"/> array. 
            Examples of addresses M100, S100, B1A, if it is X, Y, X017 is an octal address, Y10 is a hexadecimal address.
            </summary>
            <remarks>
            根据协议的规范，最多读取256长度的bool数组信息，如果需要读取更长的bool信息，需要按字为单位进行读取的操作。
            </remarks>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否成功，地址示例M100，S100，B1A，如果是X,Y, X017就是8进制地址，Y10就是16进制地址。<br />
            Batch write <see cref="T:System.Boolean"/> array data, return whether the write was successful. 
            Examples of addresses M100, S100, B1A, if it is X, Y, X017 is an octal address, Y10 is a hexadecimal address.
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.BuildReadCommand(System.String,System.UInt16,System.Boolean,System.Byte)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isBit">指示是否按照位成批的读出</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.BuildWriteWordCommand(System.String,System.Byte[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.BuildWriteBoolCommand(System.String,System.Boolean[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.CheckResponseLegal(System.Byte[])">
            <summary>
            检测反馈的消息是否合法
            </summary>
            <param name="response">接收的报文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA3CNet">
            <summary>
            基于Qna 兼容3C帧的格式一的通讯，具体的地址需要参照三菱的基本地址<br />
            Based on Qna-compatible 3C frame format one communication, the specific address needs to refer to the basic address of Mitsubishi.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp" path="remarks"/>
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CNet.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Station"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CNet.SumCheck">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.SumCheck"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CNet.Format">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Format"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp">
            <summary>
            基于Qna 兼容3C帧的格式一的通讯，具体的地址需要参照三菱的基本地址，本类是基于tcp通讯的实现<br />
            Based on Qna-compatible 3C frame format one communication, the specific address needs to refer to the basic address of Mitsubishi. This class is based on TCP communication.
            </summary>
            <remarks>
            地址可以携带站号信息，例如：s=2;D100
            </remarks>
            <example>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
               <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>边沿继电器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>ZR文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR2A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的触点</term>
                <term>SS</term>
                <term>SS100,SS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的线圈</term>
                <term>SC</term>
                <term>SC100,SC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的当前值</term>
                <term>SN</term>
                <term>SN100,SN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前值</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.#ctor">
            <summary>
            实例化默认的对象<br />
            Instantiate the default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化对象<br />
            Specify the IP address and port number to instantiate the object
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Station"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.SumCheck">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.SumCheck"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Format">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Format"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认<br />
            Read PLC data in batches, in units of words, supports reading X, Y, M, S, D, T, C. The specific address range needs to be confirmed according to the PLC model
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Write(System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认<br />
            The data written to the PLC in batches is in units of words, that is, at least 2 bytes of information. It supports X, Y, M, S, D, T, and C. The specific address range needs to be confirmed according to the PLC model.
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型<br />
            Read bool data in batches. The supported types are X, Y, S, T, C. The specific address range depends on the type of PLC.
            </summary>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Write(System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型<br />
            Write arrays of type bool in batches. The supported types are X, Y, S, T, C. The specific address range depends on the type of PLC.
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecA3CNetHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.RemoteRunAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.RemoteRun"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.RemoteStopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.RemoteStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.ReadPlcTypeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNetOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA3CServer">
            <summary>
            <b>[商业授权]</b> 基于MC协议的A3C格式虚拟服务器，可以模拟A3C格式的PLC，支持格式1，2，3，4，具体可以使用<see cref="P:HslCommunication.Profinet.Melsec.MelsecA3CServer.Format"/>来设置，
            支持设置是否校验，同时支持网口或是串口的访问<br />
            <b>[Authorization]</b> A3C format virtual server based on MC protocol can simulate A3C format PLC, support format 1, 2, 3, 4, 
            specifically you can use <see cref="P:HslCommunication.Profinet.Melsec.MelsecA3CServer.Format"/> to set, support whether to verify the setting, 
            and also support network Port or serial port access
            </summary>
            <remarks>
            可访问的地址支持M,X,Y,B,D,W,R,ZR地址，其中 M,X,Y,B 支持位访问
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CServer.#ctor">
            <summary>
            实例化一个虚拟的A3C服务器
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CServer.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Station"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CServer.SumCheck">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.SumCheck"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CServer.Format">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Format"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CServer.PackCommand(System.UInt16,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecCipNet">
            <summary>
            三菱PLC的EIP协议的实现，当PLC使用了 QJ71EIP71 模块时就需要使用本类来访问
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecCipNet.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecCipNet.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecCipNet.Read(System.String,System.UInt16)">
            <summary>
            Read data information, data length for read array length information
            </summary>
            <param name="address">Address format of the node</param>
            <param name="length">In the case of arrays, the length of the array </param>
            <returns>Result data with result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecCipNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecCipNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxLinks">
            <summary>
            三菱计算机链接协议，适用FX3U系列，FX3G，FX3S等等系列，通常在PLC侧连接的是485的接线口<br />
            Mitsubishi Computer Link Protocol, suitable for FX3U series, FX3G, FX3S, etc., usually the 485 connection port is connected on the PLC side
            </summary>
            <remarks>
            关于在PLC侧的配置信息，协议：专用协议  传送控制步骤：格式一  站号设置：0
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinks.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Station"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinks.WaittingTime">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.WaittingTime"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinks.SumCheck">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.SumCheck"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinks.Format">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Format"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.StartPLC(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StartPLC(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.StopPLC(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StopPLC(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.ReadPlcType(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadPlcType(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp">
            <summary>
            三菱计算机链接协议的网口版本，适用FX3U系列，FX3G，FX3S等等系列，通常在PLC侧连接的是485的接线口<br />
            Network port version of Mitsubishi Computer Link Protocol, suitable for FX3U series, FX3G, FX3S, etc., usually the 485 connection port is connected on the PLC side
            </summary>
            <remarks>
            </remarks>
            <example>
            支持的通讯的系列如下参考
            <list type="table">
                <listheader>
                    <term>系列</term>
                    <term>是否支持</term>
                    <term>备注</term>
                </listheader>
                <item>
                    <description>FX3UC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3U系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3GC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3G系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3S系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2NC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2N系列</description>
                    <description>部分支持(v1.06+)</description>
                    <description>通过监控D8001来确认版本号</description>
                </item>
                <item>
                    <description>FX1NC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1N系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1S系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0N系列</description>
                    <description>部分支持(v1.20+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0S系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2C系列</description>
                    <description>部分支持(v3.30+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2(FX)系列</description>
                    <description>部分支持(v3.30+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
            </list>
            数据地址支持的格式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>8</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>8</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.#ctor">
            <summary>
            实例化默认的对象<br />
            Instantiate the default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化默认的对象<br />
            Specify the IP address and port number to instantiate the default object
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks.Station"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.WaittingTime">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks.WaittingTime"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.SumCheck">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks.SumCheck"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Format">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks.Format"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.Write(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StartPLC(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.StartPLC(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StopPLC(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.StopPLC(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadPlcType(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxLinksHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteFxLinks,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StartPLCAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StartPLC(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StopPLCAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StopPLC(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadPlcTypeAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadPlcType(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxLinksServer">
            <summary>
            三菱的虚拟的FxLinks服务器
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.#ctor">
            <summary>
            实例化一个虚拟的FxLinks服务器
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Station"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.SumCheck">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.SumCheck"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.Format">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteA3C.Format"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.PackCommand(System.Byte,System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp">
            <summary>
            三菱串口协议的网络版，如果使用的是 FX3U编程口(fx2n) -> GOT1000(RS232)(或是GOT2000)  -> 上位机(以太网) 的方式，那么就需要把<see cref="P:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.UseGOT"/>设置为 <c>True</c><br />
            The network version of the Mitsubishi serial port protocol, if you use the FX3U programming port (fx2n) -> GOT1000 (RS232) (or GOT2000) -> host computer (Ethernet) method, 
            then you need to put <see cref="P:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.UseGOT" /> is set to <c>True</c>
            </summary>
            <remarks>
            一般老旧的型号，例如FX2N之类的，需要将<see cref="P:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.IsNewVersion"/>设置为<c>False</c>，如果是FX3U新的型号，则需要将<see cref="P:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.IsNewVersion"/>设置为<c>True</c>
            </remarks>
            <example>
            字读写地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>D0-D511,D8000-D8255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>TN</term>
                <term>TN10,TN20</term>
                <term>TN0-TN255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>CN</term>
                <term>CN10,CN20</term>
                <term>CN0-CN199,CN200-CN255</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            位地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>M0-M1023,M8000-M8255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X1,X20</term>
                <term>X0-X177</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>Y0-Y177</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>S0-S999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器触点</term>
                <term>TS</term>
                <term>TS10,TS20</term>
                <term>TS0-TS255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器线圈</term>
                <term>TC</term>
                <term>TC10,TC20</term>
                <term>TC0-TC255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器触点</term>
                <term>CS</term>
                <term>CS10,CS20</term>
                <term>CS0-CS255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器线圈</term>
                <term>CC</term>
                <term>CC10,CC20</term>
                <term>CC0-CC255</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="Usage" title="简单的使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.#ctor">
            <summary>
            实例化网络版的三菱的串口协议的通讯对象<br />
            Instantiate the communication object of Mitsubishi's serial protocol on the network
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址及端口号来实例化三菱的串口协议的通讯对象<br />
            Specify the IP address and port number to instantiate the communication object of Mitsubishi's serial protocol
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.UseGOT">
            <summary>
            获取或设置是否使用GOT连接三菱的PLC，当使用了GOT连接到
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.IsNewVersion">
            <summary>
            当前的编程口协议是否为新版，默认为新版，如果无法读取，切换旧版再次尝试<br />
            Whether the current programming port protocol is the new version, the default is the new version, 
            if it cannot be read, switch to the old version and try again
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ActivePlc">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ActivePlc(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ActivePlcAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ActivePlc(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecHelper">
            <summary>
            所有三菱通讯类的通用辅助工具类，包含了一些通用的静态方法，可以使用本类来获取一些原始的报文信息。详细的操作参见例子<br />
            All general auxiliary tool classes of Mitsubishi communication class include some general static methods. 
            You can use this class to get some primitive message information. See the example for detailed operation
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.McA1EAnalysisAddress(System.String)">
            <summary>
            解析A1E协议数据地址<br />
            Parse A1E protocol data address
            </summary>
            <param name="address">数据地址</param>
            <returns>结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.GetErrorDescription(System.Int32)">
            <summary>
            根据三菱的错误码去查找对象描述信息
            </summary>
            <param name="code">错误码</param>
            <returns>描述信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildBytesFromAddress(System.Int32,HslCommunication.Profinet.Melsec.MelsecMcDataType)">
            <summary>
            从三菱的地址中构建MC协议的6字节的ASCII格式的地址
            </summary>
            <param name="address">三菱地址</param>
            <param name="type">三菱的数据类型</param>
            <returns>6字节的ASCII格式的地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.TransBoolArrayToByteData(System.Byte[])">
            <summary>
            将0，1，0，1的字节数组压缩成三菱格式的字节数组来表示开关量的
            </summary>
            <param name="value">原始的数据字节</param>
            <returns>压缩过后的数据字节</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.TransBoolArrayToByteData(System.Boolean[])">
            <summary>
            将bool的组压缩成三菱格式的字节数组来表示开关量的
            </summary>
            <param name="value">原始的数据字节</param>
            <returns>压缩过后的数据字节</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.FxCalculateCRC(System.Byte[],System.Int32,System.Int32)">
            <summary>
            计算Fx协议指令的和校验信息
            </summary>
            <param name="data">字节数据</param>
            <param name="start">起始的索引信息</param>
            <param name="tail">结束的长度信息</param>
            <returns>校验之后的数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.CheckCRC(System.Byte[])">
            <summary>
            检查指定的和校验是否是正确的
            </summary>
            <param name="data">字节数据</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp">
            <summary>
            三菱PLC通讯类，采用UDP的协议实现，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为ascii通讯<br />
            Mitsubishi PLC communication class is implemented using UDP protocol and Qna compatible 3E frame protocol. 
            The Ethernet module needs to be configured first on the PLC side, and it must be ascii communication.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet" path="remarks"/>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.McType">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McType"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.McAnalysisAddress(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ExtractActualData(System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.ExtractActualData(System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadRandom(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadRandom(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadRandomInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadRandomUInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomUInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadExtend(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadExtend(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadMemory(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadMemory(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadSmartModule(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadSmartModule(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.RemoteReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ErrorStateReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ErrorStateReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet">
            <summary>
            三菱PLC通讯类，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为ASCII通讯格式<br />
            Mitsubishi PLC communication class is implemented using Qna compatible 3E frame protocol. 
            The Ethernet module on the PLC side needs to be configured first. It must be ascii communication.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet" path="remarks"/>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.McType">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McType"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.McAnalysisAddress(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ExtractActualData(System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.ExtractActualData(System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandom(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandom(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomUInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomUInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomAsync(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomInt16Async(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomUInt16Async(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomUInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadExtend(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadExtend(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadExtendAsync(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadExtend(System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadMemory(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadMemory(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadMemoryAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadMemory(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadSmartModule(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadSmartModule(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadSmartModuleAsync(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadSmartModule(System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ErrorStateReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ErrorStateReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteRunAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteRun"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteStopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteResetAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadPlcTypeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ErrorStateResetAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ErrorStateReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcDataType">
            <summary>
            三菱PLC的数据类型，此处包含了几个常用的类型<br />
            Data types of Mitsubishi PLC, here contains several commonly used types
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcDataType.#ctor(System.UInt16,System.Byte,System.String,System.Int32)">
            <summary>
            实例化一个三菱数据类型对象，如果您清楚类型代号，可以根据值进行扩展<br />
            Instantiate a Mitsubishi data type object, if you know the type code, you can expand according to the value
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0，0代表按字，1代表按位</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcDataType.DataCode">
            <summary>
            类型的代号值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.M">
            <summary>
            M内部继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SM">
            <summary>
            SM特殊继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.S">
            <summary>
            S步进继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.L">
            <summary>
            L锁存继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.F">
            <summary>
            F报警器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.V">
            <summary>
            V边沿继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.B">
            <summary>
            B链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SB">
            <summary>
            SB特殊链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.DX">
            <summary>
            DX直接访问输入
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.DY">
            <summary>
            DY直接访问输出
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.D">
            <summary>
            D数据寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SD">
            <summary>
            特殊链接存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.W">
            <summary>
            W链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SW">
            <summary>
            SW特殊链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R">
            <summary>
            R文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Z">
            <summary>
            变址寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.ZR">
            <summary>
            文件寄存器ZR区
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.TN">
            <summary>
            定时器的当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.TS">
            <summary>
            定时器的触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.TC">
            <summary>
            定时器的线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SS">
            <summary>
            累计定时器的触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SC">
            <summary>
            累计定时器的线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SN">
            <summary>
            累计定时器的当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.CN">
            <summary>
            计数器的当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.CS">
            <summary>
            计数器的触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.CC">
            <summary>
            计数器的线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_Y">
            <summary>
            Y输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_M">
            <summary>
            M内部继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_SM">
            <summary>
            特殊继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_L">
            <summary>
            锁存继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_F">
            <summary>
            报警器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_V">
            <summary>
            变址继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_S">
            <summary>
            S步进继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_B">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_SB">
            <summary>
            特殊链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_DX">
            <summary>
            直接访问输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_DY">
            <summary>
            直接访问输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_D">
            <summary>
            数据寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_SD">
            <summary>
            特殊数据寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_W">
            <summary>
            链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_SW">
            <summary>
            特殊链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_R">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_Z">
            <summary>
            变址寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LSTS">
            <summary>
            长累计定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LSTC">
            <summary>
            长累计定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LSTN">
            <summary>
            长累计定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_STS">
            <summary>
            累计定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_STC">
            <summary>
            累计定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_STN">
            <summary>
            累计定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LTS">
            <summary>
            长定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LTC">
            <summary>
            长定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LTN">
            <summary>
            长定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_TS">
            <summary>
            定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_TC">
            <summary>
            定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_TN">
            <summary>
            定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LCS">
            <summary>
            长计数器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LCC">
            <summary>
            长计数器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_LCN">
            <summary>
            长计数器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_CS">
            <summary>
            计数器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_CC">
            <summary>
            计数器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R_CN">
            <summary>
            计数器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_B">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_M">
            <summary>
            内部辅助继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_L">
            <summary>
            锁存继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_SM">
            <summary>
            控制继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_SD">
            <summary>
            控制存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_D">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_R">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_ZR">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_W">
            <summary>
            链路寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_TC">
            <summary>
            计时器（线圈）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_CC">
            <summary>
            计数器（线圈）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_X">
            <summary>
            输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_Y">
            <summary>
            输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_L">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_R">
            <summary>
            内部继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_DT">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_LD">
            <summary>
            链接存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_SM">
            <summary>
            特殊链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_SD">
            <summary>
            特殊链接存储器
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcRNet">
            <summary>
            三菱的R系列的MC协议，支持的地址类型和 <see cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet"/> 有区别，详细请查看对应的API文档说明
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.#ctor">
            <summary>
            实例化三菱R系列的Qna兼容3E帧协议的通讯对象<br />
            Instantiate the communication object of Mitsubishi's Qna compatible 3E frame protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个默认的对象<br />
            Specify the IP address and port number to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRNet.McType">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McType"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRNet.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRNet.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McAnalysisAddress(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ExtractActualData(System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.ExtractActualData(System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandom(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandom(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandomInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandomUInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomUInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandomAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandomAsync(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandomInt16Async(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandomInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandomUInt16Async(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadRandomUInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.AnalysisAddress(System.String)">
            <summary>
            分析三菱R系列的地址，并返回解析后的数据对象
            </summary>
            <param name="address">字符串地址</param>
            <returns>是否解析成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.BuildReadMcCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean)">
            <summary>
            从三菱地址，是否位读取进行创建读取的MC的核心报文
            </summary>
            <param name="address">地址数据</param>
            <param name="isBit">是否进行了位读取操作</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.BuildWriteWordCoreCommand(HslCommunication.Core.Address.McAddressData,System.Byte[])">
            <summary>
            以字为单位，创建数据写入的核心报文
            </summary>
            <param name="address">三菱的数据地址</param>
            <param name="value">实际的原始数据信息</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.BuildWriteBitCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean[])">
            <summary>
            以位为单位，创建数据写入的核心报文
            </summary>
            <param name="address">三菱的地址信息</param>
            <param name="value">原始的bool数组数据</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA1EServer">
            <summary>
            <b>[商业授权]</b> 三菱MC-A1E协议的虚拟服务器，支持M,X,Y,D,W的数据池读写操作，支持二进制及ASCII格式进行读写操作，需要在实例化的时候指定。<br />
            <b>[Authorization]</b> The Mitsubishi MC-A1E protocol virtual server supports M, X, Y, D, W data pool read and write operations, 
            and supports binary and ASCII format read and write operations, which need to be specified during instantiation.
            </summary>
            <remarks>
            本三菱的虚拟PLC仅限商业授权用户使用，感谢支持。
            如果你没有可以测试的三菱PLC，想要测试自己开发的上位机软件，或是想要在本机实现虚拟PLC，然后进行IO的输入输出练习，都可以使用本类来实现，先来说明下地址信息
            <br />
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EServer.#ctor(System.Boolean)">
            <summary>
            实例化一个默认参数的mc协议的服务器<br />
            Instantiate a mc protocol server with default parameters
            </summary>
            <param name="isBinary">是否是二进制，默认是二进制，否则是ASCII格式</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EServer.ReadFromMcCore(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EServer.ReadFromMcAsciiCore(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcUdp">
            <summary>
            三菱PLC通讯类，采用UDP的协议实现，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为二进制通讯<br />
            Mitsubishi PLC communication class is implemented using UDP protocol and Qna compatible 3E frame protocol. 
            The Ethernet module needs to be configured first on the PLC side, and it must be binary communication.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet" path="remarks"/>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage2" title="简单的长连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample1" title="基本的读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample2" title="批量读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample3" title="随机字读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample4" title="随机批量字读取示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcUdp.McType">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McType"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcUdp.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcUdp.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.McAnalysisAddress(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ExtractActualData(System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.ExtractActualData(System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadRandom(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadRandom(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadRandomInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadRandomUInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomUInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadTags(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.ReadTags(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadTags(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadTags(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadExtend(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadExtend(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadMemory(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadMemory(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadSmartModule(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadSmartModule(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.RemoteReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ErrorStateReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ErrorStateReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcNet">
            <summary>
            三菱PLC通讯类，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为二进制通讯<br />
            Mitsubishi PLC communication class is implemented using Qna compatible 3E frame protocol. 
            The Ethernet module on the PLC side needs to be configured first. It must be binary communication.
            </summary>
            <remarks>
            支持读写的数据类型详细参考API文档，支持高级的数据读取，例如读取智能模块，缓冲存储器等等。
            </remarks>
            <list type="number">
            目前组件测试通过的PLC型号列表，有些来自于网友的测试
            <item>Q06UDV PLC  感谢hwdq0012</item>
            <item>fx5u PLC  感谢山楂</item>
            <item>Q02CPU PLC </item>
            <item>L02CPU PLC </item>
            </list>
            地址的输入的格式支持多种复杂的地址表示方式：
            <list type="number">
            <item>[商业授权] 扩展的数据地址: 表示为 ext=1;W100  访问扩展区域为1的W100的地址信息</item>
            <item>[商业授权] 缓冲存储器地址: 表示为 mem=32  访问地址为32的本站缓冲存储器地址</item>
            <item>[商业授权] 智能模块地址：表示为 module=3;4106  访问模块号3，偏移地址是4106的数据，偏移地址需要根据模块的详细信息来确认。</item>
            <item>[商业授权] 基于标签的地址: 表示位 s=AAA  假如标签的名称为AAA，但是标签的读取是有条件的，详细参照<see cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String,System.UInt16)"/></item>
            <item>普通的数据地址，参照下面的信息</item>
            </list>
            <example><list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>8进制用0开头，X017</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>8进制用0开头，Y017</term>
              </item>
               <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>边沿继电器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>ZR文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR2A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的触点</term>
                <term>SS</term>
                <term>SS100,SS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的线圈</term>
                <term>SC</term>
                <term>SC100,SC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的当前值</term>
                <term>SN</term>
                <term>SN100,SN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前值</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage2" title="简单的长连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample1" title="基本的读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample2" title="批量读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample3" title="随机字读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample4" title="随机批量字读取示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor">
            <summary>
            实例化三菱的Qna兼容3E帧协议的通讯对象<br />
            Instantiate the communication object of Mitsubishi's Qna compatible 3E frame protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个默认的对象<br />
            Specify the IP address and port number to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcNet.McType">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McType"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.McAnalysisAddress(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ExtractActualData(System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.IReadWriteMc.ExtractActualData(System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.Read(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandom(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomUInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadRandomUInt16(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomAsync(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomInt16Async(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomUInt16Async(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomUInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadBool(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McBinaryHelper.ReadTags(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String[],System.UInt16[])"/>
            <param name="tag">数据标签</param>
            <param name="length">读取的数据长度</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTagsAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTagsAsync(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadExtend(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadExtend(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadExtendAsync(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadExtend(System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadMemory(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadMemory(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadMemoryAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadMemory(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadSmartModule(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadSmartModule(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc,System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadSmartModuleAsync(System.UInt16,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadSmartModule(System.UInt16,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteRun(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteStop(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.RemoteReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ReadPlcType(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ErrorStateReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.McHelper.ErrorStateReset(HslCommunication.Profinet.Melsec.Helper.IReadWriteMc)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteRunAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteRun"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteStopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteResetAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadPlcTypeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ErrorStateResetAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ErrorStateReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcServer">
            <summary>
            <b>[商业授权]</b> 三菱MC协议的虚拟服务器，支持M,X,Y,D,W的数据池读写操作，支持二进制及ASCII格式进行读写操作，需要在实例化的时候指定。<br />
            <b>[Authorization]</b> The Mitsubishi MC protocol virtual server supports M, X, Y, D, W data pool read and write operations, 
            and supports binary and ASCII format read and write operations, which need to be specified during instantiation.
            </summary>
            <remarks>
            本三菱的虚拟PLC仅限商业授权用户使用，感谢支持。
            如果你没有可以测试的三菱PLC，想要测试自己开发的上位机软件，或是想要在本机实现虚拟PLC，然后进行IO的输入输出练习，都可以使用本类来实现，先来说明下地址信息
            <br />
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.#ctor(System.Boolean)">
            <summary>
            实例化一个默认参数的mc协议的服务器<br />
            Instantiate a mc protocol server with default parameters
            </summary>
            <param name="isBinary">是否是二进制，默认是二进制，否则是ASCII格式</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ReadFromMcCore(System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。<br />
            The method that should be triggered when a message of the mc protocol is received, 
            allowing inheritance to be rewritten to implement custom return or data monitoring.
            </summary>
            <param name="mcCore">mc报文</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ReadFromMcAsciiCore(System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。<br />
            The method that should be triggered when a message of the mc protocol is received, 
            allowing inheritance to be rewritten to implement custom return or data monitoring.
            </summary>
            <param name="mcCore">mc报文</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.PackCommand(System.UInt16,System.Byte[])">
            <summary>
            将状态码，数据打包成一个完成的回复报文信息
            </summary>
            <param name="status">状态信息</param>
            <param name="data">数据</param>
            <returns>状态信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing">是否托管对象</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcServer.IsBinary">
            <summary>
            获取或设置当前的通信格式是否是二进制<br />
            Get or set whether the current communication format is binary
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcUdpServer">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdpServer.#ctor(System.Boolean)">
            <summary>
            实例化一个默认参数的mc协议的服务器<br />
            Instantiate a mc protocol server with default parameters
            </summary>
            <param name="isBinary">是否是二进制，默认是二进制，否则是ASCII格式</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcUdpServer.ReceiveCacheLength">
            <summary>
            获取或设置一次接收时的数据长度，默认2KB数据长度
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdpServer.ServerStart(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdpServer.RefreshReceive">
            <summary>
            重新开始接收数据
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxSerial">
            <summary>
            三菱的串口通信的对象，适用于读取FX系列的串口数据，支持的类型参考文档说明<br />
            Mitsubishi's serial communication object is suitable for reading serial data of the FX series. Refer to the documentation for the supported types.
            </summary>
            <remarks>
            一般老旧的型号，例如FX2N之类的，需要将<see cref="P:HslCommunication.Profinet.Melsec.MelsecFxSerial.IsNewVersion"/>设置为<c>False</c>，如果是FX3U新的型号，则需要将<see cref="P:HslCommunication.Profinet.Melsec.MelsecFxSerial.IsNewVersion"/>设置为<c>True</c>
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp" path="remarks"/>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="Usage" title="简单的使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxSerial.IsNewVersion">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.IsNewVersion"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.ActivePlc">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ActivePlc(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.ActivePlcAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.Helper.MelsecFxSerialHelper.ActivePlc(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.WriteAsync(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.NamespaceDoc">
            <summary>
            在三菱的PLC通信的MC协议中，分为串行通信的报文和以太网接口的报文。<br />
            在串口通信中，共有以下几种帧，其中1C,2C,3C帧支持格式1，2，3，4，在C帧里支持格式5通信<br />
            <list type="number">
            <item>4C帧，QnA系列串行通信模块专用协议（Qna扩展帧）</item>
            <item>3C帧，QnA系列串行通信模块专用协议（Qna帧）</item>
            <item>2C帧，QnA系列串行通信模块专用协议（Qna简易帧）</item>
            <item>1C帧，A系列计算机链接模块专用协议</item>
            </list>
            在以太网通信中，共有以下几种帧，每种帧支持二进制和ASCII格式
            <list type="number">
            <item>4E帧，是3E帧上附加了“序列号”。</item>
            <item>3E帧，QnA系列以太网接口模块的报文格式，兼容SLMP的报文格式</item>
            <item>1E帧，A系列以太网接口模块的报文格式</item>
            </list>
            在以太网通信里，HSL主要针对1E帧协议和3E帧协议进行实现，大概说一下怎么选择通信类对象，对于三菱PLC而言，需要事先在PLC侧的网络配置中进行
            相关的配置操作，具体是配置二进制格式还是ASCII格式，然后配置端口，配置TCP还是UDP协议。<br />
            <see cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet"/>，<see cref="T:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet"/>，<see cref="T:HslCommunication.Profinet.Melsec.MelsecMcUdp"/>, <see cref="T:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp"/> 这四个类都是MC协议的Qna兼容3E帧实现，分别
            是TCP二进制，TCP的ASCII，UDP的二进制，UDP的ASCI格式。适用Q系列，L系列，FX5U系列，还有以太网模块QJ71E71。<br />
            <see cref="T:HslCommunication.Profinet.Melsec.MelsecA1ENet"/>, <see cref="T:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet"/> 这两个类是MC协议的Qna兼容1E协议实现，
            分别是二进制和ASCII格式的实现，主要适用A系列的PLC，Fx3u，以及有些老的PLC，使用了北辰模块实现的通信也是选择的是 A1E 协议来通信。<br />
            <see cref="T:HslCommunication.Profinet.Melsec.MelsecA3CNet"/> 是MC协议的3C帧的实现，主要支持串行通信的模块的实现。<br />
            <see cref="T:HslCommunication.Profinet.Melsec.MelsecFxSerial"/> 是FX编程口的协议的实现，测试并不在所有的老型号上都很稳定。具体支持的系列需要参照类的说明，
            当使用GOT触摸屏连接PLC时，需要使用类<see cref="T:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp"/>并将属性<see cref="P:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.UseGOT"/>设置为 <c>True</c>。<br />
            <see cref="T:HslCommunication.Profinet.Melsec.MelsecFxLinks"/> 是三菱的计算机链接协议，通常是三菱的485接口，而不是编程口，该协议支持多种格式及是否和校验，实际参数选择需要根据PLC的配置来决定。<br />
            <br />
            三菱Q系列PLC带以太网模块，使用MC 二进制协议通讯，在网络中断情况下无法正常连接的情况，解决方案如下：<br />
            1. 生存确认选择确认模式；<br />
            2. 初始设置中将"对象目标生存确认开始间隔定时器"从1200改为12<br />
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.Helper.IHostLink">
            <summary>
            HostLink的接口实现
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.Helper.IHostLink.ICF">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ICF"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.Helper.IHostLink.DA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.DA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.Helper.IHostLink.SA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.Helper.IHostLink.SID">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SID"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.Helper.IHostLink.ResponseWaitTime">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ResponseWaitTime"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.Helper.IHostLink.UnitNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnitNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.Helper.IHostLink.ReadSplits">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ReadSplits"/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper">
            <summary>
            欧姆龙的OmronHostLinkCMode的辅助类方法
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
            <remarks>
            地址里可以额外指定单元号信息，例如 s=2;D100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
            <remarks>
            地址里可以额外指定单元号信息，例如 s=2;D100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.Byte)">
            <summary>
            <b>[商业授权]</b> 读取PLC的当前的型号信息<br />
            <b>[Authorization]</b> Read the current model information of the PLC
            </summary>
            <param name="omron">PLC连接对象</param>
            <param name="unitNumber">站号信息</param>
            <returns>型号</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte)">
            <summary>
            <b>[商业授权]</b> 读取PLC当前的操作模式，0: 编程模式  1: 运行模式  2: 监视模式<br />
            <b>[Authorization]</b> Reads the Operation mode of the CPU Unit. 0: PROGRAM mode  1: RUN mode  2: MONITOR mode
            </summary>
            <param name="omron">PLC连接对象</param>
            <param name="unitNumber">站号信息</param>
            <returns>0: 编程模式  1: 运行模式  2: 监视模式</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ChangePlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte,System.Byte)">
            <summary>
            <b>[商业授权]</b> 将当前PLC的模式变更为指定的模式，0: 编程模式  1: 运行模式  2: 监视模式<br />
            <b>[Authorization]</b> Change the current PLC mode to the specified mode, 0: programming mode 1: running mode 2: monitoring mode
            </summary>
            <param name="omron">PLC连接对象</param>
            <param name="unitNumber">站号信息</param>
            <param name="mode">0: 编程模式  1: 运行模式  2: 监视模式</param>
            <returns>是否变更成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.AnalysisAddress(System.String,System.Boolean,System.Boolean)">
            <summary>
            解析欧姆龙的数据地址，参考来源是Omron手册第188页，比如D100， E1.100<br />
            Analyze Omron's data address, the reference source is page 188 of the Omron manual, such as D100, E1.100
            </summary>
            <param name="address">数据地址</param>
            <param name="isBit">是否是位地址</param>
            <param name="isRead">是否读取</param>
            <returns>解析后的结果地址对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.BuildReadCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据读取的地址，长度，是否位读取创建Fins协议的核心报文<br />
            According to the read address, length, whether to read the core message that creates the Fins protocol
            </summary>
            <param name="address">地址，具体格式请参照示例说明</param>
            <param name="length">读取的数据长度</param>
            <param name="isBit">是否使用位读取</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.BuildWriteWordCommand(System.String,System.Byte[])">
            <summary>
            根据读取的地址，长度，是否位读取创建Fins协议的核心报文<br />
            According to the read address, length, whether to read the core message that creates the Fins protocol
            </summary>
            <param name="address">地址，具体格式请参照示例说明</param>
            <param name="value">等待写入的数据</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ResponseValidAnalysis(System.Byte[],System.Boolean)">
            <summary>
            验证欧姆龙的Fins-TCP返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <param name="isRead">是否读取</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.PackCommand(System.Byte[],System.Byte)">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd">fins指令</param>
            <param name="unitNumber">站号信息</param>
            <returns>完整的质量</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.GetModelText(System.String)">
            <summary>
            获取model的字符串描述信息
            </summary>
            <param name="model">型号代码</param>
            <returns>是否解析成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.GetErrorMessage(System.Int32)">
            <summary>
            根据错误码的信息，返回错误的具体描述的文本<br />
            According to the information of the error code, return the text of the specific description of the error
            </summary>
            <param name="err">错误码</param>
            <returns>错误的描述文本</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper">
            <summary>
            欧姆龙的OmronHostLink相关辅助方法
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.ResponseValidAnalysis(System.Byte[],System.Byte[])">
            <summary>
            验证欧姆龙的Fins-TCP返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容
            </summary>
            <param name="send">发送的报文信息</param>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.GetErrorText(System.Int32)">
            <summary>
            根据错误信息获取当前的文本描述信息
            </summary>
            <param name="error">错误代号</param>
            <returns>文本消息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.PackCommand(HslCommunication.Profinet.Omron.Helper.IHostLink,System.Byte,System.Byte[])">
            <summary>
            将 fins 命令的报文打包成 HostLink 格式的报文信息，打包之后的结果可以直接发送给PLC<br />
            Pack the message of the fins command into the message information in the HostLink format, and the packaged result can be sent directly to the PLC
            </summary>
            <param name="hostLink">HostLink协议的plc通信对象</param>
            <param name="station">站号信息</param>
            <param name="cmd">fins命令</param>
            <returns>可发送PLC的完整的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.Read(HslCommunication.Profinet.Omron.Helper.IHostLink,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.Write(HslCommunication.Profinet.Omron.Helper.IHostLink,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.ReadAsync(HslCommunication.Profinet.Omron.Helper.IHostLink,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.WriteAsync(HslCommunication.Profinet.Omron.Helper.IHostLink,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.ReadBool(HslCommunication.Profinet.Omron.Helper.IHostLink,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.Write(HslCommunication.Profinet.Omron.Helper.IHostLink,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.ReadBoolAsync(HslCommunication.Profinet.Omron.Helper.IHostLink,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkHelper.WriteAsync(HslCommunication.Profinet.Omron.Helper.IHostLink,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronCipNet">
            <summary>
            欧姆龙PLC的CIP协议的类，支持NJ,NX,NY系列PLC，支持tag名的方式读写数据，假设你读取的是局部变量，那么使用 Program:MainProgram.变量名<br />
            Omron PLC's CIP protocol class, support NJ, NX, NY series PLC, support tag name read and write data, assuming you read local variables, then use Program: MainProgram. Variable name
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.#ctor">
            <summary>
            Instantiate a communication object for a OmronCipNet PLC protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.#ctor(System.String,System.Int32)">
            <summary>
            Specify the IP address and port to instantiate a communication object for a OmronCipNet PLC protocol
            </summary>
            <param name="ipAddress">PLC IpAddress</param>
            <param name="port">PLC Port</param>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadFloat(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadStruct``1(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Int16[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.UInt16[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.UInt32[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Single[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Int64[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.UInt64[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Double[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronConnectedCipNet">
            <summary>
            基于连接的对象访问的CIP协议的实现，用于对Omron PLC进行标签的数据读写，对数组，多维数组进行读写操作，支持的数据类型请参照API文档手册。<br />
            The implementation of the CIP protocol based on connected object access is used to read and write tag data to Omron PLC, 
            and read and write arrays and multidimensional arrays. For the supported data types, please refer to the API documentation manual.
            </summary>
            <remarks>
            支持普通标签的读写，类型要和标签对应上。如果标签是数组，例如 A 是 INT[0...9] 那么Read("A", 1)，返回的是10个short所有字节数组。
            如果需要返回10个长度的short数组，请调用 ReadInt16("A[0], 10"); 地址必须写 "A[0]"，不能写 "A" , 如需要读取结构体，参考 <see cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadStruct``1(System.String)"/>
            </remarks>
            <example>
            首先说明支持的类型地址，在PLC里支持了大量的类型，有些甚至在C#里是不存在的。现在做个统一的声明
            <list type="table">
              <listheader>
                <term>PLC类型</term>
                <term>含义</term>
                <term>代号</term>
                <term>C# 类型</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>bool</term>
                <term>位类型数据</term>
                <term>0xC1</term>
                <term>bool</term>
                <term></term>
              </item>
              <item>
                <term>SINT</term>
                <term>8位的整型</term>
                <term>0xC2</term>
                <term>sbyte</term>
                <term>有符号8位很少用，HSL直接用byte</term>
              </item>
              <item>
                <term>USINT</term>
                <term>无符号8位的整型</term>
                <term>0xC6</term>
                <term>byte</term>
                <term>如需要，使用<see cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/>实现</term>
              </item>
              <item>
                <term>BYTE</term>
                <term>8位字符数据</term>
                <term>0xD1</term>
                <term>byte</term>
                <term>如需要，使用<see cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/>实现</term>
              </item>
              <item>
                <term>INT</term>
                <term>16位的整型</term>
                <term>0xC3</term>
                <term>short</term>
                <term></term>
              </item>
              <item>
                <term>UINT</term>
                <term>无符号的16位整型</term>
                <term>0xC7</term>
                <term>ushort</term>
                <term></term>
              </item>
              <item>
                <term>DINT</term>
                <term>32位的整型</term>
                <term>0xC4</term>
                <term>int</term>
                <term></term>
              </item>
              <item>
                <term>UDINT</term>
                <term>无符号的32位整型</term>
                <term>0xC8</term>
                <term>uint</term>
                <term></term>
              </item>
              <item>
                <term>LINT</term>
                <term>64位的整型</term>
                <term>0xC5</term>
                <term>long</term>
                <term></term>
              </item>
              <item>
                <term>ULINT</term>
                <term>无符号的64位的整型</term>
                <term>0xC9</term>
                <term>ulong</term>
                <term></term>
              </item>
              <item>
                <term>REAL</term>
                <term>单精度浮点数</term>
                <term>0xCA</term>
                <term>float</term>
                <term></term>
              </item>
              <item>
                <term>DOUBLE</term>
                <term>双精度浮点数</term>
                <term>0xCB</term>
                <term>double</term>
                <term></term>
              </item>
              <item>
                <term>STRING</term>
                <term>字符串数据</term>
                <term>0xD0</term>
                <term>string</term>
                <term>前两个字节为字符长度</term>
              </item>
              <item>
                <term>8bit string BYTE</term>
                <term>8位的字符串</term>
                <term>0xD1</term>
                <term></term>
                <term>本质是BYTE数组</term>
              </item>
              <item>
                <term>16bit string WORD</term>
                <term>16位的字符串</term>
                <term>0xD2</term>
                <term></term>
                <term>本质是WORD数组，可存放中文</term>
              </item>
              <item>
                <term>32bit string DWORD</term>
                <term>32位的字符串</term>
                <term>0xD2</term>
                <term></term>
                <term>本质是DWORD数组，可存放中文</term>
              </item>
            </list>
            在读写操作之前，先看看怎么实例化和连接PLC<br />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage" title="实例化及连接示例" />
            现在来说明以下具体的操作细节。我们假设有如下的变量：<br />
            CESHI_A       SINT<br />
            CESHI_B       BYTE<br />
            CESHI_C       INT<br />
            CESHI_D       UINT<br />
            CESHI_E       SINT[0..9]<br />
            CESHI_F       BYTE[0..9]<br />
            CESHI_G       INT[0..9]<br />
            CESHI_H       UINT[0..9]<br />
            CESHI_I       INT[0..511]<br />
            CESHI_J       STRING[12]<br />
            ToPc_ID1      ARRAY[0..99] OF STRING[20]<br />
            CESHI_O       BOOL<br />
            CESHI_P       BOOL[0..31]<br />
            对 CESHI_A 来说，读写这么操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage2" title="读写示例" />
            对于 CESHI_B 来说，写入的操作有点特殊
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage3" title="读写示例" />
            对于 CESHI_C, CESHI_D 来说，就是 ReadInt16(string address) , Write( string address, short value ) 和 ReadUInt16(string address) 和 Write( string address, ushort value ) 差别不大。
            所以我们着重来看看数组的情况，以 CESHI_G 标签为例子:<br />
            情况一，我想一次读取这个标签所有的字节数组（当长度满足的情况下，会一次性返回数据）
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage4" title="读写示例" />
            情况二，我想读取第3个数，或是第6个数开始，一共5个数
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage5" title="读写示例" />
            其他的数组情况都是类似的，我们来看看字符串 CESHI_J 变量
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage6" title="读写示例" />
            对于 bool 变量来说，就是 ReadBool("CESHI_O") 和 Write("CESHI_O", true) 操作，如果是bool数组，就不一样了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage7" title="读写示例" />
            最后我们来看看结构体的操作，假设我们有个结构体<br />
            MyData.Code     STRING(12)<br />
            MyData.Value1   INT<br />
            MyData.Value2   INT<br />
            MyData.Value3   REAL<br />
            MyData.Value4   INT<br />
            MyData.Value5   INT<br />
            MyData.Value6   INT[0..3]<br />
            因为bool比较复杂，暂时不考虑。要读取上述的结构体，我们需要定义结构一样的数据
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage8" title="结构体" />
            定义好后，我们再来读取就很简单了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage9" title="读写示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.#ctor(System.String,System.Int32)">
            <summary>
            根据指定的IP及端口来实例化这个连接对象
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.GetLargeForwardOpen(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ProductName">
            <summary>
            当前产品的型号信息<br />
            Model information of the current product
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadCipFromServer(System.Byte[][])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadCipFromServer(System.Byte[][])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadStruct``1(System.String)">
            <summary>
            <b>[商业授权]</b> 读取一个结构体的对象，需要事先根据实际的数据点位定义好结构体，然后使用本方法进行读取，当结构体定义不对时，本方法将会读取失败<br />
            <b>[Authorization]</b> To read a structure object, you need to define the structure in advance according to the actual data points, 
            and then use this method to read. When the structure definition is incorrect, this method will fail to read
            </summary>
            <remarks>
            本方法需要商业授权支持，具体的使用方法，参考API文档的示例代码
            </remarks>
            <example>
            我们来看看结构体的操作，假设我们有个结构体<br />
            MyData.Code     STRING(12)<br />
            MyData.Value1   INT<br />
            MyData.Value2   INT<br />
            MyData.Value3   REAL<br />
            MyData.Value4   INT<br />
            MyData.Value5   INT<br />
            MyData.Value6   INT[0..3]<br />
            因为bool比较复杂，暂时不考虑。要读取上述的结构体，我们需要定义结构一样的数据
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage8" title="结构体" />
            定义好后，我们再来读取就很简单了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronConnectedCipNetSample.cs" region="Usage9" title="读写示例" />
            </example>
            <typeparam name="T">结构体的类型</typeparam>
            <param name="address">结构体对象的地址</param>
            <returns>是否读取成功的对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadCipFromServerAsync(System.Byte[][])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadCipFromServer(System.Byte[][])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadStructAsync``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadStruct``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.GetMaxTransferBytes">
            <summary>
            获取传递的最大长度的字节信息
            </summary>
            <returns>字节长度</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Read(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[],System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadBool(System.String,System.UInt16)">
            <summary>
            读取bool数据信息，如果读取的是单bool变量，就直接写变量名，如果是 bool 数组，就 <br />
            Read a single bool data information, if it is a single bool variable, write the variable name directly, 
            if it is a value of a bool array composed of int, it is always accessed with "i=" at the beginning, for example, "i=A[0]"
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">读取的数组长度信息</param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadByte(System.String)">
            <summary>
            读取PLC的byte类型的数据<br />
            Read the byte type of PLC data
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadTag(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadTag(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadAsync(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Read(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadTagAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadTag(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteTagAsync(System.String,System.UInt16,System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadFloat(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadString(System.String,System.UInt16)">
            <summary>
            读取字符串数据，默认为UTF-8编码<br />
            Read string data, default is UTF-8 encoding
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的string数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadStringAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Int16[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.UInt16[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.UInt32[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Single[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Int64[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.UInt64[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Double[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronConnectedCipNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronCpuUnitData">
            <summary>
            欧姆的Cpu的单元信息数据类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCpuUnitData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCpuUnitData.#ctor(System.Byte[])">
            <summary>
            根据原始的数据来实例化相关的CPU单元信息
            </summary>
            <param name="data">原始字节数</param>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitData.Model">
            <summary>
            Cpu unit Model
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitData.Version">
            <summary>
            CPU Unit internal system version
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitData.LargestEMNumber">
            <summary>
            Largest number, 0 to 19, in CPU Unit’s EM area.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitData.ProgramAreaSize">
            <summary>
            Maximum size of usable program area，unit: k words
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitData.IOMSize">
            <summary>
            The size of the area (CIO, WR, HR, AR, timer/counter completion flags, TN) in which bit commands can be used( always 23). unit: bytes
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitData.DMSize">
            <summary>
            Total words in the DM area (always 32,768)
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitData.EMSize">
            <summary>
            Among the banks in the EM area, the number of banks(0 to D ) without file memory
            </summary>
            <remarks>
            Banks (1 bank = 32,768 words)
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitData.TCSize">
            <summary>
            Maximum number of timers/counters available (always 8)
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronCpuUnitStatus">
            <summary>
            欧姆龙Cpu的状态信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.#ctor(System.Byte[])">
            <summary>
            从原始的字节数组来实例化一个
            </summary>
            <param name="data">原始的字节数据</param>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.Status">
            <summary>
            Run 或是 Stop
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.BatteryStatus">
            <summary>
            No 或是 Present
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.CpuStatus">
            <summary>
            Normal 或是 Standby
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.Mode">
            <summary>
            PROGRAM, MONITOR, RUN
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.ErrorCode">
            <summary>
            Among errors that occur when the command is executed, the error code indicates the most serious. If there are no errors, it will be 0000 (hex)
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.ErrorMessage">
            <summary>
            Indicates messages from execution of FAL(006) or FALS(007). If there is no error message, 
            or if FAL(006) or FALS(007) are not being executed, 16 spaces( ASCII 20) will be returned.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCpuUnitStatus.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsDataType">
            <summary>
            欧姆龙的Fins协议的数据类型
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsDataType.#ctor(System.Byte,System.Byte)">
            <summary>
            实例化一个Fins的数据类型
            </summary>
            <param name="bitCode">进行位操作的指令</param>
            <param name="wordCode">进行字操作的指令</param>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsDataType.BitCode">
            <summary>
            进行位操作的指令
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsDataType.WordCode">
            <summary>
            进行字操作的指令
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.DM">
            <summary>
            DM Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.CIO">
            <summary>
            CIO Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.WR">
            <summary>
            Work Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.HR">
            <summary>
            Holding Bit Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.AR">
            <summary>
            Auxiliary Bit Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.TIM">
            <summary>
            TIM Area
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsNet">
            <summary>
            欧姆龙PLC通讯类，采用Fins-Tcp通信协议实现，支持的地址信息参见api文档信息。本协议下PLC默认的端口号为 9600，也可以手动更改，重启PLC更改生效。<br />
            Omron PLC communication class is implemented using Fins-Tcp communication protocol. For the supported address information, please refer to the api document information.
            The default port number of the PLC under this protocol is 9600, and it can also be changed manually. Restart the PLC to make the changes take effect.
            </summary>
            <remarks>
            <note type="important">PLC的IP地址的要求，最后一个整数的范围应该小于250，否则会发生连接不上的情况。</note>
            <br />
            <note type="warning">如果在测试的时候报错误码64，经网友 上海-Lex 指点，是因为PLC中产生了报警，如伺服报警，模块错误等产生的，但是数据还是能正常读到的，屏蔽64报警或清除plc错误可解决</note>
            <br />
            <note type="warning">如果碰到NX系列连接失败，或是无法读取的，需要使用网口2，配置ip地址，网线连接网口2，配置FINSTCP，把UDP的端口改成9601的，这样就可以读写了。</note><br />
            需要特别注意<see cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.ReadSplits"/>属性，在超长数据读取时，规定了切割读取的长度，在不是CP1H及扩展模块的时候，可以设置为999，提高一倍的通信速度。
            </remarks>
            <example>
            地址列表：
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>DM Area</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>CIO Area</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Work Area</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Holding Bit Area</term>
                <term>H</term>
                <term>H100,H200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Auxiliary Bit Area</term>
                <term>A</term>
                <term>A100,A200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>EM Area</term>
                <term>E</term>
                <term>E0.0,EF.200,E10.100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="Usage2" title="简单的长连接使用" />
            下面演示下各种类型的读写操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample1" title="各种类型读取的示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample1" title="各种类型写入的示例" />
            如果想要一次性读取不同类型的数据的话，可以读取byte[]，然后自行解析
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample2" title="自定义解析读取" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample2" title="自定义解析写入" />
            读写bool的示例代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="读取bool示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="写入bool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor">
            <summary>
            实例化一个欧姆龙PLC Fins帧协议的通讯对象<br />
            Instantiate a communication object of Omron PLC Fins frame protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个欧姆龙PLC Fins帧协议的通讯对象<br />
            Specify the IP address and port number to instantiate a communication object of the Omron PLC Fins frame protocol
            </summary>
            <param name="ipAddress">PLCd的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.ICF">
            <summary>
            信息控制字段，默认0x80<br />
            Information control field, default 0x80
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.RSV">
            <summary>
            系统使用的内部信息<br />
            Internal information used by the system
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.GCT">
            <summary>
            网络层信息，默认0x02，如果有八层消息，就设置为0x07<br />
            Network layer information, default is 0x02, if there are eight layers of messages, set to 0x07
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.DNA">
            <summary>
            PLC的网络号地址，默认0x00<br />
            PLC network number address, default 0x00
            </summary>
            <remarks>
            00: Local network<br />
            01-7F: Remote network address (decimal: 1 to 127)
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA1">
            <summary>
            PLC的节点地址，默认为0，在和PLC连接的过程中，自动从PLC获取到DA1的值。<br />
            The node address of the PLC is 0 by default. During the process of connecting with the PLC, the value of DA1 is automatically obtained from the PLC.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA2">
            <summary>
            PLC的单元号地址，通常都为0<br />
            PLC unit number address, usually 0
            </summary>
            <remarks>
            00: CPU Unit<br />
            FE: Controller Link Unit or Ethernet Unit connected to network<br />
            10 TO 1F: CPU Bus Unit<br />
            E1: Inner Board
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.SNA">
            <summary>
            上位机的网络号地址<br />
            Network number and address of the computer
            </summary>
            <remarks>
            00: Local network<br />
            01-7F: Remote network (1 to 127 decimal)
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA1">
            <summary>
            上位机的节点地址，默认是0x01，当连接PLC之后，将由PLC来设定当前的值。<br />
            The node address of the host computer is 0x01 by default. After connecting to the PLC, the PLC will set the current value.
            </summary>
            <remarks>
            <note type="important">v9.6.5版本及之前的版本都需要手动设置，如果是多连接，相同的节点是连接不上PLC的。</note>
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA2">
            <summary>
            上位机的单元号地址<br />
            Unit number and address of the computer
            </summary>
            <remarks>
            00: CPU Unit<br />
            10-1F: CPU Bus Unit
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.SID">
            <summary>
            设备的标识号<br />
            Service ID. Used to identify the process generating the transmission. 
            Set the SID to any number between 00 and FF
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.ReadSplits">
            <summary>
            进行字读取的时候对于超长的情况按照本属性进行切割，默认500，如果不是CP1H及扩展模块的，可以设置为999，可以提高一倍的通信速度。<br />
            When reading words, it is cut according to this attribute for the case of overlength. The default is 500. 
            If it is not for CP1H and expansion modules, it can be set to 999, which can double the communication speed.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.PackCommand(System.Byte[])">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd">FINS的核心指令</param>
            <returns>完整的可用于发送PLC的命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Int32)"/>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102,D103存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[])"/>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102,D103存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadString(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.WriteAsync(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Int32)"/>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean[])"/>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Run">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Run(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Stop">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Stop(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadCpuUnitData">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitData(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadCpuUnitStatus">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitStatus(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.RunAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Run(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.StopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Stop(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadCpuUnitDataAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitData(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadCpuUnitStatusAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitStatus(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsNetHelper">
            <summary>
            Omron PLC的FINS协议相关的辅助类，主要是一些地址解析，读写的指令生成。<br />
            The auxiliary classes related to the FINS protocol of Omron PLC are mainly some address resolution and the generation of read and write instructions.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.BuildReadCommand(System.String,System.UInt16,System.Boolean,System.Int32)">
            <summary>
            根据读取的地址，长度，是否位读取创建Fins协议的核心报文<br />
            According to the read address, length, whether to read the core message that creates the Fins protocol
            </summary>
            <param name="address">地址，具体格式请参照示例说明</param>
            <param name="length">读取的数据长度</param>
            <param name="isBit">是否使用位读取</param>
            <param name="splitLength">读取的长度切割，默认500</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.BuildWriteWordCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            根据写入的地址，数据，是否位写入生成Fins协议的核心报文<br />
            According to the written address, data, whether the bit is written to generate the core message of the Fins protocol
            </summary>
            <param name="address">地址内容，具体格式请参照示例说明</param>
            <param name="value">实际的数据</param>
            <param name="isBit">是否位数据</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ResponseValidAnalysis(System.Byte[])">
            <summary>
            验证欧姆龙的Fins-TCP返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容<br />
            Verify that the data returned by Omron's Fins-TCP is correct data, if correct, and return all data content
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.UdpResponseValidAnalysis(System.Byte[])">
            <summary>
            验证欧姆龙的Fins-Udp返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容<br />
            Verify that the data returned by Omron's Fins-Udp is correct data, if correct, and return all data content
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.GetStatusDescription(System.Int32)">
            <summary>
            根据欧姆龙返回的错误码，获取错误信息的字符串描述文本<br />
            According to the error code returned by Omron, get the string description text of the error message
            </summary>
            <param name="err">错误码</param>
            <returns>文本描述</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Int32)">
            <summary>
            从欧姆龙PLC中读取想要的数据，返回读取结果，读取长度的单位为字，地址格式为"D100","C100","W100","H100","A100"<br />
            Read the desired data from the Omron PLC and return the read result. The unit of the read length is word. The address format is "D100", "C100", "W100", "H100", "A100"
            </summary>
            <param name="omron">PLC设备的连接对象</param>
            <param name="address">读取地址，格式为"D100","C100","W100","H100","A100"</param>
            <param name="length">读取的数据长度</param>
            <param name="splits">分割信息</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[])">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型，地址格式为"D100","C100","W100","H100","A100"<br />
            Write data to PLC, the data format is the original byte type, and the address format is "D100", "C100", "W100", "H100", "A100"
            </summary>
            <param name="omron">PLC设备的连接对象</param>
            <param name="address">初始地址</param>
            <param name="value">原始的字节数据</param>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Int32)">
            <summary>
            从欧姆龙PLC中批量读取位软元件，地址格式为"D100.0","C100.0","W100.0","H100.0","A100.0"<br />
            Read bit devices in batches from Omron PLC with address format "D100.0", "C100.0", "W100.0", "H100.0", "A100.0"
            </summary>
            <param name="omron">PLC设备的连接对象</param>
            <param name="address">读取地址，格式为"D100","C100","W100","H100","A100"</param>
            <param name="length">读取的长度</param>
            <param name="splits">分割信息</param>
            <returns>带成功标志的结果数据对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean[])">
            <summary>
            向PLC中位软元件写入bool数组，返回是否写入成功，比如你写入D100,values[0]对应D100.0，地址格式为"D100.0","C100.0","W100.0","H100.0","A100.0"<br />
            Write the bool array to the PLC's median device and return whether the write was successful. For example, if you write D100, values [0] corresponds to D100.0 
            and the address format is "D100.0", "C100.0", "W100. 0 "," H100.0 "," A100.0 "
            </summary>
            <param name="omron">PLC设备的连接对象</param>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，可以指定任意的长度</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Run(HslCommunication.Core.IReadWriteDevice)">
            <summary>
            将CPU单元的操作模式更改为RUN，从而使PLC能够执行其程序。<br />
            Changes the CPU Unit’s operating mode to RUN, enabling the PLC to execute its program.
            </summary>
            <remarks>
            当执行RUN时，CPU单元将开始运行。 在执行RUN之前，您必须确认系统的安全性。 启用“禁止覆盖受保护程序”设置时，无法执行此命令。<br />
            The CPU Unit will start operation when RUN is executed. You must confirm the safety of the system before executing RUN.
            When the “prohibit overwriting of protected program” setting is enabled, this command cannot be executed.
            </remarks>
            <param name="omron">PLC设备的连接对象</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.RunAsync(HslCommunication.Core.IReadWriteDevice)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Run(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Stop(HslCommunication.Core.IReadWriteDevice)">
            <summary>
            将CPU单元的操作模式更改为PROGRAM，停止程序执行。<br />
            Changes the CPU Unit’s operating mode to PROGRAM, stopping program execution.
            </summary>
            <remarks>
            当执行STOP时，CPU单元将停止操作。 在执行STOP之前，您必须确认系统的安全性。<br />
            The CPU Unit will stop operation when STOP is executed. You must confirm the safety of the system before executing STOP.
            </remarks>
            <param name="omron">PLC设备的连接对象</param>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.StopAsync(HslCommunication.Core.IReadWriteDevice)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Stop(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitData(HslCommunication.Core.IReadWriteDevice)">
            <summary>
            <b>[商业授权]</b> 读取CPU的一些数据信息，主要包含型号，版本，一些数据块的大小<br />
            <b>[Authorization]</b> Read some data information of the CPU, mainly including the model, version, and the size of some data blocks
            </summary>
            <param name="omron">PLC设备的连接对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitDataAsync(HslCommunication.Core.IReadWriteDevice)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitData(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitStatus(HslCommunication.Core.IReadWriteDevice)">
            <summary>
            <b>[商业授权]</b> 读取CPU单元的一些操作状态数据，主要包含运行状态，工作模式，错误信息等。<br />
            <b>[Authorization]</b> Read some operating status data of the CPU unit, mainly including operating status, working mode, error information, etc.
            </summary>
            <param name="omron">PLC设备的连接对象</param>
            <returns>是否读取成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitStatusAsync(HslCommunication.Core.IReadWriteDevice)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitStatus(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsServer">
            <summary>
            <b>[商业授权]</b> 欧姆龙的虚拟服务器，支持DM区，CIO区，Work区，Hold区，Auxiliary区，可以方便的进行测试<br />
            <b>[Authorization]</b> Omron's virtual server supports DM area, CIO area, Work area, Hold area, and Auxiliary area, which can be easily tested
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.#ctor">
            <summary>
            实例化一个Fins协议的服务器<br />
            Instantiate a Fins protocol server
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsServer.DataFormat">
            <inheritdoc cref="P:HslCommunication.Core.ByteTransformBase.DataFormat"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ReadFromFinsCore(System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。<br />
            The method that should be triggered when a message of the mc protocol is received is allowed to be inherited and rewritten to achieve a custom return or data monitoring.
            </summary>
            <param name="finsCore">mc报文</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.PackCommand(System.Int32,System.Byte[],System.Byte[])">
            <summary>
            将核心报文打包的方法，追加报文头<br />
            The method of packing the core message, adding the message header
            </summary>
            <param name="status">错误码</param>
            <param name="finsCore">Fins的核心报文</param>
            <param name="data">核心的内容</param>
            <returns>完整的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.Dispose(System.Boolean)">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsUdp">
            <summary>
            欧姆龙的Udp协议的实现类，地址类型和Fins-TCP一致，无连接的实现，可靠性不如<see cref="T:HslCommunication.Profinet.Omron.OmronFinsNet"/><br />
            Omron's Udp protocol implementation class, the address type is the same as Fins-TCP, 
            and the connectionless implementation is not as reliable as <see cref="T:HslCommunication.Profinet.Omron.OmronFinsNet"/>
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Omron.OmronFinsNet" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.ICF">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.ICF"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.RSV">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.RSV"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.GCT">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.GCT"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.DNA">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DNA"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.DA1">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA1"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.DA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.SNA">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SNA"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.SA1">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA1"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.SA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.SID">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SID"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.ReadSplits">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.ReadSplits"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.PackCommand(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.PackCommand(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.ReadString(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Write(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Run">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Run(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Stop">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.Stop(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.ReadCpuUnitData">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitData(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.ReadCpuUnitStatus">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ReadCpuUnitStatus(HslCommunication.Core.IReadWriteDevice)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsUdpServer">
            <inheritdoc cref="T:HslCommunication.Profinet.Omron.OmronFinsServer"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdpServer.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdpServer.ReceiveCacheLength">
            <summary>
            获取或设置一次接收时的数据长度，默认2KB数据长度
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdpServer.ServerStart(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdpServer.PackCommand(System.Int32,System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdpServer.RefreshReceive">
            <summary>
            重新开始接收数据
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLink">
            <summary>
            欧姆龙的HostLink协议的实现，地址支持示例 DM区:D100; CIO区:C100; Work区:W100; Holding区:H100; Auxiliary区: A100<br />
            Implementation of Omron's HostLink protocol, address support example DM area: D100; CIO area: C100; Work area: W100; Holding area: H100; Auxiliary area: A100
            </summary>
            <remarks>
            感谢 深圳～拾忆 的测试，地址可以携带站号信息，例如 s=2;D100 
            <br />
            <note type="important">
            如果发现串口线和usb同时打开才能通信的情况，需要按照如下的操作：<br />
            串口线不是标准的串口线，电脑的串口线的235引脚分别接PLC的329引脚，45线短接，就可以通讯，感谢 深圳-小君(QQ932507362)提供的解决方案。
            </note>
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.ICF">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ICF"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.DA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.DA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.SA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.SID">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SID"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.ResponseWaitTime">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ResponseWaitTime"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.UnitNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnitNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.ReadSplits">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ReadSplits"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.SerialPortInni(System.String)">
            <summary>
            初始化串口信息，9600波特率，7位数据位，1位停止位，偶校验<br />
            Initial serial port information, 9600 baud rate, 7 data bits, 1 stop bit, even parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.SerialPortInni(System.String,System.Int32)">
            <summary>
            初始化串口信息，波特率，7位数据位，1位停止位，偶校验<br />
            Initializes serial port information, baud rate, 7-bit data bit, 1-bit stop bit, even parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLinkCMode">
            <summary>
            欧姆龙的HostLink的C-Mode实现形式，地址支持携带站号信息，例如：s=2;D100<br />
            Omron's HostLink C-Mode implementation form, the address supports carrying station number information, for example: s=2;D100
            </summary>
            <remarks>
            暂时只支持的字数据的读写操作，不支持位的读写操作。另外本模式下，程序要在监视模式运行才能写数据，欧姆龙官方回复的。
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkCMode.UnitNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnitNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ReadPlcType(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ReadPlcMode">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ReadPlcMode(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ChangePlcMode(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ChangePlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ChangePlcMode(System.Byte,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ChangePlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp">
            <summary>
            欧姆龙的HostLink的C-Mode实现形式，当前的类是通过以太网透传实现。地址支持携带站号信息，例如：s=2;D100<br />
            The C-Mode implementation form of Omron’s HostLink, the current class is realized through Ethernet transparent transmission. 
            Address supports carrying station number information, for example: s=2;D100
            </summary>
            <remarks>
            暂时只支持的字数据的读写操作，不支持位的读写操作。另外本模式下，程序要在监视模式运行才能写数据，欧姆龙官方回复的。
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.UnitNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnitNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.ReadPlcType(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.ReadPlcMode">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.ReadPlcMode(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ReadPlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.ChangePlcMode(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ChangePlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.ChangePlcMode(System.Byte,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.Helper.OmronHostLinkCModeHelper.ChangePlcMode(HslCommunication.Core.IReadWriteDevice,System.Byte,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer">
            <summary>
            欧姆龙的HostLinkCMode协议的虚拟服务器
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsServer.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer.UnitNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLink.UnitNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer.ReadFromFinsCore(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer.PackCommand(System.Int32,System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCModeServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp">
            <summary>
            欧姆龙的HostLink协议的实现，基于Tcp实现，地址支持示例 DM区:D100; CIO区:C100; Work区:W100; Holding区:H100; Auxiliary区: A100<br />
            Implementation of Omron's HostLink protocol, based on tcp protocol, address support example DM area: D100; CIO area: C100; Work area: W100; Holding area: H100; Auxiliary area: A100
            </summary>
            <remarks>
            感谢 深圳～拾忆 的测试，地址可以携带站号信息，例如 s=2;D100 
            <br />
            <note type="important">
            如果发现串口线和usb同时打开才能通信的情况，需要按照如下的操作：<br />
            串口线不是标准的串口线，电脑的串口线的235引脚分别接PLC的329引脚，45线短接，就可以通讯，感谢 深圳-小君(QQ932507362)提供的解决方案。
            </note>
            </remarks>
            <example>
            欧姆龙的地址参考如下：
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>DM Area</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>CIO Area</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Work Area</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Holding Bit Area</term>
                <term>H</term>
                <term>H100,H200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Auxiliary Bit Area</term>
                <term>A</term>
                <term>A100,A200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ICF">
            <summary>
            Specifies whether or not there are network relays. Set “80” (ASCII: 38,30) 
            when sending an FINS command to a CPU Unit on a network.Set “00” (ASCII: 30,30) 
            when sending to a CPU Unit connected directly to the host computer.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.DA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SID">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SID"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ResponseWaitTime">
            <summary>
            The response wait time sets the time from when the CPU Unit receives a command block until it starts 
            to return a response.It can be set from 0 to F in hexadecimal, in units of 10 ms.
            If F(15) is set, the response will begin to be returned 150 ms (15 × 10 ms) after the command block was received.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnitNumber">
            <summary>
            PLC设备的站号信息<br />
            PLC device station number information
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ReadSplits">
            <summary>
            进行字读取的时候对于超长的情况按照本属性进行切割，默认260。<br />
            When reading words, it is cut according to this attribute for the case of overlength. The default is 260.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLinkServer">
            <summary>
            <b>[商业授权]</b> 欧姆龙的HostLink虚拟服务器，支持DM区，CIO区，Work区，Hold区，Auxiliary区，可以方便的进行测试<br />
            <b>[Authorization]</b> Omron's HostLink virtual server supports DM area, CIO area, Work area, Hold area, and Auxiliary area, which can be easily tested
            </summary>
            <remarks>
            支持TCP的接口以及串口，方便客户端进行测试，或是开发用于教学的虚拟服务器对象
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkServer.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsServer.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkServer.UnitNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLink.UnitNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkServer.PackCommand(System.Int32,System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet">
            <summary>
            开放以太网协议，仍然在开发中<br />
            Open Ethernet protocol, still under development
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的IP地址及端口来初始化对象<br />
            Use the specified IP address and port to initialize the object
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.ReadCustomer(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            自定义的命令读取
            </summary>
            <param name="mid"></param>
            <param name="revison"></param>
            <param name="stationId"></param>
            <param name="spindleId"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.BuildReadCommand(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            构建一个读取的初始报文
            </summary>
            <param name="mid"></param>
            <param name="revison"></param>
            <param name="stationId"></param>
            <param name="spindleId"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper">
            <summary>
            Mewtocol协议的辅助类信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)">
            <summary>
            读取单个的地址信息的bool值，地址举例：SR0.0  X0.0  Y0.0  R0.0  L0.0<br />
            Read the bool value of a single address, for example: SR0.0 X0.0 Y0.0 R0.0 L0.0
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">起始地址</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <summary>
            批量读取松下PLC的位数据，按照字为单位，地址为 X0,X10,Y10，读取的长度为16的倍数<br />
            Read the bit data of Panasonic PLC in batches, the unit is word, the address is X0, X10, Y10, and the read length is a multiple of 16
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[])">
            <summary>
            批量读取松下PLC的位数据，传入一个读取的地址列表，地址支持X,Y,R,T,C,L, 举例：R1.0, X2.0, R3.A<br />
            Batch read the bit data of Panasonic PLC, pass in a read address list, the address supports X, Y, R, T, C, L, for example: R1.0, X2.0, R3.A
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">等待读取的地址列表，数组长度不限制</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean)">
            <summary>
            往指定的地址写入bool数据，地址举例：SR0.0  X0.0  Y0.0  R0.0  L0.0<br />
            Write bool data to the specified address. Example address: SR0.0 X0.0 Y0.0 R0.0 L0.0
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">起始地址</param>
            <param name="value">数据值信息</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])">
            <summary>
            往指定的地址写入 <see cref="T:System.Boolean"/> 数组，地址举例 X0.0  Y0.0  R0.0  L0.0，
            起始的位地址必须为16的倍数，写入的 <see cref="T:System.Boolean"/> 数组长度也为16的倍数。<br />
            Write the <see cref="T:System.Boolean"/> array to the specified address, address example: SR0.0 X0.0 Y0.0 R0.0 L0.0, 
            the starting bit address must be a multiple of 16. <see cref="T:System.Boolean"/> The length of the array is also a multiple of 16. <br />
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">起始地址</param>
            <param name="values">数据值信息</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[],System.Boolean[])">
            <summary>
            将Bool数组值写入到指定的离散地址里，一个地址对应一个bool值，地址数组长度和值数组长度必须相等，地址支持X,Y,R,T,C,L, 举例：R1.0, X2.0, R3.A<br />
            Write the Bool array value to the specified discrete address, one address corresponds to one bool value, 
            the length of the address array and the length of the value array must be equal, the address supports X, Y, R, T, C, L, for example: R1.0, X2.0, R3.A
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">离散的地址列表</param>
            <param name="value">bool数组值</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <summary>
            读取指定地址的原始数据，地址示例：D0  F0  K0  T0  C0, 地址支持携带站号的访问方式，例如：s=2;D100<br />
            Read the original data of the specified address, address example: D0 F0 K0 T0 C0, the address supports carrying station number information, for example: s=2;D100
            </summary>
            <param name="plc">PLC通信对象</param>
            <param name="station">站号信息</param>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <returns>原始的字节数据的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <summary>
            将数据写入到指定的地址里去，地址示例：D0  F0  K0  T0  C0, 地址支持携带站号的访问方式，例如：s=2;D100<br />
            Write data to the specified address, address example: D0 F0 K0 T0 C0, the address supports carrying station number information, for example: s=2;D100
            </summary>
            <param name="plc">PLC对象</param>
            <param name="station">站号信息</param>
            <param name="address">起始地址</param>
            <param name="value">真实数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[],System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[],System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicHelper">
            <summary>
            松下PLC的辅助类，提供了基本的辅助方法，用于解析地址，计算校验和，创建报文<br />
            The auxiliary class of Panasonic PLC provides basic auxiliary methods for parsing addresses, calculating checksums, and creating messages
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.CalculateComplexAddress(System.String)">
            <summary>
            位地址转换方法，101等同于10.1等同于10*16+1=161<br />
            Bit address conversion method, 101 is equivalent to 10.1 is equivalent to 10 * 16 + 1 = 161
            </summary>
            <param name="address">地址信息</param>
            <returns>实际的位地址信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址<br />
            Parse the data address, resolve the address type, start address
            </summary>
            <param name="address">数据地址</param>
            <returns>解析出地址类型，起始地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.PackPanasonicCommand(System.Byte,System.String,System.Boolean)">
            <summary>
            将松下的命令打包成带有%开头，CRC校验，CR结尾的完整的命令报文。如果参数 <c>useExpandedHeader</c> 设置为 <c>Ture</c>，则命令头使用 &lt; 开头
            </summary>
            <param name="station">站号信息</param>
            <param name="cmd">松下的命令。例如 RCSR100F</param>
            <param name="useExpandedHeader">设置是否使用扩展的命令头消息</param>
            <returns>原始的字节数组的命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildReadOneCoil(System.Byte,System.String)">
            <summary>
            创建读取离散触点的报文指令<br />
            Create message instructions for reading discrete contacts
            </summary>
            <param name="station">站号信息</param>
            <param name="address">地址信息</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildReadCoils(System.Byte,System.String[])">
            <summary>
            创建读取多个bool值得报文命令
            </summary>
            <param name="station">站号信息</param>
            <param name="address">等待读取的地址数组</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildWriteOneCoil(System.Byte,System.String,System.Boolean)">
            <summary>
            创建写入离散触点的报文指令<br />
            Create message instructions to write discrete contacts
            </summary>
            <param name="station">站号信息</param>
            <param name="address">地址信息</param>
            <param name="value">bool值数组</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildWriteCoils(System.Byte,System.String[],System.Boolean[])">
            <summary>
            创建写入多个离散触点的报文指令
            </summary>
            <param name="station">站号信息</param>
            <param name="address">等待写入的地址列表</param>
            <param name="value">等待写入的值列表，长度应和地址长度一致</param>
            <returns>所有写入命令的报文列表</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            创建批量读取触点的报文指令<br />
            Create message instructions for batch reading contacts
            </summary>
            <param name="station">站号信息</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBit">是否进行位为单位</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            创建批量读取触点的报文指令<br />
            Create message instructions for batch reading contacts
            </summary>
            <param name="station">设备站号</param>
            <param name="address">地址信息</param>
            <param name="values">数据值</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.ExtraActualData(System.Byte[])">
            <summary>
            检查从PLC反馈的数据，并返回正确的数据内容<br />
            Check the data feedback from the PLC and return the correct data content
            </summary>
            <param name="response">反馈信号</param>
            <returns>是否成功的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.ExtraActualBool(System.Byte[])">
            <summary>
            检查从PLC反馈的数据，并返回正确的数据内容<br />
            Check the data feedback from the PLC and return the correct data content
            </summary>
            <param name="response">反馈信号</param>
            <returns>是否成功的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.GetErrorDescription(System.Int32)">
            <summary>
            根据错误码获取到错误描述文本<br />
            Get the error description text according to the error code
            </summary>
            <param name="err">错误代码</param>
            <returns>字符信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.GetMcErrorDescription(System.Int32)">
            <summary>
            根据MC的错误码去查找对象描述信息
            </summary>
            <param name="code">错误码</param>
            <returns>描述信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicMcNet">
            <summary>
            松下PLC的数据读写类，基于MC协议的实现，具体的地址格式请参考备注说明<br />
            Data reading and writing of Panasonic PLC, based on the implementation of the MC protocol, please refer to the note for specific address format
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址示例一</term>
                <term>地址范围</term>
                <term>字操作</term>
                <term>位操作</term>
              </listheader>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X0000,X100F</term>
                <term>X0000～X109F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y0000,Y100F</term>
                <term>Y0000～Y109F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>L</term>
                <term>L0000,L100F</term>
                <term>L0000～L0127F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>内部继电器</term>
                <term>R</term>
                <term>R0000,R100F</term>
                <term>R0000～R511F,R9000～R951F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>数据存储器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>D0～D65532,D90000～D90999</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>特殊存储器</term>
                <term>SD</term>
                <term>SD100,SD200</term>
                <term>SD0～SD999</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>链路寄存器</term>
                <term>LD</term>
                <term>LD0,LD100</term>
                <term>LD0～LD255</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>定时器（当前值）</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>TN0～TN1023</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>定时器（接点）</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>TS0～TS1023</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>计数器（当前值）</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>CN0～CN1023</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>计数器（接点）</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>CS0～CS1023</term>
                <term>√</term>
                <term>√</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.#ctor">
            <summary>
            实例化松下的的Qna兼容3E帧协议的通讯对象<br />
            Instantiate Panasonic's Qna compatible 3E frame protocol communication object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址及端口号来实例化一个松下的Qna兼容3E帧协议的通讯对象<br />
            Specify an IP address and port number to instantiate a Panasonic Qna compatible 3E frame protocol communication object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicMewtocol">
            <summary>
            松下PLC的数据交互协议，采用Mewtocol协议通讯，支持的地址列表参考api文档<br />
            The data exchange protocol of Panasonic PLC adopts Mewtocol protocol for communication. For the list of supported addresses, refer to the api document.
            </summary>
            <remarks>
            地址支持携带站号的访问方式，例如：s=2;D100
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.#ctor(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.#ctor(System.Byte)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String[],System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[],System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBoolAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.WriteAsync(System.String[],System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String[],System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp">
            <summary>
            松下PLC的数据交互协议，采用Mewtocol协议通讯，基于Tcp透传实现的机制，支持的地址列表参考api文档<br />
            The data exchange protocol of Panasonic PLC adopts Mewtocol protocol for communication. 
            It is based on the mechanism of Tcp transparent transmission. For the list of supported addresses, refer to the api document.
            </summary>
            <remarks>
            地址支持携带站号的访问方式，例如：s=2;D100
            </remarks>
            <example>
            触点地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>外部输入继电器</term>
                <term>X</term>
                <term>X11,X1F</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>X33 等同于 X3.3</term>
              </item>
              <item>
                <term>外部输出继电器</term>
                <term>Y</term>
                <term>Y22,Y2A</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>Y21 等同于 Y2.1</term>
              </item>
              <item>
                <term>内部继电器</term>
                <term>R</term>
                <term>R0F,R100F</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>R21 等同于 R2.1</term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0,T100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0,C100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>L</term>
                <term>L0F,L100F</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>L21 等同于 L2.1</term>
              </item>
            </list>
            数据地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器 DT</term>
                <term>D</term>
                <term>D0,D100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器 LD</term>
                <term>LD</term>
                <term>LD0,LD100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器 FL</term>
                <term>F</term>
                <term>F0,F100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>目标值 SV</term>
                <term>S</term>
                <term>S0,S100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>经过值 EV</term>
                <term>K</term>
                <term>K0,K100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>索引寄存器 IX</term>
                <term>IX</term>
                <term>IX0,IX100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>索引寄存器 IY</term>
                <term>IY</term>
                <term>IY0,IY100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.#ctor(System.Byte)">
            <summary>
            实例化一个默认的松下PLC通信对象，默认站号为0xEE<br />
            Instantiate a default Panasonic PLC communication object, the default station number is 0xEE
            </summary>
            <param name="station">站号信息，默认为0xEE</param>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            实例化一个默认的松下PLC通信对象，指定ip地址，端口，默认站号为0xEE<br />
            Instantiate a default Panasonic PLC communication object, specify the IP address, port, and the default station number is 0xEE
            </summary>
            <param name="ipAddress">Ip地址数据</param>
            <param name="port">端口号</param>
            <param name="station">站号信息，默认为0xEE</param>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Station">
            <summary>
            PLC设备的目标站号，需要根据实际的设置来填写<br />
            The target station number of the PLC device needs to be filled in according to the actual settings
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String[],System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.Helper.MewtocolHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String[],System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBoolAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.WriteAsync(System.String[],System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String[],System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer">
            <summary>
            <b>[商业授权]</b> 松下Mewtocol协议的虚拟服务器，支持串口和网口的操作<br />
            <b>[Authorization]</b> Panasonic Mewtocol protocol virtual server, supports serial and network port operations
            </summary>
            <remarks>
            地址的地址分为线圈型和整型，线圈支持X,Y,R,L, 字单位的整型支持 X,Y,R,L,D,LD,F<br />
            The address of the address is divided into coil type and integer type, the coil supports X, Y, R, L, and the integer type of word unit supports X, Y, R, L, D, LD, F
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Read(System.String,System.UInt16)"/>
            <remarks>
            在服务器端的功能实现里，暂时不支持C,T数据的访问。<br />
            In the server-side function implementation, access to C and T data is temporarily not supported.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Byte[])"/>
            <remarks>
            在服务器端的功能实现里，暂时不支持C,T数据的访问。<br />
            In the server-side function implementation, access to C and T data is temporarily not supported.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String,System.UInt16)"/>
            <remarks>
            在服务器端的功能实现里，长度支持任意的长度信息。<br />
            In the server-side function implementation, the length supports arbitrary length information.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.CreateFailedResponse(System.Byte)">
            <summary>
            创建一个失败的返回消息，指定错误码即可，会自动计算出来BCC校验和
            </summary>
            <param name="code">错误码</param>
            <returns>原始字节报文，用于反馈消息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.ReadFromCommand(System.Byte[])">
            <summary>
            根据命令来获取相关的数据内容
            </summary>
            <param name="cmd">原始的命令码</param>
            <returns>返回的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Sick.SickIcrTcpServer">
            <summary>
            Sick的扫码器的服务器信息，只要启动服务器之后，扫码器配置将条码发送到PC的指定端口上来即可，就可以持续的接收条码信息，同样也适用于海康，基恩士，DATELOGIC 。<br />
            The server information of Sick's code scanner, as long as the server is started, the code scanner is configured to send the barcode to the designated port of the PC, and it can continuously receive the barcode information.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.#ctor">
            <summary>
            实例化一个默认的服务器对象<br />
            Instantiate a default server object
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Sick.SickIcrTcpServer.ReceivedBarCodeDelegate">
            <summary>
            接收条码数据的委托信息<br />
            Entrusted information to receive barcode data
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="barCode">条码信息</param>
        </member>
        <member name="E:HslCommunication.Profinet.Sick.SickIcrTcpServer.OnReceivedBarCode">
            <summary>
            当接收到条码数据的时候触发<br />
            Triggered when barcode data is received
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.AddConnectBarcodeScan(System.String,System.Int32)">
            <summary>
            新增一个主动连接的请求，将不会收到是否连接成功的信息，当网络中断及奔溃之后，会自动重新连接。<br />
            A new active connection request will not receive a message whether the connection is successful. When the network is interrupted and crashed, it will automatically reconnect.
            </summary>
            <param name="ipAddress">对方的Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="P:HslCommunication.Profinet.Sick.SickIcrTcpServer.OnlineCount">
            <summary>
            获取当前在线的客户端数量<br />
            Get the number of clients currently online
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper">
            <summary>
            西门子PPI协议的辅助类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址，DB块的地址<br />
            Parse data address, parse out address type, start address, db block address
            </summary>
            <param name="address">起始地址，例如M100，I0，Q0，V100 ->
            Start address, such as M100,I0,Q0,V100</param>
            <returns>解析数据地址，解析出地址类型，起始地址，DB块的地址 ->
            Parse data address, parse out address type, start address, db block address</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.BuildReadCommand(System.Byte,HslCommunication.Core.Address.S7AddressData,System.UInt16,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.BuildReadCommand(System.Byte,HslCommunication.Core.Address.S7AddressData,System.UInt16,System.Boolean)">
            <summary>
            生成一个读取字数据指令头的通用方法<br />
            A general method for generating a command header to read a Word data
            </summary>
            <param name="station">设备的站号信息 -> Station number information for the device</param>
            <param name="address">起始地址，例如M100，I0，Q0，V100 ->
            Start address, such as M100,I0,Q0,V100</param>
            <param name="length">读取数据长度 -> Read Data length</param>
            <param name="isBit">是否为位读取</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            生成一个写入PLC数据信息的报文内容
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址</param>
            <param name="values">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.GetMsgFromStatus(System.Byte)">
            <summary>
            根据错误代号信息，获取到指定的文本信息<br />
            According to the error code information, get the specified text information
            </summary>
            <param name="code">错误状态信息</param>
            <returns>消息文本</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.GetMsgFromStatus(System.Byte,System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="errorClass">错误类型</param>
            <param name="errorCode">错误代码</param>
            <returns>错误信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.BuildWriteCommand(System.Byte,System.String,System.Boolean[])">
            <summary>
            创建写入PLC的bool类型数据报文指令
            </summary>
            <param name="station">PLC的站号信息</param>
            <param name="address">地址信息</param>
            <param name="values">bool[]数据值</param>
            <returns>带有成功标识的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.CheckResponse(System.Byte[])">
            <summary>
            检查西门子PLC的返回的数据和合法性，对反馈的数据进行初步的校验
            </summary>
            <param name="content">服务器返回的原始的数据内容</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.GetExecuteConfirm(System.Byte)">
            <summary>
            根据站号信息获取命令二次确认的报文信息
            </summary>
            <param name="station">站号信息</param>
            <returns>二次命令确认的报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Byte,System.Object)">
            <summary>
            从西门子的PLC中读取数据信息，地址为"M100","AI100","I0","Q0","V100","S100"等<br />
            Read data information from Siemens PLC with addresses "M100", "AI100", "I0", "Q0", "V100", "S100", etc.
            </summary>
            <param name="plc">PLC的通信对象</param>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <param name="station">当前的站号信息</param>
            <param name="communicationLock">当前的同通信锁</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)">
            <summary>
            从西门子的PLC中读取bool数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等<br />
            Read bool data information from Siemens PLC, the addresses are "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc.
            </summary>
            <param name="plc">PLC的通信对象</param>
            <param name="address">西门子的地址数据信息</param>
            <param name="station">当前的站号信息</param>
            <param name="communicationLock">当前的同通信锁</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Byte,System.Object)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[],System.Byte,System.Object)">
            <summary>
            将字节数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等<br />
            Write byte data to Siemens PLC with addresses "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc.
            </summary>
            <param name="plc">PLC的通信对象</param>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <param name="station">当前的站号信息</param>
            <param name="communicationLock">当前的同通信锁</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean[],System.Byte,System.Object)">
            <summary>
            将bool数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等<br />
            Write the bool data to Siemens PLC with the addresses "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc.
            </summary>
            <param name="plc">PLC的通信对象</param>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <param name="station">当前的站号信息</param>
            <param name="communicationLock">当前的同通信锁</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Start(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)">
            <summary>
            启动西门子PLC为RUN模式，参数信息可以携带站号信息 "s=2;", 注意，分号是必须的。<br />
            Start Siemens PLC in RUN mode, parameter information can carry station number information "s=2;", note that the semicolon is required.
            </summary>
            <param name="plc">PLC的通信对象</param>
            <param name="parameter">额外的参数信息，例如可以携带站号信息 "s=2;", 注意，分号是必须的。</param>
            <param name="station">当前的站号信息</param>
            <param name="communicationLock">当前的同通信锁</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Stop(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)">
            <summary>
            停止西门子PLC，切换为Stop模式，参数信息可以携带站号信息 "s=2;", 注意，分号是必须的。<br />
            Stop Siemens PLC and switch to Stop mode, parameter information can carry station number information "s=2;", note that the semicolon is required.
            </summary>
            <param name="plc">PLC的通信对象</param>
            <param name="parameter">额外的参数信息，例如可以携带站号信息 "s=2;", 注意，分号是必须的。</param>
            <param name="station">当前的站号信息</param>
            <param name="communicationLock">当前的同通信锁</param>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)">
            <summary>
            读取西门子PLC的型号信息，参数信息可以携带站号信息 "s=2;", 注意，分号是必须的。<br />
            Read the model information of Siemens PLC, the parameter information can carry the station number information "s=2;", note that the semicolon is required.
            </summary>
            <param name="plc">PLC的通信对象</param>
            <param name="parameter">额外的参数信息，例如可以携带站号信息 "s=2;", 注意，分号是必须的。</param>
            <param name="station">当前的站号信息</param>
            <param name="communicationLock">当前的同通信锁</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensS7Helper.AnalysisReadBit(System.Byte[])">
            <summary>
            读取BOOL时，根据S7协议的返回报文，正确提取出实际的数据内容
            </summary>
            <param name="content">PLC返回的原始字节信息</param>
            <returns>解析之后的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.Helper.SiemensS7Helper.AnalysisReadByte(System.Byte[])">
            <summary>
            读取字数据时，根据S7协议返回的报文，解析出实际的原始字节数组信息
            </summary>
            <param name="content">PLC返回的原始字节数组</param>
            <returns>实际的结果数据对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensDateTime">
            <summary>
            Contains the methods to convert between <see cref="T:System.DateTime"/> and S7 representation of datetime values.
            </summary>
            <remarks>
            这部分的代码参考了另一个s7的库，感谢原作者，此处贴出出处，遵循 MIT 协议
            
            https://github.com/S7NetPlus/s7netplus
            </remarks>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensDateTime.SpecMinimumDateTime">
            <summary>
            The minimum <see cref="T:System.DateTime"/> value supported by the specification.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensDateTime.SpecMaximumDateTime">
            <summary>
            The maximum <see cref="T:System.DateTime"/> value supported by the specification.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensDateTime.FromByteArray(System.Byte[])">
            <summary>
            Parses a <see cref="T:System.DateTime"/> value from bytes.
            </summary>
            <param name="bytes">Input bytes read from PLC.</param>
            <returns>A <see cref="T:System.DateTime"/> object representing the value read from PLC.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of
              <paramref name="bytes"/> is not 8 or any value in <paramref name="bytes"/>
              is outside the valid range of values.</exception>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensDateTime.ToArray(System.Byte[])">
            <summary>
            Parses an array of <see cref="T:System.DateTime"/> values from bytes.
            </summary>
            <param name="bytes">Input bytes read from PLC.</param>
            <returns>An array of <see cref="T:System.DateTime"/> objects representing the values read from PLC.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of
              <paramref name="bytes"/> is not a multiple of 8 or any value in
              <paramref name="bytes"/> is outside the valid range of values.</exception>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensDateTime.ToByteArray(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> value to a byte array.
            </summary>
            <param name="dateTime">The DateTime value to convert.</param>
            <returns>A byte array containing the S7 date time representation of <paramref name="dateTime"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of
              <paramref name="dateTime"/> is before <see cref="P:SpecMinimumDateTime"/>
              or after <see cref="P:SpecMaximumDateTime"/>.</exception>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensDateTime.ToByteArray(System.DateTime[])">
            <summary>
            Converts an array of <see cref="T:System.DateTime"/> values to a byte array.
            </summary>
            <param name="dateTimes">The DateTime values to convert.</param>
            <returns>A byte array containing the S7 date time representations of <paramref name="dateTimes"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when any value of
              <paramref name="dateTimes"/> is before <see cref="P:SpecMinimumDateTime"/>
              or after <see cref="P:SpecMaximumDateTime"/>.</exception>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet">
            <summary>
            使用了Fetch/Write协议来和西门子进行通讯，该种方法需要在PLC侧进行一些配置<br />
            Using the Fetch/write protocol to communicate with Siemens, this method requires some configuration on the PLC side
            </summary>
            <remarks>
            配置的参考文章地址：https://www.cnblogs.com/dathlin/p/8685855.html
            <br />
            与S7协议相比较而言，本协议不支持对单个的点位的读写操作。如果读取M100.0，需要读取M100的值，然后进行提取位数据。
            
            如果需要写入位地址的数据，可以读取plc的byte值，然后进行与或非，然后写入到plc之中。
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.#ctor">
            <summary>
            实例化一个西门子的Fetch/Write协议的通讯对象<br />
            Instantiate a communication object for a Siemens Fetch/write protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个西门子的Fetch/Write协议的通讯对象<br />
            Instantiate a communication object for a Siemens Fetch/write protocol
            </summary>
            <param name="ipAddress">PLC的Ip地址 -> Specify IP Address</param>
            <param name="port">PLC的端口 -> Specify IP Port</param>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Read(System.String,System.UInt16)">
            <summary>
            从PLC读取数据，地址格式为I100，Q100，DB20.100，M100，T100，C100，以字节为单位<br />
            Read data from PLC, address format I100,Q100,DB20.100,M100,T100,C100, in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100，T100，C100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100,T100,C100
            </param>
            <param name="length">读取的数量，以字节为单位 -> The number of reads, in bytes</param>
            <returns>带有成功标志的字节信息 -> Byte information with a success flag</returns>
            <example>
            假设起始地址为M100，M100存储了温度，100.6℃值为1006，M102存储了压力，1.23Mpa值为123，M104，M105，M106，M107存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到PLC数据，地址格式为I100，Q100，DB20.100，M100，以字节为单位<br />
            Writes data to the PLC data, in the address format i100,q100,db20.100,m100, in bytes
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="value">要写入的实际数据 -> The actual data to write</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设起始地址为M100，M100,M101存储了温度，100.6℃值为1006，M102,M103存储了压力，1.23Mpa值为123，M104-M107存储了产量计数，写入如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.ReadByte(System.String)">
            <summary>
            读取指定地址的byte数据<br />
            Reads the byte data for the specified address
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <returns>byte类型的结果对象 -> Result object of type Byte</returns>
            <remarks>
            <note type="warning">
            不适用于DB块，定时器，计数器的数据读取，会提示相应的错误，读取长度必须为偶数
            </note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回是否写入成功<br />
            Writes byte data to the PLC and returns whether the write succeeded
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="value">要写入的实际数据 -> The actual data to write</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.CalculateAddressStarted(System.String)">
            <summary>
            计算特殊的地址信息<br />
            Calculate special address information
            </summary>
            <param name="address">字符串信息</param>
            <returns>实际值</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址，DB块的地址<br />
            Parse data address, parse out address type, start address, db block address
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <returns>解析出地址类型，起始地址，DB块的地址 -> Resolves address type, start address, db block address</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取字数据指令头的通用方法<br />
            A general method for generating a command header to read a Word data
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="count">读取数据个数 -> Number of Read data</param>
            <returns>带结果对象的报文数据 -> Message data with a result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.BuildWriteCommand(System.String,System.Byte[])">
            <summary>
            生成一个写入字节数据的指令<br />
            Generate an instruction to write byte data
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="data">实际的写入的内容 -> The actual content of the write</param>
            <returns>带结果对象的报文数据 -> Message data with a result object</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer">
            <summary>
            <b>[商业授权]</b> 西门子的Fetch/Write协议的虚拟PLC，可以用来调试通讯，也可以实现一个虚拟的PLC功能，从而开发一套带虚拟环境的上位机系统，可以用来演示，测试。<br />
            <b>[Authorization]</b> The virtual PLC of Siemens Fetch/Write protocol can be used for debugging communication, and can also realize a virtual PLC function, so as to develop a set of upper computer system with virtual environment, which can be used for demonstration and testing.
            </summary>
            <remarks>
            本虚拟服务器的使用需要企业商业授权，否则只能运行24小时。本协议实现的虚拟PLC服务器，主要支持I,Q,M,DB块的数据读写操作，例如 M100, DB1.100，服务器端也可以对位进行读写操作，例如M100.1，DB1.100.2；
            但是不支持连接的远程客户端对位进行操作。
            </remarks>
            <example>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>V寄存器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>V寄存器本质就是DB块1</term>
              </item>
            </list>
            本虚拟的PLC共有4个DB块，DB1.X, DB2.X, DB3.X, 和其他DB块。对于远程客户端的读写长度，暂时没有限制。
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.#ctor">
            <summary>
            实例化一个S7协议的服务器，支持I，Q，M，DB1.X, DB2.X, DB3.X 数据区块的读写操作<br />
            Instantiate a server with S7 protocol, support I, Q, M, DB1.X data block read and write operations
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensMPI">
            <summary>
            西门子的MPI协议信息，注意：未测试通过，无法使用<br />
            Siemens MPI protocol information, note: it has not passed the test and cannot be used
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.#ctor">
            <summary>
            实例化一个西门子的MPI协议对象<br />
            Instantiate a Siemens MPI protocol object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensMPI.Station">
            <summary>
            西门子PLC的站号信息<br />
            Siemens PLC station number information
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.Handle">
            <summary>
            与PLC进行握手<br />
            Handshake with PLC
            </summary>
            <returns>是否握手成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.Read(System.String,System.UInt16)">
            <summary>
            从西门子的PLC中读取数据信息，地址为"M100","AI100","I0","Q0","V100","S100"等，详细请参照API文档<br />
            Read data information from Siemens PLC, the address is "M100", "AI100", "I0", "Q0", "V100", "S100", etc., please refer to the API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.ReadBool(System.String,System.UInt16)">
            <summary>
            从西门子的PLC中读取bool数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档<br />
            Read the bool data information from Siemens PLC. The addresses are "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc. For details, please Refer to API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.Write(System.String,System.Byte[])">
            <summary>
            将字节数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档<br />
            Write byte data to Siemens PLC, the address is "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc. Refer to API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.ReadByte(System.String)">
            <summary>
            从西门子的PLC中读取byte数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档<br />
            Read byte data information from Siemens PLC. The addresses are "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc. For details, please Refer to API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.Write(System.String,System.Byte)">
            <summary>
            将byte数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档<br />
            Write byte data to Siemens PLC, the address is "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc. API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            生成一个读取字数据指令头的通用方法<br />
            A general method for generating a command header to read a Word data
            </summary>
            <param name="station">设备的站号信息 -> Station number information for the device</param>
            <param name="address">起始地址，例如M100，I0，Q0，V100 ->
            Start address, such as M100,I0,Q0,V100</param>
            <param name="length">读取数据长度 -> Read Data length</param>
            <param name="isBit">是否为位读取</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            生成一个写入PLC数据信息的报文内容<br />
            Generate a message content to write PLC data information
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址</param>
            <param name="values">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.GetMsgFromStatus(System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="code">状态</param>
            <returns>消息文本</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.GetMsgFromStatus(System.Byte,System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="errorClass">错误类型</param>
            <param name="errorCode">错误代码</param>
            <returns>错误信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensPLCS">
            <summary>
            西门子的PLC类型，目前支持的访问类型
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S1200">
            <summary>
            1200系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S300">
            <summary>
            300系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S400">
            <summary>
            400系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S1500">
            <summary>
            1500系列PLC
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S200Smart">
            <summary>
            200的smart系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S200">
            <summary>
            200系统，需要额外配置以太网模块
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensPPI">
            <summary>
            西门子的PPI协议，适用于s7-200plc，注意，由于本类库的每次通讯分成2次操作，内部增加了一个同步锁，所以单次通信时间比较久，另外，地址支持携带站号，例如：s=2;M100<br />
            Siemens' PPI protocol is suitable for s7-200plc. Note that since each communication of this class library is divided into two operations, 
            and a synchronization lock is added inside, the single communication time is relatively long. In addition, 
            the address supports carrying the station number, for example : S=2;M100
            </summary>
            <remarks>
            适用于西门子200的通信，非常感谢 合肥-加劲 的测试，让本类库圆满完成。注意：M地址范围有限 0-31地址<br />
            在本类的<see cref="T:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp"/>实现类里，如果使用了Async的异步方法，没有增加同步锁，多线程调用可能会引发数据错乱的情况。<br />
            In the <see cref="T:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp"/> implementation class of this class, if the asynchronous method of Async is used, 
            the synchronization lock is not added, and multi-threaded calls may cause data disorder.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.#ctor">
            <summary>
            实例化一个西门子的PPI协议对象<br />
            Instantiate a Siemens PPI protocol object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensPPI.Station">
            <summary>
            西门子PLC的站号信息<br />
            Siemens PLC station number information
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Read(HslCommunication.Core.IReadWriteDevice,System.String,System.UInt16,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte[],System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Write(HslCommunication.Core.IReadWriteDevice,System.String,System.Boolean[],System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadByte(System.String)">
            <summary>
            从西门子的PLC中读取byte数据信息，地址为"M100","AI100","I0","Q0","V100","S100"等，详细请参照API文档<br />
            Read byte data information from Siemens PLC. The addresses are "M100", "AI100", "I0", "Q0", "V100", "S100", etc. Please refer to the API documentation for details.
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte)">
            <summary>
            向西门子的PLC中写入byte数据，地址为"M100","AI100","I0","Q0","V100","S100"等，详细请参照API文档<br />
            Write byte data from Siemens PLC with addresses "M100", "AI100", "I0", "Q0", "V100", "S100", etc. For details, please refer to the API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadBoolAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Start(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Start(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Stop(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.Stop(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadPlcType(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp">
            <inheritdoc cref="T:HslCommunication.Profinet.Siemens.SiemensPPI"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口号来实例化对象<br />
            Instantiate the object with the specified IP address and port number
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Siemens.SiemensPPI.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadBoolAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Start(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Start(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Stop(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Stop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadPlcType(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.StartAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Start(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.StopAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Stop(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadPlcTypeAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.Helper.SiemensPPIHelper.ReadPlcType(HslCommunication.Core.IReadWriteDevice,System.String,System.Byte,System.Object)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensPPIServer">
            <summary>
            PPIServer的虚拟服务器对象，支持的地址类型和S7虚拟服务器一致
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensPPIServer.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.IsNeedShakeHands">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.PackReadBack(System.Byte[],System.Collections.Generic.List{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.PackWriteBack(System.Byte[],System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.DealWithSerialReceivedData(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensS7Net">
            <summary>
            一个西门子的客户端类，使用S7协议来进行数据交互，对于s300,s400需要关注<see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Slot"/>和<see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Rack"/>的设置值，
            对于s200，需要关注<see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.LocalTSAP"/>和<see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.DestTSAP"/>的设置值，详细参考demo的设置。 <br />
            A Siemens client class uses the S7 protocol for data exchange. For s300 and s400, 
            you need to pay attention to the setting values of <see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Slot"/> and <see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Rack"/>. For s200, 
            you need to pay attention to <see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Slot"/> and <see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Rack"/>. See cref="LocalTSAP"/> and <see cref="P:HslCommunication.Profinet.Siemens.SiemensS7Net.DestTSAP"/> settings, 
            please refer to the demo settings for details.
            </summary>
            <remarks>
            暂时不支持bool[]的批量写入操作，请使用 Write(string, byte[]) 替换。<br />
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100，当然了你也可以输入V100</note><br />
            如果读取PLC的字符串string数据，可以使用 <see cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadString(System.String)"/>
            </remarks>
            <example>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>V寄存器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>V寄存器本质就是DB块1</term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>仅在200smart测试通过</term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>仅在200smart测试通过</term>
              </item>
              <item>
                <term>智能输入寄存器</term>
                <term>AI</term>
                <term>AI100,AI200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>智能输出寄存器</term>
                <term>AQ</term>
                <term>AQ100,AQ200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100</note>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="Usage2" title="简单的长连接使用" />
            
            假设起始地址为M100，M100存储了温度，100.6℃值为1006，M102存储了压力，1.23Mpa值为123，M104，M105，M106，M107存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample1" title="Read示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteExample1" title="Write示例" />
            以下是一个复杂的读取示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample3" title="Read示例" />
            在西门子PLC，字符串分为普通的string，和WString类型，前者为单字节的类型，后者为双字节的字符串类型<br />
            一个字符串除了本身的数据信息，还有字符串的长度信息，比如字符串 "12345"，比如在PLC的地址 DB1.0 存储的字节是 FE 05 31 32 33 34 35, 第一个字节是最大长度，第二个字节是当前长度，后面的才是字符串的数据信息。<br />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadWriteString" title="字符串读写示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.#ctor(HslCommunication.Profinet.Siemens.SiemensPLCS)">
            <summary>
            实例化一个西门子的S7协议的通讯对象 <br />
            Instantiate a communication object for a Siemens S7 protocol
            </summary>
            <param name="siemens">指定西门子的型号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.#ctor(HslCommunication.Profinet.Siemens.SiemensPLCS,System.String)">
            <summary>
            实例化一个西门子的S7协议的通讯对象并指定Ip地址 <br />
            Instantiate a communication object for a Siemens S7 protocol and specify an IP address
            </summary>
            <param name="siemens">指定西门子的型号</param>
            <param name="ipAddress">Ip地址</param>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Initialization(HslCommunication.Profinet.Siemens.SiemensPLCS,System.String)">
            <summary>
            初始化方法<br />
            Initialize method
            </summary>
            <param name="siemens">指定西门子的型号 -> Designation of Siemens</param>
            <param name="ipAddress">Ip地址 -> IpAddress</param>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Slot">
            <summary>
            PLC的槽号，针对S7-400的PLC设置的<br />
            The slot number of PLC is set for PLC of s7-400
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Rack">
            <summary>
            PLC的机架号，针对S7-400的PLC设置的<br />
            The frame number of the PLC is set for the PLC of s7-400
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.ConnectionType">
            <summary>
            获取或设置当前PLC的连接方式，PG: 0x01，OP: 0x02，S7Basic: 0x03...0x10<br />
            Get or set the current PLC connection mode, PG: 0x01, OP: 0x02, S7Basic: 0x03...0x10
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.LocalTSAP">
            <summary>
            西门子相关的本地TSAP参数信息<br />
            A parameter information related to Siemens
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.DestTSAP">
            <summary>
            西门子相关的远程TSAP参数信息<br />
            A parameter information related to Siemens
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.PDULength">
            <summary>
            获取当前西门子的PDU的长度信息，不同型号PLC的值会不一样。<br />
            Get the length information of the current Siemens PDU, the value of different types of PLC will be different.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadOrderNumber">
            <summary>
            从PLC读取订货号信息<br />
            Reading order number information from PLC
            </summary>
            <returns>CPU的订货号信息 -> Order number information for the CPU</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadOrderNumberAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadOrderNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.HotStart">
            <summary>
            对PLC进行热启动，目前仅适用于200smart型号<br />
            Hot start for PLC, currently only applicable to 200smart model
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ColdStart">
            <summary>
            对PLC进行冷启动，目前仅适用于200smart型号<br />
            Cold start for PLC, currently only applicable to 200smart model
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Stop">
            <summary>
            对PLC进行停止，目前仅适用于200smart型号<br />
            Stop the PLC, currently only applicable to the 200smart model
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.HotStartAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.HotStart"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ColdStartAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ColdStart"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.StopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Stop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)">
            <summary>
            从PLC读取原始的字节数据，地址格式为I100，Q100，DB20.100，M100，长度参数以字节为单位<br />
            Read the original byte data from the PLC, the address format is I100, Q100, DB20.100, M100, length parameters in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100<br />
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="length">读取的数量，以字节为单位<br />
            The number of reads, in bytes</param>
            <returns>
            是否读取成功的结果对象 <br />
            Whether to read the successful result object</returns>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Siemens.SiemensS7Net" path="note"/>
            </remarks>
            <example>
            假设起始地址为M100，M100存储了温度，100.6℃值为1006，M102存储了压力，1.23Mpa值为123，M104，M105，M106，M107存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBitFromPLC(System.String)">
            <summary>
            从PLC读取数据，地址格式为I100，Q100，DB20.100，M100，以位为单位 ->
            Read the data from the PLC, the address format is I100，Q100，DB20.100，M100, in bits units
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String[],System.UInt16[])">
            <summary>
            一次性从PLC获取所有的数据，按照先后顺序返回一个统一的Buffer，需要按照顺序处理，两个数组长度必须一致，数组长度无限制<br />
            One-time from the PLC to obtain all the data, in order to return a unified buffer, need to be processed sequentially, two array length must be consistent
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100<br />
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="length">数据长度数组<br />
            Array of data Lengths</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <remarks>
            <note type="warning">原先的批量的长度为19，现在已经内部自动处理整合，目前的长度为任意和长度。</note>
            </remarks>
            <example>
            以下是一个高级的读取示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample3" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(HslCommunication.Core.Address.S7AddressData[])">
            <summary>
            读取西门子的地址数据信息，支持任意个数的数据读取<br />
            Read Siemens address data information, support any number of data reading
            </summary>
            <param name="s7Addresses">
            西门子的数据地址<br />
            Siemens data address</param>
            <returns>返回的结果对象信息 -> Whether to read the successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadS7AddressData(HslCommunication.Core.Address.S7AddressData[])">
            <summary>
            单次的读取，只能读取最多19个数组的长度，所以不再对外公开该方法
            </summary>
            <param name="s7Addresses">西门子的地址对象</param>
            <returns>返回的结果对象信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteBase(System.Byte[])">
            <summary>
            基础的写入数据的操作支持<br />
            Operational support for the underlying write data
            </summary>
            <param name="entireValue">完整的字节数据 -> Full byte data</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到PLC数据，地址格式为I100，Q100，DB20.100，M100，以字节为单位<br />
            Writes data to the PLC data, in the address format I100,Q100,DB20.100,M100, in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="value">写入的原始数据 -> Raw data written to</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设起始地址为M100，M100,M101存储了温度，100.6℃值为1006，M102,M103存储了压力，1.23Mpa值为123，M104-M107存储了产量计数，写入如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBitFromPLCAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBitFromPLC(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadAsync(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadAsync(HslCommunication.Core.Address.S7AddressData[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(HslCommunication.Core.Address.S7AddressData[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadS7AddressDataAsync(HslCommunication.Core.Address.S7AddressData[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadS7AddressData(HslCommunication.Core.Address.S7AddressData[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteBaseAsync(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteBase(System.Byte[])" />
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String)">
            <summary>
            读取指定地址的bool数据，地址格式为I100，M100，Q100，DB20.100<br />
            reads bool data for the specified address in the format I100，M100，Q100，DB20.100
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <remarks>
            <note type="important">
            对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100
            </note>
            </remarks>
            <example>
            假设读取M100.0的位是否通断
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String,System.UInt16)">
            <summary>
            读取指定地址的bool数组，地址格式为I100，M100，Q100，DB20.100<br />
            reads bool array data for the specified address in the format I100，M100，Q100，DB20.100
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="length">读取的长度信息</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <remarks>
            <note type="important">
            对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100
            </note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean)">
            <summary>
            写入PLC的一个位，例如"M100.6"，"I100.7"，"Q100.0"，"DB20.100.0"，如果只写了"M100"默认为"M100.0"<br />
            Write a bit of PLC, for example  "M100.6",  "I100.7",  "Q100.0",  "DB20.100.0", if only write  "M100" defaults to  "M100.0"
            </summary>
            <param name="address">起始地址，格式为"M100.6",  "I100.7",  "Q100.0",  "DB20.100.0" ->
            Start address, format  "M100.6",  "I100.7",  "Q100.0",  "DB20.100.0"</param>
            <param name="value">写入的数据，True或是False -> Writes the data, either True or False</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设写入M100.0的位是否通断
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean[])">
            <summary>
            [警告] 向PLC中写入bool数组，比如你写入M100,那么data[0]对应M100.0，写入的长度应该小于1600位<br />
            [Warn] Write the bool array to the PLC, for example, if you write M100, then data[0] corresponds to M100.0, 
            The length of the write should be less than 1600 bits
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 -> Starting address, formatted as I100,mM100,Q100,DB20.100</param>
            <param name="values">要写入的bool数组，长度为8的倍数 -> The bool array to write, a multiple of 8 in length</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <remarks>
            <note type="warning">
            批量写入bool数组存在一定的风险，举例写入M100.5的值 [true,false,true,true,false,true]，会读取M100-M101的byte[]，然后修改中间的位，再写入回去，
            如果读取之后写入之前，PLC修改了其他位，则会影响其他的位的数据，请谨慎使用。<br />
            There is a certain risk in batch writing bool arrays. For example, writing the value of M100.5 [true,false,true,true,false,true], 
            will read the byte[] of M100-M101, then modify the middle bit, and then Write back. 
            If the PLC modifies other bits after reading and before writing, it will affect the data of other bits. Please use it with caution.
            </note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadByte(System.String)">
            <summary>
            读取指定地址的byte数据，地址格式I100，M100，Q100，DB20.100<br />
            Reads the byte data of the specified address, the address format I100,Q100,DB20.100,M100
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <example>参考<see cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)"/>的注释</example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回值说明<br />
            Write byte data to the PLC, return value description
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 -> Starting address, formatted as I100,mM100,Q100,DB20.100</param>
            <param name="value">byte数据 -> Byte data</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteWString(System.String,System.String)">
            <summary>
            使用双字节编码的方式，将字符串以 Unicode 编码写入到PLC的地址里，可以使用中文。<br />
            Use the double-byte encoding method to write the character string to the address of the PLC in Unicode encoding. Chinese can be used.
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 -> Starting address, formatted as I100,mM100,Q100,DB20.100</param>
            <param name="value">字符串的值</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadString(System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadString(System.String,System.Text.Encoding)">
            <summary>
            读取西门子的地址的字符串信息，这个信息是和西门子绑定在一起，长度随西门子的信息动态变化的<br />
            Read the Siemens address string information. This information is bound to Siemens and its length changes dynamically with the Siemens information
            </summary>
            <remarks>
            如果指定编码，一般<see cref="P:System.Text.Encoding.ASCII"/>即可，中文需要 Encoding.GetEncoding("gb2312")
            </remarks>
            <param name="address">数据地址，具体的格式需要参照类的说明文档</param>
            <param name="encoding">自定的编码信息，一般<see cref="P:System.Text.Encoding.ASCII"/>即可，中文需要 Encoding.GetEncoding("gb2312")</param>
            <returns>带有是否成功的字符串结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadWString(System.String)">
            <summary>
            读取西门子的地址的字符串信息，这个信息是和西门子绑定在一起，长度随西门子的信息动态变化的<br />
            Read the Siemens address string information. This information is bound to Siemens and its length changes dynamically with the Siemens information
            </summary>
            <param name="address">数据地址，具体的格式需要参照类的说明文档</param>
            <returns>带有是否成功的字符串结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteWStringAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteWString(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadStringAsync(System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadString(System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadWStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadWString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadDateTime(System.String)">
            <summary>
            从PLC中读取时间格式的数据<br />
            Read time format data from PLC
            </summary>
            <param name="address">地址</param>
            <returns>时间对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.DateTime)">
            <summary>
            向PLC中写入时间格式的数据<br />
            Writes data in time format to the PLC
            </summary>
            <param name="address">地址</param>
            <param name="dateTime">时间</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadDateTimeAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadDateTime(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteAsync(System.String,System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.BuildReadCommand(HslCommunication.Core.Address.S7AddressData[])">
            <summary>
            A general method for generating a command header to read a Word data
            </summary>
            <param name="s7Addresses">siemens address</param>
            <returns>Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.BuildBitReadCommand(System.String)">
            <summary>
            生成一个位读取数据指令头的通用方法 ->
            A general method for generating a bit-read-Data instruction header
            </summary>
            <param name="address">起始地址，例如M100.0，I0.1，Q0.1，DB2.100.2 ->
            Start address, such as M100.0,I0.1,Q0.1,DB2.100.2
            </param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.BuildWriteByteCommand(HslCommunication.Core.Address.S7AddressData,System.Byte[])">
            <summary>
            生成一个写入字节数据的指令 -> Generate an instruction to write byte data
            </summary>
            <param name="s7Address">起始地址，示例M100,I100,Q100,DB1.100 -> Start Address, example M100,I100,Q100,DB1.100</param>
            <param name="data">原始的字节数据 -> Raw byte data</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.BuildWriteBitCommand(System.String,System.Boolean)">
            <summary>
            生成一个写入位数据的指令 -> Generate an instruction to write bit data
            </summary>
            <param name="address">起始地址，示例M100,I100,Q100,DB1.100 -> Start Address, example M100,I100,Q100,DB1.100</param>
            <param name="data">是否通断 -> Power on or off</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensS7Server">
            <summary>
            <b>[商业授权]</b> 西门子S7协议的虚拟服务器，支持TCP协议，模拟的是1200的PLC进行通信，在客户端进行操作操作的时候，最好是选择1200的客户端对象进行通信。<br />
            <b>[Authorization]</b> The virtual server of Siemens S7 protocol supports TCP protocol. It simulates 1200 PLC for communication. When the client is operating, it is best to select the 1200 client object for communication.
            </summary>
            <remarks>
            本西门子的虚拟PLC仅限商业授权用户使用，感谢支持。
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100</note>
            </remarks>
            <example>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>V寄存器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>V寄存器本质就是DB块1</term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
            </list>
            你可以很快速并且简单的创建一个虚拟的s7服务器
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="UseExample1" title="简单的创建服务器" />
            当然如果需要高级的服务器，指定日志，限制客户端的IP地址，获取客户端发送的信息，在服务器初始化的时候就要参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="UseExample4" title="定制服务器" />
            服务器创建好之后，我们就可以对服务器进行一些读写的操作了，下面的代码是基础的BCL类型的读写操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="ReadWriteExample" title="基础的读写示例" />
            高级的对于byte数组类型的数据进行批量化的读写操作如下：   
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="BytesReadWrite" title="字节的读写示例" />
            更高级操作请参见源代码。
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.#ctor">
            <summary>
            实例化一个S7协议的服务器，支持I，Q，M，DB1.X, DB2.X, DB3.X 数据区块的读写操作<br />
            Instantiate a server with S7 protocol, support I, Q, M, DB1.X data block read and write operations
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.GetDataAreaFromS7Address(HslCommunication.Core.Address.S7AddressData)">
            <summary>
            根据S7格式的地址，获取当前的数据缓存类对象
            </summary>
            <param name="s7Address">S7格式的数据地址信息</param>
            <returns>内存缓存对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.IsNeedShakeHands">
            <summary>
            获取是否需要进行握手报文信息
            </summary>
            <returns>是否需要进行握手操作</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.PackReadBack(System.Byte[],System.Collections.Generic.List{System.Byte})">
            <summary>
            将读取的结果数据内容进行打包，返回客户端读取
            </summary>
            <param name="command">接收的命令信息</param>
            <param name="content">读取的原始字节信息</param>
            <returns>返回客户端的原始报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.PackWriteBack(System.Byte[],System.Byte)">
            <summary>
            创建返回的报文信息
            </summary>
            <param name="packCommand">接收到的报文命令</param>
            <param name="status">返回的状态信息</param>
            <returns>返回的原始字节数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensWebApi">
            <summary>
            西门子的基于WebApi协议读写数据对象，支持对PLC的标签进行读取，适用于1500系列，该数据标签需要共享开放出来。<br />
            Siemens reads and writes data objects based on the WebApi protocol, supports reading PLC tags, 
            and is suitable for the 1500 series. The data tags need to be shared and opened.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.#ctor">
            <summary>
            实例化一个默认的西门子WebApi通信对象<br />
            Instantiate a default Siemens WebApi communication object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址及端口号来实例化一个对象，端口号默认使用443，如果是http访问，使用80端口号<br />
            Use the specified ip address and port number to instantiate an object, the port number is 443 by default, if it is http access, port 80 is used
            </summary>
            <param name="ipAddress">ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.AddRequestHeaders(System.Net.Http.Headers.HttpContentHeaders)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServer">
            <summary>
            根据设置好的用户名和密码信息，登录远程的PLC，返回是否登录成功！在读写之前，必须成功调用当前的方法，获取到token，否则无法进行通信。<br />
            According to the set user name and password information, log in to the remote PLC, and return whether the login is successful! 
            Before reading and writing, the current method must be successfully called to obtain the token, 
            otherwise communication cannot be carried out.
            </summary>
            <returns>是否连接成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectClose">
            <summary>
            和PLC断开当前的连接信息，主要是使得Token信息失效。<br />
            Disconnecting the current connection information from the PLC mainly makes the token information invalid.
            </summary>
            <returns>是否断开成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServerAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServer"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectCloseAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectClose"/>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensWebApi.Token">
            <summary>
            当前PLC的通信令牌，当调用<see cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServer"/>时，会自动获取，当然你也可以手动赋值一个合法的令牌，跳过<see cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServer"/>直接进行读写操作。<br />
            The communication token of the current PLC will be automatically obtained when <see cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServer"/> is called. Of course, 
            you can also manually assign a valid token, skip <see cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServer"/> and read it directly Write operation.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Read(System.String,System.UInt16)">
            <summary>
            从PLC中根据输入的数据标签名称，读取出原始的字节数组信息，长度参数无效，需要二次解析<br />
            According to the input data tag name, read the original byte array information from the PLC, 
            the length parameter is invalid, and a second analysis is required
            </summary>
            <param name="address">标签的地址信息，例如 "全局DB".Static_21</param>
            <param name="length">无效的参数</param>
            <returns>原始的字节数组信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadByte(System.String)">
            <summary>
            从PLC中根据输入的数据标签名称，按照类型byte进行读取出数据信息<br />
            According to the input data tag name from the PLC, read the data information according to the type byte
            </summary>
            <param name="address">标签的地址信息，例如 "全局DB".Static_21</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.Byte[])">
            <summary>
            将原始的字节数组信息写入到PLC的指定的数据标签里，写入方式为raw写入，是否写入成功取决于PLC的返回信息<br />
            Write the original byte array information to the designated data tag of the PLC. 
            The writing method is raw writing. Whether the writing is successful depends on the return information of the PLC.
            </summary>
            <param name="address">标签的地址信息，例如 "全局DB".Static_21</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功写入PLC的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.Byte)">
            <summary>
            写入<see cref="T:System.Byte"/>数组数据，返回是否成功<br />
            Write <see cref="T:System.Byte"/> array data, return whether the write was successful
            </summary>
            <param name="address">标签的地址信息，例如 "全局DB".Static_21</param>
            <param name="value">写入值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否成功<br />
            Batch write <see cref="T:System.Boolean"/> array data, return whether the write was successful
            </summary>
            <param name="address">标签的地址信息，例如 "全局DB".Static_21</param>
            <param name="value">写入值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadString(System.String,System.UInt16)">
            <summary>
            从PLC中读取字符串内容，需要指定数据标签名称，使用JSON方式读取，所以无论字符串是中英文都是支持读取的。<br />
            To read the string content from the PLC, you need to specify the data tag name and use JSON to read it, 
            so no matter whether the string is in Chinese or English, it supports reading.
            </summary>
            <param name="address">标签的地址信息，例如 "全局DB".Static_21</param>
            <param name="length">无效参数</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.String)">
            <summary>
            将字符串信息写入到PLC中，需要指定数据标签名称，如果PLC指定了类型为WString，才支持写入中文，否则会出现乱码。<br />
            To write string information into the PLC, you need to specify the data tag name. 
            If the PLC specifies the type as WString, it supports writing in Chinese, otherwise garbled characters will appear.
            </summary>
            <param name="address">标签的地址信息，例如 "全局DB".Static_21</param>
            <param name="value">字符串数据信息</param>
            <returns>是否成功写入</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadOperatingMode">
            <summary>
            读取当前PLC的操作模式，如果读取成功，结果将会是如下值之一：STOP, STARTUP, RUN, HOLD, -<br />
            Read the current operating mode of the PLC. If the reading is successful, 
            the result will be one of the following values: STOP, STARTUP, RUN, HOLD,-
            </summary>
            <returns>结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadOperatingModeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadOperatingMode"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Read(System.String[])">
            <summary>
            <b>[商业授权]</b> 从PLC读取多个地址的数据信息，每个地址的数据类型可以不一致，需要自动从<see cref="T:Newtonsoft.Json.Linq.JToken"/>中提取出正确的数据<br />
            <b>[Authorization]</b> Read the data information of multiple addresses from the PLC, the data type of each address can be inconsistent, 
            you need to automatically extract the correct data from <see cref="T:Newtonsoft.Json.Linq.JToken"/>
            </summary>
            <remarks>
            一旦中间有一个地址失败了，本方法就会返回失败，所以在调用本方法时，需要确保所有的地址正确。
            </remarks>
            <param name="address">"全局DB".Static_21</param>
            <returns>返回是否读取成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Read(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadDateTime(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadDateTime(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadDateTimeAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadDateTime(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.WriteAsync(System.String,System.DateTime)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Write(System.String,System.DateTime)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadVersion">
            <summary>
            <b>[商业授权]</b> 读取PLC的RPC接口的版本号信息<br />
            <b>[Authorization]</b> Read the version number information of the PLC's RPC interface
            </summary>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadVersionAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadVersion"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadPing">
            <summary>
            <b>[商业授权]</b> 对PLC对象进行PING操作<br />
            <b>[Authorization]</b> PING the PLC object
            </summary>
            <returns>是否PING成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadPingAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ReadPing"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Logout">
            <summary>
            从PLC退出登录，当前的token信息失效，需要再次调用<see cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServer"/>获取新的token信息才可以。<br />
            Log out from the PLC, the current token information is invalid, you need to call <see cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.ConnectServer"/> again to get the new token information.
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensWebApi.LogoutAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensWebApi.Logout"/>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoSerial">
            <summary>
            托利多电子秤的串口服务器对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.SerialPortInni(System.String)">
            <summary>
            初始化串口信息，9600波特率，8位数据位，1位停止位，无奇偶校验<br />
            Initial serial port information, 9600 baud rate, 8 data bits, 1 stop bit, no parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.SerialPortInni(System.String,System.Int32)">
            <summary>
            初始化串口信息，波特率，8位数据位，1位停止位，无奇偶校验<br />
            Initializes serial port information, baud rate, 8-bit data bit, 1-bit stop bit, no parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.SerialPortInni(System.String,System.Int32,System.Int32,System.IO.Ports.StopBits,System.IO.Ports.Parity)">
            <summary>
            初始化串口信息，波特率，数据位，停止位，奇偶校验需要全部自己来指定<br />
            Start serial port information, baud rate, data bit, stop bit, parity all need to be specified
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
            <param name="dataBits">数据位</param>
            <param name="stopBits">停止位</param>
            <param name="parity">奇偶校验</param>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.SerialPortInni(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            根据自定义初始化方法进行初始化串口信息<br />
            Initialize the serial port information according to the custom initialization method
            </summary>
            <param name="initi">初始化的委托方法</param>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.Open">
            <summary>
            打开一个新的串行端口连接<br />
            Open a new serial port connection
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.IsOpen">
            <summary>
            获取一个值，指示串口是否处于打开状态<br />
            Gets a value indicating whether the serial port is open
            </summary>
            <returns>是或否</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.Close">
            <summary>
            关闭当前的串口连接<br />
            Close the current serial connection
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoSerial.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoSerial.RtsEnable">
            <summary>
            获取或设置一个值，该值指示在串行通信中是否启用请求发送 (RTS) 信号。<br />
            Gets or sets a value indicating whether the request sending (RTS) signal is enabled in serial communication.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoSerial.PortName">
            <summary>
            当前连接串口信息的端口号名称<br />
            The port name of the current connection serial port information
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoSerial.BaudRate">
            <summary>
            当前连接串口信息的波特率<br />
            Baud rate of current connection serial port information
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoSerial.ToledoStandardDataReceivedDelegate">
            <summary>
            托利多数据接收时的委托
            </summary>
            <param name="sender">数据发送对象</param>
            <param name="toledoStandardData">数据对象</param>
        </member>
        <member name="E:HslCommunication.Profinet.Toledo.ToledoSerial.OnToledoStandardDataReceived">
            <summary>
            当接收到一条新的托利多的数据的时候触发
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoStandardData">
            <summary>
            托利多标准格式的数据类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoStandardData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoStandardData.#ctor(System.Byte[])">
            <summary>
            从缓存里加载一个标准格式的对象
            </summary>
            <param name="buffer">缓存</param>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Suttle">
            <summary>
            为 True 则是净重，为 False 则为毛重
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Symbol">
            <summary>
            为 True 则是正，为 False 则为负
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.BeyondScope">
            <summary>
            是否在范围之外
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.DynamicState">
            <summary>
            是否为动态，为 True 则是动态，为 False 则为稳态
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Unit">
            <summary>
            单位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.IsPrint">
            <summary>
            是否打印
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.IsTenExtend">
            <summary>
            是否10被扩展
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Weight">
            <summary>
            重量
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Tare">
            <summary>
            皮重
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.SourceData">
            <summary>
            解析数据的原始字节
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoStandardData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoTcpServer">
            <summary>
            托利多电子秤的TCP服务器，启动服务器后，等待电子秤的数据连接。
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoTcpServer.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoTcpServer.HasChk">
            <summary>
            获取或设置当前的报文否是含有校验的，默认为含有校验
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoTcpServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoTcpServer.ToledoStandardDataReceivedDelegate">
            <summary>
            托利多数据接收时的委托
            </summary>
            <param name="sender">数据发送对象</param>
            <param name="toledoStandardData">数据对象</param>
        </member>
        <member name="E:HslCommunication.Profinet.Toledo.ToledoTcpServer.OnToledoStandardDataReceived">
            <summary>
            当接收到一条新的托利多的数据的时候触发
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoTcpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Turck.ReaderNet">
            <summary>
            Reader协议的实现
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.#ctor">
            <summary>
            实例化默认的构造方法<br />
            Instantiate the default constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口来实例化一个对象<br />
            Instantiate an object with the specified IP address and port
            </summary>
            <param name="ipAddress">设备的Ip地址</param>
            <param name="port">设备的端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReceiveByMessage(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReceiveByMessageAsync(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Turck.ReaderNet.UID">
            <summary>
            获取设备的唯一的UID信息，本值会在连接上PLC之后自动赋值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Turck.ReaderNet.NumberOfBlock">
            <summary>
            获取当前设备的数据块总数量，本值会在连接上PLC之后自动赋值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Turck.ReaderNet.BytesOfBlock">
            <summary>
            获取当前设备的每个数据块拥有的字节数，本值会在连接上PLC之后自动赋值
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReadByte(System.String)">
            <summary>
            读取指定地址的byte数据
            </summary>
            <param name="address">起始地址</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <example>参考<see cref="M:HslCommunication.Profinet.Turck.ReaderNet.Read(System.String,System.UInt16)"/>的注释</example>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.Write(System.String,System.Byte)">
            <summary>
            向设备中写入byte数据，返回值说明<br />
            </summary>
            <param name="address">起始地址</param>
            <param name="value">byte数据 -> Byte data</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReadByteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Turck.ReaderNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.WriteAsync(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Turck.ReaderNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReadRFIDInfo">
            <summary>
            读取载码体信息，并将读取的信息进行初始化
            </summary>
            <returns>返回UID信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ReadRFIDInfoAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Turck.ReaderNet.ReadRFIDInfo"/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.ParseAddress(System.String,System.Boolean)">
            <summary>
            将字符串的地址解析出实际的整数地址，如果是位地址，支持使用小数点的形式 例如100.1
            </summary>
            <param name="address">地址信息</param>
            <param name="isBit">是否位地址</param>
            <returns>整数地址信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.CheckResponseACK(System.Byte[])">
            <summary>
            检查当前的设备的返回的数据是否是ACK消息
            </summary>
            <param name="content">设备的数据信息</param>
            <returns>是否是ACK内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.CalculateCRC(System.Byte[],System.Int32)">
            <summary>
            计算缓存数据里的CRC校验信息，并返回CRC计算的结果
            </summary>
            <param name="data">数据信息</param>
            <param name="len">计算的长度信息</param>
            <returns>CRC计算结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.CalculateAndFillCRC(System.Byte[],System.Int32)">
            <summary>
            计算并填充CRC校验到原始数据中去
            </summary>
            <param name="data">原始的数据信息</param>
            <param name="len">计算的长度信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.CheckCRC(System.Byte[],System.Int32)">
            <summary>
            校验当前数据的CRC校验是否正确
            </summary>
            <param name="data">原始数据信息</param>
            <param name="len">长度数据信息</param>
            <returns>校验结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.PackReaderCommand(System.Byte[])">
            <summary>
            将普通的命令打造成图尔克的reader协议完整命令
            </summary>
            <param name="command">命令信息</param>
            <returns>完整的命令包</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.BuildReadCommand(System.Byte,System.Byte,System.Byte)">
            <summary>
            构建读取的数据块的命令信息，一次最多读取64个字节
            </summary>
            <param name="startBlock">需要读取的起始 Block。从 0 开始。</param>
            <param name="numberBlock">需要读取的 Block 数量。 从 0 开始。</param>
            <param name="bytesOfBlock">每个数据块占用的字节数</param>
            <returns>完整的命令报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderNet.BuildWriteCommand(System.Byte,System.Byte,System.Byte,System.Byte[])">
            <summary>
            构建写入数据块的命令信息，一次最多写入64个字节
            </summary>
            <param name="startBlock">需要读取的起始 Block。从 0 开始。</param>
            <param name="numberBlock">需要读取的 Block 数量。 从 0 开始。</param>
            <param name="bytesOfBlock">每个数据块占用的字节数</param>
            <param name="value">写入的数据</param>
            <returns>完整的写入的命令报文信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Turck.ReaderServer">
            <summary>
            图尔克reader协议的虚拟服务器
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderServer.#ctor">
            <summary>
            实例化一个默认的图尔克虚拟服务器
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Turck.ReaderServer.BytesOfBlock">
            <summary>
            获取或设置每个block占用的字节数信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Turck.ReaderServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Vigor.Helper.VigorHelper">
            <summary>
            丰炜PLC的辅助方法
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
            <remarks>
            支持字地址，单次最多读取64字节，支持D,SD,R,T,C的数据读取，同时地址支持携带站号信息，s=2;D100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
            <remarks>
            需要输入位地址，最多读取1024位，支持X,Y,M,SM,S,TS(定时器触点),TC（定时器线圈）,CS(计数器触点),CC（计数器线圈）
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
            <remarks>
            支持字地址，单次最多读取64字节，支持D,SD,R,T,C的数据写入，其中C199~C200不能连续写入，前者是16位计数器，后者是32位计数器
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
            <remarks>
            支持位地址的写入，支持X,Y,M,SM,S,TS(定时器触点),TC（定时器线圈）,CS(计数器触点),CC（计数器线圈）
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.ReadAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.ReadBoolAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.WriteAsync(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="T:HslCommunication.Profinet.Vigor.Helper.VigorVsHelper">
            <summary>
            丰炜PLC的辅助类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorVsHelper.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            构建读取的报文命令，对于字地址，单次最多读取64字节，支持D,SD,R,T,C的数据读取，对于位地址，最多读取1024位，支持X,Y,M,SM,S,TS(定时器触点),TC（定时器线圈）,CS(计数器触点),CC（计数器线圈）<br />
            Construct a read message command. For word addresses, up to 64 bytes can be read at a time, and data reading of D, SD, R, T, and C is supported. For bit addresses, 
            up to 1024 bits are read, and X, Y are supported. , M, SM, S, TS (timer contact), TC (timer coil), CS (counter contact), CC (counter coil)
            </summary>
            <param name="station">站号信息</param>
            <param name="address">PLC的数据地址</param>
            <param name="length">读取的长度</param>
            <param name="isBool">是否进行位读取</param>
            <returns>完整的读取的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorVsHelper.BuildWriteWordCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            构建以字单位写入的报文，单次最多写入64个word，地址支持 D,SD,R,T,C，对于C200~C255,是属于32位的计数器<br />
            Construct a message written in word units, and write up to 64 words in a single time. The address supports D, SD, R, T, C. For C200~C255, it is a 32-bit counter
            </summary>
            <param name="station">站号信息</param>
            <param name="address">PLC的地址</param>
            <param name="value">写入的原始数据</param>
            <returns>写入命令的完整报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorVsHelper.BuildWriteBoolCommand(System.Byte,System.String,System.Boolean[])">
            <summary>
            构建以位单位写入的报文，单次最多写入1024bit，支持X,Y,M,SM,S,TS(定时器触点),TC（定时器线圈）,CS(计数器触点),CC（计数器线圈）
            </summary>
            <param name="station">站号信息</param>
            <param name="address">PLC的地址</param>
            <param name="value">等待写入的bool数组</param>
            <returns>写入位数据的完整报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.Helper.VigorVsHelper.CheckResponseContent(System.Byte[])">
            <summary>
            检查从PLC返回的报文是否正确，以及提取出正确的结果数据
            </summary>
            <param name="response">PLC返回的报文</param>
            <returns>提取的结果数据内容</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Vigor.VigorSerial">
            <summary>
            丰炜通信协议的串口通信，支持VS系列，地址支持携带站号，例如 s=2;D100, 字地址支持 D,SD,R,T,C(C200-C255是32位寄存器), 位地址支持X,Y,M,SM,S,TS(定时器触点),TC（定时器线圈）,CS(计数器触点),CC（计数器线圈)<br />
            The network port transparent transmission version of Fengwei communication protocol supports VS series, and the address supports carrying station number, 
            such as s=2;D100, word address supports D, SD, R, T, C (C200-C255 are 32-bit registers), Bit address supports X, Y, M, SM, S, TS (timer contact), 
            TC (timer coil), CS (counter contact), CC (counter coil)
            </summary>
            <remarks>
            串口默认的参数为 19200波特率，8 - N - 1方式，暂时不支持对字寄存器(D,R)进行读写位操作，感谢随时关注库的更新日志
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerial.GetWordLength(System.String,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerial.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Vigor.VigorSerial.Station">
            <summary>
            获取或设置当前PLC的站号信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerial.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerial.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerial.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Vigor.VigorSerialOverTcp">
            <summary>
            丰炜通信协议的网口透传版本，支持VS系列，地址支持携带站号，例如 s=2;D100, 字地址支持 D,SD,R,T,C(C200-C255是32位寄存器), 位地址支持X,Y,M,SM,S,TS(定时器触点),TC（定时器线圈）,CS(计数器触点),CC（计数器线圈)<br />
            The network port transparent transmission version of Fengwei communication protocol supports VS series, and the address supports carrying station number, 
            such as s=2;D100, word address supports D, SD, R, T, C (C200-C255 are 32-bit registers), Bit address supports X, Y, M, SM, S, TS (timer contact), 
            TC (timer coil), CS (counter contact), CC (counter coil)
            </summary>
            <remarks>
            暂时不支持对字寄存器(D,R)进行读写位操作，感谢随时关注库的更新日志
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.#ctor">
            <summary>
            实例化默认的构造方法<br />
            Instantiate the default constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口来实例化一个对象<br />
            Instantiate an object with the specified IP address and port
            </summary>
            <param name="ipAddress">设备的Ip地址</param>
            <param name="port">设备的端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.ReceiveByMessage(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.ReceiveByMessageAsync(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Vigor.VigorSerial.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Read(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.ReadBool(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.Helper.VigorHelper.Write(HslCommunication.Core.IReadWriteDevice,System.Byte,System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorSerialOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Vigor.VigorServer">
            <summary>
            丰炜的虚拟PLC，模拟了VS系列的通信，可以和对应的客户端进行数据读写测试，位地址支持 X,Y,M,S，字地址支持 D,R,SD
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.#ctor">
            <summary>
            实例化一个丰炜PLC的网口和串口服务器，支持数据读写操作
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Vigor.VigorServer.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Vigor.VigorSerial.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.VigorSerial.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.VigorSerial.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Vigor.VigorSerial.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.ReceiveByMessage(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.ReceiveByMessageAsync(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Vigor.VigorServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.XINJE.XinJEHelper">
            <summary>
            信捷PLC的相关辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEHelper.PraseXinJEAddress(HslCommunication.Profinet.XINJE.XinJESeries,System.String,System.Byte)">
            <summary>
            根据信捷PLC的地址，解析出转换后的modbus协议信息
            </summary>
            <param name="series">PLC的系列信息</param>
            <param name="address">汇川plc的地址信息</param>
            <param name="modbusCode">原始的对应的modbus信息</param>
            <returns>还原后的modbus地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEHelper.PraseXinJEXCAddress(System.String,System.String,System.Byte)">
            <summary>
            根据信捷PLC的地址，解析出转换后的modbus协议信息，适用XC系列
            </summary>
            <param name="station">站号的特殊指定信息，可以为空</param>
            <param name="address">信捷plc的地址信息</param>
            <param name="modbusCode">原始的对应的modbus信息</param>
            <returns>还原后的modbus地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEHelper.PraseXinJEXD1XD2XD3XL1XL3Address(System.String,System.String,System.Byte)">
            <summary>
            解析信捷的XD1,XD2,XD3,XL1,XL3系列的PLC的Modbus地址和内部软元件的对照
            </summary>
            <remarks>适用 XD1、XD2、XD3、XL1、XL3、XD5、XDM、XDC、XD5E、XDME、XL5、XL5E、XLME, XDH 只是支持的地址范围不一样而已</remarks>
            <param name="station">站号的特殊指定信息，可以为空</param>
            <param name="address">PLC内部的软元件的地址</param>
            <param name="modbusCode">默认的Modbus功能码</param>
            <returns>解析后的Modbus地址</returns>
        </member>
        <member name="T:HslCommunication.Profinet.XINJE.XinJEInternalNet">
            <summary>
            信捷内部的TCP信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.#ctor">
            <summary>
            实例化一个XINJE-Tcp协议的客户端对象<br />
            Instantiate a client object of the Modbus-Tcp protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化<br />
            Specify the server address, port number, and client's own station number to initialize
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.XINJE.XinJEInternalNet.Station">
            <summary>
            获取或者重新修改服务器的默认站号信息，当然，你可以再读写的时候动态指定，参见备注<br />
            Get or modify the default station number information of the server. Of course, you can specify it dynamically when reading and writing, see note
            </summary>
            <remarks>
            当你调用 ReadCoil("100") 时，对应的站号就是本属性的值，当你调用 ReadCoil("s=2;100") 时，就忽略本属性的值，读写寄存器的时候同理
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.XINJE.XinJEInternalNet.DataFormat">
            <inheritdoc cref="P:HslCommunication.Core.ByteTransformBase.DataFormat"/>
        </member>
        <member name="P:HslCommunication.Profinet.XINJE.XinJEInternalNet.IsStringReverse">
            <summary>
            字符串数据是否按照字来反转，默认为False<br />
            Whether the string data is reversed according to words. The default is False.
            </summary>
            <remarks>
            字符串按照2个字节的排列进行颠倒，根据实际情况进行设置
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.XINJE.XinJEInternalNet.MessageId">
            <summary>
            获取协议自增的消息号，你可以自定义modbus的消息号的规则，详细参见<see cref="T:HslCommunication.Profinet.XINJE.XinJEInternalNet"/>说明，也可以查找<see cref="T:HslCommunication.BasicFramework.SoftIncrementCount"/>说明。<br />
            Get the message number incremented by the modbus protocol. You can customize the rules of the message number of the modbus. For details, please refer to the description of <see cref = "T:HslCommunication.ModBus.ModbusTcpNet" />, or you can find the description of <see cref = "T:HslCommunication.BasicFramework.SoftIncrementCount" />
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            地址支持 D100, SD100, TD100, CD100, HD100, FD100, ETD100, HTD100, HCD100, HSD100, 各自的地址范围取决于实际PLC的范围，比如D的地址在XLH型号上可达 0~499999<br />
            Address support D100, SD100, TD100, CD100, HD100, FD100, ETD100, HTD100, HCD100, HSD100, the respective address range depends on the actual PLC range, for example, the address of D can reach 0~499999 on the XLH model
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            地址支持 M100, X100, Y100, SM100, T100, C100, HM100, HS100, HT100, HSC100 各自的地址范围取决于实际PLC的范围，比如M的地址在XLH型号上可达 0~199999<br />
            The address supports M100, X100, Y100, SM100, T100, C100, HM100, HS100, HT100, HSC100, the respective address range depends on the actual PLC range, for example, the address of M can reach 0~199999 on the XLH model
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
            <remarks>
            地址支持 D100, SD100, TD100, CD100, HD100, FD100, ETD100, HTD100, HCD100, HSD100,  各自的地址范围取决于实际PLC的范围，比如D的地址在XLH型号上可达 0~499999<br />
            Address support D100, SD100, TD100, CD100, HD100, FD100, ETD100, HTD100, HCD100, HSD100,  the respective address range depends on the actual PLC range, for example, the address of D can reach 0~499999 on the XLH model
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
            <remarks>
            地址支持 M100, Y100, SM100, T100, C100, 各自的地址范围取决于实际PLC的范围，比如M的地址在XLH型号上可达 0~199999<br />
            The address supports M100, Y100, SM100, T100, C100, the respective address range depends on the actual PLC range, for example, the address of M can reach 0~199999 on the XLH model
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEInternalNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.XINJE.XinJEServer">
            <summary>
            信捷内部TCP的虚拟服务器类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEServer.#ctor">
            <summary>
            实例化一个默认参数的mc协议的服务器<br />
            Instantiate a mc protocol server with default parameters
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEServer.PackCommand(System.Byte[],System.UInt16,System.Byte[])">
            <summary>
            将状态码，数据打包成一个完成的回复报文信息
            </summary>
            <param name="command">原始的命令数据</param>
            <param name="status">状态信息</param>
            <param name="data">数据</param>
            <returns>状态信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJEServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.XINJE.XinJESerialOverTcp">
            <summary>
            信捷PLC的XC,XD,XL系列的串口转网口通讯类，虽然硬件层走的是TCP协议，但是底层使用ModbusRtu协议实现，每个系列支持的地址类型及范围不一样，详细参考API文档<br />
            Xinje PLC's XC, XD, XL series serial port to network port communication type, although the hardware layer uses TCP protocol, 
            but the bottom layer is implemented by ModbusRtu protocol. The address types and ranges supported by each series are different. 
            Please refer to the API documentation for details.
            </summary>
            <remarks>
            对于XC系列适用于XC1/XC2/XC3/XC5/XCM/XCC系列，线圈支持X,Y,S,M,T,C，寄存器支持D,F,E,T,C<br />
            对于XD,XL系列适用于XD1/XD2/XD3/XD5/XDM/XDC/XD5E/XDME/XDH/XL1/XL3/XL5/XL5E/XLME，
            线圈支持X,Y,S,M,SM,T,C,ET,SEM,HM,HS,HT,HC,HSC 寄存器支持D,ID,QD,SD,TD,CD,ETD,HD,HSD,HTD,HCD,HSCD,FD,SFD,FS<br />
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.XINJE.XinJESerial" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerialOverTcp.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerialOverTcp.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            通过指定站号，ip地址，端口号来实例化一个新的对象
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="station">站号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerialOverTcp.#ctor(HslCommunication.Profinet.XINJE.XinJESeries,System.String,System.Int32,System.Byte)">
            <summary>
            通过指定站号，IP地址，端口以及PLC的系列来实例化一个新的对象<br />
            Instantiate a new object by specifying the station number and PLC series
            </summary>
            <param name="series">PLC的系列</param>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="station">站号信息</param>
        </member>
        <member name="P:HslCommunication.Profinet.XINJE.XinJESerialOverTcp.Series">
            <summary>
            获取或设置当前的信捷PLC的系列，默认XC系列
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerialOverTcp.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerialOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.XINJE.XinJESeries">
            <summary>
            信捷PLC的不同系列的枚举
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.XINJE.XinJESeries.XC">
            <summary>
            XC系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.XINJE.XinJESeries.XD">
            <summary>
            XD系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.XINJE.XinJESeries.XL">
            <summary>
            XL系列
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.XINJE.XinJESerial">
            <summary>
            信捷PLC的XC,XD,XL系列的串口通讯类，底层使用ModbusRtu协议实现，每个系列支持的地址类型及范围不一样，详细参考API文档<br />
            XC, XD, XL series serial communication of Xinje PLC, the bottom layer is implemented by ModbusRtu protocol, 
            the address type and range supported by each series are different, please refer to the API document for details
            </summary>
            <remarks>
            对于XC系列适用于XC1/XC2/XC3/XC5/XCM/XCC系列，线圈支持X,Y,S,M,T,C，寄存器支持D,F,E,T,C<br />
            对于XD,XL系列适用于XD1/XD2/XD3/XD5/XDM/XDC/XD5E/XDME/XDH/XL1/XL3/XL5/XL5E/XLME，
            线圈支持X,Y,S,M,SM,T,C,ET,SEM,HM,HS,HT,HC,HSC 寄存器支持D,ID,QD,SD,TD,CD,ETD,HD,HSD,HTD,HCD,HSCD,FD,SFD,FS<br />
            </remarks>
            地址可以携带站号访问，例如 s=2;M100
            <example>
            以下是XC1/XC2/XC3/XC5/XCM/XCC系列的地址内容
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M0-M7999，M8000-M8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>流程继电器</term>
                <term>S</term>
                <term>S0-S1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T618</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C634</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X1037 或者X0.0-X103.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y1037 或者Y0.0-Y103.7</term>
                <term>8</term>
                <term></term>
              </item>
            </list>
            寄存器、 字元件、字变量地址定义：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>Flash寄存器</term>
                <term>F</term>
                <term>F0-F5000;F8000-F8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>扩展内部寄存器</term>
                <term>E</term>
                <term>E0-E36863</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T618</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C634</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            <c>我们再来看看XD1、 XD2、 XD3、 XL1、 XL3 系列，支持的地址类型和地址范围如下：</c><br />
            线圈、 位元件、位变量地址定义
            <list type = "table" >
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄电器</term>
                <term>M</term>
                <term>M0-M7999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X77,X10000-X11177,X20000-X20177,X30000-X30077 或者X0.0-X37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y77,Y10000-Y11177,Y20000-Y20177,Y30000-Y30077 或者Y0.0-Y37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SM</term>
                <term>SM0-SM2047</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T575</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C575</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ET</term>
                <term>ET0-ET31</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SEM</term>
                <term>SEM0-SEM31</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HM</term>
                <term>HM0-HM959</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HS</term>
                <term>HS0-HS127</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HT</term>
                <term>HT0-HT95</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HC</term>
                <term>HT0-HC95</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSC</term>
                <term>HST0-HSC31</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            寄存器、 字元件、字变量地址定义：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D7999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ID</term>
                <term>ID0-ID99，ID10000-ID10999，ID20000-ID20199,ID30000-ID30099</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>QD</term>
                <term>QD0-QD99，QD10000-QD10999，QD20000-QD20199,QD30000-QD30099</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SD</term>
                <term>SD0-SD2047</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>TD</term>
                <term>TD0-TD575</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>CD</term>
                <term>CD0-CD575</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ETD</term>
                <term>ETD0-ETD31</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HD</term>
                <term>HD0-HD999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSD</term>
                <term>HSD0-HSD499</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HTD</term>
                <term>HTD0-HTD95</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HCD</term>
                <term>HCD0-HCD95</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSCD</term>
                <term>HSCD0-HSCD31</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>FD</term>
                <term>FD0-FD5119</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SFD</term>
                <term>SFD0-SFD1999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>FSD</term>
                <term>FS0-FS47</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            <c>我们再来看看XD5、 XDM、 XDC、 XD5E、 XDME、 XL5、 XL5E、 XLME 系列，支持的地址类型和地址范围如下：</c><br />
            线圈、 位元件、位变量地址定义
            <list type = "table" >
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄电器</term>
                <term>M</term>
                <term>M0-M20479</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X77,X10000-X11777,X20000-X20177,X30000-X30077 或者X0.0-X37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y77,Y10000-Y11777,Y20000-Y20177,Y30000-Y30077 或者Y0.0-Y37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S7999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SM</term>
                <term>SM0-SM4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ET</term>
                <term>ET0-ET39</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SEM</term>
                <term>SEM0-SEM127</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HM</term>
                <term>HM0-HM6143</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HS</term>
                <term>HS0-HS999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HT</term>
                <term>HT0-HT1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HC</term>
                <term>HT0-HC1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSC</term>
                <term>HST0-HSC39</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            寄存器、 字元件、字变量地址定义：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D20479</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ID</term>
                <term>ID0-ID99，ID10000-ID11599，ID20000-ID20199,ID30000-ID30099</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>QD</term>
                <term>QD0-QD99，QD10000-QD11599，QD20000-QD20199,QD30000-QD30099</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SD</term>
                <term>SD0-SD4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>TD</term>
                <term>TD0-TD4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>CD</term>
                <term>CD0-CD4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ETD</term>
                <term>ETD0-ETD39</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HD</term>
                <term>HD0-HD6143</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSD</term>
                <term>HSD0-HSD1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HTD</term>
                <term>HTD0-HTD1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HCD</term>
                <term>HCD0-HCD1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSCD</term>
                <term>HSCD0-HSCD39</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>FD</term>
                <term>FD0-FD8191</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SFD</term>
                <term>SFD0-SFD4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>FSD</term>
                <term>FS0-FS47</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            <c>我们再来看看XDH  系列，支持的地址类型和地址范围如下：</c><br />
            线圈、 位元件、位变量地址定义
            <list type = "table" >
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄电器</term>
                <term>M</term>
                <term>M0-M20479</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X77,X10000-X11777,X20000-X20077 或者X0.0-X37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y77,Y10000-Y11777,Y20000-Y20077 或者Y0.0-Y37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S7999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SM</term>
                <term>SM0-SM4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ET</term>
                <term>ET0-ET39</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SEM</term>
                <term>SEM0-SEM127</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HM</term>
                <term>HM0-HM6143</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HS</term>
                <term>HS0-HS999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HT</term>
                <term>HT0-HT1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HC</term>
                <term>HT0-HC1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSC</term>
                <term>HST0-HSC39</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            寄存器、 字元件、字变量地址定义：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D20479</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ID</term>
                <term>ID0-ID99，ID10000-ID11599，ID20000-ID20099</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>QD</term>
                <term>QD0-QD99，QD10000-QD11599，QD20000-QD20099</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SD</term>
                <term>SD0-SD4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>TD</term>
                <term>TD0-TD4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>CD</term>
                <term>CD0-CD4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>ETD</term>
                <term>ETD0-ETD39</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HD</term>
                <term>HD0-HD6143</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSD</term>
                <term>HSD0-HSD1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HTD</term>
                <term>HTD0-HTD1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HCD</term>
                <term>HCD0-HCD1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>HSCD</term>
                <term>HSCD0-HSCD39</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>FD</term>
                <term>FD0-FD8191</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SFD</term>
                <term>SFD0-SFD4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>FSD</term>
                <term>FS0-FS47</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerial.#ctor(System.Byte)">
            <summary>
            指定客户端自己的站号来初始化<br />
            Specify the client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerial.#ctor(HslCommunication.Profinet.XINJE.XinJESeries,System.Byte)">
            <summary>
            通过指定站号以及PLC的系列来实例化一个新的对象<br />
            Instantiate a new object by specifying the station number and PLC series
            </summary>
            <param name="series">PLC的系列</param>
            <param name="station">站号信息</param>
        </member>
        <member name="P:HslCommunication.Profinet.XINJE.XinJESerial.Series">
            <summary>
            获取或设置当前的信捷PLC的系列，默认XC系列
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerial.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJESerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.XINJE.XinJETcpNet">
            <summary>
            信捷PLC的XC,XD,XL系列的网口通讯类，底层使用ModbusTcp协议实现，每个系列支持的地址类型及范围不一样，详细参考API文档<br />
            XC, XD, XL series of Xinje PLC's network port communication class, the bottom layer is realized by ModbusTcp protocol, 
            each series supports different address types and ranges, please refer to the API document for details
            </summary>
            <remarks>
            对于XC系列适用于XC1/XC2/XC3/XC5/XCM/XCC系列，线圈支持X,Y,S,M,T,C，寄存器支持D,F,E,T,C<br />
            对于XD,XL系列适用于XD1/XD2/XD3/XD5/XDM/XDC/XD5E/XDME/XDH/XL1/XL3/XL5/XL5E/XLME，
            线圈支持X,Y,S,M,SM,T,C,ET,SEM,HM,HS,HT,HC,HSC 寄存器支持D,ID,QD,SD,TD,CD,ETD,HD,HSD,HTD,HCD,HSCD,FD,SFD,FS<br />
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.Profinet.XINJE.XinJESerial" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            通过指定站号，ip地址，端口号来实例化一个新的对象
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="station">站号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.#ctor(HslCommunication.Profinet.XINJE.XinJESeries,System.String,System.Int32,System.Byte)">
            <summary>
            通过指定站号，IP地址，端口以及PLC的系列来实例化一个新的对象<br />
            Instantiate a new object by specifying the station number and PLC series
            </summary>
            <param name="series">PLC的系列</param>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="station">站号信息</param>
        </member>
        <member name="P:HslCommunication.Profinet.XINJE.XinJETcpNet.Series">
            <summary>
            获取或设置当前的信捷PLC的系列，默认XC系列
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.TranslateToModbusAddress(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.Write(System.String,System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.Write(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.WriteAsync(System.String,System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.WriteAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.XINJE.XinJETcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Yamatake.DigitronCPL">
            <summary>
            日本山武的数字指示调节器，目前适配SDC40B
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPL.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Yamatake.DigitronCPL.Station">
            <summary>
            获取或设置当前的站号信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPL.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPL.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPL.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPL.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp">
            <summary>
            山武的数字指定调节器的通信协议，基于CPL转网口的实现，测试型号 SDC40B
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp.Station">
            <summary>
            获取或设置当前的站号信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Yamatake.DigitronCPLServer">
            <summary>
            <b>[商业授权]</b> 山武的数字指示调节器的虚拟设备，支持和HSL本身进行数据通信测试<br />
            <b>[Authorization]</b> Yamatake’s digital indicating regulator is a virtual device that supports data communication testing with HSL itself
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLServer.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Yamatake.DigitronCPLServer.Station">
            <summary>
            获取或设置当前虚拟仪表的站号信息，如果站号不一致，将不予访问<br />
            Get or set the station number information of the current virtual instrument. If the station number is inconsistent, it will not be accessed
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLServer.CheckSerialReceiveDataComplete(System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.DigitronCPLServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Yamatake.Helper.DigitronCPLHelper">
            <summary>
            辅助类方法
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.Helper.DigitronCPLHelper.BuildReadCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            构建写入操作的报文信息
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="length">长度的长度</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.Helper.DigitronCPLHelper.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            构建写入操作的命令报文
            </summary>
            <param name="station">站号信息</param>
            <param name="address">数据的地址</param>
            <param name="value">等待写入的值</param>
            <returns>写入的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.Helper.DigitronCPLHelper.PackResponseContent(System.Byte,System.Int32,System.Byte[],System.Byte)">
            <summary>
            用于服务器反馈的数据的报文打包操作
            </summary>
            <param name="station">站号</param>
            <param name="err">错误码，如果为0则表示正常</param>
            <param name="value">原始数据值信息</param>
            <param name="dataType">数据类型</param>
            <returns>打包的报文数据信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.Helper.DigitronCPLHelper.GetErrorText(System.Int32)">
            <summary>
            根据错误码获取到相关的错误代号信息
            </summary>
            <param name="err">错误码</param>
            <returns>错误码对应的文本描述信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yamatake.Helper.DigitronCPLHelper.ExtraActualResponse(System.Byte[])">
            <summary>
            从反馈的数据内容中解析出真实的数据信息
            </summary>
            <param name="response">仪表反馈的真实的数据信息</param>
            <returns>解析之后的实际数据信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.YASKAWA.MemobusTcpNet">
            <summary>
            扩展的Memobus协议信息，除了支持普通的线圈，输入继电器，保持寄存器，输入寄存器的读写操作，还支持扩展的保持寄存器和输入寄存器读写操作。<br />
            The extended Memobus protocol information not only supports reading and writing operations of ordinary coils, input relays, 
            holding registers, and input registers, but also supports reading and writing operations of extended holding registers and input registers.
            </summary>
            <remarks>
            其中线圈和输入继电器使用<see cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.ReadBool(System.String,System.UInt16)"/>和<see cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Boolean)"/>,<see cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Boolean[])"/>的方法，读取输入继电器地址：x=2;100。
            其他的方法针对的是寄存器，保持型寄存器地址：100或 x=3;100，输入寄存器：x=4;100，扩展保持型寄存器x=9;100，写入x=11;100, 扩展输入寄存器：x=10;100<br />
            The coil and input relay use <see cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.ReadBool(System.String,System.UInt16)"/> and <see cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Boolean)"/>,<see cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Boolean[])" /> method, 
            read the input relay address: x=2;100. Other methods are for registers, holding register address: 100 or x=3;100, input register: x=4;100, 
            extended holding register x=9;100, writing x=11;100, extended input Register: x=10;100
            <br /><br />
            读取的最大的字为 2044 个字，写入的最大的字数为 2043 个字
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.#ctor">
            <summary>
            实例化一个Memobus-Tcp协议的客户端对象<br />
            Instantiate a client object of the Memobus-Tcp protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.#ctor(System.String,System.Int32)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化<br />
            Specify the server address, port number, and client's own station number to initialize
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.PackCommandWithHeader(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.CpuTo">
            <summary>
            获取或设置发送目标的CPU的编号信息，默认为 2<br />
            Get or set the CPU number information of the sending destination, the default is 2
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.CpuFrom">
            <summary>
            获取或设置发送源的CPU的编号信息，默认为 1<br />
            Get or set the number information of the sending source CPU, the default is 1
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            默认使用功能码01，读取线圈操作，如果需要指定读取输入线圈，地址需要携带额外的参数，例如 x=2;100<br />
            The function code 01 is used by default to read the coil operation. If you need to specify the read input coil, the address needs to carry additional parameters, such as x=2;100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Boolean)">
            <inheritdoc/>
            <remarks>
            单一线圈的状态变更，使用的主功能码为0x20, 子功能码为0x05<br />
            The status of a single coil is changed, the main function code used is 0x20, and the sub function code is 0x05
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
            <remarks>
            多个线圈的状态更改，默认使用的是 0x0f 子功能码。<br />
            The status of multiple coils is changed, and the sub-function code 0x0f is used by default.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            地址默认使用功能码03，如果需要指定其他的功能码地址，需要手动指定功能码，例如：x=4;100, x=9;100, x=10;100, 当然也可以写成 x=0x0A;100<br />
            The address uses function code 03 by default. If you need to specify other function code addresses, 
            you need to manually specify the function code, for example: x=4;100, x=9;100, x=10;100, of course, it can also be written as x=0x0A; 100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
            <remarks>
            连续的寄存器写入操作，默认功能码是0x10，如果需要写入扩展的寄存器，使用 x=0xA;100 或是 x=10;100 即可。<br />
            For continuous register write operation, the default function code is 0x10. If you need to write an extended register, use x=0xA;100 or x=10;100.
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Int16)">
            <inheritdoc/>
            <remarks>
            单一保持寄存器的值变更，使用的主功能码为0x20, 默认子功能码为0x06，也可以写入扩展的保持型寄存器，子功能码为0x0B
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            单一保持寄存器的值变更，使用的主功能码为0x20, 默认子功能码为0x06
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.BulidReadCommand(System.Byte,System.Byte,System.Byte,System.Byte,System.UInt16,System.UInt16)">
            <summary>
            构建读取的命令报文，支持功能码 01,02,03,04,09,0A
            </summary>
            <param name="mfc">主功能码</param>
            <param name="sfc">子功能码</param>
            <param name="cpuTo">目标的CPU编号</param>
            <param name="cpuFrom">发送源CPU编号</param>
            <param name="address">起始地址</param>
            <param name="length">读取地址长度</param>
            <returns>结果报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.YASKAWA.MemobusTcpNet.BuildWriteCommand(System.Byte,System.Byte,System.Byte,System.Byte,System.UInt16,System.Boolean)">
            <summary>
            构建写入单一的线圈的状态变更的报文
            </summary>
            <param name="mfc">主功能码</param>
            <param name="sfc">子功能码</param>
            <param name="cpuTo">目标的CPU编号</param>
            <param name="cpuFrom">发送源CPU编号</param>
            <param name="address">起始地址</param>
            <param name="value">写入的通断值信息</param>
            <returns>写入的报文</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Yokogawa.YokogawaLinkHelper">
            <summary>
            横河PLC的通信辅助类。
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkHelper.GetErrorMsg(System.Byte)">
            <summary>
            获取横河PLC的错误的具体描述信息
            </summary>
            <param name="code">错误码</param>
            <returns>错误的描述信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer">
            <summary>
            <b>[商业授权]</b> 横河PLC的虚拟服务器，支持X,Y,I,E,M,T,C,L继电器类型的数据读写，支持D,B,F,R,V,Z,W,TN,CN寄存器类型的数据读写，可以用来测试横河PLC的二进制通信类型<br />
            <b>[Authorization]</b> Yokogawa PLC's virtual server, supports X, Y, I, E, M, T, C, L relay type data read and write, 
            supports D, B, F, R, V, Z, W, TN, CN register types The data read and write can be used to test the binary communication type of Yokogawa PLC
            </summary>
            <remarks>
            其中的X继电器可以在服务器进行读写操作，但是远程的PLC只能进行读取，所有的数据读写的最大的范围按照协议进行了限制。
            </remarks>
            <example>
            地址示例如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>Input relay</term>
                <term>X</term>
                <term>X100,X200</term>
                <term>√</term>
                <term>√</term>
                <term>服务器端可读可写</term>
              </item>
              <item>
                <term>Output relay</term>
                <term>Y</term>
                <term>Y100,Y200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Internal relay</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Share relay</term>
                <term>E</term>
                <term>E100,E200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Special relay</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Time relay</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Counter relay</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>link relay</term>
                <term>L</term>
                <term>L100, L200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Data register</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>File register</term>
                <term>B</term>
                <term>B100,B200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Cache register</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Shared register</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Index register</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Special register</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Link register</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Timer current value</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Counter current value</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            你可以很快速并且简单的创建一个虚拟的横河服务器
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\YokogawaLinkServerSample.cs" region="UseExample1" title="简单的创建服务器" />
            当然如果需要高级的服务器，指定日志，限制客户端的IP地址，获取客户端发送的信息，在服务器初始化的时候就要参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\YokogawaLinkServerSample.cs" region="UseExample4" title="定制服务器" />
            服务器创建好之后，我们就可以对服务器进行一些读写的操作了，下面的代码是基础的BCL类型的读写操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\YokogawaLinkServerSample.cs" region="ReadWriteExample" title="基础的读写示例" />
            高级的对于byte数组类型的数据进行批量化的读写操作如下：   
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\YokogawaLinkServerSample.cs" region="BytesReadWrite" title="字节的读写示例" />
            更高级操作请参见源代码。
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.#ctor">
            <summary>
            实例化一个横河PLC的服务器，支持X,Y,I,E,M,T,C,L继电器类型的数据读写，支持D,B,F,R,V,Z,W,TN,CN寄存器类型的数据读写<br />
            Instantiate a Yokogawa PLC server, support X, Y, I, E, M, T, C, L relay type data read and write, 
            support D, B, F, R, V, Z, W, TN, CN Register type data reading and writing
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.StartProgram">
            <summary>
            如果未执行程序，则开始执行程序<br />
            Starts executing a program if it is not being executed
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.StopProgram">
            <summary>
            停止当前正在执行程序<br />
            Stops the executing program.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp">
            <summary>
            横河PLC的二进制通信类，支持X,Y,I,E,M,T,C,L继电器类型的数据读写，支持D,B,F,R,V,Z,W,TN,CN寄存器类型的数据读写，还支持一些高级的信息读写接口，详细参考API文档。<br />
            Yokogawa PLC's binary communication type, supports X, Y, I, E, M, T, C, L relay type data read and write, 
            supports D, B, F, R, V, Z, W, TN, CN registers Types of data reading and writing, and some advanced information reading and writing interfaces are also supported. 
            Please refer to the API documentation for details.
            </summary>
            <remarks>
            基础的数据读写面向VIP用户开放，高级的读写随机数据，启动停止命令，读取程序状态，
            系统信息，PLC时间，读写特殊的模块数据需要商业用户授权，读取的数据长度，读取的随机地址长度，在商业授权下，长度不受限制，可以无限大。
            </remarks>
            <example>
            地址示例如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>Input relay</term>
                <term>X</term>
                <term>X100,X200</term>
                <term>√</term>
                <term>√</term>
                <term>只能读，不能写</term>
              </item>
              <item>
                <term>Output relay</term>
                <term>Y</term>
                <term>Y100,Y200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Internal relay</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Share relay</term>
                <term>E</term>
                <term>E100,E200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Special relay</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Time relay</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Counter relay</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>link relay</term>
                <term>L</term>
                <term>L100, L200</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Data register</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>File register</term>
                <term>B</term>
                <term>B100,B200</term>
                <term>√</term>
                <term>×</term>
                <term>Only available for sequence CPU modules F3SP22, F3SP25, F3SP28, F3SP35, F3SP38, F3SP53, F3SP58, F3SP59, F3SP66, F3SP67, F3SP71 and F3SP76</term>
              </item>
              <item>
                <term>Cache register</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>√</term>
                <term>×</term>
                <term>Only available for sequence CPU modules F3SP71 and F3SP76</term>
              </item>
              <item>
                <term>Shared register</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Index register</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Special register</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Link register</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Timer current value</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>Counter current value</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            例如我们正常读取一个D100的数据如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\YokogawaLinkTcpSample.cs" region="Sample1" title="Read示例" />
            我们在读取的时候可以动态的变更cpu信息，参考下面的代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\YokogawaLinkTcpSample.cs" region="Sample2" title="Read示例" />
            关于随机读写的代码示例，可以读写地址分布很散的地址，参考下面的代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\YokogawaLinkTcpSample.cs" region="Sample3" title="Read示例" />
            最后看一下读取特殊模块的数据，可以读取基本的字节数据，也可以使用富文本的地址读取
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\YokogawaLinkTcpSample.cs" region="Sample4" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址和端口号来实例化一个对象<br />
            Specify the IP address and port number to instantiate an object
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.CpuNumber">
            <summary>
            获取或设置当前的CPU Number，默认值为1<br />
            Get or set the current CPU Number, the default value is 1
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Read(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            读取的线圈地址支持X,Y,I,E,M,T,C,L，寄存器地址支持D,B,F,R,V,Z,W,TN,CN，举例：D100；也可以携带CPU进行访问，举例：cpu=2;D100<br />
            <b>[商业授权]</b> 如果想要读取特殊模块的数据，需要使用 <b>Special:</b> 开头标记，举例：Special:unit=0;slot=1;100<br />
            The read coil address supports X, Y, I, E, M, T, C, L, and the register address supports D, B, F, R, V, Z, W, TN, CN, for example: D100; 
            it can also be carried CPU access, for example: cpu=2;D100. <br />
            <b>[Authorization]</b> If you want to read the data of a special module, you need to use the <b>Special:</b> beginning tag, for example: Special:unit=0;slot=1;100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Write(System.String,System.Byte[])">
            <inheritdoc/>
            <remarks>
            写入的线圈地址支持Y,I,E,M,T,C,L，寄存器地址支持D,B,F,R,V,Z,W,TN,CN，举例：D100；也可以携带CPU进行访问，举例：cpu=2;D100<br />
            如果想要写入特殊模块的数据，需要使用 <b>Special:</b> 开头标记，举例：Special:unit=0;slot=1;100<br />
            The read coil address supports Y, I, E, M, T, C, L, and the register address supports D, B, F, R, V, Z, W, TN, CN, for example: D100; 
            it can also be carried CPU access, for example: cpu=2;D100.
            If you want to read the data of a special module, you need to use the <b>Special:</b> beginning tag, for example: Special:unit=0;slot=1;100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
            <remarks>
            读取的线圈地址支持X,Y,I,E,M,T,C,L，举例：Y100；也可以携带CPU进行访问，举例：cpu=2;Y100<br />
            The read coil address supports X, Y, I, E, M, T, C, L, for example: Y100; you can also carry the CPU for access, for example: cpu=2;Y100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Write(System.String,System.Boolean[])">
            <inheritdoc/>
            <remarks>
            写入的线圈地址支持Y,I,E,M,T,C,L，举例：Y100；也可以携带CPU进行访问，举例：cpu=2;Y100<br />
            The write coil address supports Y, I, E, M, T, C, L, for example: Y100; you can also carry the CPU for access, for example: cpu=2;Y100
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomBool(System.String[])">
            <summary>
            <b>[商业授权]</b> 随机读取<see cref="T:System.Boolean"/>数组信息，主需要出传入<see cref="T:System.String"/>数组地址信息，就可以返回批量<see cref="T:System.Boolean"/>值<br />
            <b>[Authorization]</b> Random read <see cref="T:System.Boolean"/> array information, the master needs to pass in the <see cref="T:System.String"/> array address information, and then the batch can be returned to <see cref="T:System.Boolean"/> value
            </summary> 
            <param name="address">批量地址信息</param>
            <remarks>
            读取的线圈地址支持X,Y,I,E,M,T,C,L，举例：Y100；也可以携带CPU进行访问，举例：cpu=2;Y100<br />
            The read coil address supports X, Y, I, E, M, T, C, L, for example: Y100; you can also carry the CPU for access, for example: cpu=2;Y100
            </remarks>
            <returns>带有成功标志的Bool数组信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandomBool(System.String[],System.Boolean[])">
            <summary>
            <b>[商业授权]</b> 随机写入<see cref="T:System.Boolean"/>数组信息，主需要出传入<see cref="T:System.String"/>数组地址信息，以及对应的<see cref="T:System.Boolean"/>数组值<br />
            <b>[Authorization]</b> Randomly write the <see cref="T:System.Boolean"/> array information, the main need to pass in the <see cref="T:System.String"/> array address information, 
            and the corresponding <see cref="T:System.Boolean"/> array value
            </summary>
            <param name="address">批量地址信息</param>
            <param name="value">批量的数据值信息</param>
            <remarks>
            写入的线圈地址支持Y,I,E,M,T,C,L，举例：Y100；也可以携带CPU进行访问，举例：cpu=2;Y100<br />
            The write coil address supports Y, I, E, M, T, C, L, for example: Y100; you can also carry the CPU for access, for example: cpu=2;Y100
            </remarks>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandom(System.String[])">
            <summary>
            <b>[商业授权]</b> 随机读取<see cref="T:System.Byte"/>数组信息，主需要出传入<see cref="T:System.String"/>数组地址信息，就可以返回批量<see cref="T:System.Byte"/>值<br />
            <b>[Authorization]</b> Random read <see cref="T:System.Byte"/> array information, the master needs to pass in the <see cref="T:System.String"/> array address information, and then the batch can be returned to <see cref="T:System.Byte"/> value
            </summary> 
            <remarks>
            Supports D,B,F,R,V,Z,W,TN,CN，example: D100
            </remarks>
            <param name="address">批量地址信息</param>
            <returns>带有成功标志的Bool数组信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomInt16(System.String[])">
            <summary>
            <b>[商业授权]</b> 随机读取<see cref="T:System.Int16"/>数组信息，主需要出传入<see cref="T:System.String"/>数组地址信息，就可以返回批量<see cref="T:System.Int16"/>值<br />
            <b>[Authorization]</b> Random read <see cref="T:System.Int16"/> array information, the master needs to pass in the <see cref="T:System.Int16"/> array address information, and then the batch can be returned to <see cref="T:System.Int16"/> value
            </summary> 
            <param name="address">批量地址信息</param>
            <returns>带有成功标志的Bool数组信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomUInt16(System.String[])">
            <summary>
            <b>[商业授权]</b> 随机读取<see cref="T:System.UInt16"/>数组信息，主需要出传入<see cref="T:System.String"/>数组地址信息，就可以返回批量<see cref="T:System.UInt16"/>值<br />
            <b>[Authorization]</b> Random read <see cref="T:System.UInt16"/> array information, the master needs to pass in the <see cref="T:System.UInt16"/> array address information, and then the batch can be returned to <see cref="T:System.UInt16"/> value
            </summary> 
            <remarks>
            Supports D, B, F, R, V, Z, W, TN, CN，example: D100
            </remarks>
            <param name="address">批量地址信息</param>
            <returns>带有成功标志的Bool数组信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandom(System.String[],System.Byte[])">
            <summary>
            <b>[商业授权]</b> 随机写入<see cref="T:System.Byte"/>数组信息，主需要出传入<see cref="T:System.String"/>数组地址信息，以及对应的<see cref="T:System.Byte"/>数组值<br />
            <b>[Authorization]</b> Randomly write the <see cref="T:System.Byte"/> array information, the main need to pass in the <see cref="T:System.String"/> array address information, 
            and the corresponding <see cref="T:System.Byte"/> array value
            </summary>
            <remarks>
            Supports D, B, F, R, V, Z, W, TN, CN，example: D100
            </remarks>
            <param name="address">批量地址信息</param>
            <param name="value">批量的数据值信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandom(System.String[],System.Int16[])">
            <summary>
            <b>[商业授权]</b> 随机写入<see cref="T:System.Int16"/>数组信息，主需要出传入<see cref="T:System.String"/>数组地址信息，以及对应的<see cref="T:System.Int16"/>数组值<br />
            <b>[Authorization]</b> Randomly write the <see cref="T:System.Int16"/> array information, the main need to pass in the <see cref="T:System.Int16"/> array address information, 
            and the corresponding <see cref="T:System.Int16"/> array value
            </summary>
            <remarks>
            Supports D, B, F, R, V, Z, W, TN, CN，example: D100
            </remarks>
            <param name="address">批量地址信息</param>
            <param name="value">批量的数据值信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandom(System.String[],System.UInt16[])">
            <summary>
            <b>[商业授权]</b> 随机写入<see cref="T:System.UInt16"/>数组信息，主需要出传入<see cref="T:System.String"/>数组地址信息，以及对应的<see cref="T:System.UInt16"/>数组值<br />
            <b>[Authorization]</b> Randomly write the <see cref="T:System.UInt16"/> array information, the main need to pass in the <see cref="T:System.UInt16"/> array address information, 
            and the corresponding <see cref="T:System.UInt16"/> array value
            </summary>
            <remarks>
            Supports D, B, F, R, V, Z, W, TN, CN，example: D100
            </remarks>
            <param name="address">批量地址信息</param>
            <param name="value">批量的数据值信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteAsync(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomBoolAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomBool(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandomBoolAsync(System.String[],System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandomBool(System.String[],System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomInt16Async(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomUInt16Async(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadRandomUInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandomAsync(System.String[],System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandom(System.String[],System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandomAsync(System.String[],System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandom(System.String[],System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandomAsync(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.WriteRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Start">
            <summary>
            <b>[商业授权]</b> 如果未执行程序，则开始执行程序<br />
            <b>[Authorization]</b> Starts executing a program if it is not being executed
            </summary>
            <remarks>
            This command will be ignored if it is executed while a program is being executed.<br />
            Refer to the users manual for the individual modules for the response formats that are used at error times.
            </remarks>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Stop">
            <summary>
            <b>[商业授权]</b> 停止当前正在执行程序<br />
            <b>[Authorization]</b> Stops the executing program.
            </summary>
            <remarks>
            This command will be ignored if it is executed when no program is being executed.<br />
            Refer to the users manual for the individual modules for the response formats that are used at error times.
            </remarks>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ModuleReset">
            <summary>
            <b>[商业授权]</b> 重置当前的模块，当前打开的连接被强制关闭。 模块中所做的设置也将被清除。然后当前对象需要重连PLC。<br />
            <b>[Authorization]</b> When this command is executed via an Ethernet interface module or an Ethernet connection of an F3SP66, F3SP67, 
            F3SP71 or F3SP76 sequence CPU module, the connection which is currently open is forced to close. 
            The settings made in the modules are also cleared. Then the current object needs to reconnect to the PLC.
            </summary>
            <returns>是否重置成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadProgramStatus">
            <summary>
            <b>[商业授权]</b> 读取当前PLC的程序状态，返回1：RUN；2：Stop；3：Debug；255：ROM writer<br />
            <b>[Authorization]</b> Read the program status. return code 1:RUN; 2:Stop; 3:Debug; 255:ROM writer
            </summary>
            <returns>当前PLC的程序状态，返回1：RUN；2：Stop；3：Debug；255：ROM writer</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadSystemInfo">
            <summary>
            <b>[商业授权]</b> 读取当前PLC的系统状态，系统的ID，CPU类型，程序大小信息<br />
            <b>[Authorization]</b> Read current PLC system status, system ID, CPU type, program size information
            </summary>
            <returns>系统信息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadDateTime">
            <summary>
            <b>[商业授权]</b> 读取当前PLC的时间信息，包含年月日时分秒<br />
            <b>[Authorization]</b> Read current PLC time information, including year, month, day, hour, minute, and second
            </summary>
            <returns>PLC的当前的时间信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadSpecialModule(System.Byte,System.Byte,System.UInt16,System.UInt16)">
            <summary>
            <b>[商业授权]</b> 读取特殊模块的数据信息，需要指定模块单元号，模块站号，数据地址，长度信息。<br />
            <b>[Authorization]</b> To read the data information of a special module, you need to specify the module unit number, module slot number, data address, and length information.
            </summary>
            <param name="moduleUnit">模块的单元号</param>
            <param name="moduleSlot">模块的站号</param>
            <param name="dataPosition">模块的数据地址</param>
            <param name="length">长度信息</param>
            <returns>带有成功标识的byte[]，可以自行解析出所需要的各种类型的数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.StartAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Start"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.StopAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.Stop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ModuleResetAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ModuleReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadProgramStatusAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadProgramStatus"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadSystemInfoAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadSystemInfo"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadDateTimeAsync">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadDateTime"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadSpecialModuleAsync(System.Byte,System.Byte,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ReadSpecialModule(System.Byte,System.Byte,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.CheckContent(System.Byte[])">
            <summary>
            检查当前的反馈内容，如果没有发生错误，就解析出实际的数据内容。<br />
            Check the current feedback content, if there is no error, parse out the actual data content.
            </summary>
            <param name="content">原始的数据内容</param>
            <returns>解析之后的数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            构建读取命令的原始报文信息
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="address">地址数据信息</param>
            <param name="length">数据长度信息</param>
            <param name="isBit">是否位访问</param>
            <returns>实际的读取的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildReadRandomCommand(System.Byte,System.String[],System.Boolean)">
            <summary>
            构建随机读取的原始报文的初始命令
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="address">实际的数据地址信息</param>
            <param name="isBit">是否是位读取</param>
            <returns>实际的读取的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildWriteBoolCommand(System.Byte,System.String,System.Boolean[])">
            <summary>
            构建批量写入Bool数组的命令，需要指定CPU Number信息和设备地址信息
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="address">设备地址数据</param>
            <param name="value">实际的bool数组</param>
            <returns>构建的写入指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildWriteRandomBoolCommand(System.Byte,System.String[],System.Boolean[])">
            <summary>
            构建批量随机写入Bool数组的命令，需要指定CPU Number信息和设备地址信息
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="address">设备地址数据</param>
            <param name="value">实际的bool数组</param>
            <returns>构建的写入指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildWriteWordCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            构建字写入的命令报文信息，需要指定设备地址
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="address">地址</param>
            <param name="value">原始的数据值</param>
            <returns>原始的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildWriteRandomWordCommand(System.Byte,System.String[],System.Byte[])">
            <summary>
            构建随机写入字的命令的报文
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="address">地址</param>
            <param name="value">原始的数据值</param>
            <returns>原始的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildStartCommand(System.Byte)">
            <summary>
            构建启动PLC的命令报文
            </summary>
            <param name="cpu">Cpu Number</param>
            <returns>原始的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildStopCommand(System.Byte)">
            <summary>
            构建停止PLC的命令报文
            </summary>
            <param name="cpu">Cpu Number</param>
            <returns>原始的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildReadSpecialModule(System.Byte,System.Byte,System.Byte,System.UInt16,System.UInt16)">
            <summary>
            构建读取特殊模块的命令报文
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="moduleUnit">模块单元号</param>
            <param name="moduleSlot">模块站号</param>
            <param name="dataPosition">数据位置</param>
            <param name="length">长度信息</param>
            <returns>原始的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildReadSpecialModule(System.Byte,System.String,System.UInt16)">
            <summary>
            构建读取特殊模块的命令报文，需要传入高级地址，必须以 <b>Special:</b> 开头表示特殊模块地址，示例：Special:cpu=1;unit=0;slot=1;100<br />
            To construct a command message to read a special module, the advanced address needs to be passed in. 
            It must start with <b>Special:</b> to indicate the address of the special module, for example: Special:cpu=1;unit=0;slot=1;100
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="address">高级的混合地址，除了Cpu可以不携带，例如：Special:unit=0;slot=1;100</param>
            <param name="length">长度信息</param>
            <returns>原始的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildWriteSpecialModule(System.Byte,System.Byte,System.Byte,System.UInt16,System.Byte[])">
            <summary>
            构建读取特殊模块的命令报文
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="moduleUnit">模块单元号</param>
            <param name="moduleSlot">模块站号</param>
            <param name="dataPosition">数据位置</param>
            <param name="data">数据内容</param>
            <returns>原始的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.BuildWriteSpecialModule(System.Byte,System.String,System.Byte[])">
            <summary>
            构建写入特殊模块的命令报文，需要传入高级地址，必须以 <b>Special:</b> 开头表示特殊模块地址，示例：Special:cpu=1;unit=0;slot=1;100<br />
            To construct a command message to write a special module, the advanced address needs to be passed in. 
            It must start with <b>Special:</b> to indicate the address of the special module, for example: Special:cpu=1;unit=0;slot=1;100
            </summary>
            <param name="cpu">Cpu Number</param>
            <param name="address">高级的混合地址，除了Cpu可以不携带，例如：Special:unit=0;slot=1;100</param>
            <param name="data">写入的原始数据内容</param>
            <returns>原始的报文命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaLinkTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo">
            <summary>
            横河PLC的系统基本信息<br />
            Basic system information of Yokogawa PLC
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo.SystemID">
            <summary>
            当前系统的ID名称，例如F3SP21-ON<br />
            The ID name of the current system, such as F3SP21-ON
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo.Revision">
            <summary>
            当前系统的修订版本号<br />
            The revision number of the current system
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo.CpuType">
            <summary>
            当前系统的类型，分为 <b>Sequence</b> 和 <b>BASIC</b> <br />
            The type of the current system, divided into <b>Sequence</b> and <b>BASIC</b>
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo.ProgramAreaSize">
            <summary>
            当前系统的程序大小，如果是Sequence系统，就是步序总量，如果是BASIC系统，就是字节数量<br />
            The program size of the current system, if it is a Sequence system, it is the total number of steps, if it is a BASIC system, it is the number of bytes
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo.Parse(System.Byte[])">
            <summary>
            根据原始的数据信息解析出<see cref="T:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo"/>对象<br />
            Analyze the <see cref="T:HslCommunication.Profinet.Yokogawa.YokogawaSystemInfo"/> object according to the original data information
            </summary>
            <param name="content">原始的数据信息</param>
            <returns>是否解析成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Properties.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.abstr1">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.abstr11">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Activity_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.AddressViewer">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.alipay">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.asset_progressBar_24x24_on">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.AudioRecording">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.brackets_Square_16xMD">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Class_489">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.ClassIcon">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Cloud_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Copy_6524">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Delegate_8339">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.docview_xaml_on_16x16">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Enum_582">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Event_594">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Event_594_exp">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.glasses_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.grid_Data_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.lightningBolt_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.ListView_687">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Method_636">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.mm_facetoface_collect_qrcode_1525331158525">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Module_648">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.PropertyIcon">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.qrcode_for_gh_319218678954_258">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Soundfile_461">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Structure_507">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.TabControl_707">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Table_748">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Tag_7213">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Textfile_818_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.TreeView_713">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.usbcontroller">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.UseCaseDiagramFile_usecasediagram_13447_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.VirtualMachine">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.WebForm_ASPX__815_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.WebFormTemplate_11274_16x_color">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.WindowsForm_817_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="T:HslCommunication.Robot.ABB.ABBWebApiClient">
            <summary>
            ABB机器人的web api接口的客户端，可以方便快速的获取到abb机器人的一些数据信息<br />
            The client of ABB robot's web API interface can easily and quickly obtain some data information of ABB robot
            </summary>
            <remarks>
            参考的界面信息是：http://developercenter.robotstudio.com/webservice/api_reference
            
            关于额外的地址说明，如果想要查看，可以调用<see cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSelectStrings"/> 返回字符串列表来看看。
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.#ctor(System.String)">
            <summary>
            使用指定的ip地址来初始化对象<br />
            Initializes the object using the specified IP address
            </summary>
            <param name="ipAddress">Ip地址信息</param>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口号来初始化对象<br />
            Initializes the object with the specified IP address and port number
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>
            使用指定的ip地址，端口号，用户名，密码来初始化对象<br />
            Initialize the object with the specified IP address, port number, username, and password
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
            <param name="name">用户名</param>
            <param name="password">密码</param>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.Read(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.ReadString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.Write(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.ReadByAddress(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.ReadByAddressAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSelectStrings">
            <summary>
            获取当前支持的读取的地址列表<br />
            Gets a list of addresses for currently supported reads
            </summary>
            <returns>数组信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetCtrlState">
            <summary>
            获取当前的控制状态，Content属性就是机器人的控制信息<br />
            Get the current control state. The Content attribute is the control information of the robot
            </summary>
            <returns>带有状态信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetErrorState">
            <summary>
            获取当前的错误状态，Content属性就是机器人的状态信息<br />
            Gets the current error state. The Content attribute is the state information of the robot
            </summary>
            <returns>带有状态信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetJointTarget">
            <summary>
            获取当前机器人的物理关节点信息，返回json格式的关节信息<br />
            Get the physical node information of the current robot and return the joint information in json format
            </summary>
            <returns>带有关节信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSpeedRatio">
            <summary>
            获取当前机器人的速度配比信息<br />
            Get the speed matching information of the current robot
            </summary>
            <returns>带有速度信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetOperationMode">
            <summary>
            获取当前机器人的工作模式<br />
            Gets the current working mode of the robot
            </summary>
            <returns>带有工作模式信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOIn">
            <summary>
            获取当前机器人的本机的输入IO<br />
            Gets the input IO of the current robot's native
            </summary>
            <returns>带有IO信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOOut">
            <summary>
            获取当前机器人的本机的输出IO<br />
            Gets the output IO of the current robot's native
            </summary>
            <returns>带有IO信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIO2In">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOIn"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIO2Out">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOOut"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetLog(System.Int32)">
            <summary>
            获取当前机器人的日志记录，默认记录为10条<br />
            Gets the log record for the current robot, which is 10 by default
            </summary>
            <param name="logCount">读取的最大的日志总数</param>
            <returns>带有IO信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSystem">
            <summary>
            获取当前机器人的系统信息，版本号，唯一ID等信息<br />
            Get the current robot's system information, version number, unique ID and other information
            </summary>
            <returns>系统的基本信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRobotTarget">
            <summary>
            获取机器人的目标坐标信息<br />
            Get the current robot's target information
            </summary>
            <returns>系统的基本信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetServoEnable">
            <summary>
            获取当前机器人的伺服使能状态<br />
            Get the current robot servo enable state
            </summary>
            <returns>机器人的伺服使能状态</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRapidExecution">
            <summary>
            获取当前机器人的当前程序运行状态<br />
            Get the current program running status of the current robot
            </summary>
            <returns>机器人的当前的程序运行状态</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRapidTasks">
            <summary>
            获取当前机器人的任务列表<br />
            Get the task list of the current robot
            </summary>
            <returns>任务信息的列表</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetCtrlStateAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetCtrlState"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetErrorStateAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetErrorState"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetJointTargetAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetJointTarget"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSpeedRatioAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSpeedRatio"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetOperationModeAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetOperationMode"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOInAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOIn"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOOutAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOOut"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIO2InAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOIn"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIO2OutAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOOut"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetLogAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetLog(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSystemAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSystem"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRobotTargetAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRobotTarget"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetServoEnableAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetServoEnable"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRapidExecutionAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRapidExecution"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRapidTasksAsync">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRapidTasks"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.ABB.ABBWebApiServer">
            <summary>
            <b>[商业授权]</b> ABB机器人的虚拟服务器，基于WebApi协议构建，可用于读取一些数据信息<br />
            <b>[Authorization]</b>The virtual server of ABB robot, built based on the WebApi protocol, can be used to read some data information
            </summary>
            <remarks>
            本虚拟服务器实例化之后，就可以启动了，需要注意的是，程序需要管理员模式运行，否则启动服务的时候会报错，显示拒绝当前的操作。
            支持和<see cref="T:HslCommunication.Robot.ABB.ABBWebApiClient"/>进行测试通信。本服务器的运行需要商业授权支持，否则只能运行24小时。
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiServer.SetLoginAccount(System.String,System.String)">
            <summary>
            设置用户的登录信息，用户名和密码信息<br />
            Set user login information, user name and password information
            </summary>
            <param name="name">用户名</param>
            <param name="password">密码</param>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiServer.HandleRequest(System.Net.HttpListenerRequest,System.Net.HttpListenerResponse,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.HttpServer.HandleRequest(System.Net.HttpListenerRequest,System.Net.HttpListenerResponse,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.EFORT.EfortData">
            <summary>
            埃夫特机器人的数据结构<br />
            The data structure of the efort robot
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.EfortData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.PacketStart">
            <summary>
            报文开始的字符串
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.PacketOrders">
            <summary>
            数据命令
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.PacketHeartbeat">
            <summary>
            数据心跳
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ErrorStatus">
            <summary>
            报警状态，1:有报警，0：无报警
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.HstopStatus">
            <summary>
            急停状态，1：无急停，0：有急停
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.AuthorityStatus">
            <summary>
            权限状态，1：有权限，0：无权限
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ServoStatus">
            <summary>
            伺服状态，1：有使能，0：未使能
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.AxisMoveStatus">
            <summary>
            轴运动状态，1：有运动，0：未运动
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProgMoveStatus">
            <summary>
            程序运行状态，1：有运行，0：未运行
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProgLoadStatus">
            <summary>
            程序加载状态，1：有加载，0：无加载
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProgHoldStatus">
            <summary>
            程序暂停状态，1：有暂停，0：无暂停
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ModeStatus">
            <summary>
            模式状态，1:手动，2:自动，3:远程
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.SpeedStatus">
            <summary>
            读读状态，百分比（单位）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.IoDOut">
            <summary>
            IoDOut状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.IoDIn">
            <summary>
            IoDIn状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.IoIOut">
            <summary>
            IoIOut状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.IoIIn">
            <summary>
            IoIIn状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProjectName">
            <summary>
            加载工程名
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProgramName">
            <summary>
            加载程序名
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ErrorText">
            <summary>
            错误信息
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisPos">
            <summary>
            一到七轴的角度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbCartPos">
            <summary>
            X,Y,Z,A,B,C方向，也叫笛卡尔坐标系
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisSpeed">
            <summary>
            一到七轴的速度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisAcc">
            <summary>
            一到七轴的加速度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisAccAcc">
            <summary>
            一到七轴的加加速度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisTorque">
            <summary>
            一到七轴的力矩
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisDirCnt">
            <summary>
            轴反向计数
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisTime">
            <summary>
            轴工作总时长
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbDeviceTime">
            <summary>
            设备开机总时长
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.PacketEnd">
            <summary>
            报文结束标记
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.EfortData.PraseFromPrevious(System.Byte[])">
            <summary>
            从之前的版本数据构造一个埃夫特机器人的数据类型
            </summary>
            <param name="data">真实的数据内容</param>
            <returns>转换的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.EfortData.PraseFrom(System.Byte[])">
            <summary>
            从新版本数据构造一个埃夫特机器人的数据类型
            </summary>
            <param name="data">真实的数据内容</param>
            <returns>转换的结果内容</returns>
        </member>
        <member name="T:HslCommunication.Robot.EFORT.ER7BC10">
            <summary>
            埃夫特机器人对应型号为ER7B-C10，此协议为定制版，新版报文对齐<br />
            The corresponding model of efort robot is er7b-c10. This protocol is the customized version, and the new version is the message alignment
            </summary>
            <remarks>
            针对的控制器是KEBA控制器
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的对象，并指定IP地址和端口号，端口号通常为8008<br />
            Instantiate a default object and specify the IP address and port number, usually 8008
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.GetReadCommand">
            <summary>
            获取发送的消息的命令<br />
            Gets the command to send the message
            </summary>
            <returns>字节数组命令</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.Read(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.Write(System.String,System.Byte[])">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作<br />
            This robot does not support this method operation, will always return failed, invalid operation
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.Write(System.String,System.String)">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作<br />
            This robot does not support this method operation, will always return failed, invalid operation
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ReadEfortData">
            <summary>
            读取机器人的详细信息，返回解析后的数据类型<br />
            Read the details of the robot and return the resolved data type
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ReadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadStringAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Robot.EFORT.ER7BC10.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.EFORT.ER7BC10.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ReadEfortDataAsync">
            <inheritdoc cref="M:HslCommunication.Robot.EFORT.ER7BC10.ReadEfortData"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.EFORT.ER7BC10Previous">
            <summary>
            埃夫特机器人对应型号为ER7B-C10，此协议为旧版的定制版，报文未对齐的版本<br />
            The corresponding model of the efort robot is er7b-c10. This protocol is a customized version of the old version, and the message is not aligned
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的对象，并指定IP地址和端口号，端口号通常为8008<br />
            Instantiate a default object and specify the IP address and port number, usually 8008
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.GetReadCommand">
            <summary>
            获取发送的消息的命令<br />
            Gets the command to send the message
            </summary>
            <returns>字节数组命令</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Read(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Write(System.String,System.Byte[])">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作<br />
            This robot does not support this method operation, will always return failed, invalid operation
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Write(System.String,System.String)">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作<br />
            This robot does not support this method operation, will always return failed, invalid operation
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadEfortData">
            <summary>
            读取机器人的详细信息<br />
            Read the details of the robot
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadEfortDataAsync">
            <inheritdoc cref="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadEfortData"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.Estun.EstunData">
            <summary>
            埃斯顿的数据类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunData.#ctor(System.Byte[],HslCommunication.Core.IByteTransform)">
            <summary>
            使用指定的原始字节数据来实例化埃斯顿机器人对象
            </summary>
            <param name="source">原始字节数组</param>
            <param name="byteTransform">字节转换</param>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.ManualMode">
            <summary>
            获取或设置当前的手动操作模式
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.AutoMode">
            <summary>
            获取或设置当前的自动操作模式
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.RemoteMode">
            <summary>
            获取或设置当前的远程操作模式
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.EnableStatus">
            <summary>
            获取或设置使能状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.RunStatus">
            <summary>
            获取或设置运行状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.ErrorStatus">
            <summary>
            获取或设置错误状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.ProgramRunStatus">
            <summary>
            获取或设置程序运行状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.RobotMoving">
            <summary>
            机器人正在动作
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.ProjectName">
            <summary>
            获取或设置当前加载的工程名
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.DO">
            <summary>
            SimDout, 共计64位长度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.RobotCommandStatus">
            <summary>
            机器人的执行命令状态，16长度的bool数组
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.AO">
            <summary>
            用户的AO，32个长度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.GlobalSpeedValue">
            <summary>
            全局的速度值
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.DI">
            <summary>
            SimDI, 共计64个bit
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.AI">
            <summary>
            用户的AI，32个长度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Estun.EstunData.ReadWriteFlag">
            <summary>
            读写标志位
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunData.LoadBySourceData(System.Byte[],HslCommunication.Core.IByteTransform)">
            <summary>
            从原始的字节数据里加载
            </summary>
            <param name="source">原始字节数据</param>
            <param name="byteTransform">字节转换的类</param>
        </member>
        <member name="T:HslCommunication.Robot.Estun.EstunTcpNet">
            <summary>
            一个埃斯顿的机器人的通信类，底层使用的是ModbusTCP协议，支持读取简单机器人数据，并且支持对机器人进行一些操作。<br />
            A communication class of Estun's robot, the bottom layer uses the ModbusTCP protocol, supports reading simple robot data, and supports some operations on the robot.
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.#ctor">
            <summary>
            实例化一个Modbus-Tcp协议的客户端对象<br />
            Instantiate a client object of the Modbus-Tcp protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化<br />
            Specify the server address, port number, and client's own station number to initialize
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.ReadRobotData">
            <summary>
            读取埃斯顿的机器人的数据
            </summary>
            <returns>机器人数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.RobotStartPrograme">
            <summary>
            机器人程序启动
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.RobotStopPrograme">
            <summary>
            机器人程序停止
            </summary>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.RobotResetError">
            <summary>
            机器人的错误进行复位
            </summary>
            <returns>是否重置了错误</returns>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.RobotLoadProject(System.String)">
            <summary>
            机器人重新装载程序名
            </summary>
            <param name="projectName">程序的名称</param>
            <returns>是否装载成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.RobotUnregisterProject">
            <summary>
            机器人卸载程序名
            </summary>
            <returns>是否卸载成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.RobotSetGlobalSpeedValue(System.Int16)">
            <summary>
            机器人设置全局速度值
            </summary>
            <param name="value">全局速度值</param>
            <returns>是否设置成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.RobotCommandStatusRestart">
            <summary>
            重置机器人的命令状态
            </summary>
            <returns>是否操作成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Estun.EstunTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucAlarm">
            <summary>
            Fanuc机器人的报警对象
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.AlarmID">
            <summary>
            AlarmID
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.AlarmNumber">
            <summary>
            AlarmNumber
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.CauseAlarmID">
            <summary>
            CauseAlarmID
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.CauseAlarmNumber">
            <summary>
            CauseAlarmNumber
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.Severity">
            <summary>
            Severity
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.Time">
            <summary>
            Time
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.AlarmMessage">
            <summary>
            AlarmMessage
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.CauseAlarmMessage">
            <summary>
            CauseAlarmMessage
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.SeverityMessage">
            <summary>
            SeverityMessage
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucAlarm.LoadByContent(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            从字节数据加载真实的信息
            </summary>
            <param name="byteTransform">字节变换</param>
            <param name="content">原始的字节内容</param>
            <param name="index">索引</param>
            <param name="encoding">编码</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucAlarm.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucAlarm.PraseFrom(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            从数据内容创建报警信息
            </summary>
            <param name="byteTransform">字节变换</param>
            <param name="content">原始的字节内容</param>
            <param name="index">索引</param>
            <param name="encoding">编码</param>
            <returns>报警信息</returns>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucData">
            <summary>
            Fanuc机器人的所有的数据信息
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucData.LoadByContent(System.Byte[])">
            <summary>
            从原始的数据内容加载数据
            </summary>
            <param name="content">原始的内容</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucData.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucData.PraseFrom(System.Byte[])">
            <summary>
            从字节数组解析出fanuc的数据信息
            </summary>
            <param name="content">原始的字节数组</param>
            <returns>fanuc数据</returns>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucHelper">
            <summary>
            Fanuc的辅助方法信息
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_Q">
            <summary>
            Q区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_I">
            <summary>
            I区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_AQ">
            <summary>
            AQ区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_AI">
            <summary>
            AI区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_M">
            <summary>
            M区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_D">
            <summary>
            D区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_G">
            <summary>
            命令数据
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.AnalysisFanucAddress(System.String)">
            <summary>
            从FANUC机器人地址进行解析数据信息，地址为D,I,Q,M,AI,AQ区<br />
            Parse data information from FANUC robot address, the address is D, I, Q, M, AI, AQ area
            </summary>
            <param name="address">fanuc机器人的地址信息</param>
            <returns>解析结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.BulidReadData(System.Byte,System.UInt16,System.UInt16)">
            <summary>
            构建读取数据的报文内容
            </summary>
            <param name="sel">数据类别</param>
            <param name="address">偏移地址</param>
            <param name="length">长度</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.BuildReadResponseData(System.Byte[])">
            <summary>
            构建读取返回的数据信息
            </summary>
            <param name="data">数据</param>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.BuildWriteData(System.Byte,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            构建写入的数据报文，需要指定相关的参数信息
            </summary>
            <param name="sel">数据类别</param>
            <param name="address">偏移地址</param>
            <param name="value">原始数据内容</param>
            <param name="length">写入的数据长度</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.GetFanucCmds">
            <summary>
            获取所有的命令信息<br />
            Get all command information
            </summary>
            <returns>命令数组</returns>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucInterfaceNet">
            <summary>
            Fanuc机器人的PC Interface实现，在R-30iB mate plus型号上测试通过，支持读写任意的数据，写入操作务必谨慎调用，写入数据不当造成生命财产损失，作者概不负责。读写任意的地址见api文档信息<br />
            The Fanuc robot's PC Interface implementation has been tested on R-30iB mate plus models. It supports reading and writing arbitrary data. The writing operation must be called carefully. 
            Improper writing of data will cause loss of life and property. The author is not responsible. Read and write arbitrary addresses see api documentation information
            </summary>
            <remarks>
            注意：如果再读取机器人的数据时，发生了GB2312编码获取的异常的时候(通常是基于.net core的项目会报错)，使用如下的方法进行解决<br />
            1. 从nuget安装组件 <b>System.Text.Encoding.CodePages</b><br />
            2. 刚进入系统的时候，调用一行代码： System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);<br />
            Note: If you read the data of the robot again, when an exception occurs in the GB2312 code acquisition (usually a project based on .net core will report an error), use the following method to solve it.<br />
            1. Install the component <b>System.Text.Encoding.CodePages</b> from nuget<br />
            2. When you first enter the system, call a line of code: System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);<br />
            </remarks>
            <example>
            我们看看实际的地址支持的情况，如果使用绝对地址进行访问的话，支持的地址格式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>R寄存器</term>
                <term>R</term>
                <term>R1-R10</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>R1-R5为int类型，R6-R10为float类型，本质还是数据寄存器</term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>AI</term>
                <term>AI100,AI200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>AQ</term>
                <term>AQ100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>中间继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            我们先来看看简单的情况
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Robot\FANUC\FanucInterfaceNetSample.cs" region="Sample1" title="简单的读取" />
            读取fanuc部分数据
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Robot\FANUC\FanucInterfaceNetSample.cs" region="Sample2" title="属性读取" />
            最后是比较高级的任意数据读写
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Robot\FANUC\FanucInterfaceNetSample.cs" region="Sample3" title="复杂读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip及端口来实例化一个默认的对象，端口默认60008<br />
            Specify the IP and port to instantiate a default object, the port defaults to 60008
            </summary>
            <param name="ipAddress">ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucInterfaceNet.ClientId">
            <summary>
            获取或设置当前客户端的ID信息，默认为1024<br />
            Gets or sets the ID information of the current client. The default is 1024.
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucInterfaceNet.FanucDataRetainTime">
            <summary>
            获取或设置缓存的Fanuc数据的有效时间，对<see cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadString(System.String)"/>方法有效，默认为100，单位毫秒。也即是在100ms内频繁读取机器人的属性数据的时候，优先读取缓存值，提高读取效率。<br />
            Gets or sets the valid time of the cached Fanuc data. It is valid for the <see cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadString(System.String)" /> method. The default is 100, in milliseconds. 
            That is, when the attribute data of the robot is frequently read within 100ms, the cache value is preferentially read to improve the reading efficiency.
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.String,System.UInt16)">
            <summary>
            按照字为单位批量读取设备的原始数据，需要指定地址及长度，地址示例：D1，AI1，AQ1，共计3个区的数据，注意地址的起始为1<br />
            Read the raw data of the device in batches in units of words. You need to specify the address and length. Example addresses: D1, AI1, AQ1, a total of 3 areas of data. Note that the start of the address is 1.
            </summary>
            <param name="address">起始地址，地址示例：D1，AI1，AQ1，共计3个区的数据，注意起始的起始为1</param>
            <param name="length">读取的长度，字为单位</param>
            <returns>返回的数据信息结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.String,System.Byte[])">
            <summary>
            写入原始的byte数组数据到指定的地址，返回是否写入成功，地址示例：D1，AI1，AQ1，共计3个区的数据，注意起始的起始为1<br />
            Write the original byte array data to the specified address, and return whether the write was successful. Example addresses: D1, AI1, AQ1, a total of 3 areas of data. Note that the start of the address is 1.
            </summary>
            <param name="address">起始地址，地址示例：D1，AI1，AQ1，共计3个区的数据，注意起始的起始为1</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadBool(System.String,System.UInt16)">
            <summary>
            按照位为单位批量读取设备的原始数据，需要指定地址及长度，地址示例：M1，I1，Q1，共计3个区的数据，注意地址的起始为1<br />
            Read the raw data of the device in batches in units of boolean. You need to specify the address and length. Example addresses: M1，I1，Q1, a total of 3 areas of data. Note that the start of the address is 1.
            </summary>
            <param name="address">起始地址，地址示例：M1，I1，Q1，共计3个区的数据，注意地址的起始为1</param>
            <param name="length">读取的长度，位为单位</param>
            <returns>返回的数据信息结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.String,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否写入成功，需要指定起始地址，地址示例：M1，I1，Q1，共计3个区的数据，注意地址的起始为1<br />
            Write <see cref="T:System.Boolean"/> array data in batches. If the write success is returned, you need to specify the starting address. Example address: M1, I1, Q1, a total of 3 areas of data. Note that the starting address is 1.
            </summary>
            <param name="address">起始地址，地址示例：M1，I1，Q1，共计3个区的数据，注意地址的起始为1</param>
            <param name="value">等待写入的数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.Byte,System.UInt16,System.UInt16)">
            <summary>
            按照字为单位批量读取设备的原始数据，需要指定数据块地址，偏移地址及长度，主要针对08, 10, 12的数据块，注意地址的起始为1<br />
            Read the raw data of the device in batches in units of words. You need to specify the data block address, offset address, and length. It is mainly for data blocks of 08, 10, and 12. Note that the start of the address is 1.
            </summary>
            <param name="select">数据块信息</param>
            <param name="address">偏移地址</param>
            <param name="length">读取的长度，字为单位</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.Byte,System.UInt16,System.Byte[])">
            <summary>
            写入原始的byte数组数据到指定的地址，返回是否写入成功，，需要指定数据块地址，偏移地址，主要针对08, 10, 12的数据块，注意起始的起始为1<br />
            Write the original byte array data to the specified address, and return whether the writing is successful. You need to specify the data block address and offset address, 
            which are mainly for the data blocks of 08, 10, and 12. Note that the start of the start is 1.
            </summary>
            <param name="select">数据块信息</param>
            <param name="address">偏移地址</param>
            <param name="value">原始数据内容</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadBool(System.Byte,System.UInt16,System.UInt16)">
            <summary>
            按照位为单位批量读取设备的原始数据，需要指定数据块地址，偏移地址及长度，主要针对70, 72, 76的数据块，注意地址的起始为1<br />
            </summary>
            <param name="select">数据块信息</param>
            <param name="address">偏移地址</param>
            <param name="length">读取的长度，字为单位</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteBool(System.Byte,System.UInt16,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否写入成功，需要指定数据块地址，偏移地址，主要针对70, 72, 76的数据块，注意起始的起始为1
            </summary>
            <param name="select">数据块信息</param>
            <param name="address">偏移地址</param>
            <param name="value">原始的数据内容</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadAsync(System.Byte,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.Byte,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteAsync(System.Byte,System.UInt16,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.Byte,System.UInt16,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadBoolAsync(System.Byte,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadBool(System.Byte,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteBoolAsync(System.Byte,System.UInt16,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteBool(System.Byte,System.UInt16,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadFanucData">
            <summary>
            读取机器人的详细信息，返回解析后的数据类型<br />
            Read the details of the robot and return the resolved data type
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSDO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的SDO信息<br />
            Read the SDO information of the robot
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取的长度</param>
            <returns>结果数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSDO(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的SDO信息<br />
            Write the SDO information of the robot
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSDI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的SDI信息<br />
            Read the SDI information of the robot
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSDI(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的SDI信息<br />
            Write the SDI information of the robot
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadRDI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的RDI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRDI(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的RDI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadUI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的UI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadUO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的UO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteUO(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的UO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的SI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的SO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSO(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的SO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadGI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的GI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">数据长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteGI(System.UInt16,System.UInt16[])">
            <summary>
            写入机器人的GI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadGO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的GO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteGO(System.UInt16,System.UInt16[])">
            <summary>
            写入机器人的GO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>写入结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadPMCR2(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的PMCR2信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WritePMCR2(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的PMCR2信息
            </summary>
            <param name="address">偏移信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadRDO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的RDO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRDO(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的RDO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRXyzwpr(System.UInt16,System.Single[],System.Int16[],System.Int16,System.Int16)">
            <summary>
            写入机器人的Rxyzwpr信息，谨慎调用，
            </summary>
            <param name="Address">偏移地址</param>
            <param name="Xyzwpr">姿态信息</param>
            <param name="Config">设置信息</param>
            <param name="UserFrame">参考系</param>
            <param name="UserTool">工具</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRJoint(System.UInt16,System.Single[],System.Int16,System.Int16)">
            <summary>
            写入机器人的Joint信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="joint">关节坐标</param>
            <param name="UserFrame">参考系</param>
            <param name="UserTool">工具</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadFanucDataAsync">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadFanucData"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSDOAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSDO(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSDOAsync(System.UInt16,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSDO(System.UInt16,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSDIAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSDI(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSDIAsync(System.UInt16,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSDI(System.UInt16,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadRDIAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadRDI(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRDIAsync(System.UInt16,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRDI(System.UInt16,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadUIAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadUI(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadUOAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadUO(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteUOAsync(System.UInt16,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteUO(System.UInt16,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSIAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSI(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSOAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSO(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSOAsync(System.UInt16,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSO(System.UInt16,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadGIAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadGI(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteGIAsync(System.UInt16,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteGI(System.UInt16,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadGOAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadGO(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteGOAsync(System.UInt16,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteGO(System.UInt16,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadPMCR2Async(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadPMCR2(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WritePMCR2Async(System.UInt16,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WritePMCR2(System.UInt16,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadRDOAsync(System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadRDO(System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRDOAsync(System.UInt16,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRDO(System.UInt16,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRXyzwprAsync(System.UInt16,System.Single[],System.Int16[],System.Int16,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRXyzwpr(System.UInt16,System.Single[],System.Int16[],System.Int16,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRJointAsync(System.UInt16,System.Single[],System.Int16,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRJoint(System.UInt16,System.Single[],System.Int16,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucPose">
            <summary>
            机器人的姿态数据
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.Xyzwpr">
            <summary>
            Xyzwpr
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.Config">
            <summary>
            Config
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.Joint">
            <summary>
            Joint
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.UF">
            <summary>
            UF
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.UT">
            <summary>
            UT
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.ValidC">
            <summary>
            ValidC
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.ValidJ">
            <summary>
            ValidJ
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucPose.LoadByContent(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32)">
            <summary>
            从原始数据解析出当前的姿态数据
            </summary>
            <param name="byteTransform">数据解析对象</param>
            <param name="content">原始的内容</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucPose.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucPose.ParseFrom(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32)">
            <summary>
            从原始的字节数据创建一个新的姿态数据
            </summary>
            <param name="byteTransform">数据解析对象</param>
            <param name="content">原始的内容</param>
            <param name="index">索引位置</param>
            <returns>姿态数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucPose.TransConfigStringArray(System.Int16[])">
            <summary>
            将short类型的config数组转换成string数组类型的config
            </summary>
            <param name="value">short数组的值</param>
            <returns>string数组的值</returns>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucRobotServer">
            <summary>
            <b>[商业授权]</b> 虚拟的FANUC机器人的服务器对象，支持I,Q,M,D,AI,AQ数据区的数据读写，其中D区是机器人数据存放的区域，相关的数据需要去机器人区读取。详细参见api文档信息。<br />
            <b>[Authorization]</b> The server object of the virtual FANUC robot supports data reading and writing in I, Q, M, D, AI, and AQ data areas, 
            where D area is the area where the robot data is stored, and related data needs to be read in the robot area. See the api documentation for details.
            </summary>
            <remarks>
            本虚拟服务器需要商业授权，否则只能运行24小时。
            <inheritdoc cref="T:HslCommunication.Robot.FANUC.FanucInterfaceNet" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.#ctor">
            <summary>
            实例化一个默认的对象信息，并初始化机器人的相关数据<br />
            Instantiate a default object information and initialize the relevant data of the robot
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.ReadFromCoreServer(HslCommunication.Core.Net.AppSession,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucTask">
            <summary>
            Fanuc机器人的任务类
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucTask.ProgramName">
            <summary>
            ProgramName
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucTask.LineNumber">
            <summary>
            LineNumber
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucTask.State">
            <summary>
            State
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucTask.ParentProgramName">
            <summary>
            ParentProgramName
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucTask.LoadByContent(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            从原始的数据对象加载数据信息
            </summary>
            <param name="byteTransform">字节变换</param>
            <param name="content">原始的字节数据</param>
            <param name="index">索引信息</param>
            <param name="encoding">编码</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucTask.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucTask.ParseFrom(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            从原始的数据信息初始化一个任务对象
            </summary>
            <param name="byteTransform">字节变换</param>
            <param name="content">原始的字节数据</param>
            <param name="index">索引信息</param>
            <param name="encoding">编码</param>
            <returns>任务对象</returns>
        </member>
        <member name="T:HslCommunication.Robot.Hyundai.HyundaiData">
            <summary>
            Hyundai的数据类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.#ctor(System.Byte[])">
            <summary>
            通过缓存对象实例化一个
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.Command">
            <summary>
            命令码，从控制器发数据到PC和PC到控制器，两者的命令不一样
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.CharDummy">
            <summary>
            虚标记
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.State">
            <summary>
            状态码
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.Count">
            <summary>
            标记数据，从PLC发送给机器人的数据，原封不动的返回
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.IntDummy">
            <summary>
            虚标记
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.Data">
            <summary>
            关节坐标数据，包含X,Y,Z,W,P,R，三个位置数据，三个角度数据。
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.LoadBy(System.Byte[],System.Int32)">
            <summary>
            从字节数组的指定索引开始加载现在机器人的数据
            </summary>
            <param name="buffer">原始的字节数据</param>
            <param name="index">起始的索引信息</param>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.ToBytes">
            <summary>
            将现代机器人的数据转换为字节数组
            </summary>
            <returns>字节数组</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.Hyundai.HyundaiUdpNet">
            <summary>
            现代机器人的UDP通讯类，注意本类是服务器，需要等待机器人先配置好ip地址及端口，然后连接到本服务器才能正确的进行操作。详细参见api文档注释<br />
            The UDP communication class of modern robots. Note that this class is a server. You need to wait for the robot to configure the IP address and port first, 
            and then connect to this server to operate correctly. See api documentation for details
            </summary>
            <remarks>
            为使用联机跟踪功能，通过JOB文件的 OnLTrack 命令激活本功能后对通信及位置增量命令 Filter 进行设置，必要时以 LIMIT 命令设置机器人的动作领域，速度限制项。
            最后采用 OnLTrack 命令关闭联机跟踪功能以退出本功能。<br />
            功能开始，通信及 Filter 设置，程序示例： OnLTrack ON,IP=192.168.1.254,PORT=7127,CRD=1,Bypass,Fn=10
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.ThreadReceiveCycle">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.WriteIncrementPos(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            将指定的增量写入机器人，需要指定6个参数，位置和角度信息，其中位置单位为mm，角度单位为°<br />
            To write the specified increment to the robot, you need to specify 6 parameters, 
            position and angle information, where the position unit is mm and the angle unit is °
            </summary>
            <param name="x">X轴增量信息，单位毫米</param>
            <param name="y">Y轴增量信息，单位毫米</param>
            <param name="z">Z轴增量信息，单位毫米</param>
            <param name="rx">X轴角度增量信息，单位角度</param>
            <param name="ry">Y轴角度增量信息，单位角度</param>
            <param name="rz">Z轴角度增量信息，单位角度</param>
            <returns>是否写入机器人成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.WriteIncrementPos(System.Double[])">
            <summary>
            将指定的增量写入机器人，需要指定6个参数，位置和角度信息，其中位置单位为mm，角度单位为°<br />
            To write the specified increment to the robot, you need to specify 6 parameters, position and angle information, where the position unit is mm and the angle unit is °
            </summary>
            <param name="pos">增量的数组信息</param>
            <returns>是否写入机器人成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.Write(HslCommunication.Robot.Hyundai.HyundaiData)">
            <summary>
            将指定的命令写入机器人，该命令是完全自定义的，需要遵循机器人的通讯协议，在写入之前，需要调用<see cref="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerStart(System.Int32)"/> 方法<br />
            Write the specified command to the robot. The command is completely customized and needs to follow the robot's communication protocol. 
            Before writing, you need to call the <see cref="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerStart(System.Int32)" />
            </summary>
            <param name="data">机器人数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.MoveX(System.Double)">
            <summary>
            机器人在X轴上移动一小段距离，单位毫米<br />
            The robot moves a short distance on the X axis, in millimeters
            </summary>
            <param name="value">移动距离，单位毫米</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.MoveY(System.Double)">
            <summary>
            机器人在Y轴上移动一小段距离，单位毫米<br />
            The robot moves a short distance on the Y axis, in millimeters
            </summary>
            <param name="value">移动距离，单位毫米</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.MoveZ(System.Double)">
            <summary>
            机器人在Z轴上移动一小段距离，单位毫米<br />
            The robot moves a short distance on the Z axis, in millimeters
            </summary>
            <param name="value">移动距离，单位毫米</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.RotateX(System.Double)">
            <summary>
            机器人在X轴方向上旋转指定角度，单位角度<br />
            The robot rotates the specified angle in the X axis direction, the unit angle
            </summary>
            <param name="value">旋转角度，单位角度</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.RotateY(System.Double)">
            <summary>
            机器人在Y轴方向上旋转指定角度，单位角度<br />
            The robot rotates the specified angle in the Y axis direction, the unit angle
            </summary>
            <param name="value">旋转角度，单位角度</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.RotateZ(System.Double)">
            <summary>
            机器人在Z轴方向上旋转指定角度，单位角度<br />
            The robot rotates the specified angle in the Z axis direction, the unit angle
            </summary>
            <param name="value">旋转角度，单位角度</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="T:HslCommunication.Robot.Hyundai.HyundaiUdpNet.OnHyundaiMessageReceiveDelegate">
            <summary>
            收到机器人消息的事件委托
            </summary>
            <param name="data">机器人消息</param>
        </member>
        <member name="E:HslCommunication.Robot.Hyundai.HyundaiUdpNet.OnHyundaiMessageReceive">
            <summary>
            当接收到机器人数据的时候触发的事件
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.KUKA.KukaAvarProxyNet">
            <summary>
            Kuka机器人的数据交互类，通讯支持的条件为KUKA 的 KRC4 控制器中运行KUKAVARPROXY 这个第三方软件，端口通常为7000<br />
            The data interaction class of Kuka robot is supported by the third-party software KUKAVARPROXY running in the KRC4 controller of Kuka. The port is usually 7000
            </summary>
            <remarks>
            非常感谢 昆山-LT 网友的测试和意见反馈。<br />
            其中KUKAVARPROXY 这个第三方软件在来源地址：
            https://github.com/ImtsSrl/KUKAVARPROXY <br />
            如果想要更详细的了解配置，连接，数据读取操作，请点击下面的连接：http://blog.davidrobot.com/2019/03/hsl_for_kuka.html?tdsourcetag=s_pctim_aiomsg
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的Kuka机器人对象，并指定IP地址和端口号，端口号通常为7000<br />
            Instantiate a default Kuka robot object and specify the IP address and port number, usually 7000
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Read(System.String)">
            <summary>
            读取Kuka机器人的数据内容，根据输入的变量名称来读取<br />
            Read the data content of the Kuka robot according to the input variable name
            </summary>
            <param name="address">地址数据</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.ReadString(System.String)">
            <summary>
            读取Kuka机器人的所有的数据信息，返回字符串信息，解码方式为ANSI，需要指定变量名称<br />
            Read all the data information of the Kuka robot, return the string information, decode by ANSI, need to specify the variable name
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Write(System.String,System.Byte[])">
            <summary>
            根据Kuka机器人的变量名称，写入原始的数据内容<br />
            Write the original data content according to the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Write(System.String,System.String)">
            <summary>
            根据Kuka机器人的变量名称，写入ANSI编码的字符串数据信息<br />
            Writes ansi-encoded string data information based on the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">ANSI编码的字符串</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.ReadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.PackCommand(System.Byte[])">
            <summary>
            将核心的指令打包成一个可用于发送的消息对象<br />
            Package the core instructions into a message object that can be sent
            </summary>
            <param name="commandCore">核心命令</param>
            <returns>最终实现的可以发送的机器人的字节数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.KUKA.KukaTcpNet">
            <summary>
            Kuka机器人的数据交互类，通讯支持的条件为KUKA 的 TCP通讯
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的Kuka机器人对象，并指定IP地址和端口号，端口号通常为9999<br />
            Instantiate a default Kuka robot object and specify the IP address and port number, usually 9999
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.Read(System.String)">
            <summary>
            读取Kuka机器人的数据内容，根据输入的变量名称来读取<br />
            Read the data content of the Kuka robot according to the input variable name
            </summary>
            <param name="address">地址数据</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ReadString(System.String)">
            <summary>
            读取Kuka机器人的所有的数据信息，返回字符串信息，解码方式为UTF8，需要指定变量名称<br />
            Read all the data information of the Kuka robot, return the string information, decode by ANSI, need to specify the variable name
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String,System.Byte[])">
            <summary>
            根据Kuka机器人的变量名称，写入原始的数据内容<br />
            Write the original data content according to the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String,System.String)">
            <summary>
            根据Kuka机器人的变量名称，写入UTF8编码的字符串数据信息<br />
            Writes ansi-encoded string data information based on the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">ANSI编码的字符串</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String[],System.String[])">
            <summary>
            根据Kuka机器人的变量名称，写入多个UTF8编码的字符串数据信息<br />
            Write multiple UTF8 encoded string data information according to the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">ANSI编码的字符串</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.StartProgram(System.String)">
            <summary>
            启动机器人的指定的程序<br />
            Start the specified program of the robot
            </summary>
            <param name="program">程序的名字</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ResetProgram">
            <summary>
            复位当前的程序<br />
            Reset current program
            </summary>
            <returns>复位结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.StopProgram">
            <summary>
            停止当前的程序<br />
            Stop current program
            </summary>
            <returns>复位结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ReadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaTcpNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaTcpNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.WriteAsync(System.String[],System.String[])">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String[],System.String[])"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.StartProgramAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaTcpNet.StartProgram(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ResetProgramAsync">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaTcpNet.ResetProgram"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.StopProgramAsync">
            <inheritdoc cref="M:HslCommunication.Robot.KUKA.KukaTcpNet.StopProgram"/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.BuildReadCommands(System.String[])">
            <summary>
            构建读取变量的报文命令
            </summary>
            <param name="address">地址信息</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.BuildReadCommands(System.String)">
            <summary>
            构建读取变量的报文命令
            </summary>
            <param name="address">地址信息</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.BuildWriteCommands(System.String[],System.String[])">
            <summary>
            构建写入变量的报文命令
            </summary>
            <param name="address">地址信息</param>
            <param name="values">数据信息</param>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.BuildWriteCommands(System.String,System.String)">
            <summary>
            构建写入变量的报文命令
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据信息</param>
            <returns>字符串信息</returns>
        </member>
        <member name="T:HslCommunication.Robot.YAMAHA.YamahaRCX">
            <summary>
            雅马哈机器人的数据访问类
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址和端口来实例化一个对象
            </summary>
            <param name="ipAddress">IP地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadFromServer(System.Byte[],System.Int32)">
            <summary>
            发送命令行到socket, 并从机器人读取指定的命令行
            </summary>
            <param name="send">等待发送的数据</param>
            <param name="lines">接收的行数</param>
            <returns>结果的结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadFromServerAsync(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadFromServer(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadCommandAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadCommand(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ResetAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Reset"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.RunAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Run"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.StopAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Stop"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadMotorStatusAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadMotorStatus"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadModeStatusAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadModeStatus"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadJointsAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadJoints"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadEmergencyStatusAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadEmergencyStatus"/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadCommand(System.String,System.Int32)">
            <summary>
            读取指定的命令的方法，需要指定命令，和接收命令的行数信息<br />
            The method of reading the specified command requires the specified command and the line number information of the received command
            </summary>
            <param name="command">命令</param>
            <param name="lines">接收的行数信息</param>
            <returns>接收的命令</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Reset">
            <summary>
            指定程序复位信息，对所有的程序进行复位。当重新启动了程序时，从主程序或者任务 1 中最后执行的程序开头开始执行。<br />
            Specify the program reset information to reset all programs. When the program is restarted, 
            execution starts from the beginning of the main program or the last executed program in task 1.
            </summary>
            <returns>执行结果是否成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Run">
            <summary>
            执行程序运行。执行所有的 RUN 状态程序。<br />
            Execute the program to run. Execute all RUN state programs.
            </summary>
            <returns>执行结果是否成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Stop">
            <summary>
            执行程序停止。执行所有的 STOP 状态程序。<br />
            The execution program stops. Execute all STOP state programs.
            </summary>
            <returns>执行结果是否成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadMotorStatus">
            <summary>
            获取马达电源状态，返回的0:马达电源关闭; 1:马达电源开启; 2:马达电源开启＋所有机器人伺服开启<br />
            Get the motor power status, return 0: motor power off; 1: motor power on; 2: motor power on + all robot servos on
            </summary>
            <returns>返回的0:马达电源关闭; 1:马达电源开启; 2:马达电源开启＋所有机器人伺服开启</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadModeStatus">
            <summary>
            读取模式状态<br />
            Read mode status
            </summary>
            <returns>模式的状态信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadJoints">
            <summary>
            读取关节的基本数据信息<br />
            Read the basic data information of the joint
            </summary>
            <returns>关节信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadEmergencyStatus">
            <summary>
            读取紧急停止状态，0 ：正常状态、1 ：紧急停止状态<br />
            Read emergency stop state, 0: normal state, 1: emergency stop state
            </summary>
            <returns>0 ：正常状态、1 ：紧急停止状态</returns>
        </member>
        <member name="T:HslCommunication.Robot.YASKAWA.Helper.YRCHelper">
            <summary>
            安川机器人的静态辅助方法
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.Helper.YRCHelper.GetErrorMessage(System.Int32)">
            <summary>
            根据错误信息获取安川机器人的错误信息文本<br />
            Obtain the error message text of the Yaskawa robot according to the error message
            </summary>
            <param name="err">错误号</param>
            <returns>错误文本信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.Helper.YRCHelper.ExtraErrorMessage(System.String)">
            <summary>
            当机器人返回ERROR的错误指令后，检测消息里面是否有相关的错误码数据，如果存在，就解析出错误对应的文本<br />
            When the robot returns the error instruction of ERROR, it checks whether there is related error code data in the message, 
            and if it exists, it parses out the text corresponding to the error
            </summary>
            <param name="errText">返回的完整的报文</param>
            <returns>带有错误文本的数据信息</returns>
        </member>
        <member name="T:HslCommunication.Robot.YASKAWA.Helper.YRCHighEthernetHelper">
            <summary>
            安川机器人的高速以太网的辅助方法
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.Helper.YRCHighEthernetHelper.BuildCommand(System.Byte,System.Byte,System.UInt16,System.UInt16,System.Byte,System.Byte,System.Byte[])">
            <summary>
            构建完整的读取指令
            </summary>
            <param name="handle">处理分区，1:机器人控制 2:文件控制</param>
            <param name="requestID">请求ID， 客户端每次命令输出的时请增量</param>
            <param name="command">命令编号，相当于CIP通信的CLASS</param>
            <param name="dataAddress">数据队列编号，相当于CIP通信的Instance</param>
            <param name="dataAttribute">单元编号，相当于CIP通信协议的Attribute</param>
            <param name="dataHandle">处理请求，定义数据的请方法</param>
            <param name="dataPart">数据部分的内容</param>
            <returns>构建结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.Helper.YRCHighEthernetHelper.CheckResponseContent(System.Byte[])">
            <summary>
            检查当前的机器人反馈的数据是否正确
            </summary>
            <param name="response">从机器人反馈的数据</param>
            <returns>是否检查正确</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.Helper.YRCHighEthernetHelper.GetErrorText(System.Byte,System.Int32)">
            <summary>
            根据状态信息及附加状态信息来获取错误的文本描述信息
            </summary>
            <param name="status">状态信息</param>
            <param name="affix">附加状态信息</param>
            <returns>错误的文本描述信息</returns>
        </member>
        <member name="T:HslCommunication.Robot.YASKAWA.YRC1000TcpNet">
            <summary>
            安川机器人的Ethernet 服务器功能对应的客户端通讯类<br />
            Yaskawa robot's Ethernet server features a communication class
            </summary>
            <remarks>
            要想成功的通信，有两个至关重要的前提。<br />
            1. 开启以太网服务器，[系统]-[设定]-[选项功能]-[网络功能设定]启用网络功能。<br />
            2. 开启远程的命令，[输入输出]-[模拟输入]-[远程命令选择] 激活远程命令
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.#ctor(System.String,System.Int32)">
            <summary>
            指定机器人的ip地址及端口号来实例化对象<br />
            Specify the robot's IP address and port number to instantiate the object
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Type">
            <summary>
            获取或设置当前的机器人类型，默认为 <see cref="F:HslCommunication.Robot.YASKAWA.YRCType.YRC1000"/>
            Get or set the current robot type, the default is <see cref="F:HslCommunication.Robot.YASKAWA.YRCType.YRC1000"/>
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Read(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadStringAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadStringAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.WriteAsync(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.WriteAsync(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            before read data , the connection should be Initialized
            </summary>
            <param name="socket">connected socket</param>
            <returns>whether is the Initialization is success.</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <summary>
            before read data , the connection should be Initialized
            </summary>
            <param name="socket">connected socket</param>
            <returns>whether is the Initialization is success.</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadFromCoreServer(System.Net.Sockets.Socket,System.String)">
            <summary>
            Read string value from socket
            </summary>
            <param name="socket">connected socket</param>
            <param name="send">string value</param>
            <returns>received string value with is successfully</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadByCommand(System.String,System.String)">
            <summary>
            根据指令来读取设备的信息，如果命令数据为空，则传入null即可，注意，所有的命令不带换行符<br />
            Read the device information according to the instructions. If the command data is empty, pass in null. Note that all commands do not have a newline character
            </summary>
            <remarks>
            此处举几个例子<br />
            "RALARM", NULL    错误报警代码读取。<br />
            "RPOSJ", NULL     关节坐标系的坐标位置读取。<br />
            "RJSEQ", NULL     读取当前的程序名，行编号，步编号。<br />
            "SAVEV", "7,000" 读取变量数据。字符串变量
            </remarks>
            <param name="command">命令的内容</param>
            <param name="commandData">命令数据内容</param>
            <returns>最终的结果内容，需要对IsSuccess进行验证</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadFromCoreServer(System.Net.Sockets.Socket,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadByCommandAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadByCommand(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadALARM">
            <summary>
            读取机器人的报警信息<br />
            Read the alarm information of the robot
            </summary>
            <returns>原始的报警信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadPOSJ">
            <summary>
            关节坐标系的坐标位置读取。<br />
            Read the coordinate data information of the robot
            </summary>
            <returns>原始的报警信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadPOSC(System.Int32,System.Boolean)">
            <summary>
            指定坐标系的当前值读取。并且可以指定外部轴的有无。<br />
            The current value of the specified coordinate system is read. And you can specify the presence or absence of an external axis.
            </summary>
            <param name="coordinate">指定读取坐标 0:基座坐标，1:机器人坐标，2-65分别表示用户坐标1-64</param>
            <param name="hasExteralAxis">外部轴的有/无</param>
            <returns>坐标系当前值</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadStats">
            <summary>
            模式状态，循环状态，动作状态，报警错误状态，伺服状态的读取。<br />
            Reading of mode status, cycle status, action status, alarm error status, and servo status.
            </summary>
            <remarks>
            [0]: 单步
            [1]: 1循环
            [2]: 自动连续
            [3]: 运行中
            [4]: 运转中
            [5]: 示教
            [6]: 在线
            [7]: 命令模式
            [9]: 示教编程器HOLD中
            [10]: 外部HOLD中
            [11]: 命令HOLD中
            [12]: 发生警报
            [13]: 发生错误
            [14]: 伺服ON
            </remarks>
            <returns>状态信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadJSeq">
            <summary>
            读取当前的程序名，行编号，步编号。<br />
            Read the current program name, line number, and step number.
            </summary>
            <returns>读取结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadUFrame(System.Int32)">
            <summary>
            读取指定用户的坐标数据。<br />
            Read the coordinate data of the specified user.
            </summary>
            <param name="frame">用户坐标编号，1-64</param>
            <returns>坐标值</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadByteVariable(System.String)">
            <summary>
            读取机器人的字节型变量的数据，需要传入变量的编号<br />
            To read the data of the byte variable of the robot, the number of the variable needs to be passed in
            </summary>
            <param name="variableAdderss">变量的编号</param>
            <returns>包含是否成功的结果数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadIntegerVariable(System.String)">
            <summary>
            读取机器人的整型变量的数据，需要传入变量的编号<br />
            To read the data of the integer variable of the robot, the number of the variable needs to be passed in
            </summary>
            <param name="variableAdderss">变量的编号</param>
            <returns>包含是否成功的结果数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadDoubleIntegerVariable(System.String)">
            <summary>
            读取机器人的双精度整型变量的数据，需要传入变量的编号<br />
            To read the data of the double integer variable of the robot, the number of the variable needs to be passed in
            </summary>
            <param name="variableAdderss">变量的编号</param>
            <returns>包含是否成功的结果数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadRealVariable(System.String)">
            <summary>
            读取机器人的实数变量的数据，需要传入变量的编号<br />
            To read the data of the real variable of the robot, the number of the variable needs to be passed in
            </summary>
            <param name="variableAdderss">变量的编号</param>
            <returns>包含是否成功的结果数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadStringVariable(System.String)">
            <summary>
            读取机器人的字符串变量的数据，需要传入变量的编号<br />
            To read the data of the string variable of the robot, the number of the variable needs to be passed in
            </summary>
            <param name="variableAdderss">变量的编号</param>
            <returns>包含是否成功的结果数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Hold(System.Boolean)">
            <summary>
            进行HOLD 的 ON/OFF 操作，状态参数 False: OFF操作，True: ON操作<br />
            Perform HOLD ON operation, False: OFF，True: ON
            </summary>
            <param name="status">状态参数 False: OFF操作，True: ON操作</param>
            <returns>是否成功的HOLD操作</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Reset">
            <summary>
            对机械手的报警进行复位<br />
            Reset the alarm of the manipulator
            </summary>
            <remarks>
            传输报警仅可在示教编程器上进行复位。
            </remarks>
            <returns>是否复位成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Cancel">
            <summary>
            进行错误取消<br />
            Make an error cancellation
            </summary>
            <returns>是否取消成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Mode(System.Int32)">
            <summary>
            选择模式。模式编号为1:示教模式，2:再现模式<br />
            Choose a mode. The mode number is 1: teaching mode, 2: reproduction mode
            </summary>
            <param name="number">模式编号为1:示教模式，2:再现模式</param>
            <remarks>
            MODE 命令，是在「操作条件」 画面中获得外部模式切换的许可后可以使用。
            </remarks>
            <returns>模式是否选择成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Cycle(System.Int32)">
            <summary>
            选择循环。循环编号 1:步骤，2:1循环，3:连续自动<br />
            Choose loop. Cycle number 1: step, 2:1 cycle, 3: continuous automatic
            </summary>
            <param name="number">循环编号 1:步骤，2:1循环，3:连续自动</param>
            <returns>循环是否选择成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Svon(System.Boolean)">
            <summary>
            进行伺服电源的ON/OFF操作，状态参数 False: OFF，True: ON<br />
            Carry out the ON/OFF operation of the servo power, the status parameter False: OFF，True: ON
            </summary>
            <param name="status">状态参数 False: OFF，True: ON</param>
            <remarks>
            通过此命令伺服ON的时候，请连接机器人专用端子台（ MTX） 的外部伺服ON（ EXSVON）信号的29和 30 。</remarks>
            <returns>是否伺服电源是否成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.HLock(System.Boolean)">
            <summary>
            设定示教编程器和 I/O的操作信号的联锁。 状态参数 False: OFF，True: ON<br />
            Set the interlock between the programming pendant and the operation signal of I/O. Status parameter False: OFF，True: ON
            </summary>
            <param name="status">状态参数 False: OFF，True: ON</param>
            <remarks>
            联锁为ON时，仅可执行以下操作。
            <list type="number">
            <item>示教编程器的非常停止</item>
            <item>Ｉ /O 的模式切换， 外部启动， 外部伺服ON，循环切换， I/O 禁止、 PP/PANEL 禁止、 主程序调出以外的输入信号</item>
            </list>
            示教编程器在编辑中或者通过其他的功能访问文件时，不能使用HLOCK.
            </remarks>
            <returns>是否设定成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.MSDP(System.String)">
            <summary>
            接受消息数据时， 在YRC1000的示教编程器的远程画面下显示消息若。若不是远程画面时，强制切换到远程画面。显示MDSP命令的消息。<br />
            When receiving message data, a message is displayed on the remote screen of the YRC1000 programming pendant. 
            If it is not a remote screen, it is forced to switch to the remote screen. Display the message of the MDSP command.
            </summary>
            <param name="message">显示信息（最大 30byte 字符串）</param>
            <returns>是否显示成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Start(System.String)">
            <summary>
            开始程序。操作时指定程序名时，此程序能附带对应主程序，则从该程序的开头开始执行。如果没有指定，则从前行开始执行<br />
            Start the program. When the program name is specified during operation, the program can be accompanied by the corresponding main program, 
            and the execution starts from the beginning of the program. If not specified, execute from the previous line
            </summary>
            <param name="programName">开始动作程序名称，可以省略</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Delete(System.String)">
            <summary>
            删除指定的程序。指定「*」 时， 删除当前登录的所有程序。指定「 删除程序名称」 时，仅删除指定的程序。<br />
            Delete the specified program. When "*" is specified, all currently registered programs will be deleted. 
            When "delete program name" is specified, only the specified program will be deleted.
            </summary>
            <param name="programName">删除的程序名称，如果设置为「*」时，删除当前登录的所有程序。</param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.SetMJ(System.String)">
            <summary>
            指定的程序设定为主程序。设定主程序的同时执行程序也被设定。<br />
            The specified program is set as the main program. The execution program is also set when the main program is set.
            </summary>
            <param name="programName">设定的程序名称</param>
            <returns>是否设定成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.JSeq(System.String,System.Int32)">
            <summary>
            设定执行程序的名称和行编号。<br />
            Set the name and line number of the executed program.
            </summary>
            <param name="programName">设定程序名称</param>
            <param name="line">设定行编号（ 0 ～ 9999）</param>
            <returns>是否设定成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.MoveJ(HslCommunication.Robot.YASKAWA.YRCRobotData)">
            <summary>
            向指定的坐标系位置进行关节动作。其中没有外部轴的系统， 7-12外部轴的值设定为「0」<br />
            Perform joint motions to the specified coordinate system position.
            where there is no external axis system, the value of 7-12 external axis is set to "0"
            </summary>
            <param name="robotData">机器的的数据信息</param>
            <remarks>
            其中形态数据由6个bool数组组成，每个bool含义参考参数说明，0表示 <c>False</c>，1表示 <c>True</c>
            </remarks>
            <returns>是否动作成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.IORead(System.Int32,System.Int32)">
            <summary>
            读取I/O 信号。 I/O 数据是每8个点输出，所以读出接点数是8的倍数。<br />
            Read I/O signal. I/O data is output every 8 points, so the number of read contacts is a multiple of 8.
            </summary>
            <param name="address">读出开始点编号</param>
            <param name="length">读出的接点数</param>
            <returns>读取的结果点位信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.IOWrite(System.Int32,System.Boolean[])">
            <summary>
            写入I/O信号状态，写入接点数请指定8的倍数。IO 信号的网络写入仅可是（ #27010 ～ #29567）。<br />
            To write I/O signal status, please specify a multiple of 8 for the number of write contacts. 
            The network write of IO signal is only available (#27010 to #29567).
            </summary>
            <param name="address">写入开始接点编号</param>
            <param name="value">写入的bool值，写入接点数请指定8的倍数。</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadALARMAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadALARM"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadPOSJAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadPOSJ"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadPOSCAsync(System.Int32,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadPOSC(System.Int32,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadStatsAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadStats"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadJSeqAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadJSeq"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadUFrameAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadUFrame(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadByteVariableAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadByteVariable(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadIntegerVariableAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadIntegerVariable(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadDoubleIntegerVariableAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadDoubleIntegerVariable(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadRealVariableAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadRealVariable(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadStringVariableAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadStringVariable(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.HoldAsync(System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Hold(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ResetAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Reset"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.CancelAsync">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Cancel"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ModeAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Mode(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.CycleAsync(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Cycle(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.SvonAsync(System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Svon(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.HLockAsync(System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.HLock(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.MSDPAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.MSDP(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.StartAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Start(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.DeleteAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Delete(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.SetMJAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.SetMJ(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.JSeqAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.JSeq(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.MoveJAsync(HslCommunication.Robot.YASKAWA.YRCRobotData)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.MoveJ(HslCommunication.Robot.YASKAWA.YRCRobotData)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.IOReadAsync(System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.IORead(System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.IOWriteAsync(System.Int32,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.IOWrite(System.Int32,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.YASKAWA.YRCAlarmItem">
            <summary>
            安川的报警信息
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCAlarmItem.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCAlarmItem.#ctor(HslCommunication.Core.IByteTransform,System.Byte[],System.Text.Encoding)">
            <summary>
            使用原始数据来实例化一个报警的对象
            </summary>
            <param name="byteTransform">字节的变换顺序</param>
            <param name="content">原始字节数据</param>
            <param name="encoding">字符串的编码信息</param>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCAlarmItem.AlarmCode">
            <summary>
            报警代码
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCAlarmItem.Time">
            <summary>
            报警发生的时间
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCAlarmItem.Message">
            <summary>
            报警文字列名称
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCAlarmItem.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.YASKAWA.YRCHighEthernet">
            <summary>
            安川机器人的通信类，基于高速以太网的通信，基于UDP协议实现，默认端口10040，支持读写一些数据地址
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的IP地址和端口号信息来实例化一个对象
            </summary>
            <param name="ipAddress">IP地址</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadCommand(System.UInt16,System.UInt16,System.Byte,System.Byte,System.Byte[])">
            <summary>
            使用自定义的命令来读取机器人指定的数据信息，每个命令返回的数据格式互不相同，需要根据手册来自定义解析的。<br />
            Use custom commands to read the data information specified by the robot. 
            The data format returned by each command is different from each other, 
            and you need to customize the analysis according to the manual.
            </summary>
            <param name="command">命令编号，相当于CIP 通信协议的Class</param>
            <param name="dataAddress">数据队列编号，相当于CIP 通信协议的Instance</param>
            <param name="dataAttribute">单元编号，相当于CIP 通信协议的Attribute</param>
            <param name="dataHandle">处理(请求), 定义数据请求方法。</param>
            <param name="dataPart">附加数据信息</param>
            <returns>从机器人返回的设备数据，如果是写入状态，则 Content 为 NULL</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadAlarms">
            <summary>
            读取机器人的最新的报警列表信息，最多为四个报警
            </summary>
            <returns>报警列表信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadHistoryAlarms(System.UInt16,System.Int16)">
            <summary>
            读取机器人的指定的报警信息，需要指定报警类型，及报警数量，其中length为1-100之间。
            </summary>
            <param name="alarmType">报警类型，1-100:重故障; 1001-1100: 轻故障; 2001-2100: 用户报警(系统); 3001-3100: 用户报警(用户); 4001-4100:在线报警</param>
            <param name="length">读取的报警的个数</param>
            <returns>报警列表信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadStats">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadStats"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadJSeq(System.UInt16)">
            <summary>
            读取当前的机器人的程序名称，行编号，步骤编号，速度超出值。需要指定当前的任务号，默认为1，表示主任务<br />
            Read the current robot's program name, line number, step number, and speed exceeding value. 
            Need to specify the current task number, the default is 1, which means the main task
            </summary>
            <param name="task">任务标识，1:主任务; 2-16分别表示子任务1-子任务15</param>
            <returns>读取的任务的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadPose">
            <summary>
            读取机器人的姿态信息，包括X,Y,Z,Rx,Ry,Rz,如果是七轴机器人，还包括Re
            </summary>
            <returns>姿态信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadTorqueData">
            <summary>
            读取力矩数据功能
            </summary>
            <returns>力矩信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadIO(System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadIO(System.UInt16,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteIO(System.UInt16,System.Byte)">
            <summary>
            写入IO的数据，只可写入网络输入信号，也即地址是 2701~2956
            </summary>
            <param name="address">网络输入信号，也即地址是 2701~2956</param>
            <param name="value">表示8个bool的字节数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadIO(System.UInt16,System.Int32)">
            <summary>
            读取IO数据，需要指定IO的地址。
            </summary>
            <remarks>
            io地址如下：<br />
            1~512: 机器人通用输入命令；1001~1512：机器人通用输出命令；2001~2512：外部输入信号；2701~2956：网络输入信号；
            3001~3512：外部输出信号；3701~3956：网络输出信号；4001~4256：机器人专用输入信号；5001~5512：机器人专用输出信号；
            6001~6064：接口面板输入信号；7001~7999：辅助继电器信号；8001~8512：机器人控制状态信号；8701~8720：模拟输入信号；
            </remarks>
            <param name="address">信号地址，详细参见注释</param>
            <param name="length">读取的数据长度信息</param>
            <returns>bool值</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteIO(System.UInt16,System.Byte[])">
            <summary>
            写入多个IO数据的命令，写入的字节长度需要是2的倍数
            </summary>
            <param name="address">网络输入信号，也即地址是 2701~2956</param>
            <param name="value">连续的字数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadRegisterVariable(System.UInt16)">
            <summary>
            读取寄存器的数据，地址范围 0 ~ 999
            </summary>
            <param name="address">地址索引</param>
            <returns>读取结果数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteRegisterVariable(System.UInt16,System.UInt16)">
            <summary>
            将数据写入到寄存器，支持写入的地址范围为 0 ~ 599
            </summary>
            <param name="address">地址索引</param>
            <param name="value">等待写入的值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadRegisterVariable(System.UInt16,System.Int32)">
            <summary>
            批量读取多个寄存器的数据，地址范围 0 ~ 999，指定读取的数据长度，最大不超过237 个
            </summary>
            <param name="address">地址索引</param>
            <param name="length">读取的数据长度，最大不超过237 个</param>
            <returns>读取结果内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteRegisterVariable(System.UInt16,System.UInt16[])">
            <summary>
            写入多个数据到寄存器，地址范围 0 ~ 999，指定读取的数据长度，最大不超过237 个
            </summary>
            <param name="address">地址索引</param>
            <param name="value">等待写入的数据，最大不超过237 个长度</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadByteVariable(System.UInt16)">
            <summary>
            读取字节型变量的数据，标准地址范围为 0 ~ 99
            </summary>
            <param name="address">标准地址范围为 0 ~ 99</param>
            <returns>读取的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteByteVariable(System.UInt16,System.Byte)">
            <summary>
            将数据写入到字节型变量的地址里去，标准地址范围为 0 ~ 99
            </summary>
            <param name="address">标准地址范围为 0 ~ 99</param>
            <param name="value">等待写入的值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadByteVariable(System.UInt16,System.Int32)">
            <summary>
            读取多个的字节型变量的数据，读取的最大个数为 474 个。
            </summary>
            <param name="address">标准地址范围为 0 ~ 99</param>
            <param name="length">读取的数据个数，读取的最大个数为 474 个</param>
            <returns>结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteByteVariable(System.UInt16,System.Byte[])">
            <summary>
            将多个字节的变量的数据写入到指定的地址，最大个数为 474 个，仅可指定2的倍数
            </summary>
            <param name="address">标准地址范围为 0 ~ 99</param>
            <param name="vaule">写入的值，最大个数为 474 个，仅可指定2的倍数</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadIntegerVariable(System.UInt16)">
            <summary>
            读取单个的整型变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">0 ～ 99（ 标准设定时）</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteIntegerVariable(System.UInt16,System.Int16)">
            <summary>
            将单个的数据写入到整型变量去，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="value">等待写入的值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadIntegerVariable(System.UInt16,System.Int32)">
            <summary>
            读取多个的整型变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="length">读取的个数</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteIntegerVariable(System.UInt16,System.Int16[])">
            <summary>
            写入多个的整型变量数据到机器人，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="value">等待写入的数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadDoubleIntegerVariable(System.UInt16)">
            <summary>
            读取单个的双精度整型变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">0 ～ 99（ 标准设定时）</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteDoubleIntegerVariable(System.UInt16,System.Int32)">
            <summary>
            将单个的数据写入到双精度整型变量去，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="value">等待写入的值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadDoubleIntegerVariable(System.UInt16,System.Int32)">
            <summary>
            读取多个的双精度整型变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="length">读取的个数，最大118个</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteDoubleIntegerVariable(System.UInt16,System.Int32[])">
            <summary>
            写入多个的双精度整型变量数据到机器人，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="value">等待写入的数据信息，最大118个数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadRealVariable(System.UInt16)">
            <summary>
            读取单个的实数型变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <returns>读取结果内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteRealVariable(System.UInt16,System.Single)">
            <summary>
            将单个的数据写入到实数型变量去，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="value">写入的值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadRealVariable(System.UInt16,System.Int32)">
            <summary>
            读取多个的实数型变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="length">读取的个数，最大118个</param>
            <returns>读取的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteRealVariable(System.UInt16,System.Single[])">
            <summary>
            写入多个的实数型的变量数据到机器人，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="value">等待写入的数据信息，最大118个数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadStringVariable(System.UInt16)">
            <summary>
            读取单个的字符串变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <returns>读取的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteStringVariable(System.UInt16,System.String)">
            <summary>
            写入单个的字符串变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="value">写入的字符串数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadStringVariable(System.UInt16,System.Int32)">
            <summary>
            读取多个的字符串变量数据，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="length">读取的字符串个数，最大个数为 29 </param>
            <returns>读取的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.WriteStringVariable(System.UInt16,System.String[])">
            <summary>
            写入多个的字符串变量数据到机器人，地址范围：0 ～ 99（ 标准设定时）
            </summary>
            <param name="address">地址范围：0 ～ 99（ 标准设定时）</param>
            <param name="value">等待写入的字符串数组，最大数组长度为 29 </param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.Hold(System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Hold(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.Reset">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Reset"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.Cancel">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Cancel"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.Svon(System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Svon(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.HLock(System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.HLock(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.Cycle(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Cycle(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.MSDP(System.String)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.MSDP(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.Start">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Start(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadManagementTime(System.UInt16)">
            <summary>
            读取机器人的诗句信息，根据地址来获取不同的时间，地址如下：<br />
            1: 控制电源的接通时间<br />
            10: 伺服电源接通时间(TOTAL)<br />
            11~18: 伺服电源接通时间(R1~R8)<br />
            21~44: 伺服电源接通时间(S1~S24)<br />
            110: 再线时间（TOTAL）<br />
            111~118: 再线时间（R1~R8）<br />
            121~144: 再线时间 (S1~S24)<br />
            210: 移动时间（TOTAL）<br />
            211~218: 移动时间（R1~R8）<br />
            221~244: 移动时间（S1~S24）<br />
            301~308: 作业时间（用途1~用途8）
            </summary>
            <param name="address">时间的地址信息，具体参照方法的注释</param>
            <returns>读取的时间信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadSystemInfo(System.UInt16)">
            <summary>
            读取系统的参数信息，其中系统种类参数：<br />
            11~18:机种信息R1~R8; <br />
            21~44:机种信息S1~S24; <br />
            101~108: 用途信息(用途1~用途8); <br />
            返回数据信息为数组，分别为 [0]:系统软件版本；[1]:机种名称/用途名称；[2]:参数版本
            </summary>
            <param name="system">统种类参数：11~18:机种信息R1~R8; 21~44:机种信息S1~S24; 101~108: 用途信息(用途1~用途8);</param>
            <returns>返回数据信息为数组，分别为 [0]:系统软件版本；[1]:机种名称/用途名称；[2]:参数版本</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.JSeq(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.JSeq(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCHighEthernet.ReadPOSC(System.Int32,System.Boolean)">
            <summary>
            指定坐标系的当前值读取。并且可以指定外部轴的有无。<br />
            The current value of the specified coordinate system is read. And you can specify the presence or absence of an external axis.
            </summary>
            <param name="coordinate">指定读取坐标 0:基座坐标，1:机器人坐标，2-65分别表示用户坐标1-64</param>
            <param name="hasExteralAxis">外部轴的有/无</param>
            <returns>坐标系当前值</returns>
        </member>
        <member name="T:HslCommunication.Robot.YASKAWA.YRCRobotData">
            <summary>
            安川机器人的数据信息，其中 Re只在YRC100中有效，没有外部轴的系统， 7-12外部轴的值设定为「0」
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCRobotData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCRobotData.#ctor(HslCommunication.Robot.YASKAWA.YRCType,System.String)">
            <summary>
            指定类型及字符串数据信息来实例化一个对象
            </summary>
            <param name="type">类型信息</param>
            <param name="value">字符串数据</param>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.SpeedPercent">
            <summary>
            动作速度（ 0.01 ～ 100.0％）
            </summary>
            <remarks>
            在读取时没有任何的含义，仅在写入数据是有效，默认为 100.0%
            </remarks>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Frame">
            <summary>
            参考系，0:基座坐标，1:机器人坐标，2-65分别表示用户坐标1-64
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.X">
            <summary>
            X 坐标值（ 单位mm、小数点第 3 位有效）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Y">
            <summary>
            Y 坐标值（单位mm、小数点第 3 位有效）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Z">
            <summary>
            Z 坐标值（单位 mm、小数点第 3 位有效）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Rx">
            <summary>
            手腕姿勢 Rx 坐标值（单位 °、小数点第 4 位有效）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Ry">
            <summary>
            手腕姿勢 Ry 坐标值（单位 °、 小数点第 4 位有效）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Rz">
            <summary>
            手腕姿勢 Rz 坐标值（单位 °、 小数点第 4 位有效）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Re">
            <summary>
            肘角姿势 Re，仅在七轴机器人的情况下有效
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Status">
            <summary>
            形态数据，各个索引含义为 [0] 0:F lip,1:N o Flip [1] 0:上方肘，1:下方肘 [2] 0:正面,1:背面 [3] 0:R＜180, 1:R≥180 [4] 0:T＜180, 1:T≥180 [5] 0:S＜180, 1:S≥180
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.ToolNumber">
            <summary>
            工具编号（ 0 ～ 63）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Axis7PulseNumber">
            <summary>
            第 7 轴脉冲数（ 行走轴时、 单位mm）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Axis8PulseNumber">
            <summary>
            第 8 轴脉冲数（ 行走轴时、 单位mm）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Axis9PulseNumber">
            <summary>
            第 9 轴脉冲数（行走轴时、 单位mm）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Axis10PulseNumber">
            <summary>
            第 10 轴脉冲数
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Axis11PulseNumber">
            <summary>
            第 11 轴脉冲数
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.YASKAWA.YRCRobotData.Axis12PulseNumber">
            <summary>
            第 12 轴脉冲数
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCRobotData.ToWriteString(HslCommunication.Robot.YASKAWA.YRCType)">
            <summary>
            将数据转换为写入命令的字符换，需要指定是否七轴机器人的信息
            </summary>
            <param name="type">机器人的型号信息</param>
            <returns>写入的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCRobotData.Parse(HslCommunication.Robot.YASKAWA.YRCType,System.String)">
            <summary>
            从实际机器人读取到的数据解析出真实的机器人信息。
            </summary>
            <param name="type">机器人类型</param>
            <param name="value">值</param>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRCRobotData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.YASKAWA.YRCType">
            <summary>
            YRC机器人的类型
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.YASKAWA.YRCType.YRC1000">
            <summary>
            YRC1000 型号，含有六轴机器人
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.YASKAWA.YRCType.YRC100">
            <summary>
            YRC100 型号，含有七轴机器人
            </summary>
        </member>
        <member name="T:HslCommunication.Secs.Gem">
            <summary>
            GEM相关的数据读写信息
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Gem.#ctor(HslCommunication.Secs.Types.ISecs)">
            <summary>
            使用指定的 <see cref="T:HslCommunication.Secs.Types.ISecs"/> 接口来初始化 GEM 对象，然后进行数据读写操作
            </summary>
            <param name="secs">Secs的通信对象</param>
        </member>
        <member name="M:HslCommunication.Secs.Gem.S1F1_AreYouThere">
            <summary>
            S1F1的功能方法
            </summary>
            <returns>在线数据信息</returns>
        </member>
        <member name="M:HslCommunication.Secs.Gem.S1F11_StatusVariableNamelist">
            <summary>
            S1F11的功能方法
            </summary>
            <returns>变量名称数组</returns>
        </member>
        <member name="M:HslCommunication.Secs.Gem.S1F11_StatusVariableNamelist(System.Int32[])">
            <summary>
            S1F11的功能方法，带参数传递
            </summary>
            <param name="statusVaruableId"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Secs.Gem.S1F13_EstablishCommunications">
            <summary>
            S1F13的功能方法，测试连接的
            </summary>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Secs.Gem.S1F15_OfflineRequest">
            <summary>
            S1F15的功能方法
            </summary>
            <remarks>
            返回值说明，0: ok, 1: refused, 2: already online
            </remarks>
            <returns>返回值说明，0: ok, 1: refused, 2: already online</returns>
        </member>
        <member name="M:HslCommunication.Secs.Gem.S1F17_OnlineRequest">
            <summary>
            S1F17的功能方法
            </summary>
            <remarks>
            返回值说明，0: ok, 1: refused, 2: already online
            </remarks>
            <returns>返回值说明，0: ok, 1: refused, 2: already online</returns>
        </member>
        <member name="M:HslCommunication.Secs.Gem.S2F13_EquipmentConstantRequest(System.Object[])">
            <summary>
            S2F13的功能方法
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="T:HslCommunication.Secs.Helper.Secs1">
            <summary>
            Secs-1的协议信息
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Helper.Secs1.BuildSecsOneMessage(System.UInt16,System.Byte,System.Byte,System.UInt16,System.UInt32,System.Byte[],System.Boolean)">
            <summary>
            根据传入的参数信息，构建完整的SECS消息报文列表
            </summary>
            <param name="deviceID">装置识别码</param>
            <param name="streamNo">主功能码</param>
            <param name="functionNo">子功能码</param>
            <param name="blockNo">数据块号</param>
            <param name="messageID">消息序号</param>
            <param name="data">真实数据消息</param>
            <param name="wBit">是否必须回复讯息</param>
            <returns>完整的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Secs.Helper.Secs1.BuildHSMSMessage(System.UInt16,System.Byte,System.Byte,System.UInt16,System.UInt32,System.Byte[],System.Boolean)">
            <summary>
            根据传入的参数信息，构建完整的SECS/HSMS消息报文列表
            </summary>
            <param name="deviceID">装置识别码</param>
            <param name="streamNo">主功能码</param>
            <param name="functionNo">子功能码</param>
            <param name="blockNo">数据块号</param>
            <param name="messageID">消息序号</param>
            <param name="data">真实数据消息</param>
            <param name="wBit">是否必须回复讯息</param>
            <returns>完整的报文信息</returns>
        </member>
        <member name="T:HslCommunication.Secs.Helper.Secs2">
            <summary>
            Secs2相关的规则
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeList">
            <summary>
            列表的类型信息
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeASCII">
            <summary>
            ASCII字符串的信息
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeSByte">
            <summary>
            有符号的1个字节长度的整型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeByte">
            <summary>
            无符号的1个字节长度的整型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeInt16">
            <summary>
            有符号的2个字节长度的整型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeUInt16">
            <summary>
            无符号的2个字节长度的整型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeInt32">
            <summary>
            有符号的4个字节长度的整型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeUInt32">
            <summary>
            无符号的4个字节长度的整型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeInt64">
            <summary>
            有符号的8个字节长度的整型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeUInt64">
            <summary>
            无符号的8个字节长度的整型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeSingle">
            <summary>
            单浮点精度的类型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeDouble">
            <summary>
            双浮点精度的类型
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeBool">
            <summary>
            Bool值信息
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeBinary">
            <summary>
            二进制的数据信息
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.TypeJIS8">
            <summary>
            JIS8类型的数据
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Helper.Secs2.ExtraToSecsItemValue(System.Byte[])">
            <summary>
            将返回的数据内容解析为实际的字符串信息，根据secsⅡ 协议定义的规则解析出实际的数据信息
            </summary>
            <param name="buffer">原始的字节数据内容</param>
            <returns>字符串消息</returns>
        </member>
        <member name="F:HslCommunication.Secs.Helper.Secs2.SecsTransform">
            <summary>
            SECS的字节顺序信息
            </summary>
        </member>
        <member name="T:HslCommunication.Secs.Message.SecsHsmsMessage">
            <summary>
            Hsms协议的消息定义
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Message.SecsHsmsMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Secs.Message.SecsHsmsMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Secs.Message.SecsHsmsMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Secs.SecsGemSerial">
            <summary>
            串口类相关的Secs
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.SecsGemSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.SecsGemSerial.ExecuteCommand(System.Byte[])">
            <summary>
            执行SECS命令
            </summary>
            <param name="command">命令信息</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="T:HslCommunication.Secs.SecsHsms">
            <summary>
            HSMS的协议实现，SECS基于TCP的版本
            </summary>
            <remarks>
            </remarks>
            <example>
            下面就看看基本的操作内容
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Secs\SecsGemSample.cs" region="Sample1" title="基本的读写" />
            如果想要手动处理下设备主要返回的数据，比如报警之类的，可以参考下面的方法
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Secs\SecsGemSample.cs" region="Sample3" title="事件回调处理" />
            关于<see cref="T:HslCommunication.Secs.Types.SecsValue"/>类型，可以非常灵活的实例化，参考下面的示例代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Secs\SecsGemSample.cs" region="Sample2" title="SecsValue说明" />
            </example>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.#ctor">
            <summary>
            实例化一个默认的对象<br />
            instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个默认的对象<br />
            Specify the IP address and port number to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Secs.SecsHsms.DeviceID">
            <summary>
            获取或设置当前的DeivceID信息
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.SecsHsms.Gem">
            <summary>
            获取或设置当前的GEM信息，可以用来方便的调用一些常用的功能接口，或是自己实现自定义的接口方法
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.DecideWhetherQAMessage(System.Net.Sockets.Socket,HslCommunication.OperateResult{System.Byte[]})">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.SendByCommand(System.Byte,System.Byte,System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Secs.Types.ISecs.SendByCommand(System.Byte,System.Byte,System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.SendByCommand(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Secs.Types.ISecs.SendByCommand(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.ReadSecsMessage(System.Byte,System.Byte,System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Secs.Types.ISecs.ReadSecsMessage(System.Byte,System.Byte,System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.ReadSecsMessage(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Secs.Types.ISecs.ReadSecsMessage(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.ReadSecsMessageAsync(System.Byte,System.Byte,System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Secs.Types.ISecs.ReadSecsMessage(System.Byte,System.Byte,System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.ReadSecsMessageAsync(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Secs.Types.ISecs.ReadSecsMessage(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue,System.Boolean)"/>
        </member>
        <member name="T:HslCommunication.Secs.SecsHsms.OnSecsMessageReceivedDelegate">
            <summary>
            Secs消息接收的事件
            </summary>
            <param name="sender">数据的发送方</param>
            <param name="secsMessage">消息内容</param>
        </member>
        <member name="E:HslCommunication.Secs.SecsHsms.OnSecsMessageReceived">
            <summary>
            当接收到非应答消息的时候触发的事件
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsms.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Secs.SecsHsmsServer">
            <summary>
            Secs Hsms的虚拟服务器，可以用来模拟Secs设备，等待客户端的连接，自定义响应客户端的数据
            </summary>
            <remarks>
            </remarks>
            <example>
            下面就看看基本的操作内容
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Secs\SecsGemSample.cs" region="Server Sample" title="基本的使用" />
            关于<see cref="T:HslCommunication.Secs.Types.SecsValue"/>类型，可以非常灵活的实例化，参考下面的示例代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Secs\SecsGemSample.cs" region="Sample2" title="SecsValue说明" />
            </example>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsmsServer.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsmsServer.SocketAsyncCallBack(System.IAsyncResult)">
            <summary>
            从远程Socket异步接收的数据信息
            </summary>
            <param name="ar">异步接收的对象</param>
        </member>
        <member name="T:HslCommunication.Secs.SecsHsmsServer.SecsMessageReceivedDelegate">
            <summary>
            当接收到来自客户的Secs信息时触发的对象<br />
            Object fired when Secs information from client is received
            </summary>
            <param name="sender">触发的服务器对象</param>
            <param name="session">消息的会话对象信息</param>
            <param name="message">实际的数据信息</param>
        </member>
        <member name="E:HslCommunication.Secs.SecsHsmsServer.OnSecsMessageReceived">
            <summary>
            接收到数据的时候就触发的事件，示例详细参考API文档信息<br />
            An event that is triggered when data is received
            </summary>
            <remarks>
            事件共有三个参数，sender指服务器本地的对象，为 <see cref="T:HslCommunication.Secs.SecsHsmsServer"/> 对象，session 指会话对象，网为 <see cref="T:HslCommunication.Core.Net.AppSession"/>，message 为收到的原始数据 <see cref="T:HslCommunication.Secs.Types.SecsMessage"/> 对象
            </remarks>
            <example>
            </example>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsmsServer.RaiseDataReceived(System.Object,HslCommunication.Core.Net.AppSession,HslCommunication.Secs.Types.SecsMessage)">
            <summary>
            触发一个数据接收的事件信息<br />
            Event information that triggers a data reception
            </summary>
            <param name="source">数据的发送方</param>
            <param name="session">消息的会话对象信息</param>
            <param name="message">实际的数据信息</param>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsmsServer.SendByCommand(HslCommunication.Core.Net.AppSession,HslCommunication.Secs.Types.SecsMessage,System.Byte,System.Byte,System.Byte[])">
            <summary>
            向指定的会话信息发送SECS格式的原始字节数据信息，session 为当前的会话对象，receiveMessage为接收到数据，后续的参数才是真实的返回数据
            </summary>
            <param name="session">当前的会话对象</param>
            <param name="receiveMessage">接收到的Secs数据</param>
            <param name="stream">功能码1</param>
            <param name="function">功能码2</param>
            <param name="data">原始的字节数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsmsServer.SendByCommand(HslCommunication.Core.Net.AppSession,HslCommunication.Secs.Types.SecsMessage,System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue)">
            <inheritdoc cref="M:HslCommunication.Secs.SecsHsmsServer.SendByCommand(HslCommunication.Core.Net.AppSession,HslCommunication.Secs.Types.SecsMessage,System.Byte,System.Byte,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsmsServer.PublishSecsMessage(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue)">
            <summary>
            发布数据到所有的在线客户端信息
            </summary>
            <param name="stream">功能码1</param>
            <param name="function">功能码2</param>
            <param name="data">数据对象</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Secs.SecsHsmsServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Secs.Types.ISecs">
            <summary>
            ISecs的接口信息，支持了将数据发送到对方，或是使用问答机制从设备获取数据<br />
            The interface information of ISecs supports sending data to the other party, or using the question and answer mechanism to obtain data from the device
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.ISecs.SendByCommand(System.Byte,System.Byte,System.Byte[],System.Boolean)">
            <summary>
            将数据发送到设备方去，只是单纯的发送数据过去，并不等待设备的数据返回，返回是否发送成功。<br />
            Sending data to the device side simply sends the data to the past, and does not wait for the data from the device to return, and returns whether the transmission is successful.
            </summary>
            <param name="stream">功能码1</param>
            <param name="function">功能码2</param>
            <param name="data">原始的字节数据</param>
            <param name="back">是否必须返回，此标记仅仅是secs报文的是否返回标记，不表示问答模式</param>
            <returns>是否发送成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.ISecs.SendByCommand(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue,System.Boolean)">
            <summary>
            将数据发送到设备方去，只是单纯的发送数据过去，并不等待设备的数据返回，返回是否发送成功。<br />
            Sending data to the device side simply sends the data to the past, and does not wait for the data from the device to return, and returns whether the transmission is successful.
            </summary>
            <param name="stream">功能码1</param>
            <param name="function">功能码2</param>
            <param name="data">Secs格式的对象信息</param>
            <param name="back">是否必须返回，此标记仅仅是secs报文的是否返回标记，不表示问答模式</param>
            <returns>是否发送成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.ISecs.ReadSecsMessage(System.Byte,System.Byte,System.Byte[],System.Boolean)">
            <summary>
            根据指定的功能码将数据报文发送给设备，并且等待从SECS设备返回Secs消息，本访问机制是问答模式的。<br />
            Send the data message to the device according to the specified function code, and wait for the Secs message to be returned from the SECS device. This access mechanism is in question-and-answer mode.
            </summary>
            <param name="stream">功能码1</param>
            <param name="function">功能码2</param>
            <param name="data">原始的字节数据</param>
            <param name="back">是否必须返回，此标记仅仅是secs报文的是否返回标记，不表示问答模式</param>
            <returns>返回SECS消息结果对象</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.ISecs.ReadSecsMessage(System.Byte,System.Byte,HslCommunication.Secs.Types.SecsValue,System.Boolean)">
            <summary>
            根据指定的功能码将数据报文发送给设备，并且等待从SECS设备返回Secs消息，本访问机制是问答模式的。<br />
            Send the data message to the device according to the specified function code, and wait for the Secs message to be returned from the SECS device. This access mechanism is in question-and-answer mode.
            </summary>
            <param name="stream">功能码1</param>
            <param name="function">功能码2</param>
            <param name="data">Secs格式的对象信息</param>
            <param name="back">是否必须返回，此标记仅仅是secs报文的是否返回标记，不表示问答模式</param>
            <returns>返回SECS消息结果对象</returns>
        </member>
        <member name="T:HslCommunication.Secs.Types.OnlineData">
            <summary>
            在线数据信息
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.OnlineData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.OnlineData.#ctor(System.String,System.String)">
            <summary>
            指定类型及其版本号来实例化一个对象
            </summary>
            <param name="model">类型信息</param>
            <param name="version">版本号</param>
        </member>
        <member name="P:HslCommunication.Secs.Types.OnlineData.ModelType">
            <summary>
            equipment model type
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.OnlineData.SoftVersion">
            <summary>
            software revision
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.OnlineData.op_Implicit(HslCommunication.Secs.Types.SecsValue)~HslCommunication.Secs.Types.OnlineData">
            <summary>
            赋值操作，可以直接赋值 <see cref="T:HslCommunication.Secs.Types.OnlineData"/> 数据
            </summary>
            <param name="value"><see cref="T:HslCommunication.Secs.Types.SecsValue"/> 数值</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.OnlineData.op_Implicit(HslCommunication.Secs.Types.OnlineData)~HslCommunication.Secs.Types.SecsValue">
            <summary>
            也可以赋值给<see cref="T:HslCommunication.Secs.Types.SecsValue"/> 数据
            </summary>
            <param name="value"><see cref="T:HslCommunication.Secs.Types.SecsValue"/> 对象</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="T:HslCommunication.Secs.Types.SecsItemType">
            <summary>
            数据类型的定义
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.List">
            <summary>
            列表数据类型，代号：L
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.Bool">
            <summary>
            Bool值类型，代号：BOOLEAN
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.Binary">
            <summary>
            二进制数据，代号：B
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.ASCII">
            <summary>
            ASCII编码的字符串，代号：A
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.JIS8">
            <summary>
            JIS类型，代号：J
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.SByte">
            <summary>
            一个字节的有符号数据，代号：I1
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.Byte">
            <summary>
            一个字节的无符号数据，代号：U1
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.Int16">
            <summary>
            两个字节的有符号数据，代号：I2
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.UInt16">
            <summary>
            两个字节的无符号数据，代号：U2
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.Int32">
            <summary>
            四个字节的有符号数据，代号：I4
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.UInt32">
            <summary>
            四个字节的无符号数据，代号：U4
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.Int64">
            <summary>
            八个字节的有符号数据，代号：I8
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.UInt64">
            <summary>
            八个字节的无符号数据，代号：U8
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.Single">
            <summary>
            四个字节的浮点数，代号：F4
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.Double">
            <summary>
            八个字节的浮点数，代号：F8
            </summary>
        </member>
        <member name="F:HslCommunication.Secs.Types.SecsItemType.None">
            <summary>
            这是一个空的类型信息
            </summary>
        </member>
        <member name="T:HslCommunication.Secs.Types.SecsMessage">
            <summary>
            Secs的消息类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsMessage.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsMessage.#ctor(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsMessage.#ctor(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsMessage.#ctor(System.Byte[],System.Int32)">
            <summary>
            通过原始的报文信息来实例化一个默认的对象
            </summary>
            <param name="message">原始的字节信息</param>
            <param name="startIndex">起始的偏移地址</param>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.DeviceID">
            <summary>
            设备的ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.R">
            <summary>
            R=false, Host → Equipment; R=true, Host ← Equipment
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.W">
            <summary>
            W=false, 不必回复讯息；W=true, 必须回复讯息
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.E">
            <summary>
            E=false, 尚有Block; E=true, 此为最后一个Block
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.StreamNo">
            <summary>
            Stream功能码
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.FunctionNo">
            <summary>
            Function功能码
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.BlockNo">
            <summary>
            获取或设置区块号信息
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.MessageID">
            <summary>
            获取或设置消息ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsMessage.Data">
            <summary>
            消息数据对象
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsMessage.GetItemValues">
            <summary>
            获取当前消息的所有对象信息
            </summary>
            <returns>Secs数据对象</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Secs.Types.SecsMessageExtension">
            <summary>
            扩展类
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsMessageExtension.ToRenderString(HslCommunication.Secs.Types.SecsValue[])">
            <summary>
            获取显示的字符串文本信息
            </summary>
            <param name="secsMessages">SECS消息类</param>
            <returns>字符串信息</returns>
        </member>
        <member name="T:HslCommunication.Secs.Types.SecsValue">
            <summary>
            SECS数据的对象信息，可以用来表示层级及嵌套的数据内容，如果需要显示，只需要<see cref="M:HslCommunication.Secs.Types.SecsValue.ToString"/> 方法即可，
            如果需要发送SECS设备，只需要 <see cref="M:HslCommunication.Secs.Types.SecsValue.ToSourceBytes"/>，并支持反序列化操作 <see cref="M:HslCommunication.Secs.Types.SecsValue.ParseFromSource(System.Byte[])"/>，无论是XML元素还是byte[]类型。
            </summary>
            <remarks>
            XML序列化，反序列化例子：<br />
            SecsValue value = new SecsValue( new object[]{ 1.23f, "ABC" } );<br />
            XElement xml = value.ToXElement( ); <br />
            SecsValue value2 = new SecsValue(xml);
            </remarks>
            <example>
            关于<see cref="T:HslCommunication.Secs.Types.SecsValue"/>类型，可以非常灵活的实例化，参考下面的示例代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Secs\SecsGemSample.cs" region="Sample2" title="SecsValue说明" />
            </example>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor">
            <summary>
            实例化一个空的SECS对象
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.String)">
            <summary>
            从一个字符串对象初始化数据信息
            </summary>
            <param name="value">字符串信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.SByte)">
            <summary>
            从一个类型为 <see cref="T:System.SByte"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.SByte[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.SByte)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Byte)">
            <summary>
            从一个类型为 <see cref="T:System.Byte"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Int16)">
            <summary>
            从一个类型为 <see cref="T:System.Int16"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Int16[])">
            <summary>
            从一个类型为 <see cref="T:System.Int32"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt16)">
            <summary>
            从一个类型为 <see cref="T:System.UInt16"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Int32)">
            <summary>
            从一个类型为 <see cref="T:System.Int32"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Int32[])">
            <summary>
            从一个类型为 <see cref="T:System.Int32"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt32)">
            <summary>
            从一个类型为 <see cref="T:System.UInt32"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Int64)">
            <summary>
            从一个类型为 <see cref="T:System.Int64"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt64)">
            <summary>
            从一个类型为 <see cref="T:System.UInt64"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Single)">
            <summary>
            从一个类型为 <see cref="T:System.Single"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Single[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Single)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Double)">
            <summary>
            从一个类型为 <see cref="T:System.Double"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Double[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Double)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Byte[])">
            <summary>
            从一个类型为 <see cref="T:System.Byte"/> 数组的对象初始化数据，需要指定 <see cref="T:HslCommunication.Secs.Types.SecsItemType"/> 来表示二进制还是byte数组类型
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Boolean)">
            <summary>
            从一个类型为 <see cref="T:System.Boolean"/> 的对象初始化数据
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            从一个类型为 <see cref="T:System.Object"/> 数组的对象初始化数据，初始化后，本对象为 <see cref="F:HslCommunication.Secs.Types.SecsItemType.List"/> 类型
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(HslCommunication.Secs.Types.SecsItemType,System.Object)">
            <summary>
            通过指定的参数信息来实例化一个对象
            </summary>
            <param name="type">数据的类型信息</param>
            <param name="value">数据值信息，当是<see cref="F:HslCommunication.Secs.Types.SecsItemType.List"/>类型时，本值为空 </param>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.#ctor(System.Xml.Linq.XElement)">
            <summary>
            从完整的XML元素进行实例化一个对象
            </summary>
            <param name="element">符合SECS的XML数据表示元素</param>
            <exception cref="T:System.ArgumentException">解析失败的异常</exception>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsValue.ItemType">
            <summary>
            类型信息
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsValue.Length">
            <summary>
            字节长度信息，如果是 <see cref="F:HslCommunication.Secs.Types.SecsItemType.List"/> 类型的话，就是数组长度，如果如 <see cref="F:HslCommunication.Secs.Types.SecsItemType.ASCII"/> 类型，就是字符串的字节长度，其他类型都是表示数据个数<br />
            Byte length information, if it is of type <see cref="F:HslCommunication.Secs.Types.SecsItemType.List"/>, it is the length of the array, if it is of type <see cref="F:HslCommunication.Secs.Types.SecsItemType.ASCII"/>,
            it is the byte length of the string, other types are the number of data
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.SecsValue.Value">
            <summary>
            数据值信息，也可以是 <see cref="T:HslCommunication.Secs.Types.SecsValue"/> 的列表信息，在设置列表之前，必须先设置类型
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.ToXElement">
            <summary>
            获取当前数值的XML表示形式
            </summary>
            <returns>XML元素信息</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.ToSourceBytes">
            <summary>
            当前的对象信息转换回实际的原始字节信息，方便写入操作
            </summary>
            <returns>原始字节数据</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.ToVaruableNames">
            <summary>
            将当前的对象转为 <see cref="T:HslCommunication.Secs.Types.VariableName"/> 数组对象信息，也就是标签名列表
            </summary>
            <returns><see cref="T:HslCommunication.Secs.Types.VariableName"/> 数组对象</returns>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.ParseFromSource(System.Byte[])">
            <summary>
            从原始的字节数据中解析出实际的 <see cref="T:HslCommunication.Secs.Types.SecsValue"/> 对象内容。
            </summary>
            <param name="source">原始字节数据</param>
            <returns>SecsItemValue对象</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.EmptyListValue">
            <summary>
            获取空的列表信息
            </summary>
            <returns>secs数据对象</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.SecsValue.GetValueLength(HslCommunication.Secs.Types.SecsValue)">
            <summary>
            获取当前的 <see cref="T:HslCommunication.Secs.Types.SecsValue"/> 的数据长度信息
            </summary>
            <param name="secsValue">secs值</param>
            <returns>数据长度信息</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.TypeHelper.TypeListCheck(HslCommunication.Secs.Types.SecsValue)">
            <summary>
            检查类型 <see cref="T:HslCommunication.Secs.Types.SecsValue"/> 的类型是否为 <see cref="F:HslCommunication.Secs.Types.SecsItemType.List"/>，如果不是，就抛出异常
            </summary>
            <param name="secsItem">等待转换的对象</param>
            <exception cref="T:System.InvalidCastException">转换异常</exception>
        </member>
        <member name="T:HslCommunication.Secs.Types.VariableName">
            <summary>
            变量名称类对象
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.VariableName.ID">
            <summary>
            变量的ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.VariableName.Name">
            <summary>
            变量的名称信息
            </summary>
        </member>
        <member name="P:HslCommunication.Secs.Types.VariableName.Units">
            <summary>
            变量的单位信息
            </summary>
        </member>
        <member name="M:HslCommunication.Secs.Types.VariableName.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Secs.Types.VariableName.op_Implicit(HslCommunication.Secs.Types.SecsValue)~HslCommunication.Secs.Types.VariableName">
            <summary>
            赋值操作，可以直接赋值 <see cref="T:HslCommunication.Secs.Types.OnlineData"/> 数据
            </summary>
            <param name="value"><see cref="T:HslCommunication.Secs.Types.SecsValue"/> 数值</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="M:HslCommunication.Secs.Types.VariableName.op_Implicit(HslCommunication.Secs.Types.VariableName)~HslCommunication.Secs.Types.SecsValue">
            <summary>
            也可以赋值给<see cref="T:HslCommunication.Secs.Types.SecsValue"/> 数据
            </summary>
            <param name="value"><see cref="T:HslCommunication.Secs.Types.SecsValue"/> 对象</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="T:HslCommunication.Serial.CheckType">
            <summary>
            校验方式
            </summary>
        </member>
        <member name="F:HslCommunication.Serial.CheckType.BCC">
            <summary>
            和校验
            </summary>
        </member>
        <member name="F:HslCommunication.Serial.CheckType.CRC16">
            <summary>
            CRC校验的方式
            </summary>
        </member>
        <member name="T:HslCommunication.Serial.SoftCRC16">
            <summary>
            用于CRC16验证的类，提供了标准的验证方法，可以方便快速的对数据进行CRC校验<br />
            The class for CRC16 validation provides a standard validation method that makes it easy to CRC data quickly
            </summary>
            <remarks>
            本类提供了几个静态的方法，用来进行CRC16码的计算和验证的，多项式码可以自己指定配置，但是预置的寄存器为0xFF 0xFF
            </remarks>
            <example>
            先演示如何校验一串数据的CRC码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Serial\SoftCRC16.cs" region="Example1" title="SoftCRC16示例" />
            然后下面是如何生成你自己的CRC校验码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Serial\SoftCRC16.cs" region="Example2" title="SoftCRC16示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Serial.SoftCRC16.CheckCRC16(System.Byte[])">
            <summary>
            来校验对应的接收数据的CRC校验码，默认多项式码为0xA001<br />
            To verify the CRC check code corresponding to the received data, the default polynomial code is 0xA001
            </summary>
            <param name="value">需要校验的数据，带CRC校验码</param>
            <returns>返回校验成功与否</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftCRC16.CheckCRC16(System.Byte[],System.Byte,System.Byte)">
            <summary>
            指定多项式码来校验对应的接收数据的CRC校验码<br />
            Specifies a polynomial code to validate the corresponding CRC check code for the received data
            </summary>
            <param name="value">需要校验的数据，带CRC校验码</param>
            <param name="CH">多项式码高位</param>
            <param name="CL">多项式码低位</param>
            <returns>返回校验成功与否</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftCRC16.CRC16(System.Byte[])">
            <summary>
            获取对应的数据的CRC校验码，默认多项式码为0xA001<br />
            Get the CRC check code of the corresponding data, the default polynomial code is 0xA001
            </summary>
            <param name="value">需要校验的数据，不包含CRC字节</param>
            <returns>返回带CRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftCRC16.CRC16(System.Byte[],System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            通过指定多项式码来获取对应的数据的CRC校验码<br />
            The CRC check code of the corresponding data is obtained by specifying the polynomial code
            </summary>
            <param name="value">需要校验的数据，不包含CRC字节</param>
            <param name="CL">多项式码地位</param>
            <param name="CH">多项式码高位</param>
            <param name="preH">预置的高位值</param>
            <param name="preL">预置的低位值</param>
            <returns>返回带CRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="T:HslCommunication.Serial.SerialBase">
            <summary>
            所有串行通信类的基类，提供了一些基础的服务，核心的通信实现<br />
            The base class of all serial communication classes provides some basic services for the core communication implementation
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.#ctor">
            <summary>
            实例化一个无参的构造方法<br />
            Instantiate a parameterless constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SetPipeSerial(HslCommunication.Core.Pipe.PipeSerial)">
            <summary>
            设置一个新的串口管道，一般来说不需要调用本方法，当多个串口设备共用一个COM口时才需要使用本方法进行设置共享的管道。<br />
            To set a new serial port pipe, generally speaking, you do not need to call this method. 
            This method is only needed to set the shared pipe when multiple serial devices share the same COM port.
            </summary>
            <remarks>
            如果需要设置共享的串口管道的话，需要是设备类对象实例化之后立即进行设置，如果在串口的初始化之后再设置操作，串口的初始化可能会失效。<br />
            If you need to set a shared serial port pipeline, you need to set it immediately after the device class object is instantiated. 
            If you set the operation after the initialization of the serial port, the initialization of the serial port may fail.
            </remarks>
            <param name="pipeSerial">共享的串口管道信息</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SerialPortInni(System.String)">
            <summary>
            初始化串口信息，9600波特率，8位数据位，1位停止位，无奇偶校验<br />
            Initial serial port information, 9600 baud rate, 8 data bits, 1 stop bit, no parity
            </summary>
            <remarks>
            portName 支持格式化的方式，例如输入 COM3-9600-8-N-1，COM5-19200-7-E-2，其中奇偶校验的字母可选，N:无校验，O：奇校验，E:偶校验，停止位可选 0, 1, 2, 1.5 四种选项
            </remarks>
            <param name="portName">端口号信息，例如"COM3"</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SerialPortInni(System.String,System.Int32)">
            <summary>
            初始化串口信息，波特率，8位数据位，1位停止位，无奇偶校验<br />
            Initializes serial port information, baud rate, 8-bit data bit, 1-bit stop bit, no parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SerialPortInni(System.String,System.Int32,System.Int32,System.IO.Ports.StopBits,System.IO.Ports.Parity)">
            <summary>
            初始化串口信息，波特率，数据位，停止位，奇偶校验需要全部自己来指定<br />
            Start serial port information, baud rate, data bit, stop bit, parity all need to be specified
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
            <param name="dataBits">数据位</param>
            <param name="stopBits">停止位</param>
            <param name="parity">奇偶校验</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SerialPortInni(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            根据自定义初始化方法进行初始化串口信息<br />
            Initialize the serial port information according to the custom initialization method
            </summary>
            <param name="initi">初始化的委托方法</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.Open">
            <summary>
            打开一个新的串行端口连接<br />
            Open a new serial port connection
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.IsOpen">
            <summary>
            获取一个值，指示串口是否处于打开状态<br />
            Gets a value indicating whether the serial port is open
            </summary>
            <returns>是或否</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.Close">
            <summary>
            关闭当前的串口连接<br />
            Close the current serial connection
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ReadFromCoreServer(System.Byte[])">
            <summary>
            将原始的字节数据发送到串口，然后从串口接收一条数据。<br />
            The raw byte data is sent to the serial port, and then a piece of data is received from the serial port.
            </summary>
            <param name="send">发送的原始字节数据</param>
            <returns>带接收字节的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteDevice.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.PackCommandWithHeader(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.PackCommandWithHeader(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.UnpackResponseContent(System.Byte[],System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.UnpackResponseContent(System.Byte[],System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ReadFromCoreServer(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            将原始的字节数据发送到串口，然后从串口接收一条数据。<br />
            The raw byte data is sent to the serial port, and then a piece of data is received from the serial port.
            </summary>
            <param name="send">发送的原始字节数据</param>
            <param name="hasResponseData">是否有数据相应，如果为true, 需要等待数据返回，如果为false, 不需要等待数据返回</param>
            <param name="usePackAndUnpack">是否需要对命令重新打包，在重写<see cref="M:HslCommunication.Serial.SerialBase.PackCommandWithHeader(System.Byte[])"/>方法后才会有影响</param>
            <returns>带接收字节的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ReadFromCoreServer(System.IO.Ports.SerialPort,System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            将数据发送到当前的串口通道上去，并且从串口通道接收一串原始的字节报文，默认对方必须返回数据，也可以手动修改不返回数据信息。<br />
            Send data to the current serial channel, and receive a string of original byte messages from the serial channel. By default, the other party must return data, or you can manually modify it to not return data information.
            </summary>
            <param name="sp">指定的串口通信对象，最终将使用该串口进行数据的收发</param>
            <param name="send">发送到串口的报文数据信息，如果<paramref name="usePackAndUnpack"/>为<c>True</c>，那么就使用<see cref="M:HslCommunication.Serial.SerialBase.PackCommandWithHeader(System.Byte[])"/>方法打包发送的报文信息。</param>
            <param name="hasResponseData">是否等待数据的返回，默认为 <c>True</c></param>
            <param name="usePackAndUnpack">是否需要对命令重新打包，在重写<see cref="M:HslCommunication.Serial.SerialBase.PackCommandWithHeader(System.Byte[])"/>方法后才会有影响</param>
            <returns>接收的完整的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ClearSerialCache">
            <summary>
            清除串口缓冲区的数据，并返回该数据，如果缓冲区没有数据，返回的字节数组长度为0<br />
            The number sent clears the data in the serial port buffer and returns that data, or if there is no data in the buffer, the length of the byte array returned is 0
            </summary>
            <returns>是否操作成功的方法</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ReadFromCoreServerAsync(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Serial.SerialBase.ReadFromCoreServer(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ReadFromCoreServerAsync(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <inheritdoc cref="M:HslCommunication.Serial.SerialBase.ReadFromCoreServer(System.Collections.Generic.IEnumerable{System.Byte[]})"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.InitializationOnOpen(System.IO.Ports.SerialPort)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ExtraOnClose(System.IO.Ports.SerialPort)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ExtraOnDisconnect(System.Net.Sockets.Socket)"/>
        </member>
        <member name="F:HslCommunication.Serial.SerialBase.LogMsgFormatBinary">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkDoubleBase.LogMsgFormatBinary"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SPSend(System.IO.Ports.SerialPort,System.Byte[])">
            <summary>
            发送数据到串口去。<br />
            Send data to serial port.
            </summary>
            <param name="serialPort">串口对象</param>
            <param name="data">字节数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.CheckReceiveDataComplete(System.IO.MemoryStream)">
            <summary>
            检查当前从串口接收的数据是否是完整的，如果是完整的，则需要返回 <c>True</c>，串口数据接收立即完成，默认返回 <c>False</c><br />
            Check whether the data currently received from the serial port is complete. If it is complete, you need to return <c>True</c>. 
            The serial port data reception is completed immediately, and the default returns <c>False</c>
            </summary>
            <remarks>
            在默认情况下，串口在接收数据之后，需要再等一个 <see cref="P:HslCommunication.Serial.SerialBase.SleepTime"/> 的时间，再没有接收到数据，才真的表明数据接收完成了，
            但是在某些情况下，可以判断是否接收完成，然后直接返回，不需要在等一个 <see cref="P:HslCommunication.Serial.SerialBase.SleepTime"/> 的时间，从而提高一倍的通信性能。<br />
            By default, after the serial port receives data, it needs to wait another <see cref="P:HslCommunication.Serial.SerialBase.SleepTime"/> time, and no more data is received, 
            it really indicates that the data reception is complete, but in some cases, you can Judge whether the reception is complete, 
            and then return directly. There is no need to wait for a <see cref="P:HslCommunication.Serial.SerialBase.SleepTime"/> time, 
            thereby doubling the communication performance.
            </remarks>
            <param name="ms">目前已经接收到数据流</param>
            <returns>如果数据接收完成，则返回True, 否则返回False</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SPReceived(System.IO.Ports.SerialPort,System.Boolean)">
            <summary>
            从串口接收一串字节数据信息，直到没有数据为止，如果参数awaitData为false, 第一轮接收没有数据则返回<br />
            Receives a string of bytes of data information from the serial port until there is no data, and returns if the parameter awaitData is false
            </summary>
            <param name="serialPort">串口对象</param>
            <param name="awaitData">是否必须要等待数据返回</param>
            <returns>结果数据对象</returns>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.RtsEnable">
            <inheritdoc cref="P:HslCommunication.Core.Pipe.PipeSerial.RtsEnable"/>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.ReceiveTimeout">
            <summary>
            接收数据的超时时间，默认5000ms<br />
            Timeout for receiving data, default is 5000ms
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.SleepTime">
            <summary>
            连续串口缓冲数据检测的间隔时间，默认20ms，该值越小，通信速度越快，但是越不稳定。<br />
            Continuous serial port buffer data detection interval, the default 20ms, the smaller the value, the faster the communication, but the more unstable.
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.IsClearCacheBeforeRead">
            <summary>
            是否在发送数据前清空缓冲数据，默认是false<br />
            Whether to empty the buffer before sending data, the default is false
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.PortName">
            <summary>
            当前连接串口信息的端口号名称<br />
            The port name of the current connection serial port information
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.BaudRate">
            <summary>
            当前连接串口信息的波特率<br />
            Baud rate of current connection serial port information
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing">是否在</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.Dispose">
            <summary>
            释放当前的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ToString">
            <inheritdoc/>
        </member>
        <member name="F:HslCommunication.Serial.SerialBase.pipeSerial">
            <summary>
            串口交互的核心
            </summary>
        </member>
        <member name="F:HslCommunication.Serial.SerialBase.AtLeastReceiveLength">
            <summary>
            从串口中至少接收的字节长度信息
            </summary>
        </member>
        <member name="T:HslCommunication.Serial.SerialDeviceBase">
            <summary>
            串口设备交互类的基类，实现了<see cref="T:HslCommunication.Core.IReadWriteDevice"/>接口的基础方法方法，需要使用继承重写来实现字节读写，bool读写操作。<br />
            The base class of the serial device interaction class, which implements the basic methods of the <see cref="T:HslCommunication.Core.IReadWriteDevice"/> interface, 
            requires inheritance rewriting to implement byte read and write, and bool read and write operations.
            </summary>
            <remarks>
            本类实现了不同的数据类型的读写交互的api，继承自本类，重写下面的四个方法将可以实现你自己的设备通信对象
            <list type="number">
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.Read(System.String,System.UInt16)"/> 方法，读取字节数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Byte[])"/> 方法，写入字节数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.ReadBool(System.String,System.UInt16)"/> 方法，读取bool数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Boolean[])"/> 方法，写入bool数组的方法。
            </item>
            </list>
            如果需要实现异步的方法。那就需要重写下面的四个方法。
            <list type="number">
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.ReadAsync(System.String,System.UInt16)"/> 方法，读取字节数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Byte[])"/> 方法，写入字节数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.ReadBoolAsync(System.String,System.UInt16)"/> 方法，读取bool数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Boolean[])"/> 方法，写入bool数组的方法。
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.#ctor">
            <summary>
            默认的构造方法实现的设备信息
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialDeviceBase.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.Serial.SerialDeviceBase.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ConnectionId"/>
        </member>
        <member name="P:HslCommunication.Serial.SerialDeviceBase.WordLength">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.GetWordLength(System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDeviceBase.GetWordLength(System.String,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadStruct``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Wait(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Wait(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Wait(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Wait(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Wait(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Wait(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Wait(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WaitAsync(System.String,System.Boolean,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Boolean,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WaitAsync(System.String,System.Int16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WaitAsync(System.String,System.UInt16,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt16,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WaitAsync(System.String,System.Int32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WaitAsync(System.String,System.UInt32,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WaitAsync(System.String,System.Int64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.Int64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WaitAsync(System.String,System.UInt64,System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Wait(System.String,System.UInt64,System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadBoolAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadBoolAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBoolAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadCustomerAsync``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteCustomerAsync``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomerAsync``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadAsync``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadAsync``1"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadStructAsync``1(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStruct``1(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt16Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt16Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt32Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt32Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadFloatAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadFloatAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloatAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt64Async(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt64Async(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64Async(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadDoubleAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadDoubleAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDoubleAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadStringAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadStringAsync(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String)" />
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteAsync(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="T:HslCommunication.Serial.SoftLRC">
            <summary>
            用于LRC验证的类，提供了标准的验证方法<br />
            The class used for LRC verification provides a standard verification method
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SoftLRC.LRC(System.Byte[])">
            <summary>
            获取对应的数据的LRC校验码<br />
            Class for LRC validation that provides a standard validation method
            </summary>
            <param name="value">需要校验的数据，不包含LRC字节</param>
            <returns>返回带LRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftLRC.CheckLRC(System.Byte[])">
            <summary>
            检查数据是否符合LRC的验证<br />
            Check data for compliance with LRC validation
            </summary>
            <param name="value">等待校验的数据，是否正确</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftLRC.CalculateAcc(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Serial.SoftLRC.CalculateAcc(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SoftLRC.CalculateAcc(System.Byte[],System.Int32,System.Int32)">
            <summary>
            根据传入的原始字节数组，计算和校验信息，可以指定起始的偏移地址和尾部的字节数量信息<br />
            Calculate and check the information according to the incoming original byte array, you can specify the starting offset address and the number of bytes at the end
            </summary>
            <param name="buffer">原始字节数组信息</param>
            <param name="headCount">起始的偏移地址信息</param>
            <param name="lastCount">尾部的字节数量信息</param>
            <returns>和校验的结果</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftLRC.CalculateAccAndFill(System.Byte[],System.Int32,System.Int32)">
            <summary>
            计算数据的和校验，并且输入和校验的值信息<br />
            Calculate the sum check of the data, and enter the value information of the sum check
            </summary>
            <param name="buffer">原始字节数组信息</param>
            <param name="headCount">起始的偏移地址信息</param>
            <param name="lastCount">尾部的字节数量信息</param>
        </member>
        <member name="M:HslCommunication.Serial.SoftLRC.CalculateAccAndCheck(System.Byte[],System.Int32,System.Int32)">
            <summary>
            计算数据的和校验，并且和当前已经存在的和校验信息进行匹配，返回是否匹配成功<br />
            Calculate the sum check of the data, and match it with the existing sum check information, and return whether the match is successful
            </summary>
            <param name="buffer">原始字节数组信息</param>
            <param name="headCount">起始的偏移地址信息</param>
            <param name="lastCount">尾部的字节数量信息</param>
            <returns>和校验是否检查通过</returns>
        </member>
        <member name="T:HslCommunication.StringResources">
            <summary>
            系统的字符串资源及多语言管理中心<br />
            System string resource and multi-language management Center
            </summary>
        </member>
        <member name="F:HslCommunication.StringResources.Language">
            <summary>
            获取或设置系统的语言选项<br />
            Gets or sets the language options for the system
            </summary>
        </member>
        <member name="M:HslCommunication.StringResources.SetLanguageChinese">
            <summary>
            将语言设置为中文<br />
            Set the language to Chinese
            </summary>
        </member>
        <member name="M:HslCommunication.StringResources.SeteLanguageEnglish">
            <summary>
            将语言设置为英文<br />
            Set the language to English
            </summary>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketClient">
            <summary>
            websocket协议的客户端实现，支持从服务器订阅，发布数据内容信息，详细参考api文档信息<br />
            Client implementation of the websocket protocol. It supports subscribing from the server and publishing data content information.
            </summary>
            <example>
            本客户端使用起来非常的方便，基本就是实例化，绑定一个数据接收的事件即可，如下所示
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketClientSample.cs" region="Sample1" title="简单的实例化" />
            假设我们需要发数据给服务端，那么可以参考如下的方式
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketClientSample.cs" region="Sample2" title="发送数据" />
            如果我们需要搭配服务器来做订阅推送的功能的话，写法上会稍微有点区别，按照下面的代码来写。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketClientSample.cs" region="Sample3" title="订阅操作" />
            当网络发生异常的时候，我们需要这么来进行重新连接。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketClientSample.cs" region="Sample4" title="异常重连" />
            </example>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip，端口来实例化一个默认的对象<br />
            Use the specified ip and port to instantiate a default objects
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.#ctor(System.String,System.Int32,System.String)">
            <summary>
            使用指定的ip，端口，额外的url信息来实例化一个默认的对象<br />
            Use the specified ip, port, and additional url information to instantiate a default object
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
            <param name="url">额外的信息，比如 /A/B?C=123456</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.#ctor(System.String)">
            <summary>
            使用指定的url来实例化一个默认的对象，例如 ws://127.0.0.1:1883/A/B?C=123456 或是 ws://www.hslcommunication.cn:1883<br />
            Use the specified url to instantiate a default object, such as ws://127.0.0.1:1883/A/B?C=123456 or ws://www.hslcommunication.cn:1883s
            </summary>
            <param name="url">完整的ws地址</param>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketClient.IpAddress">
            <summary>
            Mqtt服务器的ip地址<br />
            IP address of Mqtt server
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketClient.Port">
            <summary>
            端口号。默认1883<br />
            The port number. Default 1883
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectServer">
            <summary>
            连接服务器，实例化客户端之后，至少要调用成功一次，如果返回失败，那些请过一段时间后重新调用本方法连接。<br />
            After connecting to the server, the client must be called at least once after instantiating the client.
            If the return fails, please call this method to connect again after a period of time.
            </summary>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectServer(System.String[])">
            <summary>
            连接服务器，实例化客户端之后，至少要调用成功一次，如果返回失败，那些请过一段时间后重新调用本方法连接。<br />
            After connecting to the server, the client must be called at least once after instantiating the client.
            If the return fails, please call this method to connect again after a period of time.
            </summary>
            <param name="subscribes">订阅的消息</param>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectClose">
            <summary>
            关闭Mqtt服务器的连接。<br />
            Close the connection to the Mqtt server.
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectServerAsync">
            <inheritdoc cref="M:HslCommunication.WebSocket.WebSocketClient.ConnectServer"/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectServerAsync(System.String[])">
            <inheritdoc cref="M:HslCommunication.WebSocket.WebSocketClient.ConnectServer(System.String[])"/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectCloseAsync">
            <inheritdoc cref="M:HslCommunication.WebSocket.WebSocketClient.ConnectClose"/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.SendServer(System.String)">
            <summary>
            发送数据到WebSocket的服务器<br />
            Send data to WebSocket server
            </summary>
            <param name="message">消息</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.SendServer(System.Boolean,System.String)">
            <summary>
            发送数据到WebSocket的服务器，可以指定是否进行掩码操作<br />
            Send data to the WebSocket server, you can specify whether to perform a mask operation
            </summary>
            <param name="mask">是否进行掩码操作</param>
            <param name="message">消息</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.SendServer(System.Int32,System.Boolean,System.Byte[])">
            <summary>
            发送自定义的命令到WebSocket服务器，可以指定操作码，是否掩码操作，原始字节数据<br />
            Send custom commands to the WebSocket server, you can specify the operation code, whether to mask operation, raw byte data
            </summary>
            <param name="opCode">操作码</param>
            <param name="mask">是否进行掩码操作</param>
            <param name="payload">原始字节数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketClient.OnClientApplicationMessageReceiveDelegate">
            <summary>
            websocket的消息收到委托<br />
            websocket message received delegate
            </summary>
            <param name="message">websocket的消息</param>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketClient.OnClientApplicationMessageReceive">
             <summary>
             websocket的消息收到时触发<br />
             Triggered when a websocket message is received
            </summary>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketClient.OnClientConnectedDelegate">
            <summary>
            连接服务器成功的委托<br />
            Connection server successfully delegated
            </summary>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketClient.OnClientConnected">
            <summary>
            当客户端连接成功触发事件，就算是重新连接服务器后，也是会触发的<br />
            The event is triggered when the client is connected successfully, even after reconnecting to the server.
            </summary>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketClient.OnNetworkError">
            <summary>
            当网络发生异常的时候触发的事件，用户应该在事件里进行重连服务器
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketClient.ConnectTimeOut">
            <summary>
            获取或设置当前客户端的连接超时时间，默认10,000毫秒，单位ms<br />
            Gets or sets the connection timeout of the current client. The default is 10,000 milliseconds. The unit is ms.
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketClient.IsClosed">
            <summary>
            获取当前的客户端状态是否关闭了连接，当自己手动处理网络异常事件的时候，在重连之前就需要判断是否关闭了连接。<br />
            Obtain whether the current client status has closed the connection. When manually handling network abnormal events, you need to determine whether the connection is closed before reconnecting.
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketHelper">
            <summary>
            websocket的相关辅助的方法
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.CalculateWebscoketSha1(System.String)">
            <summary>
            计算websocket返回得令牌
            </summary>
            <param name="webSocketKey">请求的令牌</param>
            <returns>返回的令牌</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.GetSecKeyAccetp(System.String)">
            <summary>
            根据http网页的信息，计算出返回的安全令牌
            </summary>
            <param name="httpGet">网页信息</param>
            <returns>返回的安全令牌</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.CheckWebSocketLegality(System.String)">
            <summary>
            检测当前的反馈对象是否是标准的websocket请求
            </summary>
            <param name="httpGet">http的请求内容</param>
            <returns>是否验证成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.GetWebSocketSubscribes(System.String)">
            <summary>
            从当前的websocket的HTTP请求头里，分析出订阅的主题内容
            </summary>
            <param name="httpGet">http的请求内容</param>
            <returns>是否验证成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.GetWebSocketSubscribesFromUrl(System.String)">
            <summary>
            从当前的Websocket的Url里，分析出订阅的主题内容
            </summary>
            <param name="url">URL内容，例如 ws://127.0.0.1:1883/HslSubscribes=A,B</param>
            <returns>消息主题</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.GetResponse(System.String)">
            <summary>
            获取初步握手的时候的完整返回的数据信息
            </summary>
            <param name="httpGet">请求的网页信息</param>
            <returns>完整的返回信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.BuildWsSubRequest(System.String,System.Int32,System.String,System.String[])">
            <summary>
            创建连接服务器的http请求，输入订阅的主题信息
            </summary>
            <param name="ipAddress">远程服务器的ip地址</param>
            <param name="port">远程服务器的端口号</param>
            <param name="url">参数信息</param>
            <param name="subscribes">通知hsl的服务器，需要订阅的topic信息</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.BuildWsQARequest(System.String,System.Int32)">
            <summary>
            创建连接服务器的http请求，采用问答的机制
            </summary>
            <param name="ipAddress">远程服务器的ip地址</param>
            <param name="port">远程服务器的端口号</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.BuildWsRequest(System.String,System.Int32,System.String,System.String)">
            <summary>
            根据额外的参数信息，创建新的websocket的请求信息
            </summary>
            <param name="ipAddress">ip地址</param>
            <param name="port">端口号</param>
            <param name="url">跟在端口号后面的额外的参数信息</param>
            <param name="extra">额外的参数信息</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.WebScoketPackData(System.Int32,System.Boolean,System.String)">
            <summary>
            将普通的文本信息转换成websocket的报文
            </summary>
            <param name="opCode">操作信息码</param>
            <param name="isMask">是否使用掩码</param>
            <param name="message">等待转换的数据信息</param>
            <returns>数据包</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.WebScoketPackData(System.Int32,System.Boolean,System.Byte[])">
            <summary>
            将普通的文本信息转换成websocket的报文
            </summary>
            <param name="opCode">操作信息码</param>
            <param name="isMask">是否使用掩码</param>
            <param name="payload">等待转换的数据信息</param>
            <returns>数据包</returns>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketMessage">
            <summary>
            websocket 协议下的单个消息的数据对象<br />
            Data object for a single message under the websocket protocol
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketMessage.HasMask">
            <summary>
            是否存在掩码<br />
            Whether a mask exists
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketMessage.OpCode">
            <summary>
            当前的websocket的操作码<br />
            The current websocket opcode
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketMessage.Payload">
            <summary>
            负载数据
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketQANet">
            <summary>
            WebSocket的问答机制的客户端，本客户端将会在请求头上追加 RequestAndAnswer: true，本客户端将会请求服务器的信息，然后等待服务器的返回<br />
            Client of WebSocket Q &amp; A mechanism, this client will append RequestAndAnswer: true to the request header, this client will request the server information, and then wait for the server to return
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.#ctor(System.String,System.Int32)">
            <summary>
            根据指定的ip地址及端口号，实例化一个默认的对象<br />
            Instantiates a default object based on the specified IP address and port number
            </summary>
            <param name="ipAddress">远程服务器的ip地址</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.InitializationOnConnectAsync(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.ReadFromCoreServerAsync(System.Net.Sockets.Socket,System.Byte[],System.Boolean,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.ReadFromServer(System.String)">
            <summary>
            和websocket的服务器交互，将负载数据发送到服务器端，然后等待接收服务器的数据<br />
            Interact with the websocket server, send the load data to the server, and then wait to receive data from the server
            </summary>
            <param name="payload">数据负载</param>
            <returns>返回的结果数据</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.ReadFromServerAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.WebSocket.WebSocketQANet.ReadFromServer(System.String)"/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketServer">
            <summary>
            WebSocket协议的实现，支持创建自定义的websocket服务器，直接给其他的网页端，客户端，手机端发送数据信息，详细看api文档说明<br />
            The implementation of the WebSocket protocol supports the creation of custom websocket servers and sends data information directly to other web pages, clients, and mobile phones. See the API documentation for details.
            </summary>
            <example>
            使用本组件库可以非常简单方便的构造属于你自己的websocket服务器，从而实现和其他的客户端进行通信，尤其是和网页进行通讯，
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample1" title="简单的实例化" />
            当客户端发送数据给服务器的时候，会发一个事件，并且把当前的会话暴露出来，下面举例打印消息，并且演示一个例子，发送数据给指定的会话。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample2" title="接触数据" />
            也可以在其他地方发送数据给所有的客户端，只要调用一个方法就可以了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample3" title="发送数据" />
            当客户端上线之后也触发了当前的事件，我们可以手动捕获到
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample4" title="捕获上线事件" />
            我们再来看看一个高级的操作，实现订阅，大多数的情况，websocket被设计成了订阅发布的操作。基本本服务器可以扩展出非常复杂功能的系统，我们来看一种最简单的操作。
            <br />
            客户端给服务器发的数据都视为主题(topic)，这样服务器就可以辨认出主题信息，并追加主题。如下这么操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample5" title="订阅实现" />
            然后在发布的时候，调用下面的代码。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample6" title="发布数据" />
            可以看到，我们这里只有订阅操作，如果想要实现更为复杂的操作怎么办？丰富客户端发来的数据，携带命令，数据，就可以区分了。比如json数据。具体的实现需要看各位能力了。
            </example>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.ServerStart(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketServer.OnClientApplicationMessageReceiveDelegate">
            <summary>
            websocket的消息收到委托<br />
            websocket message received delegate
            </summary>
            <param name="session">当前的会话对象</param>
            <param name="message">websocket的消息</param>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketServer.OnClientApplicationMessageReceive">
             <summary>
             websocket的消息收到时触发<br />
             Triggered when a websocket message is received
            </summary>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketServer.OnClientConnectedDelegate">
            <summary>
            当前websocket连接上服务器的事件委托<br />
            Event delegation of the server on the current websocket connection
            </summary>
            <param name="session">当前的会话对象</param>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketServer.OnClientConnected">
            <summary>
            Websocket的客户端连接上来时触发<br />
            Triggered when a Websocket client connects
            </summary>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketServer.OnClientDisConnected">
            <summary>
            Websocket的客户端下线时触发<br />
            Triggered when Websocket client connects
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.StartInitialization">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.PublishAllClientPayload(System.String)">
            <summary>
            向所有的客户端强制发送消息<br />
            Force message to all clients
            </summary>
            <param name="payload">消息内容</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.PublishClientPayload(System.String,System.String)">
            <summary>
            向订阅了topic主题的客户端发送消息<br />
            Send messages to clients subscribed to topic
            </summary>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.PublishAllClientPayloadAsync(System.String)">
            <inheritdoc cref="M:HslCommunication.WebSocket.WebSocketServer.PublishAllClientPayload(System.String)"/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.PublishClientPayloadAsync(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.WebSocket.WebSocketServer.PublishClientPayload(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.SendClientPayload(HslCommunication.WebSocket.WebSocketSession,System.String)">
            <summary>
            向指定的客户端发送数据<br />
            Send data to the specified client
            </summary>
            <param name="session">会话内容</param>
            <param name="payload">消息内容</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.AddSessionTopic(HslCommunication.WebSocket.WebSocketSession,System.String)">
            <summary>
            给一个当前的会话信息动态添加订阅的主题<br />
            Dynamically add subscribed topics to a current session message
            </summary>
            <param name="session">会话内容</param>
            <param name="topic">主题信息</param>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.OnlineCount">
            <summary>
            获取当前的在线的客户端数量<br />
            Get the current number of online clients
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.IsTopicRetain">
            <summary>
            获取或设置当前的服务器是否对订阅主题信息缓存，方便订阅客户端立即收到结果，默认开启<br />
            Gets or sets whether the current server caches the topic information of the subscription, so that the subscription client can receive the results immediately. It is enabled by default.
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.OnlineSessions">
            <summary>
            获取当前的在线的客户端信息，可以用于额外的分析或是显示。
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.KeepAlivePeriod">
            <summary>
            设置的参数，最小单位为1s，当超过设置的时间间隔必须回复PONG报文，否则服务器认定为掉线。默认120秒<br />
            Set the minimum unit of the parameter is 1s. When the set time interval is exceeded, the PONG packet must be returned, otherwise the server considers it to be offline. 120 seconds by default
            </summary>
            <remarks>
            保持连接（Keep Alive）是一个以秒为单位的时间间隔，它是指客户端返回一个PONG报文到下一次返回PONG报文的时候，
            两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。
            </remarks>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.KeepAliveSendInterval">
            <summary>
            获取或是设置用于保持连接的心跳时间的发送间隔。默认30秒钟，需要在服务启动之前设置<br />
            Gets or sets the sending interval of the heartbeat time used to keep the connection. 30 seconds by default, need to be set before the service starts
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.RemoveAndCloseSession(HslCommunication.WebSocket.WebSocketSession,System.String)">
            <summary>
            让Websocket客户端正常下线，调用本方法即可自由控制会话客户端强制下线操作。<br />
            Let the Websocket client go offline normally. Call this method to freely control the session client to force offline operation.
            </summary>
            <param name="session">当前的会话信息</param>
            <param name="reason">下线的原因，默认为空</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketSession">
            <summary>
            websocket 的会话客户端
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.ActiveTime">
            <summary>
            当前客户端的激活时间
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.OnlineTime">
            <summary>
            获取当前的客户端的上线时间
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.WsSocket">
            <summary>
            当前客户端绑定的套接字对象
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.Topics">
            <summary>
            当前客户端订阅的所有的Topic信息
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.Remote">
            <summary>
            远程的客户端的ip及端口信息
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.IsQASession">
            <summary>
            当前的会话是否是问答客户端，如果是问答客户端的话，数据的推送是无效的。
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.Url">
            <summary>
            客户端请求的url信息，可能携带一些参数信息
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.IsClientSubscribe(System.String)">
            <summary>
            检查当前的连接对象是否在
            </summary>
            <param name="topic">主题信息</param>
            <returns>是否包含的结果信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.AddTopic(System.String)">
            <summary>
            动态增加一个订阅的信息
            </summary>
            <param name="topic">订阅的主题</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.RemoveTopic(System.String)">
            <summary>
            动态移除一个订阅的信息
            </summary>
            <param name="topic">订阅的主题</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WSOpCode">
            <summary>
            websocket 协议的 op的枚举信息
            </summary>
        </member>
        <member name="F:HslCommunication.WebSocket.WSOpCode.ContinuousMessageFragment">
            <summary>
            连续消息分片
            </summary>
        </member>
        <member name="F:HslCommunication.WebSocket.WSOpCode.TextMessageFragment">
            <summary>
            文本消息分片
            </summary>
        </member>
        <member name="F:HslCommunication.WebSocket.WSOpCode.BinaryMessageFragment">
            <summary>
            二进制消息分片
            </summary>
        </member>
        <member name="F:HslCommunication.WebSocket.WSOpCode.ConnectionClose">
            <summary>
            连接关闭
            </summary>
        </member>
        <member name="F:HslCommunication.WebSocket.WSOpCode.HeartbeatPing">
            <summary>
            心跳检查
            </summary>
        </member>
        <member name="F:HslCommunication.WebSocket.WSOpCode.HeartbeatPong">
            <summary>
            心跳检查
            </summary>
        </member>
    </members>
</doc>
